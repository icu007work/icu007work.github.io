<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Kotlin 进阶 | 米奇妙妙屋</title><meta name="keywords" content="Kotlin,编程入门"><meta name="author" content="Rookie_l"><meta name="copyright" content="Rookie_l"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Kotlin 进阶"><meta name="application-name" content="Kotlin 进阶"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="Kotlin 进阶"><meta property="og:url" content="https://icu007work.github.io/archives/4fa27f9d.html"><meta property="og:site_name" content="米奇妙妙屋"><meta property="og:description" content="一、标准函数和静态方法1.1 标准函数with、run和apply1.1.1 with函数with函数接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pic2.ziyuan.wang/user/xiheya/2024/05/Kotlin-Advance_535ea90c69f3c.jpg"><meta property="article:author" content="Rookie_l"><meta property="article:tag" content="二次元 码农 地中海"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic2.ziyuan.wang/user/xiheya/2024/05/Kotlin-Advance_535ea90c69f3c.jpg"><meta name="description" content="一、标准函数和静态方法1.1 标准函数with、run和apply1.1.1 with函数with函数接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://icu007work.github.io/archives/4fa27f9d"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"Rookie","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 你你你去哪啦??!","backTitle":"♪(^∇^*)你回来啦！"},
  LA51: {"enable":true,"ck":"3FfSkp1Eunbavgru","LingQueMonitorID":"3FfSkp1Eunbavgru"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"hexo-circle-of-friends-flax-ten.vercel.app/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后更新于","messageNext":"天前，其中的信息可能已经有所发展或是发生改变，请谨慎参考。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: Rookie_l","link":"链接: ","source":"来源: 米奇妙妙屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '米奇妙妙屋',
  title: 'Kotlin 进阶',
  postAI: '这篇文章主要介绍了Kotlin编程语言中的标准函数和静态方法。首先，文章介绍了Kotlin中的标准函数，包括with、run和apply。这些函数都是Kotlin的内置函数，用于简化代码和提高代码的可读性。文章详细解释了with函数的用法。with函数接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回值返回。文章最后提供了一个示例，展示了如何使用with函数。在这个示例中，我们有一个水果列表，我们需要吃完所有的水果，并将结果打印出来。这个示例展示了如何使用with函来简化这个过程。',
  pageFillDescription: '一、标准函数和静态方法, 1.1 标准函数with、run和apply, 1.1.1 with函数, 1.1.2 run函数, 1.1.3 apply函数, 1.2 定义静态方法, 1.2.1 注解, 1.2.2 顶层方法, 二、延迟初始化和密封类, 2.1 对变量延迟初始化, 2.2 使用密封类优化代码, 三、扩展函数和运算符重载, 3.1 大有用途的扩展函数, 3.2 有趣的运算符重载, 四、高阶函数详解, 4.1 定义高阶函数, 4.2 内联函数的作用, 4.3 noinline 与 crossinline, 五、高阶函数的应用, 5.1 简化SharedPreferences的用法, 5.2 简化ContentValues的用法, 六、泛型和委托, 6.1 泛型的基本用法, 6.2 类委托和委托属性, 6.2.1 类委托, 6.2.2 委托属性, 6.2.3 实现一个自己的lazy函数, 七、使用infix函数构建更可读的语法, 八、泛型的高级特性, 8.1 对泛型进行实化, 8.2 泛型实化的应用, 8.3 泛型的协变, 8.4 泛型的逆变, 九、使用协程编写高效的并发程序, 9.1 协程的基本用法, 9.2 更多的作用域构建器, 9.3 使用协程简化回调写法, 十、编写好用的工具方法, 10.1 求N个数的最大最小值, 10.2 简化Toast的用法, 10.3 简化Snackbar的用法, 十一、使用DSL构建专有的语法结构一标准函数和静态方法标准函数和函数函数接收两个参数第一个参数可以是一个任意类型的对象第二个参数是一个表达式函数会在表达式中提供第一个参数对象的上下文并使用表达式中的最后一行代码作为返回值返回示例代码如下的上下文函数的返回值具体怎么使用呢举个栗子我们有个列表现在我们需要吃完所有水果并将结果打印出来我们可以这样写这段代码的逻辑很简单就是使用来构建吃水果的字符串最后将结果打印出来我们连续调用了很多次对象的方法其实这个时候就可以考虑使用函数来让代码变得更加精简如下所示首先我们给函数的第一个参数传入了一个对象那么接下来整个表达式的上下文就会是这个对象于是我们在表达式中就不用再像刚才那样调用和方法了而是可以直接调用和方法表达式的最后一行代码会作为函数的返回值返回最终我们将结果打印出来函数函数的用法和使用场景其实和函数是非常类似的只是稍微做了一些语法改动而已首先函数通常不会直接调用而是要在某个对象的基础上调用其次函数只接收一个参数并且会在表达式中提供调用对象的上下文其他方面和函数是一样的包括也会使用表达式中的最后一行代码作为返回值返回的上下文函数的返回值接下来使用函数来改写一下上述代码总体来说变化非常小只是将调用函数并传入对象改成了调用对象的方法其他都没有任何区别这两段代码最终的执行结果是完全相同的函数函数和函数也是极其类似的都要在某个对象上调用并且只接收一个参数也会在表达式中提供调用对象的上下文但是函数无法指定返回值而是会自动返回调用对象本身上下文那么现在我们再使用函数来修改一下吃水果的这段代码如下所示注意这里的代码变化由于函数无法指定返回值只能返回调用对象本身因此这里的实际上是一个对象所以我们在最后打印的时候还要再调用它的方法才行定义静态方法静态方法在某些编程语言里面又叫作类方法指的就是那种不需要创建实例就能调用的方法所有主流的编程语言都会支持静态方法这个特性在中定义一个静态方法非常简单只需要在方法上声明一个关键字就可以了如下所示这是一个非常简单的工具类上述代码中的方法就是一个静态方法调用静态方法并不需要创建类的实例而是可以直接以这种写法来调用因而静态方法非常适合用于编写一些工具类的功能因为工具类通常没有创建实例的必要基本是全局通用的但是和绝大多数主流编程语言不同的是却极度弱化了静态方法这个概念想要在中定义一个静态方法反倒不是一件容易的事那么为什么要这样设计呢因为提供了比静态方法更好用的语法特性并且我们在上一节中已经学习过了那就是单例类像工具类这种功能在中就非常推荐使用单例类的方式来实现比如上述的工具类如果使用来实现的话就可以这样写虽然这里的方法并不是静态方法但是我们仍然可以使用的方式来调用这就是单例类所带来的便利性不过使用单例类的写法会将整个类中的所有方法全部变成类似于静态方法的调用方式而如果我们只是希望让类中的某一个方法变成静态方法的调用方式该怎么办呢这个时候就可以使用刚刚在最佳实践环节用到的了示例如下这里首先我们将从单例类改成了一个普通类然后在类中直接定义了一个方法又在中定义了一个方法现在这两个方法就有了本质的区别因为方法是一定要先创建类的实例才能调用的而方法可以直接使用的方式调用不过方法其实也并不是静态方法这个关键字实际上会在类的内部创建一个伴生类而方法就是定义在这个伴生类里面的实例方法只是会保证类始终只会存在一个伴生类对象因此调用方法实际上就是调用了类中伴生对象的方法由此可以看出确实没有直接定义静态方法的关键字但是提供了一些语法特性来支持类似于静态方法调用的写法这些语法特性基本可以满足我们平时的开发需求了然而如果你确确实实需要定义真正的静态方法仍然提供了两种实现方式注解和顶层方法下面我们来逐个学习一下注解先来看注解前面使用的单例类和都只是在语法的形式上模仿了静态方法的调用方式实际上它们都不是真正的静态方法因此如果你在代码中以静态方法的形式去调用的话你会发现这些方法并不存在而如果我们给单例类或中的方法加上注解那么编译器就会将这些方法编译成真正的静态方法如下所示注意注解只能加在单例类或中的方法上如果你尝试加在一个普通方法上会直接提示语法错误由于方法已经成为了真正的静态方法那么现在不管是在中还是在中都可以使用的写法来调用了顶层方法再来看顶层方法顶层方法指的是那些没有定义在任何类中的方法比如我们在上一节中编写的方法编译器会将所有的顶层方法全部编译成静态方法因此只要你定义了一个顶层方法那么它就一定是静态方法想要定义一个顶层方法首先需要创建一个文件对着任意包名右击在弹出的对话框中输入文件名即可注意创建类型要选择点击完成创建这样刚刚的包名路径下就会出现一个文件现在我们在这个文件中定义的任何方法都会是顶层方法比如这里我就定义一个方法吧如下所示刚才已经讲过了编译器会将所有的顶层方法全部编译成静态方法那么我们要怎么调用这个方法呢如果是在代码中调用的话那就很简单了所有的顶层方法都可以在任何位置被直接调用不用管包名路径也不用创建实例直接键入即可但如果是在代码中调用你会发现是找不到这个方法的因为中没有顶层方法这个概念所有的方法必须定义在类中那么这个方法被藏在了哪里呢我们刚才创建的文件名叫作于是编译器会自动创建一个叫作的类方法就是以静态方法的形式定义在类里面的因此在中使用的写法来调用就可以了二延迟初始化和密封类对变量延迟初始化前面学习了语言的许多特性包括变量不可变变量不可为空等等这些特性都是为了尽可能地保证程序安全而设计的但是有的时候会给我们编码带来一些麻烦例如如果项目的某个类中存在很多全局变量实例为了保证它们能够满足的空指针检查语法标准我们不得不做许多的非空判断保护才行即使非常确定它们不会为空们通过一个具体的例子来看一下吧就使用刚刚的项目来作为例子如果仔细观察中的代码会发现这里适配器的写法略微有点特殊监听点击事件通知列表有新的数据插入这里我们将设置为了全局变量但是它的初始化工作是在方法中进行的因此不得不先将赋值为同时把它的类型声明成虽然我们会在方法中对进行初始化同时能确保方法必然在方法之后才会调用但是我们在方法中调用的任何方法时仍然要进行判空处理才行否则编译肯定无法通过当我们的代码中有了越来越多的全局变量实例时这个问题就会变得越来越明显到时候我们可能需要编写大量额外的判空处理代码只是为了满足编译器的要求那么该如何解决呢其实非常简单那就是对全局变量进行延迟初始化延迟初始化使用的是关键字它可以告诉编译器我会在晚些时候对这个变量进行初始化这样就不用在一开始的时候将它赋值为了接下来使用延迟初始化对上述代码进行优化监听点击事件通知列表有新的数据插入当我们在变量前面加上关键字后就用一开始就将它赋值为同时类型声明也就可以改成了由于是不可为空的类型所以我们在方法中也就不再需要进行判空处理直接调用的任何方法就可以了当然使用关键字也不是没有任何风险如果我们在变量还没有初始化的情况下就直接使用它那么程序就一定会崩溃并且抛出一个异常我们还可以通过代码来判断一个全局变量是否已经完成了初始化这样在某些时候能够有效地避免重复对某一个变量进行初始化操作示例代码如下具体语法就是这样可用于判断变量是否已经初始化使用密封类优化代码首先来了解一下密封类具体的作用这里我们来看一个简单的例子新建一个文件文件名就叫好了然后在这个文件中编写如下代码这里定义了一个接口用于表示某个操作的执行结果接口中不用编写任何内容然后定义了两个类去实现接口一个类用于表示成功时的结果一个类用于表示失败时的结果这样就把准备工作做好了接下来再定义一个方法用于获取最终执行结果的信息代码如下方法中接收一个参数我们通过语句来判断如果属于那么就返回成功的消息如果属于那么就返回错误信息到目前为止代码都是没有问题的但比较让人讨厌的是接下来我们不得不再编写一个条件否则编译器会认为这里缺少条件分支代码将无法编译通过但实际上的执行结果只可能是或者这个条件是永远走不到的所以我们在这里直接抛出了一个异常只是为了满足编译器的语法检查而已另外编写条件还有一个潜在的风险如果我们现在新增了一个类并实现接口用于表示未知的执行结果但是忘记在方法中添加相应的条件分支编译器在这种情况下是不会提醒我们的而是会在运行的时候进入条件里面从而抛出异常并导致程序崩溃当然这种为了满足编译器的要求而编写无用条件分支的情况不仅在当中存在在或者是其他编程语言当中也普遍存在不过好消息是的密封类可以很好地解决这个问题下面我们就来学习一下密封类的关键字是它的用法同样非常简单我们可以轻松地将接口改造成密封类的写法可以看到代码并没有什么太大的变化只是将关键字改成了另外由于密封类是一个可继承的类因此在继承它的时候需要在后面加上一对括号那么改成密封类之后有什么好处呢你会发现现在方法中的条件已经不再需要了如下所示为什么这里去掉了条件仍然能编译通过呢这是因为当在语句中传入一个密封类变量作为条件时编译器会自动检查该密封类有哪些子类并强制要求你将每一个子类所对应的条件全部处理这样就可以保证即使没有编写条件也不可能会出现漏写条件分支的情况而如果我们现在新增一个类并也让它继承自此时方法就一定会报错必须增加一个的条件分支才能让代码编译通过这就是密封类主要的作用和使用方法了另外再多说一句密封类及其所有子类只能定义在同一个文件的顶层位置不能嵌套在其他类中这是被密封类底层的实现机制所限制的了解完理论知识接下来尝试结合中的一起使用顺便优化下中的代码观看现在的代码你会发现方法中就存在一个没有实际作用的条件只是抛出了一个异常而已对于这部分代码我们就可以借助密封类的特性来进行优化首先删除中的和然后新建一个文件在其中加入如下代码这里我们定义了一个密封类并让它继承自然后让和继承自这样就相当于密封类只有两个已知子类因此在语句中只要处理这两种情况的条件分支即可现在修改中的代码如下所示这里我们将的泛型指定成刚刚定义的密封类这样方法传入的参数就变成了然后我们只要在语句当中处理和这两种情况就可以了那个讨厌的终于不再需要了这种适配器的写法更加规范也更加推荐三扩展函数和运算符重载大有用途的扩展函数不少现代高级编程语言中有扩展函数这个概念却一直以来都不支持这个非常有用的功能这多少会让人有些遗憾但值得高兴的是对扩展函数进行了很好的支持因此这个知识点是我们无论如何都不能错过的首先看一下什么是扩展函数扩展函数表示即使在不修改某个类的源码的情况下仍然可以打开这个类向该类添加新的函数为了帮助你更好地理解我们先来思考一个功能一段字符串中可能包含字母数字和特殊符号等字符现在我们希望统计字符串中字母的数量你要怎么实现这个功能呢如果按照一般的编程思维可能大多数人会很自然地写出如下函数这里先定义了一个单例类然后在这个单例类中定义了一个函数该函数接收一个字符串参数在方法中我们使用循环去遍历字符串中的每一个字符如果该字符是一个字母的话那么就将计数器加最终返回计数器的值这种写法绝对可以正常工作并且这也是编程中最标准的实现思维但是有了扩展函数之后就不一样了我们可以使用一种更加面向对象的思维来实现这个功能比如说将函数添加到类当中下面我们先来学习一下定义扩展函数的语法结构其实非常简单如下所示相比于定义一个普通的函数定义扩展函数只需要在函数名的前面加上一个的语法结构就表示将该函数添加到指定类当中了了解了定义扩展函数的语法结构接下来我们就尝试使用扩展函数的方式来优化刚才的统计功能由于我们希望向类中添加一个扩展函数因此需要先创建一个文件文件名虽然并没有固定的要求但是我建议向哪个类中添加扩展函数就定义一个同名的文件这样便于你以后查找当然扩展函数也是可以定义在任何一个现有类当中的并不一定非要创建新文件不过通常来说最好将它定义成顶层方法这样可以让扩展函数拥有全局的访问域现在我们可以这样写注意这里的代码变化现在我们将方法定义成了类的扩展函数那么函数中就自动拥有了实例的上下文因此函数就不再需要接收一个字符串参数了而是直接遍历即可因为现在就代表着字符串本身定义好了扩展函数之后统计某个字符串中的字母数量只需要这样写即可是不是很神奇看上去就好像是类中自带了方法一样扩展函数在很多情况下可以让变得更加简洁丰富更加面向对象我们再次以类为例这是一个类任何一个类都不可以继承它也就是说它的只有固定的那些而已至少在中就是如此然而到了中就不一样了我们可以向类中扩展任何函数使它的变得更加丰富比如你会发现中的甚至还有函数用于反转字符串函数用于对首字母进行大写等等这都是语言自带的一些扩展函数这个特性使我们的编程工作可以变得更加简便有趣的运算符重载运算符重载是提供的一个比较有趣的语法糖我们知道中有许多语言内置的运算符关键字如而允许我们将所有的运算符甚至其他的关键字进行重载从而拓展这些运算符和关键字的用法我们先来回顾一下运算符的基本用法相信每个人都使用过加减乘除这种四则运算符在编程语言里面两个数字相加表示求这两个数字之和两个字符串相加表示对这两个字符串进行拼接这种基本用法相信接触过编程的人都明白但是的运算符重载却允许我们让任意两个对象进行相加或者是进行更多其他的运算操作当然虽然赋予了我们这种能力在实际编程的时候也要考虑逻辑的合理性比如说让两个对象相加好像并没有什么意义但是让两个对象相加就变得有意义了因为钱是可以相加的那么接下来我们首先学习一下运算符重载的基本语法然后再来实现让两个对象相加的功能运算符重载使用的是关键字只要在指定函数的前面加上关键字就可以实现运算符重载的功能了但问题在于这个指定函数是什么这是运算符重载里面比较复杂的一个问题因为不同的运算符对应的重载函数也是不同的比如说加号运算符对应的是函数减号运算符对应的是函数这里还是以加号运算符为例如果想要实现让两个对象相加的功能那么它的语法结构如下处理相加的逻辑在上述语法结构中关键字和函数名都是固定不变的而接收的参数和函数返回值可以根据你的逻辑自行设定那么上述代码就表示一个对象可以与另一个对象相加最终返回一个新的对象对应的调用方式如下这种的语法看上去好像很神奇但其实这就是给我们提供的一种语法糖它会在编译的时候被转换成的调用方式了解了运算符重载的基本语法之后下面我们开始实现一个更加有意义功能让两个对象相加首先定义类的结构这里我准备让的主构造函数接收一个参数用于表示钱的金额创建文件代码如下所示可以看到这里使用了关键字来修饰函数这是必不可少的在函数中我们将当前对象的和参数传入的对象的相加然后将得到的和传给一个新的对象并将该对象返回这样两个对象就可以相加了就是这么简单但是对象只允许和另一个对象相加有没有觉得这样不够方便呢或许你会觉得如果对象能够直接和数字相加的话就更好了这个功能当然也是可以实现的因为允许我们对同一个运算符进行多重重载代码如下所示当然我们还可以对这个例子进一步扩展比如加上汇率转换的功能让人民币的对象和美元的对象相加然后根据实时汇率进行转换从而返回一个新的对象这类功能都是非常有趣的运算符重载如果运用得好的话可以玩出很多花样例如上述代码我们就使用运算符重载实现了对类的加减运算并且加上了汇率转换实际上允许我们重载的运算符和关键字多达十几个因此下表列出了所有常用的可重载运算符和关键字对应的语法糖表达式以及它们会被转换成的实际调用函数如果你想重载其中某一种运算符或关键字只要参考刚才加号运算符重载的写法去实现就可以了语法糖表达式实际调用函数最后一个的语法糖表达式对应的实际调用函数是对象的顺序是反过来的这在语义上很好理解因为表示判断是否在当中而表示判断是否包含因此这两种表达方式是等价的例如我们判断中是否包含我们可以这样写这两个写法的效果其实是一致的实践一下假如我们有一个用于生成随机字符串长度的函数这个函数的核心思想就是将传入的字符串重复次如果我们能够使用这种写法来表示让字符串重复次这种语法体验就非常通俗易懂了而在中这又是很容易实现的要让一个字符串可以乘以一个数字那么肯定要在类中重载乘号运算符才行但是类是系统提供的类我们无法修改这个类的代码这个时候就可以借助扩展函数功能向类中添加新函数了这个时候我们加入代码这段代码应该不难理解这里只讲几个关键的点首先关键字肯定是必不可少的然后既然是要重载乘号运算符参考上表可知函数名必须是最后由于是定义扩展函数因此还要在方向名前面加上的语法结构另外必须说明的是其实的类中已经提供了一个用于将字符串重复遍的函数因此函数还可以进一步精简成如下形式进而简化成四高阶函数详解定义高阶函数高阶函数和的关系是密不可分的之前几章掌握了一些与集合相关的函数式的用法如函数等另外我们之前还学习了的标准函数如函数等这几个函数有一个共同的特点它们都会要求我们传入一个表达式作为参数像这种接收参数的函数就可以称为具有函数式编程风格的而如果你想要定义自己的函数式那就得借助高阶函数来实现了首先来看一下高阶函数的定义如果一个函数接收另一个函数作为参数或者返回值的类型是另一个函数那么该函数就称为高阶函数一个函数怎么能接收另一个函数作为参数呢这就涉及另外一个概念了函数类型我们知道编程语言中有整型布尔型等字段类型而又增加了一个函数类型的概念如果我们将这种函数类型添加到一个函数的参数声明或者返回值声明当中那么这就是一个高阶函数了接下来学习一下如何定义一个函数类型不同于定义一个普通的字段类型函数类型的语法规则是有点特殊的基本规则如下看到这个语法规则是不是很懵不用着急给大家解释一下既然是定义一个函数类型那么最关键的就是要声明该函数接收什么参数以及它的返回值是什么因此左边的部分就是用来声明该函数接收什么参数的多个参数之间使用逗号隔开如果不接收任何参数写一对空括号就可以了而右边的部分用于声明该函数的返回值是什么类型如果没有返回值就使用它大致相当于中的现在将上述函数类型添加到某个函数的参数声明或者返回值声明上那么这个函数就是一个高阶函数了如下所示可以看到这里的函数接收了一个函数类型的参数因此函数就是一个高阶函数而调用一个函数类型的参数它的语法类似于调用一个普通的函数只需要在参数名的后面加上一对括号并在括号中传入必要的参数即可现在已经了解了高阶函数的定义方式但是这种函数具体有什么用途呢由于高阶函数的用途实在是太广泛了这里如果要简单概括一下的话那就是高阶函数允许让函数类型的参数来决定函数的执行逻辑即使是同一个高阶函数只要传入不同的函数类型参数那么它的执行逻辑和最终的返回结果就可能是完全不同的为了详细说明这一点下面我们来举一个具体的例子这里我准备定义一个叫作的高阶函数并让它接收两个整型和一个函数类型的参数我们会在函数中对传入的两个整型参数进行某种运算并返回最终的运算结果但是具体进行什么运算是由传入的函数类型参数决定的新建一个文件然后在这个文件中编写如下代码这里定义了两个函数并且这两个函数的参数声明和返回值声明都和函数中的函数类型参数是完全匹配的其中函数将两个参数相加并返回函数将两个参数相减并返回分别对应了两种不同的运算操作有了上述函数之后我们就可以调用函数了在函数中编写如下代码注意这里调用函数的方式第三个参数使用了和这种写法这是一种函数引用方式的写法表示将和函数作为参数传递给函数而由于函数中使用了传入的函数类型参数来决定具体的运算逻辑因此这里实际上就是分别使用了和函数来对两个数字进行运算使用这种函数引用的写法虽然能够正常工作但是如果每次调用任何高阶函数的时候都还得先定义一个与其函数类型参数相匹配的函数这是不是有些太复杂了没错因此还支持其他多种方式来调用高阶函数比如表达式匿名函数成员引用等其中表达式是最常见也是最普遍的高阶函数调用方式接下来要重点使用表达式进行调用上述代码如果使用表达式的写法来实现的话代码如下所示注意在中如果函数的最后一个参数是一个函数那么我们可以在函数调用的括号外部传递这个函数这就是为什么下面例子可以在后面直接写而不需要把它放在括号里这种语法叫做尾随它可以让你的代码更加简洁和易读当你的表达式比较长或者包含多行代码时尾随就显得特别有用在中还可以使用表达式来定义一个匿名函数表达式的语法格式是参数列表函数体在上面例子中就是一个表达式它接受两个参数和并返回它们的余数这个表达式定义了一个函数这个函数的功能是计算两个数的余数当我们把这个表达式作为参数传递给函数时函数会在内部调用这个表达式就像调用一个普通的函数一样所以我们可以直接写因为它就是一个函数只不过这个函数没有名字我们称之为匿名函数或者函数下面我们继续对高阶函数进行探究回顾之前学习的函数它可以用于给表达式提供一个指定的上下文当需要连续调用同一个对象的多个方法时函数可以让代码变得更加精简比如就是一个典型的例子接下来我们就使用高阶函数模仿实现一个类似的功能首先我们给加上一个扩展函数这个扩展函数接收一个函数类型参数并且返回值类型也是注意上述代码使用了的扩展函数和带接收者的首先是一个扩展函数它为类添加了一个新的方法这个方法接受一个带接收者的作为参数然后在的实例上执行这个带接收者的是一种特殊的它的语法格式是接收者类型返回类型在上述代码中就是一个带接收者的这个可以在的实例上调用方法就像在的内部一样当我们调用时可以传递一个带接收者的在这个中可以直接调用的方法例如注意这个函数类型参数的声明方式和我们前面的语法有所不同它在函数类型的前面加上了一的语法结构这是什么意思呢其实这才是定义高阶函数完整的语法规则在函数类型的前面加就表示这个函数类型是定义在哪个类当中的这里将函数类型定义到类当中那这样有什么好处呢好处就是当我们调用函数时传入的表达式将会自动拥有的上下文也就是说我们可以直接调用里面的函数同时这也是函数的实现方式接下来尝试调用这个方法在这个表达式中是接收者类型这意味着这个可以在的实例上调用方法就像在的内部一样这就是为什么可以直接调用方法表示这个不接受任何参数这就是为什么上述表达式中没有参数列表是这个的返回类型但是在实际的表达式中不需要写因为可以根据代码自动推断出返回类型是所以虽然带接收者的的类型声明是但在实际的表达式中只需要写函数体不需要写可以看到函数的用法和函数基本上是一模一样的只不过我们编写的函数目前只能作用在类上面而函数是可以作用在所有类上面的如果想实现函数的这个功能需要借助于的泛型才行内联函数的作用为了接下来可以更好地理解内联函数这个知识点这里简单分析一下高阶函数的实现原理这里使用刚刚编写的函数来举例代码如下所示可以看到上述代码中调用了函数并通过表达式指定对传入的两个整型参数进行求和这段代码在中非常好理解因为这是高阶函数最基本的用法可是我们都知道的代码最终还是要编译成字节码的但中并没有高阶函数的概念那么究竟使用了什么魔法来让支持这种高阶函数的语法呢这就要归功于强大的编译器了的编译器会将这些高阶函数的语法转换成支持的语法结构上述的代码大致会被转换成如下代码考虑到可读性我对这段代码进行了些许调整并不是严格对应了转换成的代码可以看到在这里函数的第三个参数变成了一个接口这是一种内置的接口里面有一个待实现的函数而函数其实就是调用了接口的函数并把和参数传了进去在调用函数的时候之前的表达式在这里变成了接口的匿名类实现然后在函数中实现了的逻辑并将结果返回这就是高阶函数背后的实现原理你会发现原来我们一直使用的表达式在底层被转换成了匿名类的实现方式这就表明我们每调用一次表达式都会创建一个新的匿名类实例当然也会造成额外的内存和性能开销为了解决这个问题提供了内联函数的功能它可以将使用表达式带来的运行时开销完全消除内联函数的用法非常简单只需要在定义高阶函数时加上关键字的声明即可如下所示那么内联函数的工作原理又是什么呢其实并不复杂就是编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方这样也就不存在运行时的开销了首先编译器会将表达式中的代码替换到函数类型参数调用的地方如图所示接下来再将内联函数中的全部代码替换到函数调用的地方如图所示最后代码其实就变成了正是如此内联函数才能完全消除表达式所带来的运行时开销与接下来我们要讨论一些更加特殊的情况比如一个高阶函数中如果接收了两个或者更多函数类型的参数这时我们给函数加上了关键字那么编译器会自动将所有引用的表达式全部进行内联但是如果我们只想内联其中的一个表达式该怎么办呢这时就可以使用关键字了如下所示可以看到这里使用关键字声明了函数原本和这两个函数类型参数所引用的表达式都会被内联但是我们在参数的前面又加上了一个关键字那么现在就只会对参数所引用的表达式进行内联了这就是关键字的作用前面我们已经解释了内联函数的好处那么为什么还要提供一个关键字来排除内联功能呢这是因为内联的函数类型参数在编译的时候会被进行代码替换因此它没有真正的参数属性非内联的函数类型参数可以自由地传递给其他任何函数因为它就是一个真实的参数而内联的函数类型参数只允许传递给另外一个内联函数这也是它最大的局限性另外内联函数和非内联函数还有一个重要的区别那就是内联函数所引用的表达式中是可以使用关键字来进行函数返回的而非内联函数只能进行局部返回为了说明这个问题我们来看下面的例子这里定义了一个叫作的高阶函数用于在表达式中打印传入的字符串参数但是如果字符串参数为空那么就不进行打印注意表达式中是不允许直接使用关键字的这里使用了的写法表示进行局部返回并且不再执行表达式的剩余部分代码现在我们就刚好传入一个空的字符串参数运行程序打印结果如图所示可以看到除了表达式中语句之后的代码没有打印其他的日志是正常打印的说明确实只能进行局部返回但是如果我们将函数声明成一个内联函数那么情况就不一样了如下所示现在函数变成了内联函数我们就可以在表达式中使用关键字了此时的代表的是返回外层的调用函数也就是函数如果想不通为什么的话可以回顾一下之前讲的内联函数的代码替换过程打印结果如下可以看到不管是函数还是函数确实都在关键字之后停止执行了和我们所预期的结果一致将高阶函数声明成内联函数是一种良好的编程习惯事实上绝大多数高阶函数是可以直接声明成内联函数的但是也有少部分例外的情况观察下面的代码示例这段代码在没有加上关键字声明的时候绝对是可以正常工作的但是在加上关键字之后就会提示如图所示的错误首先在函数中我们创建了一个对象并在的表达式中调用了传入的函数类型参数而表达式在编译的时候会被转换成匿名类的实现方式也就是说上述代码实际上是在匿名类中调用了传入的函数类型参数而内联函数所引用的表达式允许使用关键字进行函数返回但是由于我们是在匿名类中调用的函数类型参数此时是不可能进行外层调用函数返回的最多只能对匿名类中的函数调用进行返回因此这里就提示了上述错误也就是说如果我们在高阶函数中创建了另外的或者匿名类的实现并且在这些实现中调用函数类型参数此时再将高阶函数声明成内联函数就一定会提示错误那在这种情况下该如何使用内联函数呢其实很简单借助关键字就可以很好地解决这个问题那么这个关键字又是什么呢前面我们已经分析过之所以会提示图示的错误就是因为内联函数的表达式中允许使用关键字和高阶函数的匿名类实现中不允许使用关键字之间造成了冲突而关键字就像一个契约它用于保证在内联函数的表达式中一定不会使用关键字这样冲突就不存在了问题也就巧妙地解决了声明了之后我们就无法在调用函数时的表达式中使用关键字进行函数返回了但是仍然可以使用的写法进行局部返回总体来说除了在关键字的使用上有所区别之外保留了内联函数的其他所有特性五高阶函数的应用高阶函数非常适用于简化各种的调用一些的原有用法在使用高阶函数简化之后不管是在易用性还是可读性方面都可能会有很大的提升简化的用法首先来看的用法向中存储数据的过程大致可以分为以下步调用的方法获取对象向对象中添加数据调用方法将添加的数据提交完成数据存储操作对应代码如下所示其实我们可以通过扩展函数的方式向类当中添加一个函数并且让他接收一个函数类型的参数此时函数就是一个高阶函数了首先我们通过扩展函数的方式向类中添加了一个函数并且它还接收一个函数类型的参数因此函数自然就是一个高阶函数了注意上述代码使用了中的扩展函数和带接收者的其中我们为类添加了一个新的方法这个方法接收一个带接收者的作为参数在上述代码中是一个带接收者的在这种中你可以直接调用接收者的方法就像在接收者的内部一样这个可以在的实例上调用方法当我们调用时可以传递一个带接收者的在这个中你可以直接调用的方法例如解析为接收者类型这意味着这个可以在的实例上调用方法就像在的内部一样表示这个不接受任何参数表示这个的返回类型是在中类似于中的表示这个函数没有有意义的返回值由于函数内拥有的上下文因此这里可以直接调用方法来获取对象另外函数接收的是一个的函数类型参数因此这里需要调用对函数类型参数进行调用我们就可以在函数类型参数的具体实现中添加数据了最后还要调用方法来提交数据从而完成数据存储操作定义好了函数之后我们以后在项目中使用存储数据就会更加方便了写法如下所示在中其实提供的扩展库中已经包含了上述的简化用法这个扩展库会在创建项目的时候自动引入的中版本号因此我们实际上可以直接在项目中使用如下写法来向存储数据简化的用法主要用于结合的存储和修改数据库中的数据具体的用法示例如下剑来烽火戏诸侯这段代码可以使用函数进行简化这当然没有错只是我们其实还可以做到更好不过在正式开始我们的简化之旅之前我还得向你介绍一个额外的知识点之前学过的函数的用法它允许我们使用这样的语法结构快速创建一个键值对在中使用这样的语法结构会创建一个对象有了这个知识前提之后就可以进行下一步了这个方法的作用是构建一个对象首先方法接收了一个参数也就是使用语法结构创建出来的参数类型但是我们在参数前面加上了一个关键字这是什么意思呢其实对应的就是中的可变参数列表我们允许向这个方法传入个个个甚至任意多个类型的参数这些参数都会被赋值到使用声明的这一个变量上面然后使用循环可以将传入的所有参数遍历出来再来看声明的类型由于是一种键值对的数据结构因此需要通过泛型来指定它的键和值分别对应什么类型的数据值得庆幸的是的所有键都是字符串类型的这里可以直接将键的泛型指定成但的值却可以有多种类型字符串型整型浮点型甚至是所以我们需要将值的泛型指定成这是因为是中所有类的共同基类相当于中的而则表示允许传入空值关键字是用来表示一个函数的参数可以接受可变数量的值也就是说你可以传递任意个数的同类型的值给这个参数例如如果你定义了一个函数那么你可以用不同的方式调用这个函数例如传递三个值传递两个值不传递任何值传递一个数组需要用号展开关键字可以让你的函数更灵活更方便地处理不确定数量的输入类是用来表示一对值的它有两个属性和分别表示第一个值和第二个值你可以用类来存储或返回两个相关的值而不需要创建一个新的类例如如果你想要返回一个函数的最大值和最小值你可以这样写返回一个对象然后你可以这样调用这个函数并解构对象解构对象得到和类可以让你的代码更简洁更易于阅读接下来我们开始为方法实现功能逻辑核心思路就是先创建一个对象然后遍历参数列表取出其中的数据并填入中最终将对象返回即可思路并不复杂但是存在一个问题参数的值是类型的我们怎样让它和所支持的数据类型对应起来呢这个确实没有什么好的办法只能使用语句一一进行条件判断并覆盖所支持的所有数据类型结合下面的代码来理解应该更加清楚一些可以看到上述代码基本就是按照刚才所说的思路进行实现的我们使用循环遍历了参数列表在循环中取出了和并使用语句来判断的类型注意这里将所支持的所有数据类型全部覆盖了进去然后将参数中传入的键值对逐个添加到中最终将返回另外这里还使用了中的功能比如语句进入条件分支后这个条件下面的会被自动转换成类型而不再是类型这样我们就不需要像中那样再额外进行一次向下转型了这个功能在语句中也同样适用有了这个方法之后我们使用时就会变得更加简单了比如向数据库中插入一条数据就可以这样写剑来烽火戏诸侯虽然方法已经非常好用了但是它和高阶函数却一点关系也没有因为方法接收的参数是类型的可变参数列表返回值是对象完全没有用到函数类型这和高阶函数的定义不符从功能性方面方法好像确实用不到高阶函数的知识但是从代码实现方面却可以结合高阶函数来进行进一步的优化比如借助函数方法的实现将会变得更加优雅由于函数的返回值就是它的调用对象本身因此这里我们可以使用单行代码函数的语法糖用等号替代返回值的声明另外函数的表达式中会自动拥有的上下文所以这里可以直接调用的各种方法其实库中也提供了一个具有同样功能的方法用法如下所示剑来烽火戏诸侯六泛型和委托泛型的基本用法准确来讲泛型并不是什么新鲜的事物早在版本中就引入了泛型的机制自然也就支持了泛型功能但是中的泛型和中的泛型有同有异首先解释一下什么是泛型在一般的编程模式下我们需要给任何一个变量指定一个具体的类型而泛型允许我们在不指定具体类型的情况下进行编程这样编写出来的代码将会拥有更好的扩展性举个栗子是一个可以存放数据的列表但是并没有限制我们只能存放整型数据或字符串数据因为它没有指定一个具体的类型而是使用泛型来实现的也正是如此我们才可以使用之类的语法来构建具体类型的列表那么要怎样才能定义自己的泛型实现呢这里先来学习一下基本的语法泛型主要有两种定义方式一种是定义泛型类另一种是定义泛型方法使用的语法结构都是当然括号内的并不是固定要求的事实上你使用任何英文字母或单词都可以但是通常情况下是一种约定俗成的泛型写法如果我们要定义一个泛型类就可以这么写此时的就是一个泛型类中的方法允许使用类型的参数和返回值我们在调用类和方法的时候就可以将泛型指定成具体的类型如下所示这里我们将类的泛型指定成类型于是方法就可以接收一个类型的参数并且它的返回值也变成了类型而如果我们不想定义一个泛型类只是想定义一个泛型方法应该要怎么写呢也很简单只需要将定义泛型的语法结构写在方法上面就可以了如下所示此时的调用方式也需要进行相应的调整可以看到现在是在调用方法的时候指定泛型类型了另外还拥有非常出色的类型推导机制例如我们传入了一个类型的参数它能够自动推导出泛型的类型就是型因此这里也可以直接省略泛型的指定还允许我们对泛型的类型进行限制目前你可以将方法的泛型指定成任意类型但是如果这并不是你想要的话还可以通过指定上界的方式来对泛型的类型进行约束比如这里将方法的泛型上界设置为类型如下所示这种写法就表明我们只能将方法的泛型指定成数字类型比如等但是如果你指定成字符串类型就肯定会报错因为它不是一个数字另外在默认情况下所有的泛型都是可以指定成可空类型的这是因为在不手动指定上界的时候泛型的上界默认是而如果想要让泛型的类型不可为空只需要将泛型的上界手动指定成就可以了之前高阶函数那节有编写一个函数代码如下这个函数的作用和函数基本是一样的只是函数只能作用在类上面而函数是可以作用在所有类上面的现在我们就通过本小节所学的泛型知识对函数进行扩展让它实现和函数完全一样的功能思考一下其实并不复杂只需要使用将函数定义成泛型函数再将原来所有强制指定的地方都替换成就可以了新建一个文件并编写如下代码类委托和委托属性委托是一种设计模式它的基本理念是操作对象自己不会去处理某段逻辑而是会把工作委托给另外一个辅助对象去处理这个概念对于程序员来讲可能相对比较陌生因为对于委托并没有语言层级的实现而像等语言就对委托进行了原生的支持中也是支持委托功能的并且将委托功能分为了两种类委托和委托属性下面我们逐个进行学习类委托首先来看类委托它的核心思想在于将一个类的具体实现委托给另一个类去完成我们曾经使用过这种数据结构它和有点类似只是它所存储的数据是无序的并且不能存储重复的数据是一个接口如果要使用它的话需要使用它具体的实现类比如而借助于委托模式我们可以轻松实现一个自己的实现类比如这里定义一个并让它实现接口代码如下所示可以看到的构造函数中接收了一个参数这就相当于一个辅助对象然后在接口所有的方法实现中我们都没有进行自己的实现而是调用了辅助对象中相应的方法实现这其实就是一种委托模式那么这种写法的好处是什么呢既然都是调用辅助对象的方法实现那还不如直接使用辅助对象得了这么说确实没错但如果我们只是让大部分的方法实现调用辅助对象中的方法少部分的方法实现由自己来重写甚至加入一些自己独有的方法那么就会成为一个全新的数据结构类这就是委托模式的意义所在但是这种写法也有一定的弊端如果接口中的待实现方法比较少还好要是有几十甚至上百个方法的话每个都去这样调用辅助对象中的相应方法实现那可真是要写哭了那么这个问题有没有什么解决方案呢在中确实没有但是在中可以通过类委托的功能来解决中委托使用的关键字是我们只需要在接口声明的后面使用关键字再接上受委托的辅助对象就可以免去之前所写的一大堆模板式的代码了如下所示使用类委派机制这两段代码在功能上是一样的它们都定义了一个名为的类这个类实现了接口并且使用作为辅助工具来提供接口的实现然而它们在实现方式上有所不同第一段代码中类显式地实现了接口的每一个方法每一个方法的实现都是通过调用的对应方法来完成的第二段代码中类使用了的类委托特性将接口的所有方法的实现委托给了对象这意味着类会自动拥有的所有方法并且这些方法的实现会直接使用的对应方法所以虽然这两段代码在功能上是一样的但是第二段代码更简洁因为它利用了的类委托特性避免了手动实现每一个方法的需要在第二段代码中如果我们要对某个方法进行重新实现只需要单独重写那一个方法就可以了其他的方法仍然可以享受类委托所带来的便利委托属性掌握了类委托之后接下来我们开始学习委托属性它的基本理念也非常容易理解真正的难点在于如何灵活地进行应用类委托的核心思想是将一个类的具体实现委托给另一个类去完成而委托属性的核心思想是将一个属性字段的具体实现委托给另一个类去完成我们看一下委托属性的语法结构如下所示可以看到这里使用关键字连接了左边的属性和右边的实例这是什么意思呢这种写法就代表着将属性的具体实现委托给了类去完成当调用属性的时候会自动调用类的方法当给属性赋值的时候会自动调用类的方法因此我们还得对类进行具体的实现才行代码如下所示这是一种标准的代码实现模板在类中我们必须实现和这两个方法并且都要使用关键字进行声明方法要接收两个参数第一个参数用于声明该类的委托功能可以在什么类中使用这里写成表示仅可在类中使用第二个参数是中的一个属性操作类可用于获取各种属性相关的值在当前场景下用不着但是必须在方法参数上进行声明另外这种泛型的写法表示你不知道或者不关心泛型的具体类型只是为了通过语法编译而已有点类似于中的写法至于返回值可以声明成任何类型根据具体的实现逻辑去写就行了上述代码只是一种示例写法方法也是相似的只不过它要接收个参数前两个参数和方法是相同的最后一个参数表示具体要赋值给委托属性的值这个参数的类型必须和方法返回值的类型保持一致整个委托属性的工作流程就是这样实现的现在当我们给的属性赋值时就会调用类的方法当获取中属性的值时就会调用类的方法不过其实还存在一种情况可以不用在类中实现方法那就是中的属性是使用关键字声明的这一点也很好理解如果属性是使用关键字声明的那么就意味着属性是无法在初始化之后被重新赋值的因此也就没有必要实现方法只需要实现方法就可以了实现一个自己的函数我们初始化变量时可以把想要延迟执行的代码放到代码块中这样代码块中的代码在一开始的时候就不会执行只有当变量首次被调用的时候代码块中的代码才会执行学习了的委托功能之后我们就可以对的工作原理进行解密了它的基本语法结构如下实际上并不是连在一起的关键字只有才是中的关键字在这里只是一个高阶函数而已在函数中会创建并返回一个对象当我们调用属性的时候其实调用的是对象的方法然后方法中又会调用函数传入的表达式这样表达式中的代码就可以得到执行了并且调用属性后得到的值就是表达式中最后一行代码的返回值这样看来的懒加载技术也并没有那么神秘掌握了它的实现原理之后我们也可以实现一个自己的函数在这里还没有被创建在这里被创建这段代码演示了如何使用延迟初始化来创建只有在第一次被使用时它才会被创建这是一种很好的做法特别是在对象创建代价高昂且不总是需要该对象的情况下可以帮助节省资源提高应用程序的性能七使用函数构建更可读的语法在中我们可以使用这样的语法结构构建键值对比如在自带的函数这种语法结构的优点是可读性高相比于调用一个函数它更接近于使用英语的语法来编写程序可能你会好奇这种功能是怎么实现的呢是不是语言中的一个关键字首先并不是语言中的一个关键字之所以我们能够使用这样的语法结构是因为提供了一种高级语法糖特性函数当然函数也并不是什么难理解的事物它只是把编程语言函数调用的语法规则调整了一下而已比如这样的写法实际上等价于的写法举个栗子类中有一个函数你一定使用过它可以用于判断一个字符串是否是以某个指定参数开头的比如说下面这段代码的判断结果一定会是函数的用法虽然非常简单但是借助函数我们可以使用一种更具可读性的语法来表达这段代码新建一个文件然后编写如下代码除去最前面的关键字不谈这是一个类的扩展函数我们给类添加了一个函数它也是用于判断一个字符串是否是以某个指定参数开头的并且它的内部实现就是调用的类的函数但是加上了关键字之后函数就变成了一个函数这样除了传统的函数调用方式之外我们还可以用一种特殊的语法糖格式调用函数如下所示从这个例子就能看出函数的语法规则并不复杂上述代码其实就是调用的这个字符串的函数并传入了一个字符串作为参数但是函数允许我们将函数调用时的小数点括号等计算机相关的语法去掉从而使用一种更接近英语的语法来编写程序让代码看起来更加具有可读性另外函数由于其语法糖格式的特殊性有两个比较严格的限制首先函数是不能定义成顶层函数的它必须是某个类的成员函数可以使用扩展函数的方式将它定义到某个类当中其次函数必须接收且只能接收一个参数至于参数类型是没有限制的只有同时满足这两点函数的语法糖才具备使用的条件再举个栗子比如这里有一个集合如果想要判断集合中是否包括某个指定元素一般可以这样写很简单对吗但我们仍然可以借助函数让这段代码变得更加具有可读性在文件中添加如下代码可以看到我们给接口添加了一个扩展函数这是因为是以及所有集合的总接口因此给添加一个函数那么所有集合的子类就都可以使用这个函数了另外这里还使用了上一章中学习的泛型函数的定义方法从而使得函数可以接收任意具体类型的参数而这个函数内部的实现逻辑就相当简单了只是调用了接口中的函数而已也就是说函数和函数的功能实际上是一模一样的只是它多了一个关键字从而拥有了函数的语法糖功能现在我们就可以使用如下的语法来判断集合中是否包括某个指定的元素解析一下中中缀函数的实现其实就只有一段代码这是编程语言中的一种函数声明我们先分解一下这是函数的访问修饰符表示这个函数可以在任何位置被访问这是一个在中表征中缀函数的关键字所谓中缀函数就是可以使用更自然的语言风格调用并且该函数要满足它们必须是成员函数或扩展函数它们必须有一个参数它们的参数不能接受可变数量的参数且不能有默认值这是泛型参数列表表明这个函数可以对任意类型的对象进行操作这是函数的声明函数名为参数为名为的类型对象这是函数的返回类型表示函数返回一个包含两个元素类型分别为和的对象这是函数的实现创建一个新的对象第一个元素是调用函数的对象第二个元素是函数的参数整个函数可以这样理解对任意类型的对象我们定义了一个函数它接受一个任意类型的对象作为参数并返回一个对象举个例子假设有两个变量和那么我们可以使用中缀函数简洁地构造对象代表一对值和八泛型的高级特性之前在泛型的基本用法中学习了泛型的基本用法这些基本用法其实和中泛型的用法是大致相同的因此也相对比较好理解然而实际上在泛型方面还提供了不少特有的功能掌握了这些功能你将可以更好玩转同时还能实现一些不可思议的语法特性对泛型进行实化泛型实化这个功能对于绝大多数程序员来讲是非常陌生的因为中完全没有这个概念而如果我们想要深刻地理解泛型实化就要先解释一下的泛型擦除机制才行在之前是没有泛型功能的那个时候诸如之类的数据结构可以存储任意类型的数据取出数据的时候也需要手动向下转型才行这不仅麻烦而且很危险比如说我们在同一个中存储了字符串和整型这两种数据但是在取出数据的时候却无法区分具体的数据类型如果手动将它们强制转成同一种类型那么就会抛出类型转换异常于是在中终于引入了泛型功能这不仅让诸如之类的数据结构变得简单好用也让我们的代码变得更加安全但是实际上的泛型功能是通过类型擦除机制来实现的什么意思呢就是说泛型对于类型的约束只在编译时期存在运行的时候仍然会按照之前的机制来运行是识别不出来我们在代码中指定的泛型类型的例如假设我们创建了一个集合虽然在编译时期只能向集合中添加字符串类型的元素但是在运行时期并不能知道它本来只打算包含哪种类型的元素只能识别出来它是个所有基于的语言它们的泛型功能都是通过类型擦除机制来实现的其中当然也包括了这种机制使得我们不可能使用或者这样的语法因为的实际类型在运行的时候已经被擦除了然而不同的是提供了一个内联函数的概念我们在第内联函数的作用中已经学过了这个知识点内联函数中的代码会在编译的时候自动被替换到调用它的地方这样的话也就不存在什么泛型擦除的问题了因为代码在编译之后会直接使用实际的类型来替代内联函数中的泛型声明其工作原理如下图所示最终代码会被替换成如下所示可以看到是一个带有泛型类型的内联函数函数调用了函数在代码编译之后函数中的代码将可以获得泛型的实际类型这就意味着中是可以将内联函数中的泛型进行实化的那么具体该怎么写才能将泛型实化呢首先该函数必须是内联函数才行也就是要用关键字来修饰该函数其次在声明泛型的地方必须加上关键字来表示该泛型要进行实化示例代码如下上述函数中的泛型就是一个被实化的泛型因为它满足了内联函数和关键字这两个前提条件那么借助泛型实化到底可以实现什么样的效果呢从函数名就可以看出来了这里我们准备实现一个获取泛型实际类型的功能代码如下所示虽然只有一行代码但是这里却实现了一个中完全不可能实现的功能函数直接返回了当前指定泛型的实际类型这样的语法在中是不合法的而在中借助泛型实化功能就可以使用这样的语法了运行结果打印如下如果将泛型指定成了那么就可以得到的类型如果将泛型指定了就可以得到的类型接下来学习泛型实化的应用泛型实化的应用泛型实化功能允许我们在泛型函数当中获得泛型的实际类型这也就使得类似于这样的语法成为了可能而灵活运用这一特性将可以实现一些不可思议的语法结构在四大组件当中除了之外还有都需要结合一起使用就拿启动来说我们可以这么写有没有觉得这样的语法很难受呢当然如果在没有更好选择的情况下这种写法也是可以忍受的但是的泛型实化功能使得我们拥有了更好的选择新建一个文件然后在里面编写如下代码这里我们定义了一个函数该函数接收一个参数并同时使用和关键字让泛型成为了一个被实化的泛型接下来就是神奇的地方了接收的第二个参数本来应该是一个具体的类型但由于现在已经是一个被实化的泛型了因此这里我们可以直接传入最后调用的方法来完成的启动现在如果我们要启动只需要这样写不过现在的函数其实还是有问题的因为通常在启用的时候还可能会使用附带一些参数比如下面的写法而经过刚才的封装之后我们就无法进行传参了这个问题也不难解决只需要借助之前学习的高阶函数就可以轻松搞定回到文件当中这里添加一个新的函数重载如下所示可以看到这次的函数中增加了一个函数类型参数并且它的函数类型是定义在类当中的在创建完的实例之后随即调用该函数类型参数并把的实例传入这样调用函数的时候就可以在表达式中为传递参数了如下所示泛型的协变在开始学习协变和逆变之前我们还得先了解一个约定一个泛型类或者泛型接口中的方法它的参数列表是接收数据的地方因此可以称它为位置而它的返回值是输出数据的地方因此可以称它为位置如下图所示有了这个约定前提接下来继续学习首先定义如下三个类这里先定义了一个类类中包含和这两个字段然后又定义了和这两个类让它们成为类的子类如果某个方法接收一个类型的参数而我们传入一个的实例这样合不合法呢很显然因为是的子类学生也是人呀因此这是一定合法的如果某个方法接收一个类型的参数而我们传入一个的实例这样合不合法呢看上去好像也挺正确的但是中是不允许这么做的因为不能成为的子类否则将可能存在类型转换的安全隐患为什么会存在类型转换的安全隐患呢下面我们通过一个具体的例子进行说明自定义一个类以及一个方法是一个泛型类它的内部封装了一个泛型字段调用方法可以给字段赋值调用方法可以获取字段的值接着我们假设如果编程语言允许向某个接收参数的方法传入的实例那么如下代码就会是合法的这里会报错可以看到报错信息是类型不匹配这里需要一个而我们却传给了他在方法中我们创建了一个的实例并将它封装到当中然后将作为参数传递给方法但是方法接收的是一个参数这里假设可以编译通过那么在方法中我们就可以创建一个的实例并用它来替换参数中的原有数据这种操作肯定是合法的因为也是的子类所以可以很安全地将的实例设置进去但是问题马上来了回到方法当中我们调用的方法来获取它内部封装的数据可现在中实际包含的却是一个的实例那么此时必然会产生类型转换异常所以为了杜绝这种安全隐患是不允许使用这种方式来传递参数的换句话说即使是的子类并不是的子类不过回顾一下刚才的代码你会发现问题发生的主要原因是我们在方法中向里设置了一个的实例如果在泛型上是只读的话肯定就没有类型转换的安全隐患了那么这个时候可不可以成为的子类呢讲到这里我们终于要引出泛型协变的定义了假如定义了一个的泛型类其中是的子类型同时又是的子类型那么我们就可以称在这个泛型上是协变的但是如何才能让成为的子类型呢刚才已经讲了如果一个泛型类在其泛型类型的数据上是只读的话那么它是没有类型转换安全隐患的而要实现这一点则需要让类中的所有方法都不能接收类型的参数换句话说只能出现在位置上而不能出现在位置上现在修改类的代码如下所示这里我们对类进行了改造在泛型的声明前面加上了一个关键字这就意味着现在只能出现在位置上而不能出现在位置上同时也意味着在泛型上是协变的由于泛型不能出现在位置上因此我们也就不能使用方法为参数赋值了所以这里改成了使用构造函数的方式来赋值你可能会说构造函数中的泛型不也是在位置上的吗没错但是由于这里我们使用了关键字所以构造函数中的泛型仍然是只读的因此这样写是合法且安全的另外即使我们使用了关键字但只要给它加上修饰符保证这个泛型对于外部而言是不可修改的那么就都是合法的写法经过了这样的修改之后下面的代码就可以完美编译通过且没有任何安全隐患了由于类已经进行了协变声明那么自然就是的子类了所以这里可以安全地向方法中传递参数然后在方法中去获取封装的数据虽然这里泛型声明的是类型实际获得的会是一个的实例但由于是的父类向上转型是完全安全的所以这段代码没有任何问题泛型的逆变仅从定义上来看逆变与协变却完全相反那么这里先引出定义吧假如定义了一个的泛型类其中是的子类型同时又是的子类型那么我们就可以称在这个泛型上是逆变的协变和逆变的区别如下图所示从直观的角度上来思考逆变的规则好像挺奇怪的原本是的子类型怎么能反过来成为的子类型了呢举个栗子先定义一个接口用于一些转换操作代码如下可以看到接口中声明了一个方法它接收一个类型的参数并且返回一个类型的数据这意味着参数在经过方法的转换之后将会变成一个字符串至于具体的转换逻辑是什么样的则由子类去实现接口对此并不关心那么现在我们就尝试对接口进行实现代码如下所示首先我们在方法中编写了一个的匿名类实现并通过方法将传入的对象转换成了一个姓名年龄拼接的字符串而方法接收的是一个类型的参数这里在方法中创建了一个对象并调用参数的方法将对象转换成一个字符串这段代码从安全的角度来分析是没有任何问题的因为是的子类使用的匿名类实现将对象转换成一个字符串也是绝对安全的并不存在类型转换的安全隐患但是实际上在调用方法的时候却会提示语法错误原因也很简单并不是的子类型那么这个时候逆变就可以派上用场了它就是专门用于处理这种情况的修改接口中的代码如下所示这里我们在泛型的声明前面加上了一个关键字这就意味着现在只能出现在位置上而不能出现在位置上同时也意味着在泛型上是逆变的没错只要做了这样一点修改刚才的代码就可以编译通过且正常运行了因为此时已经成为了的子类型逆变的用法大概就是这样了如果你还想再深入思考一下的话可以想一想为什么逆变的时候泛型不能出现在位置上为了解释这个问题我们先假设逆变是允许让泛型出现在位置上的然后看一看可能会产生什么样的安全隐患修改中的代码如下所示可以看到我们将方法改成了接收和这两个参数并把返回值类型改成了泛型由于逆变是不允许泛型出现在位置上的这里为了能让编译器正常编译通过所以加上了注解这和源码中使用的技巧是一样的这个时候会产生什么安全隐患呢来看看代码上述代码就是一个典型的违反逆变规则而造成类型转换异常的例子在的匿名类实现中我们使用方法中传入的和参数构建了一个对象并把这个对象直接返回由于方法的返回值要求是一个对象而是的子类因此这种写法肯定是合法的但在方法当中我们调用了的方法并传入了和这两个参数期望得到的是一个对象的返回然而实际上方法返回的却是一个对象因此这里必然会造成类型转换异常异常信息如下可以看到提示我们类型是无法转换成类型的也就是说在提供协变和逆变功能时就已经把各种潜在的类型转换安全隐患全部考虑进去了只要我们严格按照其语法规则让泛型在协变时只出现在位置上逆变时只出现在位置上就不会存在类型转换异常的情况虽然注解可以打破这一语法规则但同时也会带来额外的风险所以你在使用注解时必须很清楚自己在干什么才行最后我们再来介绍一下逆变功能在内置中的应用比较典型的例子就是的使用是一个用于比较两个对象大小的接口其源码定义如下可以看到在这个泛型上就是逆变的方法则用于实现具体的比较逻辑那么这里为什么要让接口是逆变的呢想象如下场景如果我们使用实现了让两个对象比较大小的逻辑那么用这段逻辑去比较两个对象的大小也一定是成立的因此让成为的子类合情合理这也是逆变非常典型的应用九使用协程编写高效的并发程序协程属于中非常有特色的一项技术因为大部分编程语言中是没有协程这个概念的那么什么是协程呢它其实和线程是有点类似的可以简单地将它理解成一种轻量级的线程要知道我们之前所学习的线程是非常重量级的它需要依靠操作系统的调度才能实现不同线程之间的切换而使用协程却可以仅在编程语言的层面就能实现不同协程之间的切换从而大大提升了并发编程的运行效率举一个具体点的例子比如我们有如下和两个方法在没有开启线程的情况下先后调用和这两个方法那么理论上结果一定是执行完了以后才能够得到执行而如果使用了协程在协程中去调用方法协程中去调用方法虽然它们仍然会运行在同一个线程当中但是在执行方法时随时都有可能被挂起转而去执行方法执行方法时也随时都有可能被挂起转而继续执行方法最终的输出结果也就变得不确定了可以看出协程允许我们在单线程模式下模拟多线程编程的效果代码执行时的挂起与恢复完全是由编程语言来控制的和操作系统无关这种特性使得高并发程序的运行效率得到了极大的提升试想一下开启万个线程完全是不可想象的事吧而开启万个协程就是完全可行的协程的基本用法并没有将协程纳入标准库的当中而是以依赖库的形式提供的所以如果我们想要使用协程功能需要先在文件当中添加如下依赖库首先我们要面临的第一个问题就是如何开启一个协程最简单的方式就是使用函数如下所示函数可以创建一个协程的作用域这样传递给函数的代码块表达式就是在协程中运行的了这里我们只是在代码块中打印了一行日志那么现在运行函数日志能成功打印出来吗如果你尝试一下会发现没有任何日志输出这是因为函数每次创建的都是一个顶层协程这种协程当应用程序运行结束时也会跟着一起结束刚才的日志之所以无法打印出来就是因为代码块中的代码还没来得及运行应用程序就结束了要解决这个问题也很简单我们让程序延迟一段时间再结束就行了如下所示这里使用方法让主线程阻塞秒钟现在重新运行程序日志就可以打印出来了可是这种写法还是存在问题如果代码块中的代码在秒钟之内不能运行结束那么就会被强制中断观察如下代码我们在代码块中加入了一个函数并在之后又打印了一行日志函数可以让当前协程延迟指定时间后再运行但它和方法不同函数是一个非阻塞式的挂起函数它只会挂起当前协程并不会影响其他协程的运行而方法会阻塞当前的线程这样运行在该线程下的所有协程都会被阻塞注意函数只能在协程的作用域或其他挂起函数中调用这里我们让协程挂起秒但是主线程却只阻塞了秒最终会是什么结果呢重新运行程序你会发现代码块中新增的一条日志并没有打印出来因为它还没能来得及运行应用程序就已经结束了那么有没有什么办法能让应用程序在协程中所有代码都运行完了之后再结束呢当然也是有的借助函数就可以实现这个功能函数同样会创建一个协程的作用域但是它可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程需要注意的是函数通常只应该在测试环境下使用在正式环境中使用容易产生一些性能上的问题虽说现在我们已经能够让代码在协程中运行了可是好像并没有体会到什么特别的好处这是因为目前所有的代码都是运行在同一个协程当中的而一旦涉及高并发的应用场景协程相比于线程的优势就能体现出来了那么如何才能创建多个协程呢很简单使用函数就可以了如下所示注意这里的函数和我们刚才所使用的函数不同首先它必须在协程的作用域中才能调用其次它会在当前协程的作用域下创建子协程子协程的特点是如果外层作用域的协程结束了该作用域下的所有子协程也会一同结束相比而言函数创建的永远是顶层协程这一点和线程比较像因为线程也没有层级这一说永远都是顶层的这里我们调用了两次函数也就是创建了两个子协程打印结果如下可以看到两个子协程中的日志是交替打印的说明它们确实是像多线程那样并发运行的然而这两个子协程实际却运行在同一个线程当中只是由编程语言来决定如何在多个协程之间进行调度让谁运行让谁挂起调度的过程完全不需要操作系统参与这也就使得协程的并发效率会出奇得高那么具体会有多高呢接下来做个实验这里使用函数循环创建了万个协程不过在协程当中并没有进行什么有意义的操作只是象征性地打印了一个点然后记录一下整个操作的运行耗时现在重新运行一下程序结果如下可以看到这里仅仅耗时了毫秒这足以证明协程有多么高效试想一下如果开启的是万个线程程序或许已经出现异常了不过随着函数中的逻辑越来越复杂可能你需要将部分代码提取到一个单独的函数中这个时候就产生了一个问题我们在函数中编写的代码是拥有协程作用域的但是提取到一个单独的函数中就没有协程作用域了那么我们该如何调用像这样的挂起函数呢为此提供了一个关键字使用它可以将任意函数声明成挂起函数而挂起函数之间都是可以互相调用的如下所示这样就可以在函数中调用函数了但是关键字只能将一个函数声明成挂起函数是无法给它提供协程作用域的比如你现在尝试在函数中调用函数一定是无法调用成功的因为函数要求必须在协程作用域当中才能调用这个问题可以借助函数来解决函数也是一个挂起函数因此可以在任何其他挂起函数中调用它的特点是会继承外部的协程的作用域并创建一个子协程借助这个特性我们就可以给任意挂起函数提供协程作用域了示例写法如下可以看到现在我们就可以在这个挂起函数中调用函数了另外函数和函数还有点类似它可以保证其作用域内的所有代码和子协程在全部执行完之前外部的协程会一直被挂起我们来看如下示例代码这里先使用函数创建了一个协程作用域然后调用函数创建了一个子协程在的作用域中我们又调用函数创建了一个子协程并通过循环依次打印数字到每次打印间隔一秒钟最后在和函数的结尾分别又打印了一行日志现在重新运行一下程序结果如图你会看到控制台会以的间隔依次输出数字到然后才会打印函数结尾的日志最后打印函数结尾的日志由此可见函数确实是将外部协程挂起了只有当它作用域内的所有代码和子协程都执行完毕之后函数之后的代码才能得到运行虽然看上去函数和函数的作用是有点类似的但是函数只会阻塞当前协程既不影响其他协程也不影响任何线程因此是不会造成任何性能上的问题的而函数由于会挂起外部线程如果你恰好又在主线程中当中调用它的话那么就有可能会导致界面卡死的情况所以不太推荐在实际项目中使用更多的作用域构建器我们学习了这几种作用域构建器它们都可以用于创建一个新的协程作用域不过和函数是可以在任意地方调用的函数可以在协程作用域或挂起函数中调用而函数只能在协程作用域中调用前面已经说了由于会阻塞线程因此只建议在测试环境下使用而由于每次创建的都是顶层协程一般也不太建议使用除非你非常明确就是要创建顶层协程为什么说不太建议使用顶层协程呢主要还是因为它管理起来成本太高了举个例子比如我们在某个中使用协程发起了一条网络请求由于网络请求是耗时的用户在服务器还没来得及响应的情况下就关闭了当前此时按理说应该取消这条网络请求或者至少不应该进行回调因为已经不存在了回调了也没有意义那么协程要怎样取消呢不管是函数还是函数它们都会返回一个对象只需要调用对象的方法就可以取消协程了如下所示但是如果我们每次创建的都是顶层协程那么当关闭时就需要逐个调用所有已创建协程的方法试想一下这样的代码是不是根本无法维护因此这种协程作用域构建器在实际项目中也是不太常用的下面演示一下实际项目中比较常用的写法可以看到我们先创建了一个对象然后把它传入函数当中注意这里的是个函数虽然它的命名更像是一个类函数会返回一个对象这种语法结构的设计更像是我们创建了一个的实例可能也是有意为之的有了对象之后就可以随时调用它的函数来创建一个协程了现在所有调用的函数所创建的协程都会被关联在对象的作用域下面这样只需要调用一次方法就可以将同一作用域内的所有协程全部取消从而大大降低了协程管理的成本不过相比之下函数更适合用于实际项目当中如果只是在函数中编写一些学习测试用的代码还是使用函数最为方便我们已经知道了调用函数可以创建一个新的协程但是函数只能用于执行一段逻辑却不能获取执行的结果因为它的返回值永远是一个对象那么有没有什么办法能够创建一个协程并获取它的执行结果呢当然有使用函数就可以实现函数必须在协程作用域当中才能调用它会创建一个新的子协程并返回一个对象如果我们想要获取函数代码块的执行结果只需要调用对象的方法即可代码如下所示这里我们在函数的代码块中进行了一个简单的数学运算然后调用方法获取运算结果最终将结果打印出来重新运行一下代码发现控制台会打印一个不过函数的奥秘还不止于此事实上在调用了函数之后代码块中的代码就会立刻开始执行当调用方法时如果代码块中的代码还没执行完那么方法会将当前协程阻塞住直到可以获得函数的执行结果做个小实验这里连续使用了两个函数来执行任务并在代码块中调用方法进行秒的延迟按照刚才的理论方法在函数代码块中的代码执行完之前会一直将当前协程阻塞住那么为了便于验证我们记录了代码的运行耗时现在重新运行程序结果如下可以看到整段代码的运行耗时是毫秒说明这里的两个函数确实是一种串行的关系前一个执行完了后一个才能执行但是这种写法明显是非常低效的因为两个函数完全可以同时执行从而提高运行效率现在对上述代码使用如下的写法进行修改现在我们不在每次调用函数之后就立刻使用方法获取结果了而是仅在需要用到函数的执行结果时才调用方法进行获取这样两个函数就变成一种并行关系了重新运行程序结果如下所示可以看到现在整段代码的运行耗时变成了毫秒运行效率的提升显而易见最后再来学习一个比较特殊的作用域构建器函数函数是一个挂起函数大体可以将它理解成函数的一种简化版写法示例写法如下调用函数之后会立即执行代码块中的代码同时将外部协程挂起当代码块中的代码全部执行完之后会将最后一行的执行结果作为函数的返回值返回因此基本上相当于的写法唯一不同的是函数强制要求我们指定一个线程参数协程是一种轻量级的线程的概念因此很多传统编程情况下需要开启多线程执行的并发任务现在只需要在一个线程下开启多个协程来执行就可以了但是这并不意味着我们就永远不需要开启线程了比如说中要求网络请求必须在子线程中进行即使你开启了协程去执行网络请求假如它是主线程当中的协程那么程序仍然会出错这个时候我们就应该通过线程参数给协程指定一个具体的运行线程线程参数主要有以下种值可选和表示会使用一种默认低并发的线程策略当你要执行的代码属于计算密集型任务时开启过高的并发反而可能会影响任务的运行效率此时就可以使用表示会使用一种较高并发的线程策略当你要执行的代码大多数时间是在阻塞和等待中比如说执行网络请求时为了能够支持更高的并发数量此时就可以使用则表示不会开启子线程而是在主线程中执行代码但是这个值只能在项目中使用纯程序使用这种类型的线程参数会出现错误事实上在我们刚才所学的协程作用域构建器中除了函数之外其他所有的函数都是可以指定这样一个线程参数的只不过函数是强制要求指定的而其他函数则是可选的使用协程简化回调写法之前学习了编程语言的回调机制并使用这个机制实现了获取异步网络请求数据响应的功能回调机制基本上是依靠匿名类来实现的但是匿名类的写法通常比较烦琐比如如下代码在多少个地方发起网络请求就需要编写多少次这样的匿名类实现还有没有更加简单一点的写法呢在过去可能确实没有什么更加简单的写法了不过现在的协程使我们的这种设想成为了可能只需要借助函数就能将传统回调机制的写法大幅简化下面我们就来具体学习一下函数必须在协程作用域或挂起函数中才能调用它接收一个表达式参数主要作用是将当前协程立即挂起然后在一个普通的线程中执行表达式中的代码表达式的参数列表上会传入一个参数调用它的方法或可以让协程恢复执行了解了函数的作用之后接下来我们就可以借助这个函数来对传统的回调写法进行优化首先定义一个函数代码如下所示可以看到函数是一个挂起函数并且接收一个参数在函数的内部我们调用了刚刚介绍的函数这样当前协程就会被立刻挂起而表达式中的代码则会在普通线程中执行接着我们在表达式中调用方法发起网络请求并通过传统回调的方式监听请求结果如果请求成功就调用的方法恢复被挂起的协程并传入服务器响应的数据该值会成为函数的返回值如果请求失败就调用的恢复被挂起的协程并传入具体的异常原因可是这里不是仍然使用了传统回调的写法吗代码怎么就变得更加简化了这是因为不管之后我们要发起多少次网络请求都不需要再重复进行回调实现了比如说获取百度首页的响应数据就可以这样写由于是一个挂起函数因此当它调用了函数时当前的协程就会被立刻挂起然后一直等待网络请求成功或失败后当前协程才能恢复运行这样即使不使用回调的写法我们也能够获得异步网络请求的响应数据而如果请求失败则会直接进入语句当中可是函数被声明成了挂起函数这样它也只能在协程作用域或其他挂起函数中调用了使用起来是不是非常有局限性确实如此因为函数本身就是要结合协程一起使用的不过通过合理的项目架构设计我们可以轻松地将各种协程的代码应用到一个普通的项目当中事实上函数几乎可以用于简化任何回调的写法比如使用来发起网络请求需要这样写使用函数我们马上就能对上述写法进行大幅度的简化由于不同的接口返回的数据类型也不同所以这次我们不能像刚才那样针对具体的类型进行编程了而是要使用泛型的方式定义一个函数代码如下所示这段代码相比于刚才的函数又复杂了一点首先函数仍然是一个挂起函数然后我们给它声明了一个泛型并将函数定义成了的扩展函数这样所有返回值是类型的网络请求接口就都可以直接调用函数了接着函数中使用了函数来挂起当前协程并且由于扩展函数的原因我们现在拥有了对象的上下文那么这里就可以直接调用方法让发起网络请求接下来使用同样的方式对响应的数据或者网络请求失败的情况进行处理就可以了另外还有一点需要注意在回调当中我们调用方法解析出来的对象是可能为空的如果为空的话这里的做法是手动抛出一个异常你也可以根据自己的逻辑进行更加合适的处理有了函数之后我们调用所有的接口都会变得极其简单比如刚才同样的功能就可以使用如下写法进行实现对服务器响应的数据进行处理对异常情况进行处理没有了冗长的匿名类实现只需要简单调用一下函数就可以让发起网络请求并直接获得服务器响应的数据有没有觉得代码变得极其简单当然你可能会觉得每次发起网络请求都要进行一次处理也比较麻烦其实这里我们也可以选择不处理在不处理的情况下如果发生了异常就会一层层向上抛出一直到被某一层的函数处理了为止因此我们也可以在某个统一的入口函数中只进行一次从而让代码变得更加精简十编写好用的工具方法到目前为止我们已经将大部分系统性的知识点学习完了掌握了如此多的特性还需要知道该如何对它们进行灵活运用事实上提供的丰富语法特性给我们提供了无限扩展的可能各种复杂的经过特殊的封装处理之后都能变得简单易用但是最重要的还是我们要能养成对的各种特性进行灵活运用的意识求个数的最大最小值两个数比大小这个功能相信每一位开发者都遇到过如果我想要获取两个数中较大的那个数除了使用最基本的语句之外还可以借助内置的函数如下所示这种代码看上去简单直观也很容易理解因此好像并没有什么优化的必要可是现在如果我们想要在个数中获取最大的那个数应该怎么写呢由于函数只能接收两个参数因此需要先比较前两个数的大小然后再拿较大的那个数和剩余的数进行比较写法如下有没有觉得代码开始变得复杂了呢个数中获取最大值就需要使用这种嵌套函数的写法了那如果是个数个数呢没错这个时候你就应该意识到我们是可以对函数的用法进行简化的回顾一下我们之前学过关键字它允许方法接收任意多个同等类型的参数正好满足我们这里的需求那么我们就可以新建一个文件并在其中自定义一个函数如下所示可以看到这里函数的参数声明中使用了关键字也就是说现在它可以接收任意多个整型参数接着我们使用了一个变量来记录所有数的最大值并在一开始将它赋值成了整型范围的最小值然后使用循环遍历参数列表如果发现当前遍历的数字比更大就将的值更新成这个数最终将返回即可仅仅经过这样的一层封装之后我们在使用函数时就会有翻天覆地的变化比如刚才同样的功能现在就可以使用如下的写法来实现这样我们就彻底摆脱了嵌套函数调用的写法现在不管是求个数的最大值还是求个数的最大值只需要不断地给函数传入参数就可以了不过目前我们自定义的函数还有一个缺点就是它只能求个整型数字的最大值如果我还想求个浮点型或长整型数字的最大值该怎么办呢当然你可以定义很多个函数的重载来接收不同类型的参数因为中内置的函数也是这么做的但是这种方案实现起来过于烦琐而且还会产生大量的重复代码因此这里我准备使用一种更加巧妙的做法中规定所有类型的数字都是可比较的因此必须实现接口这个规则在中也同样成立那么我们就可以借助泛型将函数修改成接收任意多个实现接口的参数代码如下所示在这个函数中是一个泛型约束这表示类型必须实现接口这样我们才能在函数体内部使用操作符来比较类型的对象在中所有的比较操作符如都定义在接口中因此如果我们想在一个泛型函数中使用这些操作符我们就需要确保泛型类型实现了接口这就是为什么我们需要写的原因这样无论是什么类型只要它实现了接口我们就可以在函数中使用比较操作符这使得我们的函数更加灵活和通用例如我们可以使用这个函数来找出一组整数浮点数或者字符串中的最大值因为这些类型都实现了接口这里将泛型的上界指定成了那么参数就必然是的子类型了接下来我们判断参数列表是否为空如果为空的话就主动抛出一个异常提醒调用者函数必须传入参数紧接着将的值赋值成参数列表中第一个参数的值然后同样是遍历参数列表如果发现了更大的值就对进行更新经过这样的修改之后我们就可以更加灵活地使用函数了比如说求个浮点型数字的最大值同样也变得轻而易举而且现在不管是双精度浮点型单精度浮点型还是短整型整型长整型只要是实现接口的子类型函数全部支持获取它们的最大值是一种一劳永逸的做法而如果你想获取个数的最小值实现的方式也是类似的只需要定义一个函数就可以了简化的用法首先回顾一下的标准用法吧如果想要在界面上弹出一段文字提示需要这样写是不是很长的一段代码而且曾经不知道有多少人因为忘记调用最后的方法导致无法弹出从而产生一些千奇百怪的由于是非常常用的功能每次都需要编写这么长的一段代码确实让人很头疼这个时候你就应该考虑对的用法进行简化了我们来分析一下的方法接收个参数第一个参数是显示的上下文环境必不可少第二个参数是显示的内容需要由调用方进行指定可以传入字符串和字符串资源两种类型第三个参数是显示的时长只支持和这两种值相对来说变化不大那么我们就可以给类和类各添加一个扩展函数并在里面封装弹出的具体逻辑这样以后每次想要弹出提示时只需要调用它们的扩展函数就可以了新建一个文件并在其中编写如下代码这里分别给类和类新增了一个函数并让它们都接收一个参数然后在函数的内部我们仍然使用了原生用法只是将弹出的内容改成了另外将的显示时长固定设置成以后如果要弹出一段文字提醒可以这样写另外这只是直接弹出一段字符串文本的写法如果你想弹出一个定义在中的字符串资源也非常简单写法如下这两种写法分别调用的就是我们刚才在类和类中添加的扩展函数当然这种写法其实还存在一个问题就是的显示时长被固定了如果我现在想要使用类型的显示时长该怎么办呢要解决这个问题其实最简单的做法就是在函数中再声明一个显示时长参数但是这样每次调用函数时都要额外多传入一个参数无疑增加了使用复杂度使用给函数设定参数默认值的功能我们就可以在不增加函数使用复杂度的情况下又让它可以支持动态指定显示时长了修改中的代码如下所示可以看到我们给函数增加了一个显示时长参数但同时也给它指定了一个参数默认值这样我们之前所使用的函数的写法将完全不受影响默认会使用类型的显示时长而如果你想要使用的显示时长只需要这样写就可以了简化的用法先来回顾一下的常规用法吧如下所示可以看到中方法的第一个参数变成了而中方法的第一个参数是另外还可以调用方法来设置一个额外的点击事件除了这些区别之外和的其他用法都是相似的那么对于这种结构的我们该如何进行简化呢其实简化的方式并不固定由于方法接收一个参数会使用这个自动查找最外层的布局用于展示因此我们就可以给类添加一个扩展函数并在里面封装显示的具体逻辑新建一个文件并编写如下代码这段代码应该还是很好理解的和刚才的函数比较相似只是我们将扩展函数添加到了类当中并在参数列表上声明了要显示的内容以及显示的时长另外和类似显示的内容也是支持传入字符串和字符串资源两种类型的因此这里我们给函数进行了两种参数类型的函数重载现在想要使用显示一段文本提示只需要这样写就可以了假如没有方法那么我们的简化工作到这里就可以结束了但是方法作为最大的特色之一如果不能支持的话我们编写的函数也就变得毫无意义了这个时候神通广大的高阶函数又能派上用场了我们可以让函数再额外接收一个函数类型参数以此来实现的完整功能支持修改中的代码如下所示在这个函数中是一个可调用的函数当你调用方法并传入一个函数作为参数时这个函数就会替换例如如果你这样调用方法那么在这行代码中就会被替换为所以当用户点击的操作文本时控制台就会打印出可以看到这里我们给两个函数都增加了一个函数类型参数并且还增加了一个用于传递给方法的字符串或字符串资源这里我们需要将新增的两个参数都设置成可为空的类型并将默认值都设置成空然后只有当两个参数都不为空的时候我们才去调用的方法来设置额外的点击事件如果触发了点击事件只需要调用函数类型参数将事件传递给外部的表达式即可这样函数就拥有比较完整的功能了比如本小节最开始的那段示例代码现在就可以使用如下写法进行实现十一使用构建专有的语法结构的全称是领域特定语言它是编程语言赋予开发者的一种特殊能力通过它我们可以编写出一些看似脱离其原始语法结构的代码从而构建出一种专有的语法结构毫无疑问也是支持的并且在中实现的实现方式并不固定比如我们之前使用函数构建出的特有语法结构就属于不过本节课我们的主要学习目标是通过高阶函数的方式来实现这也是中实现最常见的方式当我们想要在项目中添加一些依赖库需要在文件中添加依赖时其实就使用了例如是一种基于语言的构建工具因此上述的语法结构其实就是提供的功能有没有觉得很神奇不用吃惊借助的我们也可以实现类似的语法结构下面就来具体看一下吧首先新建一个文件然后在里面定义一个类代码如下所示这里我们使用了一个集合来保存所有的依赖库然后又提供了一个方法用于向集合中添加依赖库代码非常简单接下来再定义一个高阶函数代码如下所示可以看到函数接收一个函数类型参数并且该参数是定义到类中的因此调用它的时候需要先创建一个的实例然后再通过该实例调用函数类型参数这样传入的表达式就能得到执行了最后我们将类中保存的依赖库集合返回没错经过这样的设计之后我们就可以在项目中使用如下的语法结构了由于函数接收一个函数类型参数因此这里我们可以传入一个表达式而此时的表达式中拥有类的上下文因此当然就可以直接调用类中的方法来添加依赖库了当然这种语法结构和我们在文件中使用的语法结构并不完全相同这主要是因为和在语法层面还是有一定差别的另外我们也可以通过函数的返回值来获取所有添加的依赖库代码如下所示这里用一个变量接收函数的返回值然后使用循环将集合中的依赖库全部打印出来这种语法结构比起直接调用对象的方法要更直观一些而且你会发现需要添加的依赖库越多使用写法的优势就会越明显在实现了一个较为简单的之后接下来我们再尝试编写一个复杂一点的网页的展示都是由浏览器解析代码来实现的中定义了很多标签其中标签用于创建一个表格标签用于创建表格的行标签用于创建单元格将这种标签嵌套使用就可以定制出包含任意行列的表格了那么如果现在有一个需求要求我们在中动态生成表格所对应的代码你会怎么做呢最简单直接的方式就是字符串拼接了但是这种做法显然十分烦琐而且字符串拼接的代码也难以阅读这个时候又可以大显身手了借助我们可以以一种不可思议的语法结构来动态生成表格所对应的代码下面就来看一下具体应该如何实现吧仍然是在文件中进行编写首先定义一个类代码如下所示由于标签表示一个单元格其中必然是要包含内容的因此这里我们使用了一个字段来存储单元格中显示的内容另外还提供了一个方法当调用这个方法时就返回一段标签的代码并将中存储的内容拼接进去注意为了让最终输出的结果更加直观我使用了和转义符来进行换行和缩进当然可以不加这些转义符因为浏览器在解析代码时是忽略换行和缩进的完成了类接下来我们再定义一个类代码如下所示类相比于类就要复杂一些了由于标签表示表格的行它是可以包含多个标签的因此我们首先创建了一个集合用于存储当前所包含的对象接下来提供了一个函数它接收一个定义到类中并且返回值是的函数类型参数当调用函数时会先创建一个对象接着调用函数类型参数并获取它的返回值然后赋值到类的字段当中这样就可以将调用函数时传入的表达式的返回值赋值给字段了当然这里既然创建了一个对象就一定要记得将它添加到集合当中另外类中也定义了一个方法它的作用和刚才类中的方法一致只是由于每个都可能会包含很多个因此我们需要使用循环来遍历集合将所有的子都拼接到标签当中从而返回一段嵌套的代码定义好了类之后我们现在就可以使用如下的语法格式来构建表格中的一行数据那么接下来继续对进行完善再定义一个类代码如下所示这段代码相对就好理解多了因为和刚才类中的代码是比较相似的类中同样创建了一个集合用于存储当前所包含的对象然后定义了一个函数它接收一个定义到类中的函数类型参数当调用函数时会先创建一个对象接着调用函数类型参数这样表达式中的代码就能得到执行最后仍然要记得将创建的对象添加到集合当中除此之外方法中的代码也都是类似的这里遍历了集合将所有的子对象都拼接到了标签当中那么现在我们就可以使用如下的语法结构来构建一个表格了这段代码看上去已经相当不错了不过这仍然不是最终版本我们还可以再进一步对语法结构进行精简定义一个函数代码如下所示这里的函数接收一个定义到类中的函数类型参数当调用函数时会先创建一个对象接着调用函数类型参数这样表达式中的代码就能得到执行最后调用的方法获取生成的代码并作为最终的返回值返回编写了这么多代码之后我们就可以使用如下神奇的语法结构来动态生成一个表格所对应的代码了另外在中也可以使用的其他语法特性比如通过循环来批量生成和标签这里使用了函数来为表格生成两行数据每行数据中又使用了循环来遍历集合为表格填充具体的单元格数据',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-11 15:46:12',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss/charlie.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="米奇妙妙屋" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://icu007.work/wp-content/uploads/2022/03/head-1.jpeg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://icu007.work/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://chat.icu007.work/" title="ChatGPT"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="ChatGPT"/><span class="back-menu-item-text">ChatGPT</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://baidu.icu007.work/" title="帮你百度一下"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="帮你百度一下"/><span class="back-menu-item-text">帮你百度一下</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">米奇妙妙屋</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 站务</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=6842714056&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 番剧</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 碎碎念</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 传送门</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Android/" style="font-size: 1.05rem;">Android<sup>2</sup></a><a href="/tags/Dos/" style="font-size: 1.05rem;">Dos<sup>1</sup></a><a href="/tags/IDEA/" style="font-size: 1.05rem;">IDEA<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>23</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" style="font-size: 1.05rem;">Java基础语法<sup>5</sup></a><a href="/tags/Java%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">Java异常<sup>2</sup></a><a href="/tags/Java%E6%95%B0%E7%BB%84/" style="font-size: 1.05rem;">Java数组<sup>3</sup></a><a href="/tags/Java%E6%96%B9%E6%B3%95/" style="font-size: 1.05rem;">Java方法<sup>1</sup></a><a href="/tags/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" style="font-size: 1.05rem;">Java流程控制<sup>3</sup></a><a href="/tags/Java%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">Java特性<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">Java面向对象<sup>4</sup></a><a href="/tags/Kotlin/" style="font-size: 1.05rem;">Kotlin<sup>13</sup></a><a href="/tags/Markdown/" style="font-size: 1.05rem;">Markdown<sup>1</sup></a><a href="/tags/WP/" style="font-size: 1.05rem;">WP<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>2</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">排序算法<sup>1</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.05rem;">硬件<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" style="font-size: 1.05rem;">编程入门<sup>13</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">软件分享<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.05rem;">随笔<sup>13</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Kotlin/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Kotlin</span></a><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>编程入门</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Kotlin 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-05-11T07:40:52.000Z" title="发表于 2024-05-11 15:40:52">2024-05-11</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-11T07:46:12.595Z" title="更新于 2024-05-11 15:46:12">2024-05-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">39.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>138分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Kotlin 进阶"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为深圳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>深圳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Kotlin-Advance_535ea90c69f3c.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">Rookie GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="https://icu007work.github.io/archives/4fa27f9d.html"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/Kotlin/" tabindex="-1" itemprop="url">Kotlin</a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" tabindex="-1" itemprop="url">编程入门</a><h1 id="CrawlerTitle" itemprop="name headline">Kotlin 进阶</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Rookie_l</span><time itemprop="dateCreated datePublished" datetime="2024-05-11T07:40:52.000Z" title="发表于 2024-05-11 15:40:52">2024-05-11</time><time itemprop="dateCreated datePublished" datetime="2024-05-11T07:46:12.595Z" title="更新于 2024-05-11 15:46:12">2024-05-11</time></header><h2 id="一、标准函数和静态方法"><a href="#一、标准函数和静态方法" class="headerlink" title="一、标准函数和静态方法"></a>一、标准函数和静态方法</h2><h3 id="1-1-标准函数with、run和apply"><a href="#1-1-标准函数with、run和apply" class="headerlink" title="1.1 标准函数with、run和apply"></a>1.1 标准函数with、run和apply</h3><h4 id="1-1-1-with函数"><a href="#1-1-1-with函数" class="headerlink" title="1.1.1 with函数"></a>1.1.1 with函数</h4><p>with函数接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回值返回。示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(obj)&#123;</span><br><span class="line">    <span class="comment">// obj的上下文</span></span><br><span class="line">    <span class="string">&quot;value&quot;</span> <span class="comment">//with 函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体怎么使用呢？举个栗子🌰：我们有个fruit列表，现在我们需要吃完所有水果，并将结果打印出来。我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listFruit = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">builder.append(<span class="string">&quot;Start eating fruits. \n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> listFruit)&#123;</span><br><span class="line">    builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = builder.toString()</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑很简单，就是使用StringBuilder来构建吃水果的字符串，最后将结果打印出来。我们连续调用了很多次builder对象的方法。其实这个时候就可以考虑使用with函数来让代码变得更加精简。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listWith = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultWith = with(StringBuilder())&#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> listWith)&#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(resultWith)</span><br></pre></td></tr></table></figure>

<p>首先我们给with函数的第一个参数传入了一个StringBuilder对象，那么接下来整个Lambda表达式的上下文就会是这个StringBuilder对象。于是我们在Lambda表达式中就不用再像刚才那样调用builder.append()和builder.toString()方法了，而是可以直接调用append()和toString()方法。Lambda表达式的最后一行代码会作为with函数的返回值返回，最终我们将结果打印出来。</p>
<h4 id="1-1-2-run函数"><a href="#1-1-2-run函数" class="headerlink" title="1.1.2 run函数"></a>1.1.2 run函数</h4><p>run函数的用法和使用场景其实和with函数是非常类似的，只是稍微做了一些语法改动而已。首先run函数通常不会直接调用，而是要在某个对象的基础上调用；其次run函数只接收一个Lambda参数，并且会在Lambda表达式中提供调用对象的上下文。其他方面和with函数是一样的，包括也会使用Lambda表达式中的最后一行代码作为返回值返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.run&#123;</span><br><span class="line">    <span class="comment">// obj的上下文</span></span><br><span class="line">    <span class="string">&quot;value&quot;</span> <span class="comment">//run函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来使用run函数来改写一下上述代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listWith = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultRun = StringBuilder().run&#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> listWith)&#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(resultRun)</span><br></pre></td></tr></table></figure>

<p>总体来说变化非常小，只是将调用with函数并传入StringBuilder对象改成了调用StringBuilder对象的run方法，其他都没有任何区别，这两段代码最终的执行结果是完全相同的。</p>
<h4 id="1-1-3-apply函数"><a href="#1-1-3-apply函数" class="headerlink" title="1.1.3 apply函数"></a>1.1.3 apply函数</h4><p>apply函数和run函数也是极其类似的，都要在某个对象上调用，并且只接收一个Lambda参数，也会在Lambda表达式中提供调用对象的上下文，但是apply函数无法指定返回值，而是会自动返回调用对象本身。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.apply&#123;</span><br><span class="line">    <span class="comment">// obj上下文</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result == obj</span></span><br></pre></td></tr></table></figure>

<p>那么现在我们再使用apply函数来修改一下吃水果的这段代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listWith = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultApply = StringBuilder().run&#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> listWith)&#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(resulApply.toString())</span><br></pre></td></tr></table></figure>

<p>注意这里的代码变化，由于apply函数无法指定返回值，只能返回调用对象本身，因此这里的result实际上是一个StringBuilder对象，所以我们在最后打印的时候还要再调用它的toString()方法才行.</p>
<h3 id="1-2-定义静态方法"><a href="#1-2-定义静态方法" class="headerlink" title="1.2 定义静态方法"></a>1.2 定义静态方法</h3><p>静态方法在某些编程语言里面又叫作类方法，指的就是那种不需要创建实例就能调用的方法，所有主流的编程语言都会支持静态方法这个特性。</p>
<p>在Java中定义一个静态方法非常简单，只需要在方法上声明一个static关键字就可以了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do Action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个非常简单的工具类，上述代码中的doAction()方法就是一个静态方法。调用静态方法并不需要创建类的实例，而是可以直接以Util.doAction()这种写法来调用。因而静态方法非常适合用于编写一些工具类的功能，因为工具类通常没有创建实例的必要，基本是全局通用的。</p>
<p><strong>但是和绝大多数主流编程语言不同的是，Kotlin却极度弱化了静态方法这个概念，想要在Kotlin中定义一个静态方法反倒不是一件容易的事。</strong></p>
<p>那么Kotlin为什么要这样设计呢？因为Kotlin提供了比静态方法更好用的语法特性，并且我们在上一节中已经学习过了，那就是单例类。</p>
<p>像工具类这种功能，在Kotlin中就非常推荐使用单例类的方式来实现，比如上述的Util工具类，如果使用Kotlin来实现的话就可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Util&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这里的doAction()方法并不是静态方法，但是我们仍然可以使用Util.doAction()的方式来调用，这就是单例类所带来的便利性。</p>
<p>不过，使用单例类的写法会将整个类中的所有方法全部变成类似于静态方法的调用方式，而如果我们只是希望让类中的某一个方法变成静态方法的调用方式该怎么办呢？这个时候就可以使用刚刚在最佳实践环节用到的<strong>companion object</strong>了，示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do action2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先我们将Util从单例类改成了一个普通类，然后在类中直接定义了一个doAction1()方法，又在companion object中定义了一个doAction2()方法。现在这两个方法就有了本质的区别，因为doAction1()方法是一定要先创建Util类的实例才能调用的，而doAction2()方法可以直接使用Util.doAction2()的方式调用。</p>
<p>不过，doAction2()方法其实也并不是静态方法，companion object这个关键字实际上会在Util类的内部创建一个伴生类，而doAction2()方法就是定义在这个伴生类里面的实例方法。只是Kotlin会保证Util类始终只会存在一个伴生类对象，因此调用Util.doAction2()方法实际上就是调用了Util类中伴生对象的doAction2()方法。</p>
<p>由此可以看出，Kotlin确实没有直接定义静态方法的关键字，但是提供了一些语法特性来支持类似于静态方法调用的写法，这些语法特性基本可以满足我们平时的开发需求了。然而如果你确确实实需要定义真正的静态方法， Kotlin仍然提供了两种实现方式：<strong>注解和顶层方法</strong>。下面我们来逐个学习一下。</p>
<h4 id="1-2-1-注解"><a href="#1-2-1-注解" class="headerlink" title="1.2.1 注解"></a>1.2.1 注解</h4><p>先来看注解，前面使用的单例类和companion object都只是在语法的形式上模仿了静态方法的调用方式，实际上它们都不是真正的静态方法。因此如果你在Java代码中以静态方法的形式去调用的话，你会发现这些方法并不存在。而如果我们给单例类或companion object中的方法加上@JvmStatic注解，那么Kotlin编译器就会将这些方法编译成真正的静态方法，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do action2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，@JvmStatic注解只能加在单例类或companion object中的方法上，如果你尝试加在一个普通方法上，会直接提示语法错误。由于doAction2()方法已经成为了真正的静态方法，那么现在不管是在Kotlin中还是在Java中，都可以使用Util.doAction2()的写法来调用了。</p>
<h4 id="1-2-2-顶层方法"><a href="#1-2-2-顶层方法" class="headerlink" title="1.2.2 顶层方法"></a>1.2.2 顶层方法</h4><p>再来看顶层方法，顶层方法指的是那些没有定义在任何类中的方法，比如我们在上一节中编写的main()方法。Kotlin编译器会将所有的顶层方法全部编译成静态方法，因此只要你定义了一个顶层方法，那么它就一定是静态方法。</p>
<p>想要定义一个顶层方法，首先需要创建一个Kotlin文件。对着任意包名右击 → New → Kotlin File&#x2F;Class，在弹出的对话框中输入文件名即可。注意创建类型要选择File</p>
<p>点击“OK”完成创建，这样刚刚的包名路径下就会出现一个Helper.kt文件。现在我们在这个文件中定义的任何方法都会是顶层方法，比如这里我就定义一个doSomething()方法吧，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才已经讲过了，Kotlin编译器会将所有的顶层方法全部编译成静态方法，那么我们要怎么调用这个doSomething()方法呢？如果是在Kotlin代码中调用的话，那就很简单了，所有的顶层方法都可以在任何位置被直接调用，不用管包名路径，也不用创建实例，直接键入doSomething()即可.</p>
<p>但如果是在Java代码中调用，你会发现是找不到doSomething()这个方法的，因为Java中没有顶层方法这个概念，所有的方法必须定义在类中。那么这个doSomething()方法被藏在了哪里呢？我们刚才创建的Kotlin文件名叫作Helper.kt，于是Kotlin编译器会自动创建一个叫作HelperKt的Java类，doSomething()方法就是以静态方法的形式定义在HelperKt类里面的，因此在Java中使用HelperKt.doSomething()的写法来调用就可以了.</p>
<hr>
<h2 id="二、延迟初始化和密封类"><a href="#二、延迟初始化和密封类" class="headerlink" title="二、延迟初始化和密封类"></a>二、延迟初始化和密封类</h2><h3 id="2-1-对变量延迟初始化"><a href="#2-1-对变量延迟初始化" class="headerlink" title="2.1 对变量延迟初始化"></a>2.1 对变量延迟初始化</h3><p>前面学习了Kotlin语言的许多特性，包括变量不可变，变量不可为空，等等。这些特性都是为了尽可能地保证程序安全而设计的，但是有的时候会给我们编码带来一些麻烦。</p>
<p>例如如果项目的某个类中存在很多全局变量实例，为了保证它们能够满足Kotlin的空指针检查语法标准，我们不得不做许多的非空判断保护才行，即使非常确定它们不会为空。</p>
<p>们通过一个具体的例子来看一下吧，就使用刚刚的UIBestPractice项目来作为例子。如果仔细观察MainActivity中的代码，会发现这里适配器的写法略微有点特殊：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> msgList = ArrayList&lt;Msg&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter:MsgAdapter? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        adapter = MsgAdapter(msgList)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通知列表有新的数据插入</span></span><br><span class="line">        adapter?.notifyItemInserted(msgList.size - <span class="number">1</span>)</span><br><span class="line">        ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将adapter设置为了全局变量，但是它的初始化工作是在onCreate()方法中进行的，因此不得不先将adapter赋值为null，同时把它的类型声明成MsgAdapter?</p>
<p>虽然我们会在onCreate()方法中对adapter进行初始化，同时能确保onClick()方法必然在onCreate()方法之后才会调用，但是我们在onClick()方法中调用adapter的任何方法时仍然要进行判空处理才行，否则编译肯定无法通过。</p>
<p>当我们的代码中有了越来越多的全局变量实例时，这个问题就会变得越来越明显，到时候我们可能需要编写大量额外的判空处理代码，只是为了满足Kotlin编译器的要求。</p>
<p>那么该如何解决呢？其实非常简单，那就是对全局变量进行延迟初始化。</p>
<p>延迟初始化使用的是lateinit关键字，它可以告诉Kotlin编译器，我会在晚些时候对这个变量进行初始化，这样就不用在一开始的时候将它赋值为null了。</p>
<p>接下来使用延迟初始化对上述代码进行优化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> msgList = ArrayList&lt;Msg&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter:MsgAdapter</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        adapter = MsgAdapter(msgList)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通知列表有新的数据插入</span></span><br><span class="line">        adapter.notifyItemInserted(msgList.size - <span class="number">1</span>)</span><br><span class="line">        ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在adapter变量前面加上lateinit关键字后就用一开始就将它赋值为 null ，同时类型声明也就可以改成MsgAdapter了。由于MsgAdapter是不可为空的类型，所以我们在onClick()方法中也就不再需要进行判空处理，直接调用adapter的任何方法就可以了。</p>
<p>当然，使用lateinit关键字也不是没有任何风险，如果我们在adapter变量还没有初始化的情况下就直接使用它，那么程序就一定会崩溃，并且抛出一个UninitializedPropertyAccessException异常。</p>
<p>我们还可以通过代码来判断一个全局变量是否已经完成了初始化，这样在某些时候能够有效地避免重复对某一个变量进行初始化操作，示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!::adapter.isInitialized)&#123;</span><br><span class="line">    adapter = MsgAdapter(msgList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体语法就是这样，::adapter.isInitialized可用于判断adapter变量是否已经初始化。</p>
<h3 id="2-2-使用密封类优化代码"><a href="#2-2-使用密封类优化代码" class="headerlink" title="2.2 使用密封类优化代码"></a>2.2 使用密封类优化代码</h3><p>首先来了解一下密封类具体的作用，这里我们来看一个简单的例子。新建一个Kotlin文件，文件名就叫Result.kt好了，然后在这个文件中编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> msg: String) : Result</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(<span class="keyword">val</span> error: Exception) : Result</span><br></pre></td></tr></table></figure>

<p>这里定义了一个Result接口，用于表示某个操作的执行结果，接口中不用编写任何内容。然后定义了两个类去实现Result接口：一个Success类用于表示成功时的结果，一个Failure类用于表示失败时的结果，这样就把准备工作做好了。</p>
<p>接下来再定义一个getResultMsg()方法，用于获取最终执行结果的信息，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span>(result)&#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; result.msg</span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; result.error.message</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中接收一个Result参数。我们通过when语句来判断：如果Result属于Success，那么就返回成功的消息；如果Result属于Failure，那么就返回错误信息。到目前为止，代码都是没有问题的，但比较让人讨厌的是，接下来我们不得不再编写一个else条件，否则Kotlin编译器会认为这里缺少条件分支，代码将无法编译通过。但实际上Result的执行结果只可能是Success或者Failure，这个else条件是永远走不到的，所以我们在这里直接抛出了一个异常，只是为了满足Kotlin编译器的语法检查而已。</p>
<p>另外，编写else条件还有一个潜在的风险。如果我们现在新增了一个Unknown类并实现Result接口，用于表示未知的执行结果，但是忘记在getResultMsg()方法中添加相应的条件分支，编译器在这种情况下是不会提醒我们的，而是会在运行的时候进入else条件里面，从而抛出异常并导致程序崩溃。</p>
<p>当然，这种为了满足编译器的要求而编写无用条件分支的情况不仅在Kotlin当中存在，在Java或者是其他编程语言当中也普遍存在。</p>
<p>不过好消息是，Kotlin的密封类可以很好地解决这个问题，下面我们就来学习一下。密封类的关键字是sealed class，它的用法同样非常简单，我们可以轻松地将Result接口改造成密封类的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> msg: String) : Result</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(<span class="keyword">val</span> error: Exception) : Result</span><br></pre></td></tr></table></figure>

<p>可以看到，代码并没有什么太大的变化，只是将interface关键字改成了sealed class。另外，由于密封类是一个可继承的类，因此在继承它的时候需要在后面加上一对括号.</p>
<p>那么改成密封类之后有什么好处呢？你会发现现在getResultMsg()方法中的else条件已经不再需要了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span>(result)&#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; result.msg</span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; result.error.message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这里去掉了else条件仍然能编译通过呢？这是因为当在when语句中传入一个密封类变量作为条件时，Kotlin编译器会自动检查该密封类有哪些子类，并强制要求你将每一个子类所对应的条件全部处理。这样就可以保证，即使没有编写else条件，也不可能会出现漏写条件分支的情况。而如果我们现在新增一个Unknown类，并也让它继承自Result，此时getResultMsg()方法就一定会报错，必须增加一个Unknown的条件分支才能让代码编译通过。</p>
<p>这就是密封类主要的作用和使用方法了。另外再多说一句，密封类及其所有子类只能定义在同一个文件的顶层位置，不能嵌套在其他类中，这是被密封类底层的实现机制所限制的。</p>
<p>了解完理论知识，接下来尝试结合 MsgAdapter中的ViewHolder一起使用顺便优化下MsgAdapter中的代码。</p>
<p>观看MsgAdapter现在的代码，你会发现onBindViewHolder()方法中就存在一个没有实际作用的else条件，只是抛出了一个异常而已。对于这部分代码，我们就可以借助密封类的特性来进行优化。首先删除MsgAdapter中的LeftViewHolder和RightViewHolder，然后新建一个MsgViewHolder.kt文件，在其中加入如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/7-14:46</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">MsgViewHolder</span>(view: View) : RecyclerView.ViewHolder(view)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeftViewHolder</span>(view: View) : MsgViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> leftMsg: TextView = view.findViewById(R.id.leftMsg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RightViewHolder</span>(view: View) : MsgViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> rightMsg: TextView = view.findViewById(R.id.rightMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个密封类MsgViewHolder，并让它继承自RecyclerView.ViewHolder，然后让LeftViewHolder和RightViewHolder继承自MsgViewHolder。这样就相当于密封类MsgViewHolder只有两个已知子类，因此在when语句中只要处理这两种情况的条件分支即可。</p>
<p>现在修改MsgAdapter中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/2-14:34</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;MsgViewHolder&gt;() <span class="comment">/*RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;()*/</span> &#123;</span><br><span class="line">    <span class="comment">/*inner class LeftViewHolder(view: View) : RecyclerView.ViewHolder(view) &#123;</span></span><br><span class="line"><span class="comment">        val leftMsg: TextView = view.findViewById(R.id.leftMsg)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    inner class RightViewHolder(view: View) : RecyclerView.ViewHolder(view) &#123;</span></span><br><span class="line"><span class="comment">        val rightMsg: TextView = view.findViewById(R.id.rightMsg)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">return</span>  msg.type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: MsgViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (viewType == Msg.TYPE_RECEIVED)&#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_left_item,parent,<span class="literal">false</span>)</span><br><span class="line">            LeftViewHolder(view)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_right_item,parent,<span class="literal">false</span>)</span><br><span class="line">            RightViewHolder(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msgList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">MsgViewHolder</span> <span class="comment">/*RecyclerView.ViewHolder*/</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">when</span>(holder)&#123;</span><br><span class="line">            <span class="keyword">is</span> LeftViewHolder -&gt; holder.leftMsg.text = msg.content</span><br><span class="line">            <span class="keyword">is</span> RightViewHolder -&gt; holder.rightMsg.text = msg.content</span><br><span class="line">            <span class="comment">//else -&gt; throw IllegalArgumentException()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将RecyclerView.Adapter的泛型指定成刚刚定义的密封类MsgViewHolder，这样onBindViewHolder()方法传入的参数就变成了MsgViewHolder。然后我们只要在when语句当中处理LeftViewHolder和RightViewHolder这两种情况就可以了，那个讨厌的else终于不再需要了，这种RecyclerView适配器的写法更加规范也更加推荐。</p>
<hr>
<h2 id="三、扩展函数和运算符重载"><a href="#三、扩展函数和运算符重载" class="headerlink" title="三、扩展函数和运算符重载"></a>三、扩展函数和运算符重载</h2><h3 id="3-1-大有用途的扩展函数"><a href="#3-1-大有用途的扩展函数" class="headerlink" title="3.1 大有用途的扩展函数"></a>3.1 大有用途的扩展函数</h3><p>不少现代高级编程语言中有扩展函数这个概念，Java却一直以来都不支持这个非常有用的功能，这多少会让人有些遗憾。但值得高兴的是，Kotlin对扩展函数进行了很好的支持，因此这个知识点是我们无论如何都不能错过的。</p>
<p>首先看一下什么是扩展函数。扩展函数表示即使在不修改某个类的源码的情况下，仍然可以打开这个类，向该类添加新的函数。</p>
<p>为了帮助你更好地理解，我们先来思考一个功能。一段字符串中可能包含字母、数字和特殊符号等字符，现在我们希望统计字符串中字母的数量，你要怎么实现这个功能呢？如果按照一般的编程思维，可能大多数人会很自然地写出如下函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!123&quot;</span></span><br><span class="line">    <span class="keyword">val</span> count = StringUtil.lettersCount(str)</span><br><span class="line">    println(<span class="string">&quot;string is: <span class="variable">$str</span>, letterCount is : <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> StringUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lettersCount</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (char.isLetter()) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先定义了一个StringUtil单例类，然后在这个单例类中定义了一个lettersCount()函数，该函数接收一个字符串参数。在lettersCount()方法中，我们使用for-in循环去遍历字符串中的每一个字符。如果该字符是一个字母的话，那么就将计数器加1，最终返回计数器的值。</p>
<p>这种写法绝对可以正常工作，并且这也是Java编程中最标准的实现思维。但是有了扩展函数之后就不一样了，我们可以使用一种更加面向对象的思维来实现这个功能，比如说将lettersCount()函数添加到String类当中。</p>
<p>下面我们先来学习一下定义扩展函数的语法结构，其实非常简单，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于定义一个普通的函数，定义扩展函数只需要在函数名的前面加上一个ClassName.的语法结构，就表示将该函数添加到指定类当中了。</p>
<p>了解了定义扩展函数的语法结构，接下来我们就尝试使用扩展函数的方式来优化刚才的统计功<br>能。</p>
<p>由于我们希望向String类中添加一个扩展函数，因此需要先创建一个String.kt文件。文件名虽然并没有固定的要求，但是我建议向哪个类中添加扩展函数，就定义一个同名的Kotlin文件，这样便于你以后查找。当然，扩展函数也是可以定义在任何一个现有类当中的，并不一定非要创建新文件。不过通常来说，最好将它定义成顶层方法，这样可以让扩展函数拥有全局的访问域。</p>
<p>现在我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!123&quot;</span></span><br><span class="line">    println(<span class="string">&quot;string is: <span class="variable">$str</span>, letterCount is : <span class="subst">$&#123;str.lettersCount()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lettersCount</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (char <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (char.isLetter())&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的代码变化，现在我们将lettersCount()方法定义成了String类的扩展函数，那么函数中就自动拥有了String实例的上下文。因此lettersCount()函数就不再需要接收一个字符串参数了，而是直接遍历this即可，因为现在this就代表着字符串本身。</p>
<p>定义好了扩展函数之后，统计某个字符串中的字母数量只需要这样写即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;Hello World!123&quot;</span></span><br><span class="line"><span class="keyword">val</span> count = str.lettersCount()</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="string">&quot;hello world!123&quot;</span>.lettersCount()</span><br></pre></td></tr></table></figure>

<p>是不是很神奇？看上去就好像是String类中自带了lettersCount()方法一样。扩展函数在很多情况下可以让API变得更加简洁、丰富，更加面向对象。我们再次以String类为例，这是一个final类，任何一个类都不可以继承它，也就是说它的API只有固定的那些而已，至少在Java中就是如此。然而到了Kotlin中就不一样了，我们可以向String类中扩展任何函数，使它的API变得更加丰富。比如，你会发现Kotlin中的String甚至还有reverse()函数用于反转字符串，capitalize()函数用于对首字母进行大写，等等，这都是Kotlin语言自带的一些扩展函数。这个特性使我们的编程工作可以变得更加简便。</p>
<h3 id="3-2-有趣的运算符重载"><a href="#3-2-有趣的运算符重载" class="headerlink" title="3.2 有趣的运算符重载"></a>3.2 有趣的运算符重载</h3><p>运算符重载是Kotlin提供的一个比较有趣的语法糖。我们知道，Java中有许多语言内置的运算符关键字，如<code>+ - * / % ++ --</code>。而Kotlin允许我们将所有的运算符甚至其他的关键字进行重载，从而拓展这些运算符和关键字的用法。</p>
<p>我们先来回顾一下运算符的基本用法。相信每个人都使用过加减乘除这种四则运算符。在编程语言里面，两个数字相加表示求这两个数字之和，两个字符串相加表示对这两个字符串进行拼接，这种基本用法相信接触过编程的人都明白。但是Kotlin的运算符重载却允许我们让任意两个对象进行相加，或者是进行更多其他的运算操作。</p>
<p>当然，虽然Kotlin赋予了我们这种能力，在实际编程的时候也要考虑逻辑的合理性。比如说，让两个Student对象相加好像并没有什么意义，但是让两个Money对象相加就变得有意义了，因为钱是可以相加的。</p>
<p>那么接下来，我们首先学习一下运算符重载的基本语法，然后再来实现让两个Money对象相加的功能。</p>
<p>运算符重载使用的是operator关键字，只要在指定函数的前面加上operator关键字，就可以实现运算符重载的功能了。但问题在于这个指定函数是什么？这是运算符重载里面比较复杂的一个问题，因为不同的运算符对应的重载函数也是不同的。比如说加号运算符对应的是plus()函数，减号运算符对应的是minus()函数。</p>
<p>这里还是以加号运算符为例，如果想要实现让两个对象相加的功能，那么它的语法结构如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(obj: <span class="type">Obj</span>)</span></span>: Obj &#123;</span><br><span class="line">    <span class="comment">// 处理相加的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述语法结构中，关键字operator和函数名plus都是固定不变的，而接收的参数和函数返回值可以根据你的逻辑自行设定。那么上述代码就表示一个Obj对象可以与另一个Obj对象相加，最终返回一个新的Obj对象。对应的调用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> obj1 = Obj()</span><br><span class="line"><span class="keyword">val</span> obj2 = Obj()</span><br><span class="line"><span class="keyword">val</span> obj3 = obj1 + obj2</span><br></pre></td></tr></table></figure>

<p>这种obj1 + obj2的语法看上去好像很神奇，但其实这就是Kotlin给我们提供的一种语法糖，它会在编译的时候被转换成obj1.plus(obj2)的调用方式。</p>
<p>了解了运算符重载的基本语法之后，下面我们开始实现一个更加有意义功能：让两个Money对象相加。</p>
<p>首先定义Money类的结构，这里我准备让Money的主构造函数接收一个value参数，用于表示钱的金额。创建Money.kt文件，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用了operator关键字来修饰plus()函数，这是必不可少的。在plus()函数中，我们将当前Money对象的value和参数传入的Money对象的value相加，然后将得到的和传给一个新的Money对象并将该对象返回。这样两个Money对象就可以相加了，就是这么简单。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> money1 = Money(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> money2 = Money(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> money = money1 + money2</span><br><span class="line">    println(<span class="string">&quot;Money(6) + Money(7) is <span class="subst">$&#123;money.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，Money对象只允许和另一个Money对象相加，有没有觉得这样不够方便呢？或许你会觉得，如果Money对象能够直接和数字相加的话，就更好了。这个功能当然也是可以实现的，因为Kotlin允许我们对同一个运算符进行多重重载，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span>  money1 = Money(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span>  money2 = Money(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> money = money1 + money2</span><br><span class="line">    println(<span class="string">&quot;Money(6) + Money(7) is <span class="subst">$&#123;money.value&#125;</span>. Money(6) + 6 is <span class="subst">$&#123;(money1 + <span class="number">6</span>).value&#125;</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Int</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们还可以对这个例子进一步扩展，比如加上汇率转换的功能。让1人民币的Money对象和1美元的Money对象相加，然后根据实时汇率进行转换，从而返回一个新的Money对象。这类功能都是非常有趣的，运算符重载如果运用得好的话，可以玩出很多花样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span>  rmb = Money(<span class="number">7.0</span>,<span class="string">&quot;¥&quot;</span>,<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">val</span>  dollar = Money(<span class="number">6.0</span>,<span class="string">&quot;$&quot;</span>,<span class="number">7.1264772</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,dollar,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,dollar,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,rmb,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,rmb,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,dollar,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,dollar,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,rmb,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,rmb,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Dollar(6.0) + RMB(7.0) is <span class="subst">$&#123;(Dollar(<span class="number">6.0</span>) + RMB(<span class="number">7.0</span>)).value&#125;</span><span class="subst">$&#123;(Dollar(<span class="number">6.0</span>) + RMB(<span class="number">7.0</span>)).getCurrency()&#125;</span>.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;RMB(7.0) + Dollar(6.0) is <span class="subst">$&#123;(RMB(<span class="number">7.0</span>) + Dollar(<span class="number">6.0</span>)).value&#125;</span><span class="subst">$&#123;(RMB(<span class="number">7.0</span>) + Dollar(<span class="number">6.0</span>)).getCurrency()&#125;</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>, <span class="keyword">val</span> currency: String, <span class="keyword">val</span> exchangeRate: <span class="built_in">Double</span> = <span class="number">1.0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> convertedValue = money.value * (money.exchangeRate / <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.value + convertedValue, <span class="keyword">this</span>.currency, <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> convertedValue = money.value * (money.exchangeRate / <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.value - convertedValue, <span class="keyword">this</span>.currency, <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">printMoneyOperation</span><span class="params">(money1: <span class="type">Money</span>, money2: <span class="type">Money</span>, operation: <span class="type">String</span>)</span></span>: Money &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">                <span class="string">&quot;+&quot;</span> -&gt; money1 + money2</span><br><span class="line">                <span class="string">&quot;-&quot;</span> -&gt; money1 - money2</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unsupported operation: <span class="variable">$operation</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;money1.value&#125;</span><span class="subst">$&#123;money1.currency&#125;</span> <span class="variable">$operation</span> <span class="subst">$&#123;money2.value&#125;</span><span class="subst">$&#123;money2.currency&#125;</span> is <span class="subst">$&#123;result.value&#125;</span><span class="subst">$&#123;result.currency&#125;</span>.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RMB</span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: RMB &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + (dollar.value * <span class="number">7.1264772</span>)</span><br><span class="line">        <span class="keyword">return</span> RMB(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(rmb: <span class="type">RMB</span>)</span></span>: RMB &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + rmb.value</span><br><span class="line">        <span class="keyword">return</span> RMB(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrency</span><span class="params">()</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dollar</span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(rmb: <span class="type">RMB</span>)</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + (rmb.value * <span class="number">0.140322</span>)</span><br><span class="line">        <span class="keyword">return</span> Dollar(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + dollar.value</span><br><span class="line">        <span class="keyword">return</span> Dollar(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrency</span><span class="params">()</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;$&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上述代码，我们就使用运算符重载实现了对Money类的加减运算并且加上了汇率转换。</p>
<p>实际上Kotlin允许我们重载的运算符和关键字多达十几个。，因此下表列出了所有常用的可重载运算符和关键字对应的语法糖表达式，以及它们会被转换成的实际调用函数。如果你想重载其中某一种运算符或关键字，只要参考刚才加号运算符重载的写法去实现就可以了。</p>
<table>
<thead>
<tr>
<th align="center">语法糖表达式</th>
<th align="center">实际调用函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a + b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a - b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a * b</td>
<td align="center">a.times(b)</td>
</tr>
<tr>
<td align="center">a &#x2F; b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a % b</td>
<td align="center">a.rem(b)</td>
</tr>
<tr>
<td align="center">a++</td>
<td align="center">a.ic()</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()</td>
</tr>
<tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
<tr>
<td align="center">a &#x3D;&#x3D; b</td>
<td align="center">a.equals(b)</td>
</tr>
<tr>
<td align="center">a &gt; b</td>
<td align="center">a.equals(b)</td>
</tr>
<tr>
<td align="center">a &lt; b</td>
<td align="center">a.equals(b)</td>
</tr>
<tr>
<td align="center">a &gt;&#x3D; b</td>
<td align="center">a.equals(b)</td>
</tr>
<tr>
<td align="center">a &lt;&#x3D; b</td>
<td align="center">a.compareTo(b)</td>
</tr>
<tr>
<td align="center">a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
<tr>
<td align="center">a[b]</td>
<td align="center">a.get(b)</td>
</tr>
<tr>
<td align="center">a[b] &#x3D; c</td>
<td align="center">a.set(b, c)</td>
</tr>
<tr>
<td align="center">a in b</td>
<td align="center">b.contains(b)</td>
</tr>
</tbody></table>
<p>最后一个a in b的语法糖表达式对应的实际调用函数是b.contains(a)，a、b对象的顺序是反过来的。这在语义上很好理解，因为a in b表示判断a是否在b当中，而b.contains(a)表示判断b是否包含a，因此这两种表达方式是等价的。</p>
<p>例如我们判断 hello中是否包含 he，我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.contains(<span class="string">&quot;he&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;he&quot;</span> <span class="keyword">in</span> <span class="string">&quot;hello&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个写法的效果其实是一致的。</p>
<p>实践一下，假如我们有一个用于生成随机字符串长度的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> n = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    repeat(n) &#123;</span><br><span class="line">        builder.append(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的核心思想就是将传入的字符串重复n次，如果我们能够使用str * n这种写法来表示让str字符串重复n次，这种语法体验就非常通俗易懂了，而在Kotlin中这又是很容易实现的。</p>
<p>要让一个字符串可以乘以一个数字，那么肯定要在String类中重载乘号运算符才行，但是String类是系统提供的类，我们无法修改这个类的代码。这个时候就可以借助扩展函数功能向String类中添加新函数了。</p>
<p>这个时候我们加入代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    repeat(n)&#123;</span><br><span class="line">        builder.append(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码应该不难理解，这里只讲几个关键的点。首先，operator关键字肯定是必不可少的；然后既然是要重载乘号运算符，参考上表可知，函数名必须是times；最后，由于是定义扩展函数，因此还要在方向名前面加上String.的语法结构。</p>
<p>另外，必须说明的是，其实Kotlin的String类中已经提供了一个用于将字符串重复n遍的repeat()函数，因此times()函数还可以进一步精简成如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">return</span> repeat(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进而简化成：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span> = repeat(n)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、高阶函数详解"><a href="#四、高阶函数详解" class="headerlink" title="四、高阶函数详解"></a>四、高阶函数详解</h2><h3 id="4-1-定义高阶函数"><a href="#4-1-定义高阶函数" class="headerlink" title="4.1 定义高阶函数"></a>4.1 定义高阶函数</h3><p>高阶函数和Lambda的关系是密不可分的。之前几章掌握了一些与集合相关的函数式API的用法，如map、filter函数等。另外，我们之前还学习了Kotlin的标准函数，如run、apply函数等。</p>
<p>这几个函数有一个共同的特点：它们都会要求我们传入一个Lambda表达式作为参数。像这种接收Lambda参数的函数就可以称为具有函数式编程风格的API，而如果你想要定义自己的函数式API，那就得借助高阶函数来实现了</p>
<p>首先来看一下高阶函数的定义：<strong>如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数，那么该函数就称为高阶函数。</strong></p>
<p>一个函数怎么能接收另一个函数作为参数呢？这就涉及另外一个概念了：函数类型。我们知道，编程语言中有整型、布尔型等字段类型，而Kotlin又增加了一个函数类型的概念。如果我们将这种函数类型添加到一个函数的参数声明或者返回值声明当中，那么这就是一个高阶函数了。</p>
<p>接下来学习一下如何定义一个函数类型。不同于定义一个普通的字段类型，函数类型的语法规则是有点特殊的，基本规则如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String, <span class="built_in">Int</span>)-&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>

<p>看到这个语法规则是不是很懵？不用着急，给大家解释一下：既然是定义一个函数类型，那么最关键的就是要声明该函数接收什么参数，以及它的返回值是什么。因此，-&gt;左边的部分就是用来声明该函数接收什么参数的，多个参数之间使用逗号隔开，如果不接收任何参数，写一对空括号就可以了。而-&gt;右边的部分用于声明该函数的返回值是什么类型，如果没有返回值就使用Unit，它大致相当于Java中的void。</p>
<p>现在将上述函数类型添加到某个函数的参数声明或者返回值声明上，那么这个函数就是一个高阶函数了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(func: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    func(<span class="string">&quot;hello&quot;</span>, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的example()函数接收了一个函数类型的参数，因此example()函数就是一个高阶函数。而调用一个函数类型的参数，它的语法类似于调用一个普通的函数，只需要在参数名的后面加上一对括号，并在括号中传入必要的参数即可。</p>
<p>现在已经了解了高阶函数的定义方式，但是这种函数具体有什么用途呢？由于高阶函数的用途实在是太广泛了，这里如果要简单概括一下的话，那就是高阶函数允许让函数类型的参数来决定函数的执行逻辑。即使是同一个高阶函数，只要传入不同的函数类型参数，那么它的执行逻辑和最终的返回结果就可能是完全不同的。为了详细说明这一点，下面我们来举一个具体的例子。</p>
<p>这里我准备定义一个叫作num1AndNum2()的高阶函数，并让它接收两个整型和一个函数类型的参数。我们会在num1AndNum2()函数中对传入的两个整型参数进行某种运算，并返回最终的运算结果，但是具体进行什么运算是由传入的函数类型参数决定的。</p>
<p>新建一个HigherOrderFunction.kt文件，然后在这个文件中编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了两个函数，并且这两个函数的参数声明和返回值声明都和num1AndNum2()函数中的函数类型参数是完全匹配的。其中，plus()函数将两个参数相加并返回，minus()函数将两个参数相减并返回，分别对应了两种不同的运算操作。有了上述函数之后，我们就可以调用num1AndNum2()函数了，在main()函数中编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result1 = num1AndNum2(num1, num2, ::plus)</span><br><span class="line">    <span class="keyword">val</span> result2 = num1AndNum2(num1, num2, ::minus)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里调用num1AndNum2()函数的方式，第三个参数使用了::plus和::minus这种写法。这是一种函数引用方式的写法，表示将plus()和minus()函数作为参数传递给num1AndNum2()函数。而由于num1AndNum2()函数中使用了传入的函数类型参数来决定具体的运算逻辑，因此这里实际上就是分别使用了plus()和minus()函数来对两个数字进行运算。</p>
<p>使用这种函数引用的写法虽然能够正常工作，但是如果每次调用任何高阶函数的时候都还得先定义一个与其函数类型参数相匹配的函数，这是不是有些太复杂了？没错，因此Kotlin还支持其他多种方式来调用高阶函数，比如Lambda表达式、匿名函数、成员引用等。其中，Lambda表达式是最常见也是最普遍的高阶函数调用方式，接下来要重点使用lambda表达式进行调用。</p>
<p>上述代码如果使用Lambda表达式的写法来实现的话，代码如下所示：</p>
<blockquote>
<p>⭐注意：</p>
<p>在 Kotlin 中，如果函数的最后一个参数是一个函数，那么我们可以在函数调用的括号外部传递这个函数。这就是为什么下面例子可以在 <code>num1AndNum2(num1, num2)</code> 后面直接写 <code>&#123;n1, n2 -&gt; n1 % n2&#125;</code>，而不需要把它放在括号里。</p>
<p>这种语法叫做<strong>尾随 lambda</strong>，它可以让你的代码更加简洁和易读。当你的 lambda 表达式比较长或者包含多行代码时，尾随 lambda 就显得特别有用。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HighOrderFunction</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result1 = num1AndNum2(num1, num2, ::plus)</span><br><span class="line">    <span class="keyword">val</span> result2 = num1AndNum2(num1, num2, ::minus)</span><br><span class="line">    <span class="keyword">val</span> result3 = num1AndNum2(num1, num2) &#123;n1, n2 -&gt;</span><br><span class="line">        n1 % n2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result4 = num1AndNum2(num1, num2) &#123;n1, n2 -&gt;</span><br><span class="line">        n1 * n2</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result3</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result4</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⭐</p>
<p>在 Kotlin 中，还可以使用 lambda 表达式来定义一个匿名函数。lambda 表达式的语法格式是 <code>&#123; 参数列表 -&gt; 函数体 &#125;</code>。</p>
<p>在上面例子中，<code>n1, n2 -&gt; n1 % n2</code> 就是一个 lambda 表达式。它接受两个参数 <code>n1</code> 和 <code>n2</code>，并返回它们的余数。这个 lambda 表达式定义了一个函数，这个函数的功能是计算两个数的余数。</p>
<p>当我们把这个 lambda 表达式作为参数传递给 <code>num1AndNum2</code> 函数时，<code>num1AndNum2</code> 函数会在内部调用这个 lambda 表达式，就像调用一个普通的函数一样。</p>
<p>所以，我们可以直接写 <code>n1, n2 -&gt; n1 % n2</code>，因为它就是一个函数，只不过这个函数没有名字，我们称之为匿名函数或者 lambda 函数。</p>
</blockquote>
<p>下面我们继续对高阶函数进行探究。回顾之前学习的apply函数，它可以用于给Lambda表达式提供一个指定的上下文，当需要连续调用同一个对象的多个方法时，apply函数可以让代码变得更加精简，比如StringBuilder就是一个典型的例子。接下来我们就使用高阶函数模仿实现一个类似的功能。</p>
<p>首先我们给StringBuilder加上一个build扩展函数：这个扩展函数接收一个函数类型参数，并且返回值类型也是StringBuilder。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">build</span><span class="params">(block: <span class="type">StringBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span>: StringBuilder&#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⭐注意：</p>
<p>上述代码使用了 Kotlin 的<strong>扩展函数</strong>和<strong>带接收者的 lambda</strong>。</p>
<p>首先，<code>StringBuilder.build</code> 是一个扩展函数，它为 <code>StringBuilder</code> 类添加了一个新的方法。这个方法接受一个带接收者的 lambda 作为参数，然后在 <code>StringBuilder</code> 的实例上执行这个 lambda。</p>
<p>带接收者的 lambda 是一种特殊的 lambda，它的语法格式是 <code>接收者类型.() -&gt; 返回类型</code>。在上述代码中，<code>StringBuilder.() -&gt; Unit</code> 就是一个带接收者的 lambda。这个 lambda 可以在 <code>StringBuilder</code> 的实例上调用方法，就像在 <code>StringBuilder</code> 的内部一样。</p>
<p>当我们调用 <code>StringBuilder().build</code> 时，可以传递一个带接收者的 lambda。在这个 lambda 中，可以直接调用 <code>StringBuilder</code> 的方法，例如 <code>append</code>。</p>
</blockquote>
<p>注意，这个函数类型参数的声明方式和我们前面num1AndNum2的语法有所不同：它在函数类型的前面加上了一StringBuilder. 的语法结构。这是什么意思呢？其实这才是定义高阶函数完整的语法规则，在函数类型的前面加ClassName. 就表示这个函数类型是定义在哪个类当中的。这里将函数类型定义到StringBuilder类当中，那这样有什么好处呢？好处就是当我们调用build函数时传入的Lambda表达式将会自动拥有StringBuilder的上下文，也就是说我们可以直接调用StringBuilder里面的函数，同时这也是apply函数的实现方式。</p>
<p>接下来尝试调用这个方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> word = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder().build&#123;</span><br><span class="line">        append(<span class="string">&quot;start eating fruits.\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit <span class="keyword">in</span> word)&#123;</span><br><span class="line">            append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;ate all fruits.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个 lambda 表达式中：</p>
<ul>
<li><code>StringBuilder.</code> 是接收者类型。这意味着这个 lambda 可以在 <code>StringBuilder</code> 的实例上调用方法，就像在 <code>StringBuilder</code> 的内部一样。这就是为什么可以直接调用 <code>append</code> 方法。</li>
<li><code>()</code> 表示这个 lambda 不接受任何参数。这就是为什么上述 lambda 表达式中没有参数列表。</li>
<li><code>-&gt; Unit</code> 是这个 lambda 的返回类型。但是，在实际的 lambda 表达式中，不需要写 <code>-&gt; Unit</code>。因为 Kotlin 可以根据代码自动推断出返回类型是 <code>Unit</code>。</li>
</ul>
<p>所以，虽然带接收者的 lambda 的类型声明是 <code>StringBuilder.() -&gt; Unit</code>，但在实际的 lambda 表达式中，只需要写函数体，不需要写 <code>-&gt; Unit</code>。</p>
<p>可以看到，build函数的用法和apply函数基本上是一模一样的，只不过我们编写的build函数目前只能作用在StringBuilder类上面，而apply函数是可以作用在所有类上面的。如果想实现apply函数的这个功能，需要借助于Kotlin的泛型才行</p>
<h3 id="4-2-内联函数的作用"><a href="#4-2-内联函数的作用" class="headerlink" title="4.2 内联函数的作用"></a>4.2 内联函数的作用</h3><p>为了接下来可以更好地理解内联函数这个知识点，这里简单分析一下高阶函数的实现原理。</p>
<p>这里使用刚刚编写的num1Andnum2()函数来举例，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result = num1AndNum2(num1, num2) &#123; n1, n2</span><br><span class="line">        n1 + n2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，上述代码中调用了num1AndNum2()函数，并通过Lambda表达式指定对传入的两个整型参数进行求和。这段代码在Kotlin中非常好理解，因为这是高阶函数最基本的用法。可是我们都知道，Kotlin的代码最终还是要编译成Java字节码的，但Java中并没有高阶函数的概念。</p>
<p>那么Kotlin究竟使用了什么魔法来让Java支持这种高阶函数的语法呢？这就要归功于Kotlin强大的编译器了。Kotlin的编译器会将这些高阶函数的语法转换成Java支持的语法结构，上述的Kotlin代码大致会被转换成如下Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num1Andnum2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, Function operation)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) operation.invoke(num1, num2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1Andnum2(num1, num2, <span class="keyword">new</span> <span class="title class_">Function</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">invoke</span><span class="params">(Integer n1, Integer n2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n1 + n2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到可读性，我对这段代码进行了些许调整，并不是严格对应了Kotlin转换成的Java代码。可以看到，在这里num1AndNum2()函数的第三个参数变成了一个Function接口，这是一种Kotlin内置的接口，里面有一个待实现的invoke()函数。而num1AndNum2()函数其实就是调用了Function接口的invoke()函数，并把num1和num2参数传了进去。</p>
<p>在调用num1AndNum2()函数的时候，之前的Lambda表达式在这里变成了Function接口的匿名类实现，然后在invoke()函数中实现了n1 + n2的逻辑，并将结果返回。</p>
<p>这就是Kotlin高阶函数背后的实现原理。你会发现，原来我们一直使用的Lambda表达式在底层被转换成了匿名类的实现方式。这就表明，我们每调用一次Lambda表达式，都会创建一个新的匿名类实例，当然也会造成额外的内存和性能开销。</p>
<p>为了解决这个问题，Kotlin提供了内联函数的功能，它可以将使用Lambda表达式带来的运行时开销完全消除。</p>
<p>内联函数的用法非常简单，只需要在定义高阶函数时加上inline关键字的声明即可，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> operation(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么内联函数的工作原理又是什么呢？其实并不复杂，就是Kotlin编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方，这样也就不存在运行时的开销了。</p>
<p>首先，Kotlin编译器会将Lambda表达式中的代码替换到函数类型参数调用的地方，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/2023/11/25/xiheya_b3196f3ebad9a.png" alt="1700895120471.png"></p>
<p>接下来，再将内联函数中的全部代码替换到函数调用的地方，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/2023/11/25/xiheya_b528a7d70d9a5.png" alt="1700895298709.png"></p>
<p>最后代码其实就变成了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result3 = num1 % num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是如此，内联函数才能完全消除Lambda表达式所带来的运行时开销。</p>
<h3 id="4-3-noinline-与-crossinline"><a href="#4-3-noinline-与-crossinline" class="headerlink" title="4.3 noinline 与 crossinline"></a>4.3 noinline 与 crossinline</h3><p>接下来我们要讨论一些更加特殊的情况。比如，一个高阶函数中如果接收了两个或者更多函数类型的参数，这时我们给函数加上了inline关键字，那么Kotlin编译器会自动将所有引用的Lambda表达式全部进行内联。</p>
<p>但是，如果我们只想内联其中的一个Lambda表达式该怎么办呢？这时就可以使用noinline关键字了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">inlineTest</span><span class="params">(block1: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> block2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用inline关键字声明了inlineTest()函数，原本block1和block2这两个函数类型参数所引用的Lambda表达式都会被内联。但是我们在block2参数的前面又加上了一个noinline关键字，那么现在就只会对block1参数所引用的Lambda表达式进行内联了。这就是noinline关键字的作用。</p>
<p>前面我们已经解释了内联函数的好处，那么为什么Kotlin还要提供一个noinline关键字来排除内联功能呢？<strong>这是因为内联的函数类型参数在编译的时候会被进行代码替换，因此它没有真正的参数属性。非内联的函数类型参数可以自由地传递给其他任何函数，因为它就是一个真实的参数，而内联的函数类型参数只允许传递给另外一个内联函数，这也是它最大的局限性。</strong></p>
<p>另外，内联函数和非内联函数还有一个重要的区别，那就是内联函数所引用的Lambda表达式中是可以使用return关键字来进行函数返回的，而非内联函数只能进行局部返回。为了说明这个问题，我们来看下面的例子。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(str: <span class="type">String</span>, block: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;printString begin&quot;</span>)</span><br><span class="line">    block(str)</span><br><span class="line">    println(<span class="string">&quot;printString end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    printString(str) &#123;s -&gt;</span><br><span class="line">        println(<span class="string">&quot;lambda start&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span><span class="symbol">@printString</span></span><br><span class="line">        println(s)</span><br><span class="line">        println(<span class="string">&quot;lambda end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个叫作printString()的高阶函数，用于在Lambda表达式中打印传入的字符串参数。但是如果字符串参数为空，那么就不进行打印。注意，Lambda表达式中是不允许直接使用return关键字的，这里使用了return@printString的写法，表示进行局部返回，并且不再执行Lambda表达式的剩余部分代码。</p>
<p>现在我们就刚好传入一个空的字符串参数，运行程序，打印结果如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/2023/11/25/xiheya_5a0c911452403.png" alt="1700897776694.png"></p>
<p>可以看到，除了Lambda表达式中return@printString语句之后的代码没有打印，其他的日志是正常打印的，说明return@printString确实只能进行局部返回。</p>
<p>但是如果我们将printString()函数声明成一个内联函数，那么情况就不一样了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(str: <span class="type">String</span>, block: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;printString begin&quot;</span>)</span><br><span class="line">    block(str)</span><br><span class="line">    println(<span class="string">&quot;printString end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    printString(str) &#123;s -&gt;</span><br><span class="line">        println(<span class="string">&quot;lambda start&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span></span><br><span class="line">        println(s)</span><br><span class="line">        println(<span class="string">&quot;lambda end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在printString()函数变成了内联函数，我们就可以在Lambda表达式中使用return关键字了。此时的return代表的是返回外层的调用函数，也就是main()函数，如果想不通为什么的话，可以回顾一下之前讲的内联函数的代码替换过程。</p>
<p>打印结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/2023/11/25/xiheya_eaeb52005d73e.png" alt="1700897878240.png"></p>
<p>可以看到，不管是main()函数还是printString()函数，确实都在return关键字之后停止执行了，和我们所预期的结果一致。</p>
<p>将高阶函数声明成内联函数是一种良好的编程习惯，事实上，绝大多数高阶函数是可以直接声明成内联函数的，但是也有少部分例外的情况。观察下面的代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    runnable.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在没有加上inline关键字声明的时候绝对是可以正常工作的，但是在加上inline关键字之后就会提示如图所示的错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/2023/11/25/xiheya_5551909e6c42e.png" alt="1700898102099.png"></p>
<p>首先，在runRunnable()函数中，我们创建了一个Runnable对象，并在Runnable的Lambda表达式中调用了传入的函数类型参数。而Lambda表达式在编译的时候会被转换成匿名类的实现方式，也就是说，上述代码实际上是在匿名类中调用了传入的函数类型参数。</p>
<p>而内联函数所引用的Lambda表达式允许使用return关键字进行函数返回，但是由于我们是在匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多只能对匿名类中的函数调用进行返回，因此这里就提示了上述错误。</p>
<p>也就是说，如果我们在高阶函数中创建了另外的Lambda或者匿名类的实现，并且在这些实现中调用函数类型参数，此时再将高阶函数声明成内联函数，就一定会提示错误。</p>
<p>那在这种情况下该如何使用内联函数呢？其实很简单，借助crossinline关键字就可以很好地解决这个问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(<span class="keyword">crossinline</span> block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    runnable.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个crossinline关键字又是什么呢？前面我们已经分析过，之所以会提示图示的错误，就是因为内联函数的Lambda表达式中允许使用return关键字，和高阶函数的匿名类实现中不允许使用return关键字之间造成了冲突。而crossinline关键字就像一个契约，它用于保证在内联函数的Lambda表达式中一定不会使用return关键字，这样冲突就不存在了，问题也就巧妙地解决了。</p>
<p>声明了crossinline之后，我们就无法在调用runRunnable函数时的Lambda表达式中使用return关键字进行函数返回了，但是仍然可以使用return@runRunnable的写法进行局部返回。总体来说，除了在return关键字的使用上有所区别之外，crossinline保留了内联函数的其他所有特性。</p>
<hr>
<h2 id="五、高阶函数的应用"><a href="#五、高阶函数的应用" class="headerlink" title="五、高阶函数的应用"></a>五、高阶函数的应用</h2><p>高阶函数非常适用于简化各种API的调用，一些API的原有用法在使用高阶函数简化之后，不管是在易用性还是可读性方面，都可能会有很大的提升。</p>
<h3 id="5-1-简化SharedPreferences的用法"><a href="#5-1-简化SharedPreferences的用法" class="headerlink" title="5.1 简化SharedPreferences的用法"></a>5.1 简化SharedPreferences的用法</h3><p>首先来看SharedPreferences的用法。向SharedPreferences中存储数据的过程大致可以分为以下3步：</p>
<ol>
<li>调用SharedPreferences的edit()方法获取SharedPreferences.Editor对象；</li>
<li>向SharedPreferences.Editor对象中添加数据；</li>
<li>调用apply()方法将添加的数据提交，完成数据存储操作。</li>
</ol>
<p>对应代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> editor = getSharePreferences(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE).edit()</span><br><span class="line">editor.putString(<span class="string">&quot;name&quot;</span>, Tom)</span><br><span class="line">editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">editor.putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">editor.apply()</span><br></pre></td></tr></table></figure>

<p>其实我们可以通过扩展函数的方式向SharedPreference类当中添加一个open函数，并且让他接收一个函数类型的参数，此时open函数就是一个高阶函数了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">open</span><span class="params">(block: <span class="type">SharedPreferences</span>.<span class="type">Editor</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> editor = edit()</span><br><span class="line">    editor.block()</span><br><span class="line">    editor.apply()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们通过扩展函数的方式向SharedPreferences类中添加了一个open函数，并且它还接收一个函数类型的参数，因此open函数自然就是一个高阶函数了。</p>
<blockquote>
<p>⭐注意：</p>
<p>上述代码使用了Kotlin中的<strong>扩展函数</strong>和 <strong>带接收者的lambda</strong></p>
<p>其中 我们为 <code>SharedPreference</code>类添加了一个新的方法—SharedPreference.open,这个方法接收一个 <strong>带接收者的lambda</strong>作为参数。在上述代码中: <code>SharedPreferences.Editor.() -&gt; Unit</code>是一个 <strong>带接收者的lambda</strong>。在这种 lambda 中，你可以直接调用接收者的方法，就像在接收者的内部一样。这个 lambda可以在 <code>SharedPreference.Editor</code>的实例上调用方法，当我们调用<code>SharedPreferences.open</code>时，可以传递一个带接收者的 lambda。在这个 lambda 中，你可以直接调用 <code>SharedPreferences.Editor</code> 的方法，例如<code>putString</code>。</p>
<p>📕解析：</p>
<ul>
<li><code>SharedPreferences.Editor.</code> 为接收者类型。这意味着这个 lambda 可以在 <code>SharedPreferences.Editor</code> 的实例上调用方法，就像在 <code>SharedPreferences.Editor</code> 的内部一样；</li>
<li><code>()</code> 表示这个 lambda 不接受任何参数；</li>
<li><code>-&gt; Unit</code> 表示这个 lambda 的返回类型是 <code>Unit</code>。<code>Unit</code> 在 Kotlin 中类似于 Java 中的 <code>void</code>，表示这个函数没有有意义的返回值。</li>
</ul>
</blockquote>
<p>由于<code>open</code>函数内拥有<code>SharedPreferences</code>的上下文，因此这里可以直接调用<code>edit()</code>方法来获取<code>SharedPreferences.Editor</code>对象。另外<code>open</code>函数接收的是一个<code>SharedPreferences.Editor</code>的函数类型参数，因此这里需要调用<code>editor.block()</code>对函数类型参数进行调用，我们就可以在函数类型参数的具体实现中添加数据了。最后还要调用<code>editor.apply()</code>方法来提交数据，从而完成数据存储操作。</p>
<p>定义好了open函数之后，我们以后在项目中使用SharedPreferences存储数据（Android）就会更加方便了，写法如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSharedPreferences(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE).<span class="keyword">open</span> &#123;</span><br><span class="line">    putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Android中，其实Google提供的KTX扩展库中已经包含了上述SharedPreferences的简化用法，这个扩展库会在Android Studio创建项目的时候自动引入build.gradle的dependencies中。 <code>implementation &#39;androidx.core:core-ktx:版本号&#39;</code>。</p>
<p>因此，我们实际上可以直接在项目中使用如下写法来向<code>SharedPreferences</code>存储数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSharedPreferences(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE).edit &#123;</span><br><span class="line">    putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-简化ContentValues的用法"><a href="#5-2-简化ContentValues的用法" class="headerlink" title="5.2 简化ContentValues的用法"></a>5.2 简化ContentValues的用法</h3><p>ContentValues主要用于结合SQLiteDatabase的API存储和修改数据库中的数据，具体的用法示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = ContentValues()</span><br><span class="line">values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;剑来&quot;</span>)</span><br><span class="line">values.put(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;烽火戏诸侯&quot;</span>)</span><br><span class="line">values.put(<span class="string">&quot;pages&quot;</span>, <span class="number">60000</span>)</span><br><span class="line">values.put(<span class="string">&quot;price&quot;</span>, <span class="number">60.99</span>)</span><br><span class="line">db.insert(<span class="string">&quot;book&quot;</span>, <span class="literal">null</span>, valuse)</span><br></pre></td></tr></table></figure>

<p>这段代码可以使用<code>apply</code>函数进行简化。这当然没有错，只是我们其实还可以做到更好。不过在正式开始我们的简化之旅之前，我还得向你介绍一个额外的知识点。之前学过的<code>mapOf()</code>函数的用法。它允许我们使用<code>&quot;Apple&quot; to 1</code>这样的语法结构快速创建一个键值对。<strong>在Kotlin中使用A to B这样的语法结构会创建一个Pair对象。</strong></p>
<p>有了这个知识前提之后，就可以进行下一步了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cvOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;)</span></span>: ContentValues &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用是构建一个<code>ContentValues</code>对象。首先，<code>cvOf()</code>方法接收了一个<code>Pair</code>参数，也就是使用<code>A to B</code>语法结构创建出来的<strong>参数类型</strong>，但是我们在参数前面加上了一个<code>vararg</code>关键字，这是什么意思呢？其实<code>vararg</code>对应的就是Java中的可变参数列表，我们允许向这个方法传入0个、1个、2个甚至任意多个Pair类型的参数，这些参数都会被赋值到使用<code>vararg</code>声明的这一个变量上面，然后使用<code>for-in</code>循环可以将传入的所有参数遍历出来。</p>
<p>再来看声明的<code>Pair</code>类型。由于<code>Pair</code>是一种键值对的数据结构，因此需要通过泛型来指定它的键和值分别对应什么类型的数据。值得庆幸的是，<code>ContentValues</code>的所有键都是字符串类型的，这里可以直接将<code>Pair</code>键的泛型指定成<code>String</code>。但<code>ContentValues</code>的值却可以有多种类型（字符串型、整型、浮点型，甚至是null），所以我们需要将<code>Pair</code>值的泛型指定成<code>Any?</code>。这是因为<code>Any</code>是<code>Kotlin</code>中所有类的共同基类，相当于<code>Java</code>中的<code>Object</code>，而<code>Any?</code>则表示允许传入空值。</p>
<blockquote>
<p>vararg 关键字是用来表示一个函数的参数可以接受可变数量的值，也就是说，你可以传递任意个数的同类型的值给这个参数。例如，如果你定义了一个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(<span class="keyword">vararg</span> numbers: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> (n <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">     total += n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么你可以用不同的方式调用这个函数，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 传递三个值</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 传递两个值</span></span><br><span class="line">sum() <span class="comment">// 不传递任何值</span></span><br><span class="line">sum(*arrayOf(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)) <span class="comment">// 传递一个数组，需要用 * 号展开</span></span><br></pre></td></tr></table></figure>

<p>vararg 关键字可以让你的函数更灵活，更方便地处理不确定数量的输入。</p>
<p>Pair 类是用来表示一对值的，它有两个属性：first 和 second，分别表示第一个值和第二个值。你可以用 Pair 类来存储或返回两个相关的值，而不需要创建一个新的类。例如，如果你想要返回一个函数的最大值和最小值，你可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minMax</span><span class="params">(numbers: <span class="type">IntArray</span>)</span></span>: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"> <span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line"> <span class="keyword">for</span> (n <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt; min) min = n</span><br><span class="line">     <span class="keyword">if</span> (n &gt; max) max = n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Pair(min, max) <span class="comment">// 返回一个 Pair 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以这样调用这个函数，并解构 Pair 对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (min, max) = minMax(intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 解构 Pair 对象，得到 min 和 max</span></span><br><span class="line">println(<span class="string">&quot;The minimum is <span class="variable">$min</span> and the maximum is <span class="variable">$max</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Pair 类可以让你的代码更简洁，更易于阅读.</p>
</blockquote>
<p>接下来我们开始为<code>cvOf()</code>方法实现功能逻辑，核心思路就是先创建一个<code>ContentValues</code>对象，然后遍历<code>pairs</code>参数列表，取出其中的数据并填入<code>ContentValues</code>中，最终将<code>ContentValues</code>对象返回即可。思路并不复杂，但是存在一个问题：<code>Pair</code>参数的值是<code>Any?</code>类型的，我们怎样让它和<code>ContentValues</code>所支持的数据类型对应起来呢？这个确实没有什么好的办法，只能使用<code>when</code>语句一一进行条件判断，并覆盖<code>ContentValues</code>所支持的所有数据类型。结合下面的代码来理解应该更加清楚一些：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cvOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;)</span></span>: ContentValues &#123;</span><br><span class="line">    <span class="keyword">val</span> cv = ContentValues()</span><br><span class="line">    <span class="keyword">for</span> (pair <span class="keyword">in</span> pairs) &#123;</span><br><span class="line">        <span class="keyword">val</span> key = pair.first</span><br><span class="line">        <span class="keyword">val</span> value = pair.second</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> <span class="built_in">Int</span>, <span class="built_in">Long</span>, <span class="built_in">Short</span>, <span class="built_in">Float</span>, <span class="built_in">Double</span>, <span class="built_in">Boolean</span>, String, <span class="built_in">Byte</span>, ByteArray -&gt; cv.put(key, value)</span><br><span class="line">            <span class="keyword">else</span> -&gt; cv.putNull(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，上述代码基本就是按照刚才所说的思路进行实现的。我们使用<code>for-in</code>循环遍历了<code>pairs</code>参数列表，在循环中取出了<code>key</code>和<code>value</code>，并使用<code>when</code>语句来判断<code>value</code>的类型。注意，这里将<code>ContentValues</code>所支持的所有数据类型全部覆盖了进去，然后将参数中传入的键值对逐个添加到<code>ContentValues</code>中，最终将<code>ContentValues</code>返回。</p>
<p>另外，这里还使用了<code>Kotlin</code>中的<code>Smart Cast</code>功能。比如<code>when</code>语句进入<code>Int</code>条件分支后，这个条件下面的<code>value</code>会被自动转换成<code>Int</code>类型，而不再是<code>Any?</code>类型，这样我们就不需要像<code>Java</code>中那样再额外进行一次向下转型了，这个功能在<code>if</code>语句中也同样适用。</p>
<p>有了这个<code>cvOf()</code>方法之后，我们使用<code>ContentValues</code>时就会变得更加简单了，比如向数据库中插入一条数据就可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = cvOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;剑来&quot;</span>, <span class="string">&quot;author&quot;</span> to <span class="string">&quot;烽火戏诸侯&quot;</span>, <span class="string">&quot;pages&quot;</span> to <span class="number">60000</span>, <span class="string">&quot;price&quot;</span> to <span class="number">60.99</span>)</span><br><span class="line">db.insert(<span class="string">&quot;book&quot;</span>, <span class="literal">null</span>, valuse)</span><br></pre></td></tr></table></figure>

<p>虽然<code>cvOf()</code>方法已经非常好用了，但是它和高阶函数却一点关系也没有。因为<code>cvOf()</code>方法接收的参数是Pair类型的可变参数列表，返回值是<code>ContentValues</code>对象，完全没有用到函数类型，这和高阶函数的定义不符。</p>
<p>从功能性方面，<code>cvOf()</code>方法好像确实用不到高阶函数的知识，但是从代码实现方面，却可以结合高阶函数来进行进一步的优化。比如借助<code>apply</code>函数，<code>cvOf()</code>方法的实现将会变得更加优雅：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ContentValues.<span class="title">cvOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;)</span></span> = apply &#123;</span><br><span class="line">    <span class="keyword">for</span> (pair <span class="keyword">in</span> pairs) &#123;</span><br><span class="line">        <span class="keyword">val</span> key = pair.first</span><br><span class="line">        <span class="keyword">val</span> value = pair.second</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> <span class="built_in">Int</span>, <span class="built_in">Long</span>, <span class="built_in">Short</span>, <span class="built_in">Float</span>, <span class="built_in">Double</span>, <span class="built_in">Boolean</span>, String, <span class="built_in">Byte</span>, ByteArray -&gt; put(key, value)</span><br><span class="line">            <span class="keyword">else</span> -&gt; putNull(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>apply</code>函数的返回值就是它的调用对象本身，因此这里我们可以使用单行代码函数的语法糖，用等号替代返回值的声明。另外，<code>apply</code>函数的Lambda表达式中会自动拥有<code>ContentValues</code>的上下文，所以这里可以直接调用<code>ContentValues</code>的各种<code>put</code>方法。</p>
<p>其实KTX库中也提供了一个具有同样功能的contentValuesOf()方法，用法如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = contentValuesOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;剑来&quot;</span>, <span class="string">&quot;author&quot;</span> to <span class="string">&quot;烽火戏诸侯&quot;</span>, <span class="string">&quot;pages&quot;</span> to <span class="number">60000</span>, <span class="string">&quot;price&quot;</span> to <span class="number">60.99</span>)</span><br><span class="line">db.insert(<span class="string">&quot;book&quot;</span>, <span class="literal">null</span>, valuse)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、泛型和委托"><a href="#六、泛型和委托" class="headerlink" title="六、泛型和委托"></a>六、泛型和委托</h2><h3 id="6-1-泛型的基本用法"><a href="#6-1-泛型的基本用法" class="headerlink" title="6.1 泛型的基本用法"></a>6.1 泛型的基本用法</h3><p>准确来讲，泛型并不是什么新鲜的事物。Java早在1.5版本中就引入了泛型的机制，Kotlin自然也就支持了泛型功能。但是Kotlin中的泛型和Java中的泛型有同有异。</p>
<p>首先解释一下什么是泛型。在一般的编程模式下，我们需要给任何一个变量指定一个具体的类型，而<strong>泛型允许我们在不指定具体类型的情况下进行编程，这样编写出来的代码将会拥有更好的扩展性。</strong></p>
<p>举个栗子🌰：List是一个可以存放数据的列表，但是List并没有限制我们只能存放整型数据或字符串数据，<strong>因为它没有指定一个具体的类型，而是使用泛型来实现的</strong>。也正是如此，我们才可以使用<code>List&lt;Int&gt;</code>、<code>List&lt;String&gt;</code>之类的语法来构建具体类型的列表。</p>
<p>那么要怎样才能定义自己的泛型实现呢？这里先来学习一下基本的语法。</p>
<p>泛型主要有两种定义方式：<strong>一种是定义泛型类</strong>，<strong>另一种是定义泛型方法</strong>，使用的语法结构都是<code>&lt;T&gt;</code>。<strong>当然括号内的T并不是固定要求的，事实上你使用任何英文字母或单词都可以，但是通常情况下，T是一种约定俗成的泛型写法。</strong></p>
<p>如果我们要定义一个泛型类，就可以这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的MyClass就是一个泛型类，MyClass中的方法允许使用T类型的参数和返回值。</p>
<p>我们在调用MyClass类和method()方法的时候，就可以将泛型指定成具体的类型，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myClass = MyClass&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们将MyClass类的泛型指定成Int类型，于是<code>method()</code>方法就可以接收一个Int类型的参数，并且它的返回值也变成了Int类型。</p>
<p>而如果我们不想定义一个泛型类，只是想定义一个泛型方法，应该要怎么写呢？也很简单，只需要将定义泛型的语法结构写在方法上面就可以了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的调用方式也需要进行相应的调整：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myClass = MyClass()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method&lt;<span class="built_in">Int</span>&gt;(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，现在是在调用method()方法的时候指定泛型类型了。另外，Kotlin还拥有非常出色的<strong>类型推导机制</strong>，例如<strong>我们传入了一个Int类型的参数，它能够自动推导出泛型的类型就是Int型</strong>，因此这里也可以直接省略泛型的指定：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myClass = MyClass()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<p>Kotlin<strong>还允许我们对泛型的类型进行限制</strong>。目前你可以将<code>method()</code>方法的泛型指定成任意类型，但是如果这并不是你想要的话，还<strong>可以通过指定上界的方式来对泛型的类型进行约束</strong>，<strong>比如这里将<code>method()</code>方法的泛型上界设置为Number类型</strong>，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Number&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法就表明，<strong>我们只能将method()方法的泛型指定成数字类型</strong>，比如<code>Int</code>、<code>Float</code>、<code>Double</code>等。但是<strong>如果你指定成字符串类型，就肯定会报错，因为它不是一个数字。</strong></p>
<p>另外，<strong>在默认情况下，所有的泛型都是可以指定成可空类型的</strong>，这是因为在<strong>不手动指定上界的时候</strong>，<strong>泛型的上界默认是<code>Any?</code><strong>。而如果</strong>想要让泛型的类型不可为空</strong>，只需要将泛型的<strong>上界</strong>手动<strong>指定成</strong><code>Any</code>就可以了。</p>
<p>之前高阶函数那节有编写一个 build函数代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">build</span><span class="params">(block: <span class="type">StringBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span>: StringBuilder &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用和<code>apply</code>函数基本是一样的，只是<code>build</code>函数只能作用在<code>StringBuilder</code>类上面，而<code>apply</code>函数是可以作用在<strong>所有类</strong>上面的。现在我们就通过本小节所学的泛型知识对build函数进行扩展，让它实现和apply函数完全一样的功能。</p>
<p>思考一下，其实并不复杂，只需要使用<T>将build函数定义成泛型函数，再将原来所有强制指定StringBuilder的地方都替换成T就可以了。新建一个build.kt文件，并编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">build</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T&#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-类委托和委托属性"><a href="#6-2-类委托和委托属性" class="headerlink" title="6.2 类委托和委托属性"></a>6.2 类委托和委托属性</h3><p><strong>委托是一种设计模式，它的基本理念是：操作对象自己不会去处理某段逻辑，而是会把工作委托给另外一个辅助对象去处理。</strong>这个概念对于Java程序员来讲可能相对比较陌生，因为Java对于委托并没有语言层级的实现，而像C#等语言就对委托进行了原生的支持。Kotlin中也是支持委托功能的，并且将<strong>委托功能分为了两种：类委托和委托属性。</strong>下面我们逐个进行学习。</p>
<h4 id="6-2-1-类委托"><a href="#6-2-1-类委托" class="headerlink" title="6.2.1 类委托"></a>6.2.1 类委托</h4><p>首先来看<strong>类委托</strong>，<strong>它的核心思想在于将一个类的具体实现委托给另一个类去完成</strong>。我们曾经使用过Set这种数据结构，它和<strong>List</strong>有点类似，只是它所存储的数据是无序的，并且不能存储重复的数据。<strong>Set</strong>是一个接口，如果要使用它的话，需要使用它具体的实现类，比如<strong>HashSet</strong>。而借助于委托模式，我们可以轻松实现一个自己的实现类。比如这里定义一个<strong>MySet</strong>，并让它实现<strong>Set</strong>接口，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = helperSet.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = helperSet.isEmpty()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> helperSet.iterator()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helperSet.containsAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helperSet.contains(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>MySet</code>的构造函数中接收了一个<code>HashSet</code>参数，这就相当于一个辅助对象。然后在<code>Set</code>接口所有的方法实现中，我们都没有进行自己的实现，而是调用了辅助对象中相应的方法实现，这其实就是一种委托模式。</p>
<p>那么，这种写法的<strong>好处</strong>是什么呢？既然都是调用辅助对象的方法实现，那还不如直接使用辅助对象得了。这么说确实没错，但如果我们只是让大部分的方法实现调用辅助对象中的方法，少部分的方法实现由自己来重写，甚至加入一些自己独有的方法，那么<code>MySet</code>就会成为一个全新的数据结构类，这就是委托模式的意义所在。</p>
<p>但是这种写法也有一定的弊端，如果接口中的待实现方法比较少还好，要是有几十甚至上百个方法的话，每个都去这样调用辅助对象中的相应方法实现，那可真是要写哭了。那么这个问题有没有什么解决方案呢？在<code>Java</code>中确实没有，但是在<code>Kotlin</code>中可以通过类委托的功能来解决。</p>
<p><strong>Kotlin中委托使用的关键字是by</strong>，我们只需要在接口声明的后面使用by关键字，再接上受委托的辅助对象，就可以免去之前所写的一大堆模板式的代码了，如下所示：使用类委派机制：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="keyword">by</span> helperSet&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两段代码在功能上是一样的。它们都定义了一个名为 <code>MySet</code> 的类，这个类实现了 <code>Set</code> 接口，并且使用 <code>HashSet</code> 作为辅助工具来提供 <code>Set</code> 接口的实现。</p>
<p>然而，它们在实现方式上有所不同：</p>
<ul>
<li>第一段代码中，<code>MySet</code> 类显式地实现了 <code>Set</code> 接口的每一个方法。每一个方法的实现都是通过调用 <code>helperSet</code> 的对应方法来完成的。</li>
<li>第二段代码中，<code>MySet</code> 类使用了 Kotlin 的类委托特性，将 <code>Set</code> 接口的所有方法的实现委托给了 <code>helperSet</code> 对象。这意味着 <code>MySet</code> 类会自动拥有 <code>Set</code> 的所有方法，并且这些方法的实现会直接使用 <code>helperSet</code> 的对应方法。</li>
</ul>
<p>所以，虽然这两段代码在功能上是一样的，但是第二段代码更简洁，因为它利用了 Kotlin 的类委托特性，避免了手动实现每一个方法的需要。</p>
<p>在第二段代码中，如果我们要对某个方法进行重新实现，只需要单独重写那一个方法就可以了，其他的方法仍然可以享受类委托所带来的便利。</p>
<h4 id="6-2-2-委托属性"><a href="#6-2-2-委托属性" class="headerlink" title="6.2.2 委托属性"></a>6.2.2 委托属性</h4><p>掌握了类委托之后，接下来我们开始学习委托属性。它的基本理念也非常容易理解，真正的难点在于如何灵活地进行应用。</p>
<p>类委托的核心思想是将一个类的具体实现委托给另一个类去完成，而委托属性的核心思想是将一个属性（字段）的具体实现委托给另一个类去完成。</p>
<p>我们看一下委托属性的语法结构，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用by关键字连接了左边的p属性和右边的<code>Delegate</code>实例，这是什么意思呢？这种写法就代表着将p属性的具体实现委托给了<code>Delegate</code>类去完成。当调用p属性的时候会自动调用<code>Delegate</code>类的<code>getValue()</code>方法，当给p属性赋值的时候会自动调用<code>Delegate</code>类的<code>setValue()</code>方法。</p>
<p>因此，我们还得对Delegate类进行具体的实现才行，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> propValue : Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> propValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        propValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种标准的代码实现模板，在Delegate类中我们必须实现<code>getValue()</code>和<code>setValue()</code>这两个方法，并且都要使用operator关键字进行声明。</p>
<p><code>getValue()</code>方法要接收两个参数：第一个参数用于声明该Delegate类的委托功能可以在什么类中使用，这里写成MyClass表示仅可在MyClass类中使用；第二个参数<code>KProperty&lt;*&gt;</code>是Kotlin中的一个属性操作类，可用于获取各种属性相关的值，在当前场景下用不着，但是必须在方法参数上进行声明。另外，<code>&lt;*&gt;</code>这种泛型的写法表示你不知道或者不关心泛型的具体类型，只是为了通过语法编译而已，有点类似于Java中<code>&lt;?&gt;</code>的写法。至于返回值可以声明成任何类型，根据具体的实现逻辑去写就行了，上述代码只是一种示例写法。</p>
<p><code>setValue()</code>方法也是相似的，只不过它要接收3个参数。前两个参数和<code>getValue()</code>方法是相同的，最后一个参数表示具体要赋值给委托属性的值，这个参数的类型必须和<code>getValue()</code>方法返回值的类型保持一致。</p>
<p>整个委托属性的工作流程就是这样实现的，现在当我们给<code>MyClass</code>的<code>p</code>属性赋值时，就会调用<code>Delegate</code>类的<code>setValue()</code>方法，当获取<code>MyClass</code>中<code>p</code>属性的值时，就会调用<code>Delegate</code>类的<code>getValue()</code>方法。</p>
<p>不过，其实还存在一种情况可以不用在<code>Delegate</code>类中实现<code>setValue()</code>方法，那就是<code>MyClass</code>中的p属性是使用<code>val</code>关键字声明的。这一点也很好理解，如果<code>p</code>属性是使用<code>val</code>关键字声明的，那么就意味着<code>p</code>属性是无法在初始化之后被重新赋值的，因此也就没有必要实现<code>setValue()</code>方法，只需要实现<code>getValue()</code>方法就可以了。</p>
<h4 id="6-2-3-实现一个自己的lazy函数"><a href="#6-2-3-实现一个自己的lazy函数" class="headerlink" title="6.2.3 实现一个自己的lazy函数"></a>6.2.3 实现一个自己的lazy函数</h4><p>我们<strong>初始化变量</strong>时可以把想要延迟执行的代码放到by lazy代码块中，这样代码块中的代码在一开始的时候就不会执行，只有当<strong>变量</strong>首次被调用的时候，代码块中的代码才会执行。</p>
<p>学习了<code>Kotlin</code>的委托功能之后，我们就可以对<code>by lazy</code>的工作原理进行解密了，它的基本语法结构如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p <span class="keyword">by</span> lazy &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>实际上，<code>by lazy</code>并不是连在一起的关键字，只有<code>by</code>才是Kotlin中的关键字，<code>lazy</code>在这里只是一个高阶函数而已。在<code>lazy</code>函数中会创建并返回一个<code>Delegate</code>对象，当我们调用p属性的时候，其实调用的是<code>Delegate</code>对象的<code>getValue()</code>方法，然后<code>getValue()</code>方法中又会调用<code>lazy</code>函数传入的Lambda表达式，这样表达式中的代码就可以得到执行了，并且调用p属性后得到的值就是Lambda表达式中最后一行代码的返回值。</p>
<p>这样看来，Kotlin的懒加载技术也并没有那么神秘，掌握了它的实现原理之后，我们也可以实现一个自己的<code>lazy</code>函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">later</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span> = Later(block)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Later</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> block: () -&gt; T) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(any: <span class="type">Any</span>?, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span> : T &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>)&#123;</span><br><span class="line">            value = block()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> heavyObject <span class="keyword">by</span> later &#123; HeavyObject() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeavyObject</span> &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;HeavyObject is being created.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;HeavyObject is being used.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;main step in&quot;</span>)</span><br><span class="line">    <span class="comment">// 在这里，heavyObject 还没有被创建</span></span><br><span class="line">    <span class="keyword">if</span> (needHeavyObject()) &#123;</span><br><span class="line">        println(<span class="string">&quot;if step in&quot;</span>)</span><br><span class="line">        <span class="comment">// 在这里，heavyObject 被创建</span></span><br><span class="line">        heavyObject.use()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">needHeavyObject</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码演示了如何使用延迟初始化来创建 <code>heavyObject</code>。只有在 <code>heavyObject</code> 第一次被使用时，它才会被创建。这是一种很好的做法，特别是在对象创建代价高昂，且不总是需要该对象的情况下，可以帮助节省资源，提高应用程序的性能。</p>
<hr>
<h2 id="七、使用infix函数构建更可读的语法"><a href="#七、使用infix函数构建更可读的语法" class="headerlink" title="七、使用infix函数构建更可读的语法"></a>七、使用infix函数构建更可读的语法</h2><p>在Kotlin中我们可以使用<code>A to B</code>这样的语法结构构建键值对，比如在Kotlin自带的<code>mapOf()</code>函数，这种语法结构的优点是可读性高，相比于调用一个函数，它更接近于使用英语的语法来编写程序。可能你会好奇，这种功能是怎么实现的呢？to是不是Kotlin语言中的一个关键字？</p>
<p>首先，to并不是Kotlin语言中的一个关键字，之所以我们能够使用<code>A to B</code>这样的语法结构，是因为Kotlin提供了一种高级语法糖特性：<code>infix</code>函数。当然，<code>infix</code>函数也并不是什么难理解的事物，它只是把编程语言函数调用的语法规则调整了一下而已，比如<code>A to B</code>这样的写法，实际上等价于<code>A.to(B)</code>的写法。</p>
<p>举个栗子🌰：</p>
<p>String类中有一个<code>startsWith()</code>函数，你一定使用过，它可以用于判断一个字符串是否是以某个指定参数开头的。比如说下面这段代码的判断结果一定会是true：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;Hello Kotlin&quot;</span>.startsWith(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startsWith()函数的用法虽然非常简单，但是借助infix函数，我们可以使用一种更具可读性的语法来表达这段代码。新建一个infix.kt文件，然后编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">beginsWith</span><span class="params">(prefix: <span class="type">String</span>)</span></span> = startsWith(prefix)</span><br></pre></td></tr></table></figure>

<p>除去最前面的infix关键字不谈，这是一个String类的扩展函数。我们给String类添加了一个<code>beginsWith()</code>函数，它也是用于判断一个字符串是否是以某个指定参数开头的，并且它的内部实现就是调用的String类的<code>startsWith()</code>函数。</p>
<p>但是加上了infix关键字之后，<code>beginsWith()</code>函数就变成了一个infix函数，这样除了传统的函数调用方式之外，我们还可以用一种特殊的语法糖格式调用<code>beginsWith()</code>函数，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;Hello Kotlin&quot;</span> beginsWith <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个例子就能看出，infix函数的语法规则并不复杂，上述代码其实就是调用的” Hello Kotlin “这个字符串的<code>beginsWith()</code>函数，并传入了一个”Hello”字符串作为参数。但是infix函数允许我们将函数调用时的小数点、括号等计算机相关的语法去掉，从而使用一种更接近英语的语法来编写程序，让代码看起来更加具有可读性。</p>
<p>另外，infix函数由于其语法糖格式的特殊性，有两个比较严格的限制：首先，<strong>infix函数是不能定义成顶层函数的，它必须是某个类的成员函数，可以使用扩展函数的方式将它定义到某个类当中</strong>；其次，<strong>infix函数必须接收且只能接收一个参数，至于参数类型是没有限制的</strong>。只有同时满足这两点，infix函数的语法糖才具备使用的条件.</p>
<p>再举个栗子🌰：</p>
<p>比如这里有一个集合，如果想要判断集合中是否包括某个指定元素，一般可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (list.contains(<span class="string">&quot;Banana&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单对吗？但我们仍然可以借助infix函数让这段代码变得更加具有可读性。在infix.kt文件中添加如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">has</span><span class="params">(element: <span class="type">T</span>)</span></span> = contains(element)</span><br></pre></td></tr></table></figure>

<p>可以看到，我们给<code>Collection</code>接口添加了一个扩展函数，这是因为<strong>Collection是Java以及Kotlin所有集合的总接口</strong>，因此给Collection添加一个**has()**函数，那么所有集合的子类就都可以使用这个函数了。</p>
<p>另外，这里还使用了上一章中学习的泛型函数的定义方法，从而使得<code>has()</code>函数可以接收任意具体类型的参数。而这个函数内部的实现逻辑就相当简单了，只是调用了<code>Collection</code>接口中的<code>contains()</code>函数而已。也就是说，<code>has()</code>函数和<code>contains()</code>函数的功能实际上是一模一样的，只是它多了一个infix关键字，从而拥有了infix函数的语法糖功能。</p>
<p>现在我们就可以使用如下的语法来判断集合中是否包括某个指定的元素：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (list has <span class="string">&quot;Banana&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解析一下 <code>A to B</code>中 中缀函数 <code>to</code> 的实现，其实就只有一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure>

<p>这是Kotlin编程语言中的一种函数声明。我们先分解一下：</p>
<ol>
<li><code>public</code>：这是函数的访问修饰符，表示这个函数可以在任何位置被访问。</li>
<li><code>infix</code>：这是一个在Kotlin中表征中缀函数的关键字。所谓中缀函数，就是可以使用更自然的语言风格调用，并且该函数要满足“它们必须是成员函数或扩展函数、它们必须有一个参数、它们的参数不能接受可变数量的参数且不能有默认值”。</li>
<li><code>&lt;A, B&gt;</code>：这是泛型参数列表，表明这个函数可以对任意类型的对象进行操作。</li>
<li><code>A.to(that: B)</code>：这是函数的声明，函数名为<code>to</code>，参数为名为<code>that</code>的<code>B</code>类型对象。</li>
<li><code>Pair&lt;A, B&gt;</code>：这是函数的返回类型，表示函数返回一个包含两个元素，类型分别为A和B的Pair对象。</li>
<li><code>Pair(this, that)</code>：这是函数的实现，创建一个新的Pair对象，第一个元素是调用<code>to</code>函数的对象，第二个元素是函数的参数。</li>
</ol>
<p>整个函数可以这样理解：对任意类型A的对象，我们定义了一个函数<code>to</code>，它接受一个任意类型B的对象作为参数，并返回一个Pair&lt;A, B&gt;对象。</p>
<p>举个例子🌰：假设有两个变量a和b：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>那么，我们可以使用中缀函数简洁地构造Pair对象：a to b，代表一对值：1和2</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = a to b</span><br><span class="line"><span class="comment">// pair is Pair&lt;Int, Int&gt;(1, 2)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、泛型的高级特性"><a href="#八、泛型的高级特性" class="headerlink" title="八、泛型的高级特性"></a>八、泛型的高级特性</h2><p>之前在[6.1](###6.1 泛型的基本用法)中学习了<strong>Kotlin</strong>泛型的基本用法。这些基本用法其实和<strong>Java</strong>中泛型的用法是大致相同的，因此也相对比较好理解。然而实际上，<strong>Kotlin</strong>在泛型方面还提供了不少特有的功能，掌握了这些功能，你将可以更好玩转<strong>Kotlin</strong>，同时还能实现一些不可思议的语法特性。</p>
<h3 id="8-1-对泛型进行实化"><a href="#8-1-对泛型进行实化" class="headerlink" title="8.1 对泛型进行实化"></a>8.1 对泛型进行实化</h3><p>泛型实化这个功能对于绝大多数<strong>Java</strong>程序员来讲是非常陌生的，因为<strong>Java</strong>中完全没有这个概念。而如果我们想要深刻地理解泛型实化，就要先解释一下<strong>Java</strong>的泛型擦除机制才行。</p>
<p>在<strong>JDK 1.5</strong>之前，<strong>Java</strong>是没有泛型功能的，那个时候诸如<strong>List</strong>之类的数据结构可以存储任意类型的数据，取出数据的时候也需要手动向下转型才行，这不仅麻烦，而且很危险。比如说我们在同一个<strong>List</strong>中存储了字符串和整型这两种数据，但是在取出数据的时候却无法区分具体的数据类型，如果手动将它们强制转成同一种类型，那么就会抛出类型转换异常。</p>
<p>于是在<strong>JDK 1.5</strong>中，<strong>Java</strong>终于引入了泛型功能。这不仅让诸如<strong>List</strong>之类的数据结构变得简单好用，也让我们的代码变得更加安全。</p>
<p>但是实际上，<strong>Java</strong>的泛型功能是通过类型擦除机制来实现的。什么意思呢？就是说泛型对于类型的约束只在编译时期存在，运行的时候仍然会按照<strong>JDK 1.5</strong>之前的机制来运行，JVM是识别不出来我们在代码中指定的泛型类型的。例如，假设我们创建了一个<code>List&lt;String&gt;</code>集合，虽然在编译时期只能向集合中添加字符串类型的元素，但是在运行时期<strong>JVM</strong>并不能知道它本来只打算包含哪种类型的元素，只能识别出来它是个<strong>List</strong>。</p>
<p>所有基于<strong>JVM</strong>的语言，它们的泛型功能都是通过类型擦除机制来实现的，其中当然也包括了<strong>Kotlin</strong>。这种机制使得我们不可能使用<code>a is T</code>或者<code>T::class.java</code>这样的语法，因为T的实际类型在运行的时候已经被擦除了。</p>
<p>然而不同的是，<strong>Kotlin</strong>提供了一个内联函数的概念，我们在第[4.2](###4.2 内联函数的作用)中已经学过了这个知识点。内联函数中的代码会在编译的时候自动被替换到调用它的地方，这样的话也就不存在什么泛型擦除的问题了，因为代码在编译之后会直接使用实际的类型来替代内联函数中的泛型声明，其工作原理如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/xiheya/2024/01/1706065068503_a6941c17468b5.png" alt="1706065068503.png"></p>
<p>最终代码会被替换成如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// do something with String type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>bar()</code>是一个带有泛型类型的内联函数，<code>foo()</code>函数调用了<code>bar()</code>函数，在代码编译之后，<code>bar()</code>函数中的代码将可以获得泛型的实际类型。<strong>这就意味着，Kotlin中是可以将内联函数中的泛型进行实化的。</strong></p>
<p>那么具体该怎么写才能将泛型实化呢？<strong>首先，该函数必须是内联函数才行，也就是要用<code>inline</code>关键字来修饰该函数。其次，在声明泛型的地方必须加上<code>reified</code>关键字来表示该泛型要进行实化。</strong>示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数中的泛型<strong>T</strong>就是一个被实化的泛型，因为它满足了内联函数和<strong>reified</strong>关键字这两个前提条件。那么借助泛型实化，到底可以实现什么样的效果呢？从函数名就可以看出来了，这里我们准备实现一个获取泛型实际类型的功能，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> = T::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure>

<p>虽然只有一行代码，但是这里却实现了一个<strong>Java</strong>中完全不可能实现的功能：<code>getGenericType()</code>函数直接返回了当前指定泛型的实际类型。<code>T.class</code>这样的语法在<strong>Java</strong>中是不合法的，而在<strong>Kotlin</strong>中，借助泛型实化功能就可以使用<code>T::class.java</code>这样的语法了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = getGenericType&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> result2 = getGenericType&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    println(<span class="string">&quot;result1 is <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result2 is <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> = T::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure>

<p>运行结果打印如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 is class java.lang.String</span><br><span class="line">result2 is class java.lang.Integer</span><br></pre></td></tr></table></figure>

<p>如果将泛型指定成了<strong>String</strong>，那么就可以得到<code>java.lang.String</code>的类型；如果将泛型指定了<strong>Int</strong>，就可以得到<code>java.lang.Integer</code>的类型。</p>
<p>接下来学习泛型实化的应用</p>
<h3 id="8-2-泛型实化的应用"><a href="#8-2-泛型实化的应用" class="headerlink" title="8.2 泛型实化的应用"></a>8.2 泛型实化的应用</h3><p>泛型实化功能允许我们在泛型函数当中获得泛型的实际类型，这也就使得类似于<code>a is T</code>、<code>T::class.java</code>这样的语法成为了可能。而灵活运用这一特性将可以实现一些不可思议的语法结构。在<strong>Android</strong>四大组件当中，除了<strong>ContentProvider</strong>之外，<strong>Activity</strong>、<strong>Service</strong>还有<strong>BroadcastReceiver</strong>都需要结合 <strong>Intent</strong>一起使用。</p>
<p>就拿启动Activity来说：</p>
<p>我们可以这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, TestActivity::<span class="keyword">class</span>.java)</span><br><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>有没有觉得<code>TestActivity::class.java</code>这样的语法很难受呢？当然，如果在没有更好选择的情况下，这种写法也是可以忍受的，但是<strong>Kotlin</strong>的泛型实化功能使得我们拥有了更好的选择。</p>
<p>新建一个<code>reified.kt</code>文件，然后在里面编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java)</span><br><span class="line">    context.startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个<code>startActivity()</code>函数，该函数接收一个<strong>Context</strong>参数，并同时使用<strong>inline</strong>和<strong>reified</strong>关键字让泛型T成为了一个被实化的泛型。接下来就是神奇的地方了，<strong>Intent</strong>接收的第二个参数本来应该是一个具体<strong>Activity</strong>的<strong>Class</strong>类型，但由于现在<strong>T</strong>已经是一个被实化的泛型了，因此这里我们可以直接传入<code>T::class.java</code>。最后调用<strong>Context</strong>的<code>startActivity()</code>方法来完成<strong>Activity</strong>的启动。</p>
<p>现在，如果我们要启动<strong>TestActivity</strong>，只需要这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context)</span><br></pre></td></tr></table></figure>

<p>不过，现在的<code>startActivity()</code>函数其实还是有问题的，因为通常在启用<strong>Activity</strong>的时候还可能会使用<strong>Intent</strong>附带一些参数，比如下面的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, TestActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param2&quot;</span>, <span class="number">123</span>)</span><br><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>而经过刚才的封装之后，我们就无法进行传参了。这个问题也不难解决，只需要借助之前学习的高阶函数就可以轻松搞定。回到<code>reified.kt</code>文件当中，这里添加一个新的<code>startActivity()</code>函数重载，如下所示:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>, block: <span class="type">Intent</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java)</span><br><span class="line">    intent.block()</span><br><span class="line">    context.startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这次的<code>startActivity()</code>函数中增加了一个函数类型参数，并且它的函数类型是定义在<strong>Intent</strong>类当中的。在创建完<strong>Intent</strong>的实例之后，随即调用该函数类型参数，并把<strong>Intent</strong>的实例传入，这样调用<code>startActivity()</code>函数的时候就可以在<strong>Lambda</strong>表达式中为<strong>Intent</strong>传递参数了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) &#123;</span><br><span class="line">    putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">    putExtra(<span class="string">&quot;param2&quot;</span>, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-泛型的协变"><a href="#8-3-泛型的协变" class="headerlink" title="8.3 泛型的协变"></a>8.3 泛型的协变</h3><p>在开始学习协变和逆变之前，我们还得先了解一个约定。一个泛型类或者泛型接口中的方法，它的参数列表是接收数据的地方，因此可以称它为<strong>in</strong>位置，而它的返回值是输出数据的地方，因此可以称它为<strong>out</strong>位置，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/xiheya/2024/01/1706256361291_697ba5b7d4ec0.png" alt="1706256361291.png"></p>
<p>有了这个约定前提，接下来继续学习，首先定义如下三个类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age)</span><br></pre></td></tr></table></figure>

<p>这里先定义了一个<strong>Person</strong>类，类中包含<strong>name</strong>和<strong>age</strong>这两个字段。然后又定义了<strong>Student</strong>和<strong>Teacher</strong>这两个类，让它们成为<strong>Person</strong>类的子类。</p>
<p>如果某个方法接收一个<strong>Person</strong>类型的参数，而我们传入一个<strong>Student</strong>的实例，这样合不合法呢？很显然，因为<strong>Student</strong>是<strong>Person</strong>的子类，学生也是人呀，因此这是一定合法的。</p>
<p>如果某个方法接收一个<code>List&lt;Person&gt;</code>类型的参数，而我们传入一个<code>List&lt;Student&gt;</code>的实例，这样合不合法呢？看上去好像也挺正确的，但是Java中是不允许这么做的，因为<code>List&lt;Student&gt;</code>不能成为<code>List&lt;Person&gt;</code>的子类，<strong>否则将可能存在类型转换的安全隐患。</strong></p>
<p>为什么会存在类型转换的安全隐患呢？下面我们通过一个具体的例子进行说明。自定义一个<code>SimpleData</code>类以及一个<code>handleSimpleData(data: SimpleData&lt;Person&gt;)</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(t: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span> : T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleSimpleData</span><span class="params">(<span class="keyword">data</span>: <span class="type">SimpleData</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> teacher = Teacher(<span class="string">&quot;Jack&quot;</span>, <span class="number">35</span>)</span><br><span class="line">    <span class="keyword">data</span>.<span class="keyword">set</span>(teacher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SimpleData</strong>是一个泛型类，它的内部封装了一个泛型<strong>data</strong>字段，调用<code>set()</code>方法可以给<strong>data</strong>字段赋值，调用<code>get()</code>方法可以获取<strong>data</strong>字段的值。</p>
<p>接着我们假设，如果编程语言允许向某个接收<code>SimpleData&lt;Person&gt;</code>参数的方法传入<code>SimpleData&lt;Student&gt;</code>的实例，那么如下代码就会是合法的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = SimpleData&lt;Student&gt;()</span><br><span class="line">    <span class="keyword">data</span>.<span class="keyword">set</span>(student)</span><br><span class="line">    handleSimpleData(<span class="keyword">data</span>) <span class="comment">//这里会报错</span></span><br><span class="line">    <span class="keyword">val</span> studentData = <span class="keyword">data</span>.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Type mismatch.</p>
<p>Required:<br>SimpleData<Person><br>Found:<br>SimpleData<Student></p>
</blockquote>
<p>可以看到报错信息是类型不匹配，这里需要一个 <code>SimpleData&lt;Person&gt;</code> 而我们却传给了他 <code>SimpleData&lt;Student&gt;</code></p>
<p>在<code>main()</code>方法中，我们创建了一个<strong>Student</strong>的实例，并将它封装到<code>SimpleData&lt;Student&gt;</code>当中，然后将<code>SimpleData&lt;Student&gt;</code>作为参数传递给<code>handleSimpleData()</code>方法。但是<code>handleSimpleData()</code>方法接收的是一个<strong>SimpleData<Person><strong>参数（这里假设可以编译通过），那么在<code>handleSimpleData()</code>方法中，我们就可以创建一个</strong>Teacher</strong>的实例，并用它来替换<code>SimpleData&lt;Person&gt;</code>参数中的原有数据。<strong>这种操作肯定是合法的，因为Teacher也是Person的子类，所以可以很安全地将Teacher的实例设置进去。</strong></p>
<p>但是问题马上来了，回到<code>main()</code>方法当中，我们调用<code>SimpleData&lt;Student&gt;</code>的<code>get()</code>方法来获取它内部封装的<strong>Student</strong>数据，<strong>可现在<code>SimpleData&lt;Student&gt;</code>中实际包含的却是一个Teacher的实例，那么此时必然会产生类型转换异常。</strong></p>
<p>所以，为了杜绝这种安全隐患，<strong>Java</strong>是不允许使用这种方式来传递参数的。换句话说，即使<strong>Student</strong>是<strong>Person</strong>的子类，<code>SimpleData&lt;Student&gt;</code>并不是<code>SimpleData&lt;Person&gt;</code>的子类。</p>
<p>不过，回顾一下刚才的代码，你会发现问题发生的主要原因是我们在<code>handleSimpleData()</code>方法中向<code>SimpleData&lt;Person&gt;</code>里设置了一个<strong>Teacher</strong>的实例。如果<strong>SimpleData</strong>在泛型T上是只读的话，肯定就没有类型转换的安全隐患了，那么这个时候<code>SimpleData&lt;Student&gt;</code>可不可以成为<code>SimpleData&lt;Person&gt;</code>的子类呢？</p>
<p>讲到这里，我们终于要引出泛型协变的定义了。<strong>假如定义了一个<code>MyClass&lt;T&gt;</code>的泛型类，其中A是B的子类型，同时<code>MyClass&lt;A&gt;</code>又是<code>MyClass&lt;B&gt;</code>的子类型，那么我们就可以称<code>MyClass</code>在T这个泛型上是协变的。</strong></p>
<p>但是如何才能让<code>MyClass&lt;A&gt;</code>成为<code>MyClass&lt;B&gt;</code>的子类型呢？刚才已经讲了，<strong>如果一个泛型类在其泛型类型的数据上是只读的话，那么它是没有类型转换安全隐患的。</strong>而要实现这一点，则需要让<code>MyClass&lt;T&gt;</code>类中的<strong>所有方法都不能接收T类型的参数</strong>。换句话说，<strong>T只能出现在out位置上，而不能出现在in位置上。</strong></p>
<p>现在修改<strong>SimpleData</strong>类的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">out T</span>&gt; (<span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span>: T?) &#123;</span><br><span class="line">    <span class="comment">/*private var data: T? = null</span></span><br><span class="line"><span class="comment">    fun set(t: T?) &#123;</span></span><br><span class="line"><span class="comment">        data = t</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span> : T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们对<strong>SimpleData</strong>类进行了改造，在泛型T的声明前面加上了一个<strong>out</strong>关键字。这就意味着现在T只能出现在<strong>out</strong>位置上，而不能出现在<strong>in</strong>位置上，同时也意味着<strong>SimpleData</strong>在<strong>泛型T</strong>上是协变的。</p>
<p>由于<strong>泛型T</strong>不能出现在<strong>in</strong>位置上，因此我们也就不能使用<code>set()</code>方法为<strong>data</strong>参数赋值了，所以这里改成了使用构造函数的方式来赋值。你可能会说，构造函数中的泛型T不也是在<strong>in</strong>位置上的吗？没错，但是由于这里我们使用了<strong>val</strong>关键字，所以构造函数中的<strong>泛型T</strong>仍然是只读的，因此这样写是合法且安全的。另外，即使我们使用了<strong>var</strong>关键字，但只要给它加上<strong>private</strong>修饰符，保证这个泛型T对于外部而言是不可修改的，那么就都是合法的写法。</p>
<p>经过了这样的修改之后，下面的代码就可以完美编译通过且没有任何安全隐患了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = SimpleData&lt;Student&gt;(student)</span><br><span class="line">    handleSimpleData(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> studentData = <span class="keyword">data</span>.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleSimpleData</span><span class="params">(<span class="keyword">data</span>: <span class="type">SimpleData</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> personData = <span class="keyword">data</span>.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<strong>SimpleData</strong>类已经进行了协变声明，那么<code>SimpleData&lt;Student&gt;</code>自然就是<code>SimpleData&lt;Person&gt;</code>的子类了，所以这里可以安全地向<code>handleSimpleData()</code>方法中传递参数。</p>
<p>然后在<code>handleSimpleData()</code>方法中去获取<strong>SimpleData</strong>封装的数据，虽然这里泛型声明的是<strong>Person</strong>类型，实际获得的会是一个<strong>Student</strong>的实例，<strong>但由于Person是Student的父类，向上转型是完全安全的</strong>，所以这段代码没有任何问题。</p>
<h3 id="8-4-泛型的逆变"><a href="#8-4-泛型的逆变" class="headerlink" title="8.4 泛型的逆变"></a>8.4 泛型的逆变</h3><p>仅从定义上来看，逆变与协变却完全相反。那么这里先引出定义吧，<strong>假如定义了一个MyClass<T>的泛型类，其中A是B的子类型，同时MyClass<B>又是MyClass<A>的子类型，那么我们就可以称MyClass在T这个泛型上是逆变的。</strong>协变和逆变的区别如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/xiheya/2024/01/1706497381453_2f65e27d0d37d.png" alt="1706497381453.png"></p>
<p>从直观的角度上来思考，逆变的规则好像挺奇怪的，原本<strong>A是B的子类型</strong>，怎么**MyClass<B><strong>能反过来成为</strong>MyClass<A>**的子类型了呢？</p>
<p>举个栗子🌰：</p>
<p>先定义一个 <code>Transformer</code> 接口，用于一些转换操作，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>Transformer</strong>接口中声明了一个<code>transform()</code>方法，它接收一个T类型的参数，并且返回一个<strong>String</strong>类型的数据，这意味着参数T在经过<code>transform()</code>方法的转换之后将会变成一个字符串。至于具体的转换逻辑是什么样的，则由子类去实现，<strong>Transformer</strong>接口对此并不关心。</p>
<p>那么现在我们就尝试对<strong>Transformer</strong>接口进行实现，代码如下所示:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trans = <span class="keyword">object</span> : Transformer&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">Person</span>)</span></span> : String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">$&#123;t.name&#125;</span> <span class="subst">$&#123;t.age&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleTransformer(trans)  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleTransformer</span><span class="params">(trans: <span class="type">Transformer</span>&lt;<span class="type">Student</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> result = trans.transform(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们在<code>main()</code>方法中编写了一个<code>Transformer&lt;Person&gt;</code>的匿名类实现，并通过<code>transform()</code>方法将传入的<strong>Person</strong>对象转换成了一个“姓名+年龄”拼接的字符串。而<code>handleTransformer()</code>方法接收的是一个<code>Transformer&lt;Student&gt;</code>类型的参数，这里在<code>handleTransformer()</code>方法中创建了一个<strong>Student</strong>对象，并调用参数的<code>transform()</code>方法将<strong>Student</strong>对象转换成一个字符串。</p>
<p>这段代码从安全的角度来分析是没有任何问题的，因为<strong>Student</strong>是<strong>Person</strong>的子类，使用<code>Transformer&lt;Person&gt;</code>的匿名类实现将<strong>Student</strong>对象转换成一个字符串也是绝对安全的，并不存在类型转换的安全隐患。但是实际上，在调用<code>handleTransformer()</code>方法的时候却会提示语法错误，原因也很简单，<code>Transformer&lt;Person&gt;</code>并不是<code>Transformer&lt;Student&gt;</code>的子类型。</p>
<p>那么这个时候逆变就可以派上用场了，它就是专门用于处理这种情况的。修改<strong>Transformer</strong>接口中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在泛型T的声明前面加上了一个<strong>in</strong>关键字。这就意味着现在<strong>T</strong>只能出现在<strong>in</strong>位置上，而不能出现在<strong>out</strong>位置上，同时也意味着<strong>Transformer</strong>在泛型<strong>T</strong>上是逆变的。</p>
<p>没错，只要做了这样一点修改，刚才的代码就可以编译通过且正常运行了，因为此时<code>Transformer&lt;Person&gt;</code>已经成为了<code>Transformer&lt;Student&gt;</code>的子类型。</p>
<p>逆变的用法大概就是这样了，如果你还想再深入思考一下的话，可以想一想为什么逆变的时候泛型<strong>T</strong>不能出现在<strong>out</strong>位置上？为了解释这个问题，我们先假设逆变是允许让泛型T出现在out位置上的，然后看一看可能会产生什么样的安全隐患。修改<strong>Transformer</strong>中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>)</span></span>: <span class="meta">@UnsafeVariance</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们将<code>transform()</code>方法改成了接收<strong>name</strong>和<strong>age</strong>这两个参数，并把返回值类型改成了泛型<strong>T</strong>。由于逆变是不允许泛型<strong>T</strong>出现在<strong>out</strong>位置上的，这里为了能让编译器正常编译通过，所以加上了<code>@UnsafeVariance</code>注解，这和<strong>List</strong>源码中使用的技巧是一样的。</p>
<p>这个时候会产生什么安全隐患呢？来看看代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trans = <span class="keyword">object</span> : Transformer&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">return</span> Teacher(name, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleTransformer(trans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleTransformer</span><span class="params">(trans: <span class="type">Transformer</span>&lt;<span class="type">Student</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = trans.transform(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是一个典型的违反逆变规则而造成类型转换异常的例子。在<code>Transformer&lt;Person&gt;</code>的匿名类实现中，我们使用<code>transform()</code>方法中传入的<strong>name</strong>和<strong>age</strong>参数构建了一个<strong>Teacher</strong>对象，并把这个对象直接返回。由于<code>transform()</code>方法的返回值要求是一个<strong>Person</strong>对象，而<strong>Teacher</strong>是<strong>Person</strong>的子类，因此这种写法肯定是合法的。</p>
<p>但在<code>handleTransformer()</code>方法当中，我们调用了<code>Transformer&lt;Student&gt;</code>的<code>transform()</code>方法，并传入了<strong>name</strong>和<strong>age</strong>这两个参数，期望得到的是一个<strong>Student</strong>对象的返回，然而实际上<code>transform()</code>方法返回的却是一个<strong>Teacher</strong>对象，因此这里必然会造成类型转换异常。</p>
<p>异常信息如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708223607170_02ba4f0d6b5cd.png" alt="1708223607170.png"></p>
<p>可以看到，提示我们<strong>Teacher</strong>类型是无法转换成<strong>Student</strong>类型的。</p>
<p>也就是说，<strong>Kotlin</strong>在提供协变和逆变功能时，就已经把各种潜在的类型转换安全隐患全部考虑进去了。只要我们严格按照其语法规则，让泛型在协变时只出现在<strong>out</strong>位置上，逆变时只出现在<strong>in</strong>位置上，就不会存在类型转换异常的情况。虽然<code>@UnsafeVariance</code>注解可以打破这一语法规则，但同时也会带来额外的风险，所以你在使用<code>@UnsafeVariance</code>注解时，必须很清楚自己在干什么才行。</p>
<p>最后我们再来介绍一下逆变功能在<strong>Kotlin</strong>内置<strong>API</strong>中的应用，比较典型的例子就是<strong>Comparable</strong>的使用。<strong>Comparable</strong>是一个用于比较两个对象大小的接口，其源码定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>Comparable</strong>在<strong>T</strong>这个泛型上就是逆变的，<code>compareTo()</code>方法则用于实现具体的比较逻辑。那么这里为什么要让<strong>Comparable</strong>接口是逆变的呢？想象如下场景，如果我们使用<code>Comparable&lt;Person&gt;</code>实现了让两个<strong>Person</strong>对象比较大小的逻辑，那么用这段逻辑去比较两个<strong>Student</strong>对象的大小也一定是成立的，因此让<code>Comparable&lt;Person&gt;</code>成为<code>Comparable&lt;Student&gt;</code>的子类合情合理，这也是逆变非常典型的应用。</p>
<hr>
<h2 id="九、使用协程编写高效的并发程序"><a href="#九、使用协程编写高效的并发程序" class="headerlink" title="九、使用协程编写高效的并发程序"></a>九、使用协程编写高效的并发程序</h2><p><strong>协程属于Kotlin中非常有特色的一项技术</strong>，因为大部分编程语言中是没有协程这个概念的。</p>
<p><strong>那么什么是协程呢？它其实和线程是有点类似的，可以简单地将它理解成一种轻量级的线程。</strong>要知道，我们之前所学习的线程是非常重量级的，它需要依靠操作系统的调度才能实现不同线程之间的切换。而<strong>使用协程却可以仅在编程语言的层面就能实现不同协程之间的切换，从而大大提升了并发编程的运行效率。</strong></p>
<p>举一个具体点的例子，比如我们有如下**foo()<strong>和</strong>bar()**两个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a()</span><br><span class="line">    b()</span><br><span class="line">    c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x()</span><br><span class="line">    y()</span><br><span class="line">    z()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有开启线程的情况下，先后调用<code>foo()</code>和<code>bar()</code>这两个方法，那么理论上结果一定是<code>a()</code>、<code>b()</code>、<code>c()</code>执行完了以后，<code>x()</code>、<code>y()</code>、<code>z()</code>才能够得到执行。而如果使用了协程，在协程A中去调用<code>foo()</code>方法，协程B中去调用<code>bar()</code>方法，虽然它们仍然会运行在同一个线程当中，但是在执行<code>foo()</code>方法时随时都有可能被挂起转而去执行<code>bar()</code>方法，执行<code>bar()</code>方法时也随时都有可能被挂起转而继续执行<code>foo()</code>方法，最终的输出结果也就变得不确定了。</p>
<p>可以看出，<strong>协程允许我们在单线程模式下模拟多线程编程的效果，代码执行时的挂起与恢复完全是由编程语言来控制的，和操作系统无关。</strong>这种特性使得高并发程序的运行效率得到了极大的提升，试想一下，开启10万个线程完全是不可想象的事吧？而开启10万个协程就是完全可行的。</p>
<h3 id="9-1-协程的基本用法"><a href="#9-1-协程的基本用法" class="headerlink" title="9.1 协程的基本用法"></a>9.1 协程的基本用法</h3><p>Kotlin并没有将协程纳入标准库的API当中，而是以依赖库的形式提供的。所以如果我们想要使用协程功能，需要先在app&#x2F;build.gradle文件当中添加如下依赖库：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0&quot;</span></span><br><span class="line">	implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们要面临的第一个问题就是，如何开启一个协程？最简单的方式就是使用<code>Global.launch</code>函数，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GlobalScope.launch</code>函数可以创建一个协程的作用域，这样传递给<strong>launch</strong>函数的代码块（Lambda表达式）就是在协程中运行的了，这里我们只是在代码块中打印了一行日志。那么现在运行<code>main()</code>函数，日志能成功打印出来吗？如果你尝试一下，会发现没有任何日志输出。<strong>这是因为，Global.launch函数每次创建的都是一个顶层协程，这种协程当应用程序运行结束时也会跟着一起结束。</strong>刚才的日志之所以无法打印出来，就是因为代码块中的代码还没来得及运行，应用程序就结束了。</p>
<p>要解决这个问题也很简单，我们让程序延迟一段时间再结束就行了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用Thread.sleep()方法让主线程阻塞1秒钟，现在重新运行程序，日志就可以打印出来了。</p>
<p>可是这种写法还是存在问题，如果代码块中的代码在1秒钟之内不能运行结束，那么就会被强制<br>中断。观察如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">        delay(<span class="number">1500</span>)</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope finished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在代码块中加入了一个<code>delay()</code>函数，并在之后又打印了一行日志。<code>delay()</code>函数可以让当前协程延迟指定时间后再运行，但它和<code>Thread.sleep()</code>方法不同。<code>delay()</code>函数是一个非阻塞式的挂起函数，它只会挂起当前协程，并不会影响其他协程的运行。而<code>Thread.sleep()</code>方法会阻塞当前的线程，这样运行在该线程下的所有协程都会被阻塞。注意，<code>delay()</code>函数只能在协程的作用域或其他挂起函数中调用。</p>
<p>这里我们让协程挂起1.5秒，但是主线程却只阻塞了1秒，最终会是什么结果呢？重新运行程序，你会发现代码块中新增的一条日志并没有打印出来，因为它还没能来得及运行，应用程序就已经结束了。</p>
<p>那么有没有什么办法能让应用程序在协程中所有代码都运行完了之后再结束呢？当然也是有的，借助<strong>runBlocking</strong>函数就可以实现这个功能：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">        delay(<span class="number">1500</span>)</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope finished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>runBlocking</strong>函数同样会创建一个协程的作用域，但是它可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程。需要注意的是，<strong>runBlocking</strong>函数通常只应该在测试环境下使用，在正式环境中使用容易产生一些性能上的问题。</p>
<p>虽说现在我们已经能够让代码在协程中运行了，可是好像并没有体会到什么特别的好处。这是因为目前所有的代码都是运行在同一个协程当中的，而一旦涉及高并发的应用场景，协程相比于线程的优势就能体现出来了。</p>
<p>那么如何才能创建多个协程呢？很简单，使用<strong>launch</strong>函数就可以了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;launch1&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">&quot;launch1 finished&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;launch2 scope&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">&quot;launch2 finished&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的<strong>launch</strong>函数和我们刚才所使用的<code>GlobalScope.launch</code>函数不同。首先它必须在协程的作用域中才能调用，其次它会在当前协程的作用域下创建子协程。子协程的特点是如果外层作用域的协程结束了，该作用域下的所有子协程也会一同结束。相比而言，<code>GlobalScope.launch</code>函数创建的永远是顶层协程，这一点和线程比较像，因为线程也没有层级这一说，永远都是顶层的。</p>
<p>这里我们调用了两次<strong>launch</strong>函数，也就是创建了两个子协程。打印结果如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/guest/2024/02/1709102783783_31d25f330b374.png" alt="1709102783783.png"></p>
<p>可以看到，两个子协程中的日志是交替打印的，说明它们确实是像多线程那样并发运行的。然而这两个子协程实际却运行在同一个线程当中，只是由编程语言来决定如何在多个协程之间进行调度，让谁运行，让谁挂起。调度的过程完全不需要操作系统参与，这也就使得协程的并发效率会出奇得高。</p>
<p>那么具体会有多高呢？接下来做个实验。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">100000</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> end = System.currentTimeMillis()</span><br><span class="line">    println(end - start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<strong>repeat</strong>函数循环创建了10万个协程，不过在协程当中并没有进行什么有意义的操作，只是象征性地打印了一个点，然后记录一下整个操作的运行耗时。现在重新运行一下程序，结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/guest/2024/02/1709103029256_9a71690c55802.png" alt="1709103029256.png"></p>
<p>可以看到，这里仅仅耗时了541毫秒，这足以证明协程有多么高效。试想一下，如果开启的是10万个线程，程序或许已经出现OOM异常了。</p>
<p>不过，随着<strong>launch</strong>函数中的逻辑越来越复杂，可能你需要将部分代码提取到一个单独的函数中。这个时候就产生了一个问题：我们在<strong>launch</strong>函数中编写的代码是拥有协程作用域的，但是提取到一个单独的函数中就没有协程作用域了，那么我们该如何调用像<code>delay()</code>这样的挂起函数呢？</p>
<p>为此<strong>Kotlin</strong>提供了一个<strong>suspend</strong>关键字，<strong>使用它可以将任意函数声明成挂起函数，而挂起函数之间都是可以互相调用的</strong>，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在<code>printDot()</code>函数中调用<code>delay()</code>函数了。</p>
<p>但是，<strong>suspend</strong>关键字只能将一个函数声明成挂起函数，是无法给它提供协程作用域的。比如你现在尝试在<code>printDot()</code>函数中调用<strong>launch</strong>函数，一定是无法调用成功的，因为<strong>launch</strong>函数要求必须在协程作用域当中才能调用。</p>
<p>这个问题可以借助<strong>coroutineScope</strong>函数来解决。<strong>coroutineScope</strong>函数也是一个挂起函数，因此可以在任何其他挂起函数中调用。它的特点是会继承外部的协程的作用域并创建一个子协程，借助这个特性，我们就可以给任意挂起函数提供协程作用域了。示例写法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，现在我们就可以在<code>printDot()</code>这个挂起函数中调用<strong>launch</strong>函数了。另外，<strong>coroutineScope</strong>函数和<strong>runBlocking</strong>函数还有点类似，它可以保证其作用域内的所有代码和子协程在全部执行完之前，外部的协程会一直被挂起。我们来看如下示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">                    println(i)</span><br><span class="line">                    delay(<span class="number">200</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;coroutineScope finished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;runBlocking finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先使用<strong>runBlocking</strong>函数创建了一个协程作用域，然后调用<strong>coroutineScope</strong>函数创建了一个子协程。在<strong>coroutineScope</strong>的作用域中，我们又调用<strong>launch</strong>函数创建了一个子协程，并通过for循环依次打印数字1到10，每次打印间隔一秒钟。最后在<strong>runBlocking</strong>和<strong>coroutineScope</strong>函数的结尾，分别又打印了一行日志。现在重新运行一下程序，结果如图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/guest/2024/02/1709104874406_707690775e9a7.png" alt="1709104874406.png"></p>
<p>你会看到，控制台会以200ms的间隔依次输出数字1到10，然后才会打印<strong>coroutineScope</strong>函数结尾的日志，最后打印<strong>runBlocking</strong>函数结尾的日志。</p>
<p>由此可见，<strong>coroutineScope</strong>函数确实是将外部协程挂起了，只有当它作用域内的所有代码和子协程都执行完毕之后，<strong>coroutineScope</strong>函数之后的代码才能得到运行。</p>
<p>虽然看上去<strong>coroutineScope</strong>函数和<strong>runBlocking</strong>函数的作用是有点类似的，但是<strong>coroutineScope</strong>函数只会阻塞当前协程，既不影响其他协程，也不影响任何线程，因此是不会造成任何性能上的问题的。而<strong>runBlocking函数由于会挂起外部线程，如果你恰好又在主线程中当中调用它的话，那么就有可能会导致界面卡死的情况，所以不太推荐在实际项目中使用。</strong></p>
<h3 id="9-2-更多的作用域构建器"><a href="#9-2-更多的作用域构建器" class="headerlink" title="9.2 更多的作用域构建器"></a>9.2 更多的作用域构建器</h3><p>我们学习了<code>GlobalScope.launch</code>、<code>runBlocking</code>、<code>launch</code>、<code>coroutineScope</code>这几种作用域构建器，它们都可以用于创建一个新的协程作用域。<strong>不过<code>GlobalScope.launch</code>和<code>runBlocking</code>函数是可以在任意地方调用的，<code>coroutineScope</code>函数可以在协程作用域或挂起函数中调用，而<code>launch</code>函数只能在协程作用域中调用。</strong></p>
<p>前面已经说了，<code>runBlocking</code>由于会阻塞线程，因此只建议在测试环境下使用。而<code>GlobalScope.launch</code>由于每次创建的都是顶层协程，一般也不太建议使用，除非你非常明确就是要创建顶层协程。</p>
<p>为什么说不太建议使用顶层协程呢？主要还是因为它管理起来成本太高了。举个例子，比如我们在某个<strong>Activity</strong>中使用协程发起了一条网络请求，由于网络请求是耗时的，用户在服务器还没来得及响应的情况下就关闭了当前<strong>Activity</strong>，此时按理说应该取消这条网络请求，或者至少不应该进行回调，因为<strong>Activity</strong>已经不存在了，回调了也没有意义。</p>
<p>那么协程要怎样取消呢？不管是<code>GlobalScope.launch</code>函数还是<code>launch</code>函数，它们都会返回一个<strong>Job</strong>对象，只需要调用<strong>Job</strong>对象的<code>cancel()</code>方法就可以取消协程了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure>

<p>但是如果我们每次创建的都是顶层协程，那么当<strong>Activity</strong>关闭时，就需要逐个调用所有已创建协程的<code>cancel()</code>方法，试想一下，这样的代码是不是根本无法维护？</p>
<p>因此，<code>GlobalScope.launch</code>这种协程作用域构建器，在实际项目中也是不太常用的。下面演示一下实际项目中比较常用的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure>

<p>可以看到，我们先创建了一个<strong>Job</strong>对象，然后把它传入<code>CoroutineScope()</code>函数当中，注意这里的<code>CoroutineScope()</code>是个函数，虽然它的命名更像是一个类。<code>CoroutineScope()</code>函数会返回一个<strong>CoroutineScope</strong>对象，这种语法结构的设计更像是我们创建了一个<strong>CoroutineScope</strong>的实例，可能也是<strong>Kotlin</strong>有意为之的。有了<strong>CoroutineScope</strong>对象之后，就可以随时调用它的<strong>launch</strong>函数来创建一个协程了。</p>
<p>现在所有调用<strong>CoroutineScope</strong>的<strong>launch</strong>函数所创建的协程，都会被关联在<strong>Job</strong>对象的作用域下面。这样只需要调用一次<code>cancel()</code>方法，就可以将同一作用域内的所有协程全部取消，从而大大降低了协程管理的成本。</p>
<p><strong>不过相比之下，<code>CoroutineScope()</code>函数更适合用于实际项目当中，如果只是在<code>main()</code>函数中编写一些学习测试用的代码，还是使用runBlocking函数最为方便。</strong></p>
<p>我们已经知道了调用<strong>launch</strong>函数可以创建一个新的协程，但是<strong>launch</strong>函数只能用于执行一段逻辑，却不能获取执行的结果，因为它的返回值永远是一个<strong>Job</strong>对象。<strong>那么有没有什么办法能够创建一个协程并获取它的执行结果呢？当然有，使用async函数就可以实现。</strong></p>
<p><strong>async</strong>函数必须在协程作用域当中才能调用，它会创建一个新的子协程并返回一个<strong>Deferred</strong>对象，如果我们想要获取<strong>async</strong>函数代码块的执行结果，只需要调用<strong>Deferred</strong>对象的<code>await()</code>方法即可，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runBlocking &#123;</span><br><span class="line">		<span class="keyword">val</span> result = async &#123;</span><br><span class="line">			<span class="number">5</span> + <span class="number">5</span></span><br><span class="line">		&#125;.await()</span><br><span class="line">		println(result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在<strong>async</strong>函数的代码块中进行了一个简单的数学运算，然后调用<code>await()</code>方法获取运算结果，最终将结果打印出来。重新运行一下代码，发现控制台会打印一个10。</p>
<p>不过<strong>async</strong>函数的奥秘还不止于此。事实上，在调用了<strong>async</strong>函数之后，代码块中的代码就会立刻开始执行。<strong>当调用<code>await()</code>方法时，如果代码块中的代码还没执行完，那么<code>await()</code>方法会将当前协程阻塞住，直到可以获得async函数的执行结果。</strong></p>
<p>做个小实验：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">4</span>+<span class="number">6</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        println(<span class="string">&quot;result is <span class="subst">$&#123;result1 + result2&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> end = System.currentTimeMillis()</span><br><span class="line">        println(<span class="string">&quot;cost <span class="subst">$&#123;end - start&#125;</span>ms.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里连续使用了两个<strong>async</strong>函数来执行任务，并在代码块中调用<code>delay()</code>方法进行1秒的延迟。按照刚才的理论，<code>await()</code>方法在<strong>async</strong>函数代码块中的代码执行完之前会一直将当前协程阻塞住，那么为了便于验证，我们记录了代码的运行耗时。现在重新运行程序，结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/xiheya/2024/02/1709106260693_4f1cc4e6044bf.png" alt="1709106260693.png"></p>
<p>可以看到，整段代码的运行耗时是2033毫秒，说明这里的两个async函数确实是一种串行的关系，前一个执行完了后一个才能执行。</p>
<p>但是这种写法明显是非常低效的，因为两个<strong>async</strong>函数完全可以同时执行从而提高运行效率。现在对上述代码使用如下的写法进行修改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">4</span>+<span class="number">6</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;result is <span class="subst">$&#123;result1.await() + result2.await()&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> end = System.currentTimeMillis()</span><br><span class="line">        println(<span class="string">&quot;cost <span class="subst">$&#123;end - start&#125;</span>ms.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们不在每次调用<strong>async</strong>函数之后就立刻使用<code>await()</code>方法获取结果了，而是仅在需要用到<strong>async</strong>函数的执行结果时才调用<code>await()</code>方法进行获取，这样两个<strong>async</strong>函数就变成一种并行关系了。重新运行程序，结果如下所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/user/xiheya/2024/02/1709106396465_060e075f6b533.png" alt="1709106396465.png"></p>
<p>可以看到，现在整段代码的运行耗时变成了1013毫秒，运行效率的提升显而易见。</p>
<p>最后，再来学习一个比较特殊的作用域构建器：<code>withContext()</code>函数。<code>withContext()</code>函数是一个挂起函数，大体可以将它理解成<strong>async</strong>函数的一种简化版写法，示例写法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123; </span><br><span class="line">        <span class="keyword">val</span> result = withContext(Dispatchers.Default) &#123;</span><br><span class="line">            <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>withContext()</code>函数之后，会立即执行代码块中的代码，同时将外部协程挂起。当代码块中的代码全部执行完之后，会将最后一行的执行结果作为<code>withContext()</code>函数的返回值返回，因此基本上相当于<code>val result = async&#123; 5 + 5&#125;.await()</code>的写法。唯一不同的是，<code>withContext()</code>函数强制要求我们指定一个线程参数。</p>
<p>协程是一种轻量级的线程的概念，因此很多传统编程情况下需要开启多线程执行的并发任务，现在只需要在一个线程下开启多个协程来执行就可以了。但是这并不意味着我们就永远不需要开启线程了，<strong>比如说Android中要求网络请求必须在子线程中进行，即使你开启了协程去执行网络请求，假如它是主线程当中的协程，那么程序仍然会出错。这个时候我们就应该通过线程参数给协程指定一个具体的运行线程。</strong></p>
<p>线程参数主要有以下3种值可选：<code>Dispatchers.Default</code>、<code>Dispatchers.IO</code>和<code>Dispatchers.Main</code>。<code>Dispatchers.Default</code>表示会使用一种<strong>默认低并发的线程策略</strong>，当你要执行的代码属于<strong>计算密集型任务</strong>时，开启过高的并发反而可能会影响任务的运行效率，此时就可以使用<code>Dispatchers.Default</code>。<code>Dispatchers.IO</code>表示会使用一种<strong>较高并发的线程策略</strong>，当你要执行的代码<strong>大多数时间是在阻塞和等待</strong>中，比如说<strong>执行网络请求</strong>时，为了<strong>能够支持更高的并发数量</strong>，此时就可以使用<code>Dispatchers.IO</code>。**<code>Dispatchers.Main</code>则表示不会开启子线程<strong>，而是</strong>在Android主线程中执行代码<strong>，但是</strong>这个值只能在Android项目中使用，纯Kotlin程序使用这种类型的线程参数会出现错误。**</p>
<p>事实上，在我们刚才所学的协程作用域构建器中，<strong>除了<code>coroutineScope</code>函数之外，其他所有的函数都是可以指定这样一个线程参数的，只不过<code>withContext()</code>函数是强制要求指定的，而其他函数则是可选的</strong>。</p>
<h3 id="9-3-使用协程简化回调写法"><a href="#9-3-使用协程简化回调写法" class="headerlink" title="9.3 使用协程简化回调写法"></a>9.3 使用协程简化回调写法</h3><p>之前学习了编程语言的回调机制，并使用这个机制实现了获取异步网络请求数据响应的功能。回调机制基本上是依靠匿名类来实现的，但是匿名类的写法通常比较烦琐，比如如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HttpUtil.sendHttpRequest(address, <span class="keyword">object</span> : HttpCallbackListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在多少个地方发起网络请求，就需要编写多少次这样的匿名类实现。还有没有更加简单一点的写法呢？</p>
<p>在过去，可能确实没有什么更加简单的写法了。不过现在，Kotlin的协程使我们的这种设想成为了可能，只需要借助<code>suspendCoroutine</code>函数就能将传统回调机制的写法大幅简化，下面我们就来具体学习一下。</p>
<p><code>suspendCoroutine</code>函数必须在协程作用域或挂起函数中才能调用，它接收一个<strong>Lambda</strong>表达式参数，主要作用是将当前协程立即挂起，然后在一个普通的线程中执行<strong>Lambda</strong>表达式中的代码。<strong>Lambda</strong>表达式的参数列表上会传入一个<strong>Continuation</strong>参数，调用它的<code>resume()</code>方法或<code>resumeWithException()</code>可以让协程恢复执行。</p>
<p>了解了<code>suspendCoroutine</code>函数的作用之后，接下来我们就可以借助这个函数来对传统的回调写法进行优化。首先定义一个<code>request()</code>函数，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(address: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        HttpUtil.sendHttpRequest(address, <span class="keyword">object</span> : HttpCallbackListener &#123;</span><br><span class="line">    		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        		<span class="comment">// TODO</span></span><br><span class="line">	    	&#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">        		<span class="comment">// TODO</span></span><br><span class="line">    		&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>request()</code>函数是一个挂起函数，并且接收一个<strong>address</strong>参数。在<code>request()</code>函数的内部，我们调用了刚刚介绍的<code>suspendCoroutine</code>函数，这样当前协程就会被立刻挂起，而<strong>Lambda</strong>表达式中的代码则会在普通线程中执行。接着我们在<strong>Lambda</strong>表达式中调用<code>HttpUtil.sendHttpRequest()</code>方法发起网络请求，并通过传统回调的方式监听请求结果。如果请求成功就调用<code>Continuation</code>的<code>resume()</code>方法恢复被挂起的协程，并传入服务器响应的数据，该值会成为<code>suspendCoroutine</code>函数的返回值。如果请求失败，就调用<code>Continuation</code>的<code>resumeWithException()</code>恢复被挂起的协程，并传入具体的异常原因。</p>
<p>可是这里不是仍然使用了传统回调的写法吗？代码怎么就变得更加简化了？这是因为，不管之后我们要发起多少次网络请求，都不需要再重复进行回调实现了。比如说获取百度首页的响应数据，就可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBaiduResponse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = request(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>getBaiduResponse()</code>是一个挂起函数，因此当它调用了<code>request()</code>函数时，当前的协程就会被立刻挂起，然后一直等待网络请求成功或失败后，当前协程才能恢复运行。这样即使不使用回调的写法，我们也能够获得异步网络请求的响应数据，而如果请求失败，则会直接进入<strong>catch</strong>语句当中。</p>
<p>可是<code>getBaiduResponse()</code>函数被声明成了挂起函数，这样它也只能在协程作用域或其他挂起函数中调用了，使用起来是不是非常有局限性？确实如此，因为<code>suspendCoroutine</code>函数本身就是要结合协程一起使用的。不过通过合理的项目架构设计，我们可以轻松地将各种协程的代码应用到一个普通的项目当中。</p>
<p>事实上，<code>suspendCoroutine</code>函数几乎可以用于简化任何回调的写法，比如使用<code>Retrofit</code>来发起网络请求需要这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appService = ServiceCreator.create&lt;AppService&gt;()</span><br><span class="line">appService.getAppData().enqueue(<span class="keyword">object</span> : Callback&lt;List&lt;App&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, response: <span class="type">Response</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用<code>suspendCoroutine</code>函数，我们马上就能对上述写法进行大幅度的简化。由于不同的<code>Service</code>接口返回的数据类型也不同，所以这次我们不能像刚才那样针对具体的类型进行编程了，而是要使用泛型的方式。定义一个<code>await()</code>函数，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Call<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123;</span><br><span class="line">        enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123; continuation -&gt;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> body = response.body()</span><br><span class="line">                <span class="keyword">if</span> (body != <span class="literal">null</span>) continuation.resume(body)</span><br><span class="line">                <span class="keyword">else</span> continuation.resumeWithException(RuntimeException(<span class="string">&quot;reponse body is null&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWithException(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相比于刚才的<code>request()</code>函数又复杂了一点。首先<code>await()</code>函数仍然是一个挂起函数，然后我们给它声明了一个泛型T，并将<code>await()</code>函数定义成了<code>Call&lt;T&gt;</code>的扩展函数，这样所有返回值是<strong>Call</strong>类型的<code>Retrofit</code>网络请求接口就都可以直接调用<code>await()</code>函数了。</p>
<p>接着，<code>await()</code>函数中使用了<code>suspendCoroutine</code>函数来挂起当前协程，并且由于扩展函数的原因，我们现在拥有了<strong>Call</strong>对象的上下文，那么这里就可以直接调用<code>enqueue()</code>方法让<code>Retrofit</code>发起网络请求。接下来，使用同样的方式对<code>Retrofit</code>响应的数据或者网络请求失败的情况进行处理就可以了。另外还有一点需要注意，在<code>onResponse()</code>回调当中，我们调用<code>body()</code>方法解析出来的对象是可能为空的。如果为空的话，这里的做法是手动抛出一个异常，你也可以根据自己的逻辑进行更加合适的处理。</p>
<p>有了<code>await()</code>函数之后，我们调用所有<code>Retrofit</code>的<strong>Service</strong>接口都会变得极其简单，比如刚才同样的功能就可以使用如下写法进行实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAppData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> appList = ServiceCreator.create&lt;Appservice&gt;().getAppdata().await()</span><br><span class="line">        <span class="comment">// 对服务器响应的数据进行处理</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="comment">// 对异常情况进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有了冗长的匿名类实现，只需要简单调用一下await()函数就可以让Retrofit发起网络请求，并直接获得服务器响应的数据，有没有觉得代码变得极其简单？当然你可能会觉得，每次发起网络请求都要进行一次try catch处理也比较麻烦，其实这里我们也可以选择不处理。在不处理的情况下，如果发生了异常就会一层层向上抛出，一直到被某一层的函数处理了为止。因此，我们也可以在某个统一的入口函数中只进行一次try catch，从而让代码变得更加精简。</p>
<hr>
<h2 id="十、编写好用的工具方法"><a href="#十、编写好用的工具方法" class="headerlink" title="十、编写好用的工具方法"></a>十、编写好用的工具方法</h2><p>到目前为止，我们已经将<strong>Kotlin</strong>大部分系统性的知识点学习完了。掌握了如此多的<strong>Kotlin</strong>特性，还需要知道该如何对它们进行灵活运用。</p>
<p>事实上，<strong>Kotlin</strong>提供的丰富语法特性给我们提供了无限扩展的可能，各种复杂的<strong>API</strong>经过特殊的封装处理之后都能变得简单易用。但是最重要的还是我们要能养成对<strong>Kotlin</strong>的各种特性进行灵活运用的意识。</p>
<h3 id="10-1-求N个数的最大最小值"><a href="#10-1-求N个数的最大最小值" class="headerlink" title="10.1 求N个数的最大最小值"></a>10.1 求N个数的最大最小值</h3><p>两个数比大小这个功能，相信每一位开发者都遇到过。如果我想要获取两个数中较大的那个数，除了使用最基本的if语句之外，还可以借助<strong>Kotlin</strong>内置的<code>max()</code>函数，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">15</span></span><br><span class="line"><span class="keyword">val</span> larger = max(a,b)</span><br></pre></td></tr></table></figure>

<p>这种代码看上去简单直观，也很容易理解，因此好像并没有什么优化的必要。</p>
<p>可是现在如果我们想要在3个数中获取最大的那个数，应该怎么写呢？由于max()函数只能接收两个参数，因此需要先比较前两个数的大小，然后再拿较大的那个数和剩余的数进行比较，写法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">15</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> larger = max(max(a,b),c)</span><br></pre></td></tr></table></figure>

<p>有没有觉得代码开始变得复杂了呢？3个数中获取最大值就需要使用这种嵌套max()函数的写法<br>了，那如果是4个数、5个数呢？没错，这个时候你就应该意识到，我们是可以对max()函数的<br>用法进行简化的。</p>
<p>回顾一下，我们之前学过<code>vararg</code>关键字，它允许方法接收任意多个同等类型的参数，正好满足我们这里的需求。那么我们就可以新建一个<code>Max.kt</code>文件，并在其中自定义一个<code>max()</code>函数，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(<span class="keyword">vararg</span> nums: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxNum = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span>(num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        maxNum = kotlin.math.max(maxNum, num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里<code>max()</code>函数的参数声明中使用了<code>vararg</code>关键字，也就是说现在它可以接收任意多个整型参数。接着我们使用了一个<code>maxNum</code>变量来记录所有数的最大值，并在一开始将它赋值成了整型范围的最小值。然后使用<code>for-in</code>循环遍历<strong>nums</strong>参数列表，如果发现当前遍历的数字比<code>maxNum</code>更大，就将<code>maxNum</code>的值更新成这个数，最终将<code>maxNum</code>返回即可。</p>
<p>仅仅经过这样的一层封装之后，我们在使用<code>max()</code>函数时就会有翻天覆地的变化，比如刚才同样的功能，现在就可以使用如下的写法来实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">15</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> largest = max(a, b, c)</span><br></pre></td></tr></table></figure>

<p>这样我们就彻底摆脱了嵌套函数调用的写法，现在不管是求3个数的最大值还是求N个数的最大值，只需要不断地给<code>max()</code>函数传入参数就可以了。</p>
<p>不过，目前我们自定义的<code>max()</code>函数还有一个缺点，就是它只能求N个整型数字的最大值，如果我还想求N个浮点型或长整型数字的最大值，该怎么办呢？当然你可以定义很多个<code>max()</code>函数的重载，来接收不同类型的参数，因为<strong>Kotlin</strong>中内置的<code>max()</code>函数也是这么做的。但是这种方案实现起来过于烦琐，而且还会产生大量的重复代码，因此这里我准备使用一种更加巧妙的做法。</p>
<p>Java中规定，所有类型的数字都是可比较的，因此必须实现<strong>Comparable</strong>接口，这个规则在<strong>Kotlin</strong>中也同样成立。那么我们就可以借助泛型，将<code>max()</code>函数修改成接收任意多个实现<strong>Comparable</strong>接口的参数，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">max</span><span class="params">(<span class="keyword">vararg</span> nums: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty() <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Params can not be empty&quot;</span>))</span><br><span class="line">    <span class="keyword">var</span> maxNum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">            maxNum = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，<code>&lt;T: Comparable&lt;T&gt;&gt;</code> 是一个泛型约束。这表示类型 <code>T</code> 必须实现 <code>Comparable</code> 接口，这样我们才能在函数体内部使用 <code>&gt;</code> 操作符来比较 <code>T</code> 类型的对象。</p>
<p>在 Kotlin 中，所有的比较操作符（如 <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>）都定义在 <code>Comparable</code> 接口中。因此，如果我们想在一个泛型函数中使用这些操作符，我们就需要确保泛型类型 <code>T</code> 实现了 <code>Comparable</code> 接口。这就是为什么我们需要写 <code>&lt;T: Comparable&lt;T&gt;&gt;</code> 的原因。这样，无论 <code>T</code> 是什么类型，只要它实现了 <code>Comparable</code> 接口，我们就可以在函数中使用比较操作符。这使得我们的函数更加灵活和通用。例如，我们可以使用这个函数来找出一组整数、浮点数或者字符串中的最大值，因为这些类型都实现了 <code>Comparable</code> 接口。</p>
<p>这里将泛型<code>T</code>的上界指定成了<code>Comparable&lt;T&gt;</code>，<strong>那么参数<code>T</code>就必然是<code>Comparable&lt;T&gt;</code>的子类型了</strong>。接下来，我们判断nums参数列表是否为空，如果为空的话就主动抛出一个异常，提醒调用者<code>max()</code>函数必须传入参数。紧接着将<code>maxNum</code>的值赋值成nums参数列表中第一个参数的值，然后同样是遍历参数列表，如果发现了更大的值就对<code>maxNum</code>进行更新。</p>
<p>经过这样的修改之后，我们就可以更加灵活地使用<code>max()</code>函数了，比如说求3个浮点型数字的最大值，同样也变得轻而易举：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">3.5</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">3.8</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">4.1</span></span><br><span class="line"><span class="keyword">val</span> largest = max(a, b, c)</span><br></pre></td></tr></table></figure>

<p>而且现在不管是双精度浮点型、单精度浮点型，还是短整型、整型、长整型，只要是实现Comparable接口的子类型，max()函数全部支持获取它们的最大值，是一种一劳永逸的做法。</p>
<p>而如果你想获取N个数的最小值，实现的方式也是类似的，只需要定义一个min()函数就可以了:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">min</span><span class="params">(<span class="keyword">vararg</span> nums: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty() <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Params can not be empty&quot;</span>))</span><br><span class="line">    <span class="keyword">var</span> minNum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; minNum) &#123;</span><br><span class="line">            minNum = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-简化Toast的用法"><a href="#10-2-简化Toast的用法" class="headerlink" title="10.2 简化Toast的用法"></a>10.2 简化Toast的用法</h3><p>首先回顾一下Toast的标准用法吧，如果想要在界面上弹出一段文字提示需要这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(context, <span class="string">&quot;this is Toast&quot;</span>, Toast.LENGTH_SHORT).show()</span><br></pre></td></tr></table></figure>

<p>是不是很长的一段代码？而且曾经不知道有多少人因为忘记调用最后的<code>show()</code>方法，导致Toast无法弹出，从而产生一些千奇百怪的bug。</p>
<p>由于Toast是非常常用的功能，每次都需要编写这么长的一段代码确实让人很头疼，这个时候你就应该考虑对Toast的用法进行简化了。</p>
<p>我们来分析一下，Toast的<code>makeText()</code>方法接收3个参数：第一个参数是Toast显示的上下文环境，必不可少；第二个参数是Toast显示的内容，需要由调用方进行指定，可以传入字符串和字符串资源id两种类型；第三个参数是Toast显示的时长，只支持<code>Toast.LENGTH_SHORT</code>和<code>Toast.LENGTH_LONG</code>这两种值，相对来说变化不大。</p>
<p>那么我们就可以给String类和Int类各添加一个扩展函数，并在里面封装弹出Toast的具体逻辑。这样以后每次想要弹出Toast提示时，只需要调用它们的扩展函数就可以了。</p>
<p>新建一个Toast.kt文件，并在其中编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">&quot;this is Toast&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">&quot;this is Toast&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分别给String类和Int类新增了一个<code>showToast()</code>函数，并让它们都接收一个Context参数。然后在函数的内部，我们仍然使用了Toast原生API用法，只是将弹出的内容改成了this，另外将Toast的显示时长固定设置成<code>Toast.LENGTH_SHORT</code>。</p>
<p>以后如果要弹出一段文字提醒，可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is Toast&quot;</span>.showToast(context)</span><br></pre></td></tr></table></figure>

<p>另外，这只是直接弹出一段字符串文本的写法，如果你想弹出一个定义在<code>strings.xml</code>中的字符串资源，也非常简单，写法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.string.app_name.showToast(context)</span><br></pre></td></tr></table></figure>

<p>这两种写法分别调用的就是我们刚才在String类和Int类中添加的<code>showToast()</code>扩展函数。当然，这种写法其实还存在一个问题，就是Toast的显示时长被固定了，如果我现在想要使用<code>Toast.LENGTH_LONG</code>类型的显示时长该怎么办呢？要解决这个问题，其实最简单的做法就是在<code>showToast()</code>函数中再声明一个显示时长参数，但是这样每次调用<code>showToast()</code>函数时都要额外多传入一个参数，无疑增加了使用复杂度。使用给函数设定参数默认值的功能，我们就可以在不增加<code>showToast()</code>函数使用复杂度的情况下，又让它可以支持动态指定显示时长了。修改<code>Toast.kt</code>中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">	Toast.makeText(context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">	Toast.makeText(context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们给<code>showToast()</code>函数增加了一个显示时长参数，但同时也给它指定了一个参数默认值。这样我们之前所使用的<code>showToast()</code>函数的写法将完全不受影响，默认会使用<code>Toast.LENGTH_SHORT</code>类型的显示时长。而如果你想要使用<code>Toast.LENGTH_LONG</code>的显示时长，只需要这样写就可以了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is Toast&quot;</span>.showToast(context, Toast.LENGTH_LONG)</span><br></pre></td></tr></table></figure>

<h3 id="10-3-简化Snackbar的用法"><a href="#10-3-简化Snackbar的用法" class="headerlink" title="10.3 简化Snackbar的用法"></a>10.3 简化Snackbar的用法</h3><p>先来回顾一下Snackbar的常规用法吧，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Snackbar.make(view, <span class="string">&quot;This is Snackbar&quot;</span>, Snackbar.LENGTH_SHORT)</span><br><span class="line">		.setAction(<span class="string">&quot;Action&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">		.show()</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>Snackbar</strong>中<code>make()</code>方法的第一个参数变成了<strong>View</strong>，而<strong>Toast</strong>中<code>makeText()</code>方法的第一个参数是<strong>Context</strong>，另外<strong>Snackbar还可以调用<code>setAction()</code>方法来设置一个额外的点击事件</strong>。除了这些区别之外，<strong>Snackbar</strong>和<strong>Toast</strong>的其他用法都是相似的。</p>
<p>那么对于这种结构的API，我们该如何进行简化呢？其实简化的方式并不固定。</p>
<p>由于<code>make()</code>方法接收一个View参数，<strong>Snackbar</strong>会使用这个<strong>View</strong>自动查找最外层的布局，用于展示<strong>Snackbar</strong>。因此，我们就可以给<strong>View</strong>类添加一个扩展函数，并在里面封装显示<strong>Snackbar</strong>的具体逻辑。新建一个<code>Snackbar.kt</code>文件，并编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(text: <span class="type">String</span>, duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Snackbar.make(<span class="keyword">this</span>, text, duration).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(resId: <span class="type">Int</span>, duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Snackbar.make(<span class="keyword">this</span>, resId, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码应该还是很好理解的，和刚才的showToast()函数比较相似。只是我们将扩展函数添加到了View类当中，并在参数列表上声明了Snackbar要显示的内容以及显示的时长。另外，Snackbar和Toast类似，显示的内容也是支持传入字符串和字符串资源id两种类型的，因此这里我们给showSnackbar()函数进行了两种参数类型的函数重载。</p>
<p>现在想要使用Snackbar显示一段文本提示，只需要这样写就可以了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.showSnackbar(<span class="string">&quot;This is Snackbar&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>假如<strong>Snackbar</strong>没有<code>setAction()</code>方法，那么我们的简化工作到这里就可以结束了。但是<code>setAction()</code>方法作为<strong>Snackbar</strong>最大的特色之一，如果不能支持的话，我们编写的<code>showSnackbar()</code>函数也就变得毫无意义了。</p>
<p>这个时候，神通广大的高阶函数又能派上用场了，我们可以让<code>showSnackbar()</code>函数再额外接收一个函数类型参数，以此来实现<strong>Snackbar</strong>的完整功能支持。修改<code>Snackbar.kt</code>中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    text: <span class="type">String</span>, actionText: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT, block: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> snackbar = Snackbar.make(<span class="keyword">this</span>, text, duration)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionText != <span class="literal">null</span> &amp;&amp; block != <span class="literal">null</span>) &#123;</span><br><span class="line">        snackbar.setAction(actionText) &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    resId: <span class="type">Int</span>, actionText: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT, block: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> snackbar = Snackbar.make(<span class="keyword">this</span>, resId, duration)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionText != <span class="literal">null</span> &amp;&amp; block != <span class="literal">null</span>) &#123;</span><br><span class="line">        snackbar.setAction(actionText) &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，<code>block()</code> 是一个可调用的 lambda 函数。当你调用 <code>showSnackbar</code> 方法并传入一个 lambda 函数作为 <code>block</code> 参数时，这个 lambda 函数就会替换 <code>block()</code>。</p>
<p>例如，如果你这样调用 <code>showSnackbar</code> 方法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.showSnackbar(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;Action&quot;</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;Action clicked!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在 <code>snackbar.setAction(actionText) &#123; block() &#125;</code> 这行代码中，<code>block()</code> 就会被替换为 <code>println(&quot;Action clicked!&quot;)</code>。所以，当用户点击 Snackbar 的操作文本时，控制台就会打印出 “Action clicked!”。</p>
<p>可以看到，这里我们给两个<code>showSnackbar()</code>函数都增加了一个函数类型参数，并且还增加了一个用于传递给<code>setAction()</code>方法的字符串或字符串资源id。这里我们需要将新增的两个参数都设置成可为空的类型，并将默认值都设置成空，然后只有当两个参数都不为空的时候，我们才去调用<strong>Snackbar</strong>的<code>setAction()</code>方法来设置额外的点击事件。如果触发了点击事件，只需要调用函数类型参数将事件传递给外部的Lambda表达式即可。</p>
<p>这样<code>showSnackbar()</code>函数就拥有比较完整的<strong>Snackbar</strong>功能了，比如本小节最开始的那段示例代码，现在就可以使用如下写法进行实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.showSnackbar(<span class="string">&quot;This is Snackbar&quot;</span>, <span class="string">&quot;Action&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十一、使用DSL构建专有的语法结构"><a href="#十一、使用DSL构建专有的语法结构" class="headerlink" title="十一、使用DSL构建专有的语法结构"></a>十一、使用DSL构建专有的语法结构</h2><p><strong>DSL</strong>的全称是领域特定语言（<strong>Domain Specific Language</strong>），它是编程语言赋予开发者的一种特殊能力，通过它我们可以编写出一些看似脱离其原始语法结构的代码，从而构建出一种专有的语法结构。</p>
<p>毫无疑问，Kotlin也是支持DSL的，并且在Kotlin中实现DSL的实现方式并不固定，比如我们之前使用infix函数构建出的特有语法结构就属于DSL。不过本节课我们的主要学习目标是通过高阶函数的方式来实现DSL，这也是Kotlin中实现DSL最常见的方式。</p>
<p>当我们想要在项目中添加一些依赖库，需要在build.gradle文件中添加依赖时其实就使用了DSL，例如：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation &#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;</span><br><span class="line">	implementation &#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gradle是一种基于Groovy语言的构建工具，因此上述的语法结构其实就是Groovy提供的DSL功能。有没有觉得很神奇？不用吃惊，借助Kotlin的DSL，我们也可以实现类似的语法结构，下面就来具体看一下吧。</p>
<p>首先新建一个DSL.kt文件，然后在里面定义一个Dependency类，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> libraries = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">implementation</span><span class="params">(lib: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        libraries.add(lib)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了一个List集合来保存所有的依赖库，然后又提供了一个<code>implementation()</code>方法，用于向List集合中添加依赖库，代码非常简单。</p>
<p>接下来再定义一个<code>dependencies</code>高阶函数，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">(block: <span class="type">Dependency</span>.() -&gt; <span class="type">Unit</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> dependency = Dependency()</span><br><span class="line">    dependency.block()</span><br><span class="line">    <span class="keyword">return</span> dependency.libraries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>dependencies</code>函数接收一个函数类型参数，并且该参数是定义到Dependency类中的，因此调用它的时候需要先创建一个Dependency的实例，然后再通过该实例调用函数类型参数，这样传入的Lambda表达式就能得到执行了。最后，我们将Dependency类中保存的依赖库集合返回。</p>
<p>没错，经过这样的DSL设计之后，我们就可以在项目中使用如下的语法结构了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;</span></span><br><span class="line">	implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>dependencies</code>函数接收一个函数类型参数，因此这里我们可以传入一个Lambda表达式。而此时的Lambda表达式中拥有Dependency类的上下文，因此当然就可以直接调用Dependency类中的<code>implementation()</code>方法来添加依赖库了。</p>
<p>当然，这种语法结构和我们在<code>build.gradle</code>文件中使用的语法结构并不完全相同，这主要是因为Kotlin和Groovy在语法层面还是有一定差别的。</p>
<p>另外，我们也可以通过<code>dependencies</code>函数的返回值来获取所有添加的依赖库，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> libraries = dependencies &#123;</span><br><span class="line">        implementation(<span class="string">&quot;com.squareup.retrofit2:retrofit:2.6.1&quot;</span>)</span><br><span class="line">        implementation(<span class="string">&quot;com.squareup.retrofit2:converter-gson:2.6.1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (lib <span class="keyword">in</span> libraries) &#123;</span><br><span class="line">        println(lib)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用一个libraries变量接收<code>dependencies</code>函数的返回值，然后使用for-in循环将集合中的依赖库全部打印出来。</p>
<p>这种语法结构比起直接调用Dependency对象的<code>implementation()</code>方法要更直观一些，而且你会发现，需要添加的依赖库越多，使用DSL写法的优势就会越明显。在实现了一个较为简单的DSL之后，接下来我们再尝试编写一个复杂一点的DSL。</p>
<p>网页的展示都是由浏览器解析HTML代码来实现的。HTML中定义了很多标签，其中<table>标签用于创建一个表格，<tr>标签用于创建表格的行，<td>标签用于创建单元格。将这3种标签嵌套使用，就可以定制出包含任意行列的表格了。</p>
<p>那么如果现在有一个需求，要求我们在Kotlin中动态生成表格所对应的HTML代码，你会怎么做呢？最简单直接的方式就是字符串拼接了，但是这种做法显然十分烦琐，而且字符串拼接的代码也难以阅读。</p>
<p>这个时候DSL又可以大显身手了，借助DSL，我们可以以一种不可思议的语法结构来动态生成表格所对应的HTML代码，下面就来看一下具体应该如何实现吧。</p>
<p>仍然是在DSL.kt文件中进行编写，首先定义一个Td类，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Td</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span> = <span class="string">&quot;\n\t\t&lt;td&gt;<span class="variable">$content</span>&lt;/td&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<td>标签表示一个单元格，其中必然是要包含内容的，因此这里我们使用了一个content字段来存储单元格中显示的内容。另外，还提供了一个html()方法，当调用这个方法时就返回一段<td>标签的HTML代码，并将content中存储的内容拼接进去。注意，为了让最终输出的结果更加直观，我使用了\n和\t转义符来进行换行和缩进，当然可以不加这些转义符，因为浏览器在解析HTML代码时是忽略换行和缩进的。</p>
<p>完成了Td类，接下来我们再定义一个Tr类，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = ArrayList&lt;Td&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">td</span><span class="params">(block: <span class="type">Td</span>.() -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> td = Td()</span><br><span class="line">        td.content = td.block()</span><br><span class="line">        children.add(td)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">&quot;\n\t&lt;tr&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (childTag <span class="keyword">in</span> children) &#123;</span><br><span class="line">            builder.append(childTag.html())</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">&quot;\n\t&lt;/tr&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tr类相比于Td类就要复杂一些了。由于<tr>标签表示表格的行，它是可以包含多个<td>标签的，因此我们首先创建了一个children集合，用于存储当前Tr所包含的Td对象。接下来提供了一个td()函数，它接收一个定义到Td类中并且返回值是String的函数类型参数。当调用td()函数时，会先创建一个Td对象，接着调用函数类型参数并获取它的返回值，然后赋值到Td类的content字段当中，这样就可以将调用td()函数时传入的Lambda表达式的返回值赋值给content字段了。当然，这里既然创建了一个Td对象，就一定要记得将它添加到children集合当中。</p>
<p>另外，Tr类中也定义了一个html()方法，它的作用和刚才Td类中的html()方法一致。只是由于每个Tr都可能会包含很多个Td，因此我们需要使用循环来遍历children集合，将所有的子Td都拼接到<tr>标签当中，从而返回一段嵌套的HTML代码。</p>
<p>定义好了Tr类之后，我们现在就可以使用如下的语法格式来构建表格中的一行数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tr = Tr()</span><br><span class="line">tr.td &#123; <span class="string">&quot;Apple&quot;</span> &#125;</span><br><span class="line">tr.td &#123; <span class="string">&quot;Grape&quot;</span> &#125;</span><br><span class="line">tr.td &#123; <span class="string">&quot;Orange&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>那么接下来继续对DSL进行完善，再定义一个Table类，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = ArrayList&lt;Tr&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tr</span><span class="params">(block: <span class="type">Tr</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tr = Tr()</span><br><span class="line">        tr.block()</span><br><span class="line">        children.add(tr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">&quot;&lt;table&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (childTag <span class="keyword">in</span> children) &#123;</span><br><span class="line">            builder.append(childTag)</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">&quot;&lt;/table&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相对就好理解多了，因为和刚才Tr类中的代码是比较相似的。Table类中同样创建了一个children集合，用于存储当前Table所包含的Tr对象。然后定义了一个tr()函数，它接收一个定义到Tr类中的函数类型参数。当调用tr()函数时，会先创建一个Tr对象，接着调用函数类型参数，这样Lambda表达式中的代码就能得到执行。最后，仍然要记得将创建的Tr对象添加到children集合当中。</p>
<p>除此之外，html()方法中的代码也都是类似的，这里遍历了children集合，将所有的子Tr对象都拼接到了<table>标签当中。</p>
<p>那么现在，我们就可以使用如下的语法结构来构建一个表格了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> table = Table()</span><br><span class="line">table.tr &#123;</span><br><span class="line">    td &#123; <span class="string">&quot;Apple&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Grape&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Orange&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">table.tr &#123;</span><br><span class="line">    td &#123; <span class="string">&quot;Pear&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Banana&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Watermelon&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看上去已经相当不错了，不过这仍然不是最终版本，我们还可以再进一步对语法结构进行精简。定义一个table()函数，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">table</span><span class="params">(block: <span class="type">Table</span>.() -&gt; <span class="type">Unit</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> table = Table()</span><br><span class="line">    table.block()</span><br><span class="line">    <span class="keyword">return</span> table.html()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>table()</code>函数接收一个定义到Table类中的函数类型参数，当调用<code>table()</code>函数时，会先创建一个Table对象，接着调用函数类型参数，这样Lambda表达式中的代码就能得到执行。最后调用Table的<code>html()</code>方法获取生成的HTML代码，并作为最终的返回值返回。</p>
<p>编写了这么多代码之后，我们就可以使用如下神奇的语法结构来动态生成一个表格所对应的HTML代码了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/7-15:31</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> html = table &#123;</span><br><span class="line">        tr &#123;</span><br><span class="line">            td &#123; <span class="string">&quot;Apple&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Grape&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Orange&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tr &#123;</span><br><span class="line">            td &#123; <span class="string">&quot;Pear&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Banana&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Watermelon&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(html)</span><br><span class="line">    println(html.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在DSL中也可以使用Kotlin的其他语法特性，比如通过循环来批量生成<tr>和<td>标签：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> html1 = table &#123;</span><br><span class="line">        repeat(<span class="number">2</span>) &#123;</span><br><span class="line">            tr &#123;</span><br><span class="line">                <span class="keyword">val</span> fruits = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> (fruit <span class="keyword">in</span> fruits) &#123;</span><br><span class="line">                    td &#123; fruit &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(html1.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>repeat()</code>函数来为表格生成两行数据，每行数据中又使用了<code>for-in</code>循环来遍历List集合，为表格填充具体的单元格数据。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://icu007.work/wp-content/uploads/2022/03/head-1.jpeg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://icu007.work/wp-content/uploads/2022/03/head-1.jpeg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Rookie_l</div><div class="post-copyright__author_desc">偷得浮生半日闲</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://icu007work.github.io/archives/4fa27f9d.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://icu007work.github.io/archives/4fa27f9d.html')">Kotlin 进阶</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://icu007work.github.io/archives/4fa27f9d.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Kotlin 进阶&amp;url=https://icu007work.github.io/archives/4fa27f9d.html&amp;pic=https://pic2.ziyuan.wang/user/xiheya/2024/05/Kotlin-Advance_535ea90c69f3c.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icu007work.github.io" target="_blank">米奇妙妙屋</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Kotlin/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Kotlin<span class="tagsPageCount">13</span></a><a class="post-meta__box__tags" href="/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>编程入门<span class="tagsPageCount">13</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic2.ziyuan.wang/user/xiheya/2024/05/Kotlin-Advance_535ea90c69f3c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/archives/4a483fcb.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Network_0d14f49c4bca7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kotlin安卓开发-使用网络技术</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/archives/f2287651.html" title="Kotlin安卓开发-Broadcast"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Android-Broadcast_e002cd5cd46cc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-28</div><div class="title">Kotlin安卓开发-Broadcast</div></div></a></div><div><a href="/archives/add4ecd9.html" title="Kotlin入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.ziyuan.wang/2023/09/11/guest_566671d879c50.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-11</div><div class="title">Kotlin入门</div></div></a></div><div><a href="/archives/149564e1.html" title="Kotlin安卓开发-ContentProvider"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/ContentProvider_ade10dd50ff3c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-09</div><div class="title">Kotlin安卓开发-ContentProvider</div></div></a></div><div><a href="/archives/14654f7f.html" title="Kotlin安卓开发-Fragment"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Android-Fragment_459fb5ae97b91.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-15</div><div class="title">Kotlin安卓开发-Fragment</div></div></a></div><div><a href="/archives/f8eec5a0.html" title="Kotlin安卓开发-Jetpack"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Jetpack_cb169f472cca5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-24</div><div class="title">Kotlin安卓开发-Jetpack</div></div></a></div><div><a href="/archives/4928ca7e.html" title="Kotlin安卓开发-Service"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Service_595ef761c9141.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-11</div><div class="title">Kotlin安卓开发-Service</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://icu007.work/wp-content/uploads/2022/03/head-1.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">本站有关于<b style="color:#fff">科技、生活</b>相关的文章和随笔，还有<b style="color:#fff">编程基础知识</b>和<b style="color:#fff">实用工具</b>分享。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">希望你可以在本站中收获对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Rookie_l</h1><div class="author-info__desc">偷得浮生半日闲</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hiheya" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/55406380" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://pic.ziyuan.wang/2023/08/22/30087e712d9fd.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://pic.ziyuan.wang/2023/08/22/e91ab86cccd2c.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">一、标准函数和静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0with%E3%80%81run%E5%92%8Capply"><span class="toc-text">1.1 标准函数with、run和apply</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-with%E5%87%BD%E6%95%B0"><span class="toc-text">1.1.1 with函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-run%E5%87%BD%E6%95%B0"><span class="toc-text">1.1.2 run函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-apply%E5%87%BD%E6%95%B0"><span class="toc-text">1.1.3 apply函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.2 定义静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.2.1 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">1.2.2 顶层方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-text">二、延迟初始化和密封类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AF%B9%E5%8F%98%E9%87%8F%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.1 对变量延迟初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8%E5%AF%86%E5%B0%81%E7%B1%BB%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-text">2.2 使用密封类优化代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">三、扩展函数和运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%A4%A7%E6%9C%89%E7%94%A8%E9%80%94%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0"><span class="toc-text">3.1 大有用途的扩展函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9C%89%E8%B6%A3%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">3.2 有趣的运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text">四、高阶函数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%9A%E4%B9%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">4.1 定义高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.2 内联函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-noinline-%E4%B8%8E-crossinline"><span class="toc-text">4.3 noinline 与 crossinline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">五、高阶函数的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%AE%80%E5%8C%96SharedPreferences%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">5.1 简化SharedPreferences的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%AE%80%E5%8C%96ContentValues%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">5.2 简化ContentValues的用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%A7%94%E6%89%98"><span class="toc-text">六、泛型和委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">6.1 泛型的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%A7%94%E6%89%98%E5%92%8C%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7"><span class="toc-text">6.2 类委托和委托属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E7%B1%BB%E5%A7%94%E6%89%98"><span class="toc-text">6.2.1 类委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7"><span class="toc-text">6.2.2 委托属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84lazy%E5%87%BD%E6%95%B0"><span class="toc-text">6.2.3 实现一个自己的lazy函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BD%BF%E7%94%A8infix%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%8F%AF%E8%AF%BB%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">七、使用infix函数构建更可读的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">八、泛型的高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%AF%B9%E6%B3%9B%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AE%9E%E5%8C%96"><span class="toc-text">8.1 对泛型进行实化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">8.2 泛型实化的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98"><span class="toc-text">8.3 泛型的协变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%80%86%E5%8F%98"><span class="toc-text">8.4 泛型的逆变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F"><span class="toc-text">九、使用协程编写高效的并发程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">9.1 协程的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-text">9.2 更多的作用域构建器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%AE%80%E5%8C%96%E5%9B%9E%E8%B0%83%E5%86%99%E6%B3%95"><span class="toc-text">9.3 使用协程简化回调写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%BC%96%E5%86%99%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95"><span class="toc-text">十、编写好用的工具方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%B1%82N%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">10.1 求N个数的最大最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E7%AE%80%E5%8C%96Toast%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">10.2 简化Toast的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E7%AE%80%E5%8C%96Snackbar%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">10.3 简化Snackbar的用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8DSL%E6%9E%84%E5%BB%BA%E4%B8%93%E6%9C%89%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">十一、使用DSL构建专有的语法结构</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/4fa27f9d.html" title="Kotlin 进阶"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Kotlin-Advance_535ea90c69f3c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin 进阶"/></a><div class="content"><a class="title" href="/archives/4fa27f9d.html" title="Kotlin 进阶">Kotlin 进阶</a><time datetime="2024-05-11T07:40:52.000Z" title="发表于 2024-05-11 15:40:52">2024-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/4a483fcb.html" title="Kotlin安卓开发-使用网络技术"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Network_0d14f49c4bca7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin安卓开发-使用网络技术"/></a><div class="content"><a class="title" href="/archives/4a483fcb.html" title="Kotlin安卓开发-使用网络技术">Kotlin安卓开发-使用网络技术</a><time datetime="2024-03-13T07:37:24.000Z" title="发表于 2024-03-13 15:37:24">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/a3762f06.html" title="Kotlin安卓开发-Material"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Material_c668a539b4551.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin安卓开发-Material"/></a><div class="content"><a class="title" href="/archives/a3762f06.html" title="Kotlin安卓开发-Material">Kotlin安卓开发-Material</a><time datetime="2024-02-27T07:34:17.000Z" title="发表于 2024-02-27 15:34:17">2024-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/6c099795.html" title="Kotlin安卓开发-高级技巧"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Advance_7270c77bc7e69.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin安卓开发-高级技巧"/></a><div class="content"><a class="title" href="/archives/6c099795.html" title="Kotlin安卓开发-高级技巧">Kotlin安卓开发-高级技巧</a><time datetime="2024-02-04T07:31:01.000Z" title="发表于 2024-02-04 15:31:01">2024-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/f8eec5a0.html" title="Kotlin安卓开发-Jetpack"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic2.ziyuan.wang/user/xiheya/2024/05/Jetpack_cb169f472cca5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin安卓开发-Jetpack"/></a><div class="content"><a class="title" href="/archives/f8eec5a0.html" title="Kotlin安卓开发-Jetpack">Kotlin安卓开发-Jetpack</a><time datetime="2024-01-24T07:28:13.000Z" title="发表于 2024-01-24 15:28:13">2024-01-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:rookie_l@icu007.work" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/5400016811" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=61550101473898&amp;mibextid=2JQ9oc" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://icu007.work/wp-content/uploads/2022/03/head-1.jpeg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/hiheya" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/55406380" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com/iJm1hSu7/" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral/" title="本网站由 又拍云 提供CDN加速/云存储服务"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-upyun"></use></svg></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a><a class="footer-item" title="本网站由 又拍云 提供CDN加速/云存储服务" target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral/">本网站由 又拍云 提供CDN加速/云存储服务</a></div></div><div class="footer-group"><div class="footer-title">关于</div><div class="footer-links"><a class="footer-item" title="关于作者" href="/about/">关于作者</a><a class="footer-item" title="文章归档" href="/archives/">文章归档</a><a class="footer-item" title="更新日志" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral/" style="margin-inline:5px" data-title="本站使用又拍云为静态资源提供CDN加速" title="本站使用又拍云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/CDN-又拍云-blue.svg?logo=iCloud" alt="本站使用又拍云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Rookie_l" target="_blank">Rookie_l</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["尊重所有声音&#44; 但成为自己."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://icu007.work" title="主站">主站</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://icu007.work/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://chat.icu007.work/" title="ChatGPT"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="ChatGPT"/><span class="back-menu-item-text">ChatGPT</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://baidu.icu007.work/" title="帮你百度一下"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="帮你百度一下"/><span class="back-menu-item-text">帮你百度一下</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 站务</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 空调</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友链</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=6842714056&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 番剧</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 碎碎念</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 传送门</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Android/" style="font-size: 0.88rem;">Android<sup>2</sup></a><a href="/tags/Dos/" style="font-size: 0.88rem;">Dos<sup>1</sup></a><a href="/tags/IDEA/" style="font-size: 0.88rem;">IDEA<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>23</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" style="font-size: 0.88rem;">Java基础语法<sup>5</sup></a><a href="/tags/Java%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">Java异常<sup>2</sup></a><a href="/tags/Java%E6%95%B0%E7%BB%84/" style="font-size: 0.88rem;">Java数组<sup>3</sup></a><a href="/tags/Java%E6%96%B9%E6%B3%95/" style="font-size: 0.88rem;">Java方法<sup>1</sup></a><a href="/tags/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" style="font-size: 0.88rem;">Java流程控制<sup>3</sup></a><a href="/tags/Java%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">Java特性<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">Java面向对象<sup>4</sup></a><a href="/tags/Kotlin/" style="font-size: 0.88rem;">Kotlin<sup>13</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>1</sup></a><a href="/tags/WP/" style="font-size: 0.88rem;">WP<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>2</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">排序算法<sup>1</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 0.88rem;">硬件<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" style="font-size: 0.88rem;">编程入门<sup>13</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">软件分享<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 0.88rem;">随笔<sup>13</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="6842714056" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=6842714056&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'DSKC4Zc0A0aO83qSYyJIczkF-gzGzoHsz',
      appKey: 'X4vG5DxFgvkzTBQNF8IRA7gi',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, {"valine":"/js/myjs/Valine.min.js"}))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('/js/myjs/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://DSKC4Zc0.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'DSKC4Zc0A0aO83qSYyJIczkF-gzGzoHsz',
        "X-LC-Key": 'X4vG5DxFgvkzTBQNF8IRA7gi',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4201142_cetcbzr9wn.js"></script><script type="text/javascript" src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>
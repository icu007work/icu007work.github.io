<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米奇妙妙屋</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="https://icu007work.github.io/atom.xml" rel="self"/>
  
  <link href="https://icu007work.github.io/"/>
  <updated>2024-05-11T07:46:12.595Z</updated>
  <id>https://icu007work.github.io/</id>
  
  <author>
    <name>Rookie_l</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin 进阶</title>
    <link href="https://icu007work.github.io/archives/4fa27f9d.html"/>
    <id>https://icu007work.github.io/archives/4fa27f9d.html</id>
    <published>2024-05-11T07:40:52.000Z</published>
    <updated>2024-05-11T07:46:12.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、标准函数和静态方法"><a href="#一、标准函数和静态方法" class="headerlink" title="一、标准函数和静态方法"></a>一、标准函数和静态方法</h2><h3 id="1-1-标准函数with、run和apply"><a href="#1-1-标准函数with、run和apply" class="headerlink" title="1.1 标准函数with、run和apply"></a>1.1 标准函数with、run和apply</h3><h4 id="1-1-1-with函数"><a href="#1-1-1-with函数" class="headerlink" title="1.1.1 with函数"></a>1.1.1 with函数</h4><p>with函数接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回值返回。示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(obj)&#123;</span><br><span class="line">    <span class="comment">// obj的上下文</span></span><br><span class="line">    <span class="string">&quot;value&quot;</span> <span class="comment">//with 函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体怎么使用呢？举个栗子🌰：我们有个fruit列表，现在我们需要吃完所有水果，并将结果打印出来。我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listFruit = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">builder.append(<span class="string">&quot;Start eating fruits. \n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> listFruit)&#123;</span><br><span class="line">    builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = builder.toString()</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>这段代码的逻辑很简单，就是使用StringBuilder来构建吃水果的字符串，最后将结果打印出来。我们连续调用了很多次builder对象的方法。其实这个时候就可以考虑使用with函数来让代码变得更加精简。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listWith = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultWith = with(StringBuilder())&#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> listWith)&#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(resultWith)</span><br></pre></td></tr></table></figure><p>首先我们给with函数的第一个参数传入了一个StringBuilder对象，那么接下来整个Lambda表达式的上下文就会是这个StringBuilder对象。于是我们在Lambda表达式中就不用再像刚才那样调用builder.append()和builder.toString()方法了，而是可以直接调用append()和toString()方法。Lambda表达式的最后一行代码会作为with函数的返回值返回，最终我们将结果打印出来。</p><h4 id="1-1-2-run函数"><a href="#1-1-2-run函数" class="headerlink" title="1.1.2 run函数"></a>1.1.2 run函数</h4><p>run函数的用法和使用场景其实和with函数是非常类似的，只是稍微做了一些语法改动而已。首先run函数通常不会直接调用，而是要在某个对象的基础上调用；其次run函数只接收一个Lambda参数，并且会在Lambda表达式中提供调用对象的上下文。其他方面和with函数是一样的，包括也会使用Lambda表达式中的最后一行代码作为返回值返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.run&#123;</span><br><span class="line">    <span class="comment">// obj的上下文</span></span><br><span class="line">    <span class="string">&quot;value&quot;</span> <span class="comment">//run函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用run函数来改写一下上述代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listWith = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultRun = StringBuilder().run&#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> listWith)&#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(resultRun)</span><br></pre></td></tr></table></figure><p>总体来说变化非常小，只是将调用with函数并传入StringBuilder对象改成了调用StringBuilder对象的run方法，其他都没有任何区别，这两段代码最终的执行结果是完全相同的。</p><h4 id="1-1-3-apply函数"><a href="#1-1-3-apply函数" class="headerlink" title="1.1.3 apply函数"></a>1.1.3 apply函数</h4><p>apply函数和run函数也是极其类似的，都要在某个对象上调用，并且只接收一个Lambda参数，也会在Lambda表达式中提供调用对象的上下文，但是apply函数无法指定返回值，而是会自动返回调用对象本身。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.apply&#123;</span><br><span class="line">    <span class="comment">// obj上下文</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result == obj</span></span><br></pre></td></tr></table></figure><p>那么现在我们再使用apply函数来修改一下吃水果的这段代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listWith = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultApply = StringBuilder().run&#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> listWith)&#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(resulApply.toString())</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，由于apply函数无法指定返回值，只能返回调用对象本身，因此这里的result实际上是一个StringBuilder对象，所以我们在最后打印的时候还要再调用它的toString()方法才行.</p><h3 id="1-2-定义静态方法"><a href="#1-2-定义静态方法" class="headerlink" title="1.2 定义静态方法"></a>1.2 定义静态方法</h3><p>静态方法在某些编程语言里面又叫作类方法，指的就是那种不需要创建实例就能调用的方法，所有主流的编程语言都会支持静态方法这个特性。</p><p>在Java中定义一个静态方法非常简单，只需要在方法上声明一个static关键字就可以了，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do Action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常简单的工具类，上述代码中的doAction()方法就是一个静态方法。调用静态方法并不需要创建类的实例，而是可以直接以Util.doAction()这种写法来调用。因而静态方法非常适合用于编写一些工具类的功能，因为工具类通常没有创建实例的必要，基本是全局通用的。</p><p><strong>但是和绝大多数主流编程语言不同的是，Kotlin却极度弱化了静态方法这个概念，想要在Kotlin中定义一个静态方法反倒不是一件容易的事。</strong></p><p>那么Kotlin为什么要这样设计呢？因为Kotlin提供了比静态方法更好用的语法特性，并且我们在上一节中已经学习过了，那就是单例类。</p><p>像工具类这种功能，在Kotlin中就非常推荐使用单例类的方式来实现，比如上述的Util工具类，如果使用Kotlin来实现的话就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Util&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这里的doAction()方法并不是静态方法，但是我们仍然可以使用Util.doAction()的方式来调用，这就是单例类所带来的便利性。</p><p>不过，使用单例类的写法会将整个类中的所有方法全部变成类似于静态方法的调用方式，而如果我们只是希望让类中的某一个方法变成静态方法的调用方式该怎么办呢？这个时候就可以使用刚刚在最佳实践环节用到的<strong>companion object</strong>了，示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do action2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先我们将Util从单例类改成了一个普通类，然后在类中直接定义了一个doAction1()方法，又在companion object中定义了一个doAction2()方法。现在这两个方法就有了本质的区别，因为doAction1()方法是一定要先创建Util类的实例才能调用的，而doAction2()方法可以直接使用Util.doAction2()的方式调用。</p><p>不过，doAction2()方法其实也并不是静态方法，companion object这个关键字实际上会在Util类的内部创建一个伴生类，而doAction2()方法就是定义在这个伴生类里面的实例方法。只是Kotlin会保证Util类始终只会存在一个伴生类对象，因此调用Util.doAction2()方法实际上就是调用了Util类中伴生对象的doAction2()方法。</p><p>由此可以看出，Kotlin确实没有直接定义静态方法的关键字，但是提供了一些语法特性来支持类似于静态方法调用的写法，这些语法特性基本可以满足我们平时的开发需求了。然而如果你确确实实需要定义真正的静态方法， Kotlin仍然提供了两种实现方式：<strong>注解和顶层方法</strong>。下面我们来逐个学习一下。</p><h4 id="1-2-1-注解"><a href="#1-2-1-注解" class="headerlink" title="1.2.1 注解"></a>1.2.1 注解</h4><p>先来看注解，前面使用的单例类和companion object都只是在语法的形式上模仿了静态方法的调用方式，实际上它们都不是真正的静态方法。因此如果你在Java代码中以静态方法的形式去调用的话，你会发现这些方法并不存在。而如果我们给单例类或companion object中的方法加上@JvmStatic注解，那么Kotlin编译器就会将这些方法编译成真正的静态方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;do action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do action2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，@JvmStatic注解只能加在单例类或companion object中的方法上，如果你尝试加在一个普通方法上，会直接提示语法错误。由于doAction2()方法已经成为了真正的静态方法，那么现在不管是在Kotlin中还是在Java中，都可以使用Util.doAction2()的写法来调用了。</p><h4 id="1-2-2-顶层方法"><a href="#1-2-2-顶层方法" class="headerlink" title="1.2.2 顶层方法"></a>1.2.2 顶层方法</h4><p>再来看顶层方法，顶层方法指的是那些没有定义在任何类中的方法，比如我们在上一节中编写的main()方法。Kotlin编译器会将所有的顶层方法全部编译成静态方法，因此只要你定义了一个顶层方法，那么它就一定是静态方法。</p><p>想要定义一个顶层方法，首先需要创建一个Kotlin文件。对着任意包名右击 → New → Kotlin File&#x2F;Class，在弹出的对话框中输入文件名即可。注意创建类型要选择File</p><p>点击“OK”完成创建，这样刚刚的包名路径下就会出现一个Helper.kt文件。现在我们在这个文件中定义的任何方法都会是顶层方法，比如这里我就定义一个doSomething()方法吧，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才已经讲过了，Kotlin编译器会将所有的顶层方法全部编译成静态方法，那么我们要怎么调用这个doSomething()方法呢？如果是在Kotlin代码中调用的话，那就很简单了，所有的顶层方法都可以在任何位置被直接调用，不用管包名路径，也不用创建实例，直接键入doSomething()即可.</p><p>但如果是在Java代码中调用，你会发现是找不到doSomething()这个方法的，因为Java中没有顶层方法这个概念，所有的方法必须定义在类中。那么这个doSomething()方法被藏在了哪里呢？我们刚才创建的Kotlin文件名叫作Helper.kt，于是Kotlin编译器会自动创建一个叫作HelperKt的Java类，doSomething()方法就是以静态方法的形式定义在HelperKt类里面的，因此在Java中使用HelperKt.doSomething()的写法来调用就可以了.</p><hr><h2 id="二、延迟初始化和密封类"><a href="#二、延迟初始化和密封类" class="headerlink" title="二、延迟初始化和密封类"></a>二、延迟初始化和密封类</h2><h3 id="2-1-对变量延迟初始化"><a href="#2-1-对变量延迟初始化" class="headerlink" title="2.1 对变量延迟初始化"></a>2.1 对变量延迟初始化</h3><p>前面学习了Kotlin语言的许多特性，包括变量不可变，变量不可为空，等等。这些特性都是为了尽可能地保证程序安全而设计的，但是有的时候会给我们编码带来一些麻烦。</p><p>例如如果项目的某个类中存在很多全局变量实例，为了保证它们能够满足Kotlin的空指针检查语法标准，我们不得不做许多的非空判断保护才行，即使非常确定它们不会为空。</p><p>们通过一个具体的例子来看一下吧，就使用刚刚的UIBestPractice项目来作为例子。如果仔细观察MainActivity中的代码，会发现这里适配器的写法略微有点特殊：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> msgList = ArrayList&lt;Msg&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter:MsgAdapter? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        adapter = MsgAdapter(msgList)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通知列表有新的数据插入</span></span><br><span class="line">        adapter?.notifyItemInserted(msgList.size - <span class="number">1</span>)</span><br><span class="line">        ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将adapter设置为了全局变量，但是它的初始化工作是在onCreate()方法中进行的，因此不得不先将adapter赋值为null，同时把它的类型声明成MsgAdapter?</p><p>虽然我们会在onCreate()方法中对adapter进行初始化，同时能确保onClick()方法必然在onCreate()方法之后才会调用，但是我们在onClick()方法中调用adapter的任何方法时仍然要进行判空处理才行，否则编译肯定无法通过。</p><p>当我们的代码中有了越来越多的全局变量实例时，这个问题就会变得越来越明显，到时候我们可能需要编写大量额外的判空处理代码，只是为了满足Kotlin编译器的要求。</p><p>那么该如何解决呢？其实非常简单，那就是对全局变量进行延迟初始化。</p><p>延迟初始化使用的是lateinit关键字，它可以告诉Kotlin编译器，我会在晚些时候对这个变量进行初始化，这样就不用在一开始的时候将它赋值为null了。</p><p>接下来使用延迟初始化对上述代码进行优化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> msgList = ArrayList&lt;Msg&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter:MsgAdapter</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        adapter = MsgAdapter(msgList)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通知列表有新的数据插入</span></span><br><span class="line">        adapter.notifyItemInserted(msgList.size - <span class="number">1</span>)</span><br><span class="line">        ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在adapter变量前面加上lateinit关键字后就用一开始就将它赋值为 null ，同时类型声明也就可以改成MsgAdapter了。由于MsgAdapter是不可为空的类型，所以我们在onClick()方法中也就不再需要进行判空处理，直接调用adapter的任何方法就可以了。</p><p>当然，使用lateinit关键字也不是没有任何风险，如果我们在adapter变量还没有初始化的情况下就直接使用它，那么程序就一定会崩溃，并且抛出一个UninitializedPropertyAccessException异常。</p><p>我们还可以通过代码来判断一个全局变量是否已经完成了初始化，这样在某些时候能够有效地避免重复对某一个变量进行初始化操作，示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!::adapter.isInitialized)&#123;</span><br><span class="line">    adapter = MsgAdapter(msgList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体语法就是这样，::adapter.isInitialized可用于判断adapter变量是否已经初始化。</p><h3 id="2-2-使用密封类优化代码"><a href="#2-2-使用密封类优化代码" class="headerlink" title="2.2 使用密封类优化代码"></a>2.2 使用密封类优化代码</h3><p>首先来了解一下密封类具体的作用，这里我们来看一个简单的例子。新建一个Kotlin文件，文件名就叫Result.kt好了，然后在这个文件中编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> msg: String) : Result</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(<span class="keyword">val</span> error: Exception) : Result</span><br></pre></td></tr></table></figure><p>这里定义了一个Result接口，用于表示某个操作的执行结果，接口中不用编写任何内容。然后定义了两个类去实现Result接口：一个Success类用于表示成功时的结果，一个Failure类用于表示失败时的结果，这样就把准备工作做好了。</p><p>接下来再定义一个getResultMsg()方法，用于获取最终执行结果的信息，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span>(result)&#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; result.msg</span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; result.error.message</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中接收一个Result参数。我们通过when语句来判断：如果Result属于Success，那么就返回成功的消息；如果Result属于Failure，那么就返回错误信息。到目前为止，代码都是没有问题的，但比较让人讨厌的是，接下来我们不得不再编写一个else条件，否则Kotlin编译器会认为这里缺少条件分支，代码将无法编译通过。但实际上Result的执行结果只可能是Success或者Failure，这个else条件是永远走不到的，所以我们在这里直接抛出了一个异常，只是为了满足Kotlin编译器的语法检查而已。</p><p>另外，编写else条件还有一个潜在的风险。如果我们现在新增了一个Unknown类并实现Result接口，用于表示未知的执行结果，但是忘记在getResultMsg()方法中添加相应的条件分支，编译器在这种情况下是不会提醒我们的，而是会在运行的时候进入else条件里面，从而抛出异常并导致程序崩溃。</p><p>当然，这种为了满足编译器的要求而编写无用条件分支的情况不仅在Kotlin当中存在，在Java或者是其他编程语言当中也普遍存在。</p><p>不过好消息是，Kotlin的密封类可以很好地解决这个问题，下面我们就来学习一下。密封类的关键字是sealed class，它的用法同样非常简单，我们可以轻松地将Result接口改造成密封类的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> msg: String) : Result</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(<span class="keyword">val</span> error: Exception) : Result</span><br></pre></td></tr></table></figure><p>可以看到，代码并没有什么太大的变化，只是将interface关键字改成了sealed class。另外，由于密封类是一个可继承的类，因此在继承它的时候需要在后面加上一对括号.</p><p>那么改成密封类之后有什么好处呢？你会发现现在getResultMsg()方法中的else条件已经不再需要了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResultMsg</span><span class="params">(result: <span class="type">Result</span>)</span></span> = <span class="keyword">when</span>(result)&#123;</span><br><span class="line">    <span class="keyword">is</span> Success -&gt; result.msg</span><br><span class="line">    <span class="keyword">is</span> Failure -&gt; result.error.message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这里去掉了else条件仍然能编译通过呢？这是因为当在when语句中传入一个密封类变量作为条件时，Kotlin编译器会自动检查该密封类有哪些子类，并强制要求你将每一个子类所对应的条件全部处理。这样就可以保证，即使没有编写else条件，也不可能会出现漏写条件分支的情况。而如果我们现在新增一个Unknown类，并也让它继承自Result，此时getResultMsg()方法就一定会报错，必须增加一个Unknown的条件分支才能让代码编译通过。</p><p>这就是密封类主要的作用和使用方法了。另外再多说一句，密封类及其所有子类只能定义在同一个文件的顶层位置，不能嵌套在其他类中，这是被密封类底层的实现机制所限制的。</p><p>了解完理论知识，接下来尝试结合 MsgAdapter中的ViewHolder一起使用顺便优化下MsgAdapter中的代码。</p><p>观看MsgAdapter现在的代码，你会发现onBindViewHolder()方法中就存在一个没有实际作用的else条件，只是抛出了一个异常而已。对于这部分代码，我们就可以借助密封类的特性来进行优化。首先删除MsgAdapter中的LeftViewHolder和RightViewHolder，然后新建一个MsgViewHolder.kt文件，在其中加入如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/7-14:46</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">MsgViewHolder</span>(view: View) : RecyclerView.ViewHolder(view)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeftViewHolder</span>(view: View) : MsgViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> leftMsg: TextView = view.findViewById(R.id.leftMsg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RightViewHolder</span>(view: View) : MsgViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> rightMsg: TextView = view.findViewById(R.id.rightMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们定义了一个密封类MsgViewHolder，并让它继承自RecyclerView.ViewHolder，然后让LeftViewHolder和RightViewHolder继承自MsgViewHolder。这样就相当于密封类MsgViewHolder只有两个已知子类，因此在when语句中只要处理这两种情况的条件分支即可。</p><p>现在修改MsgAdapter中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/2-14:34</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;MsgViewHolder&gt;() <span class="comment">/*RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;()*/</span> &#123;</span><br><span class="line">    <span class="comment">/*inner class LeftViewHolder(view: View) : RecyclerView.ViewHolder(view) &#123;</span></span><br><span class="line"><span class="comment">        val leftMsg: TextView = view.findViewById(R.id.leftMsg)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    inner class RightViewHolder(view: View) : RecyclerView.ViewHolder(view) &#123;</span></span><br><span class="line"><span class="comment">        val rightMsg: TextView = view.findViewById(R.id.rightMsg)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">return</span>  msg.type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: MsgViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (viewType == Msg.TYPE_RECEIVED)&#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_left_item,parent,<span class="literal">false</span>)</span><br><span class="line">            LeftViewHolder(view)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_right_item,parent,<span class="literal">false</span>)</span><br><span class="line">            RightViewHolder(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msgList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">MsgViewHolder</span> <span class="comment">/*RecyclerView.ViewHolder*/</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">when</span>(holder)&#123;</span><br><span class="line">            <span class="keyword">is</span> LeftViewHolder -&gt; holder.leftMsg.text = msg.content</span><br><span class="line">            <span class="keyword">is</span> RightViewHolder -&gt; holder.rightMsg.text = msg.content</span><br><span class="line">            <span class="comment">//else -&gt; throw IllegalArgumentException()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将RecyclerView.Adapter的泛型指定成刚刚定义的密封类MsgViewHolder，这样onBindViewHolder()方法传入的参数就变成了MsgViewHolder。然后我们只要在when语句当中处理LeftViewHolder和RightViewHolder这两种情况就可以了，那个讨厌的else终于不再需要了，这种RecyclerView适配器的写法更加规范也更加推荐。</p><hr><h2 id="三、扩展函数和运算符重载"><a href="#三、扩展函数和运算符重载" class="headerlink" title="三、扩展函数和运算符重载"></a>三、扩展函数和运算符重载</h2><h3 id="3-1-大有用途的扩展函数"><a href="#3-1-大有用途的扩展函数" class="headerlink" title="3.1 大有用途的扩展函数"></a>3.1 大有用途的扩展函数</h3><p>不少现代高级编程语言中有扩展函数这个概念，Java却一直以来都不支持这个非常有用的功能，这多少会让人有些遗憾。但值得高兴的是，Kotlin对扩展函数进行了很好的支持，因此这个知识点是我们无论如何都不能错过的。</p><p>首先看一下什么是扩展函数。扩展函数表示即使在不修改某个类的源码的情况下，仍然可以打开这个类，向该类添加新的函数。</p><p>为了帮助你更好地理解，我们先来思考一个功能。一段字符串中可能包含字母、数字和特殊符号等字符，现在我们希望统计字符串中字母的数量，你要怎么实现这个功能呢？如果按照一般的编程思维，可能大多数人会很自然地写出如下函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!123&quot;</span></span><br><span class="line">    <span class="keyword">val</span> count = StringUtil.lettersCount(str)</span><br><span class="line">    println(<span class="string">&quot;string is: <span class="variable">$str</span>, letterCount is : <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> StringUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lettersCount</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (char.isLetter()) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先定义了一个StringUtil单例类，然后在这个单例类中定义了一个lettersCount()函数，该函数接收一个字符串参数。在lettersCount()方法中，我们使用for-in循环去遍历字符串中的每一个字符。如果该字符是一个字母的话，那么就将计数器加1，最终返回计数器的值。</p><p>这种写法绝对可以正常工作，并且这也是Java编程中最标准的实现思维。但是有了扩展函数之后就不一样了，我们可以使用一种更加面向对象的思维来实现这个功能，比如说将lettersCount()函数添加到String类当中。</p><p>下面我们先来学习一下定义扩展函数的语法结构，其实非常简单，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于定义一个普通的函数，定义扩展函数只需要在函数名的前面加上一个ClassName.的语法结构，就表示将该函数添加到指定类当中了。</p><p>了解了定义扩展函数的语法结构，接下来我们就尝试使用扩展函数的方式来优化刚才的统计功<br>能。</p><p>由于我们希望向String类中添加一个扩展函数，因此需要先创建一个String.kt文件。文件名虽然并没有固定的要求，但是我建议向哪个类中添加扩展函数，就定义一个同名的Kotlin文件，这样便于你以后查找。当然，扩展函数也是可以定义在任何一个现有类当中的，并不一定非要创建新文件。不过通常来说，最好将它定义成顶层方法，这样可以让扩展函数拥有全局的访问域。</p><p>现在我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!123&quot;</span></span><br><span class="line">    println(<span class="string">&quot;string is: <span class="variable">$str</span>, letterCount is : <span class="subst">$&#123;str.lettersCount()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lettersCount</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (char <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (char.isLetter())&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，现在我们将lettersCount()方法定义成了String类的扩展函数，那么函数中就自动拥有了String实例的上下文。因此lettersCount()函数就不再需要接收一个字符串参数了，而是直接遍历this即可，因为现在this就代表着字符串本身。</p><p>定义好了扩展函数之后，统计某个字符串中的字母数量只需要这样写即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;Hello World!123&quot;</span></span><br><span class="line"><span class="keyword">val</span> count = str.lettersCount()</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="string">&quot;hello world!123&quot;</span>.lettersCount()</span><br></pre></td></tr></table></figure><p>是不是很神奇？看上去就好像是String类中自带了lettersCount()方法一样。扩展函数在很多情况下可以让API变得更加简洁、丰富，更加面向对象。我们再次以String类为例，这是一个final类，任何一个类都不可以继承它，也就是说它的API只有固定的那些而已，至少在Java中就是如此。然而到了Kotlin中就不一样了，我们可以向String类中扩展任何函数，使它的API变得更加丰富。比如，你会发现Kotlin中的String甚至还有reverse()函数用于反转字符串，capitalize()函数用于对首字母进行大写，等等，这都是Kotlin语言自带的一些扩展函数。这个特性使我们的编程工作可以变得更加简便。</p><h3 id="3-2-有趣的运算符重载"><a href="#3-2-有趣的运算符重载" class="headerlink" title="3.2 有趣的运算符重载"></a>3.2 有趣的运算符重载</h3><p>运算符重载是Kotlin提供的一个比较有趣的语法糖。我们知道，Java中有许多语言内置的运算符关键字，如<code>+ - * / % ++ --</code>。而Kotlin允许我们将所有的运算符甚至其他的关键字进行重载，从而拓展这些运算符和关键字的用法。</p><p>我们先来回顾一下运算符的基本用法。相信每个人都使用过加减乘除这种四则运算符。在编程语言里面，两个数字相加表示求这两个数字之和，两个字符串相加表示对这两个字符串进行拼接，这种基本用法相信接触过编程的人都明白。但是Kotlin的运算符重载却允许我们让任意两个对象进行相加，或者是进行更多其他的运算操作。</p><p>当然，虽然Kotlin赋予了我们这种能力，在实际编程的时候也要考虑逻辑的合理性。比如说，让两个Student对象相加好像并没有什么意义，但是让两个Money对象相加就变得有意义了，因为钱是可以相加的。</p><p>那么接下来，我们首先学习一下运算符重载的基本语法，然后再来实现让两个Money对象相加的功能。</p><p>运算符重载使用的是operator关键字，只要在指定函数的前面加上operator关键字，就可以实现运算符重载的功能了。但问题在于这个指定函数是什么？这是运算符重载里面比较复杂的一个问题，因为不同的运算符对应的重载函数也是不同的。比如说加号运算符对应的是plus()函数，减号运算符对应的是minus()函数。</p><p>这里还是以加号运算符为例，如果想要实现让两个对象相加的功能，那么它的语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(obj: <span class="type">Obj</span>)</span></span>: Obj &#123;</span><br><span class="line">    <span class="comment">// 处理相加的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述语法结构中，关键字operator和函数名plus都是固定不变的，而接收的参数和函数返回值可以根据你的逻辑自行设定。那么上述代码就表示一个Obj对象可以与另一个Obj对象相加，最终返回一个新的Obj对象。对应的调用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> obj1 = Obj()</span><br><span class="line"><span class="keyword">val</span> obj2 = Obj()</span><br><span class="line"><span class="keyword">val</span> obj3 = obj1 + obj2</span><br></pre></td></tr></table></figure><p>这种obj1 + obj2的语法看上去好像很神奇，但其实这就是Kotlin给我们提供的一种语法糖，它会在编译的时候被转换成obj1.plus(obj2)的调用方式。</p><p>了解了运算符重载的基本语法之后，下面我们开始实现一个更加有意义功能：让两个Money对象相加。</p><p>首先定义Money类的结构，这里我准备让Money的主构造函数接收一个value参数，用于表示钱的金额。创建Money.kt文件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里使用了operator关键字来修饰plus()函数，这是必不可少的。在plus()函数中，我们将当前Money对象的value和参数传入的Money对象的value相加，然后将得到的和传给一个新的Money对象并将该对象返回。这样两个Money对象就可以相加了，就是这么简单。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> money1 = Money(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> money2 = Money(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> money = money1 + money2</span><br><span class="line">    println(<span class="string">&quot;Money(6) + Money(7) is <span class="subst">$&#123;money.value&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，Money对象只允许和另一个Money对象相加，有没有觉得这样不够方便呢？或许你会觉得，如果Money对象能够直接和数字相加的话，就更好了。这个功能当然也是可以实现的，因为Kotlin允许我们对同一个运算符进行多重重载，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span>  money1 = Money(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span>  money2 = Money(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> money = money1 + money2</span><br><span class="line">    println(<span class="string">&quot;Money(6) + Money(7) is <span class="subst">$&#123;money.value&#125;</span>. Money(6) + 6 is <span class="subst">$&#123;(money1 + <span class="number">6</span>).value&#125;</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money.value</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Int</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + money</span><br><span class="line">        <span class="keyword">return</span> Money(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们还可以对这个例子进一步扩展，比如加上汇率转换的功能。让1人民币的Money对象和1美元的Money对象相加，然后根据实时汇率进行转换，从而返回一个新的Money对象。这类功能都是非常有趣的，运算符重载如果运用得好的话，可以玩出很多花样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span>  rmb = Money(<span class="number">7.0</span>,<span class="string">&quot;¥&quot;</span>,<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">val</span>  dollar = Money(<span class="number">6.0</span>,<span class="string">&quot;$&quot;</span>,<span class="number">7.1264772</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,dollar,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,dollar,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,rmb,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(dollar,rmb,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,dollar,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,dollar,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,rmb,<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    Money.printMoneyOperation(rmb,rmb,<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Dollar(6.0) + RMB(7.0) is <span class="subst">$&#123;(Dollar(<span class="number">6.0</span>) + RMB(<span class="number">7.0</span>)).value&#125;</span><span class="subst">$&#123;(Dollar(<span class="number">6.0</span>) + RMB(<span class="number">7.0</span>)).getCurrency()&#125;</span>.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;RMB(7.0) + Dollar(6.0) is <span class="subst">$&#123;(RMB(<span class="number">7.0</span>) + Dollar(<span class="number">6.0</span>)).value&#125;</span><span class="subst">$&#123;(RMB(<span class="number">7.0</span>) + Dollar(<span class="number">6.0</span>)).getCurrency()&#125;</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>, <span class="keyword">val</span> currency: String, <span class="keyword">val</span> exchangeRate: <span class="built_in">Double</span> = <span class="number">1.0</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> convertedValue = money.value * (money.exchangeRate / <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.value + convertedValue, <span class="keyword">this</span>.currency, <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line">        <span class="keyword">val</span> convertedValue = money.value * (money.exchangeRate / <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">        <span class="keyword">return</span> Money(<span class="keyword">this</span>.value - convertedValue, <span class="keyword">this</span>.currency, <span class="keyword">this</span>.exchangeRate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">printMoneyOperation</span><span class="params">(money1: <span class="type">Money</span>, money2: <span class="type">Money</span>, operation: <span class="type">String</span>)</span></span>: Money &#123;</span><br><span class="line">            <span class="keyword">val</span> result = <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">                <span class="string">&quot;+&quot;</span> -&gt; money1 + money2</span><br><span class="line">                <span class="string">&quot;-&quot;</span> -&gt; money1 - money2</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unsupported operation: <span class="variable">$operation</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;money1.value&#125;</span><span class="subst">$&#123;money1.currency&#125;</span> <span class="variable">$operation</span> <span class="subst">$&#123;money2.value&#125;</span><span class="subst">$&#123;money2.currency&#125;</span> is <span class="subst">$&#123;result.value&#125;</span><span class="subst">$&#123;result.currency&#125;</span>.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RMB</span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: RMB &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + (dollar.value * <span class="number">7.1264772</span>)</span><br><span class="line">        <span class="keyword">return</span> RMB(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(rmb: <span class="type">RMB</span>)</span></span>: RMB &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + rmb.value</span><br><span class="line">        <span class="keyword">return</span> RMB(sum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrency</span><span class="params">()</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dollar</span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(rmb: <span class="type">RMB</span>)</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + (rmb.value * <span class="number">0.140322</span>)</span><br><span class="line">        <span class="keyword">return</span> Dollar(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(dollar: <span class="type">Dollar</span>)</span></span>: Dollar &#123;</span><br><span class="line">        <span class="keyword">val</span> sum = value + dollar.value</span><br><span class="line">        <span class="keyword">return</span> Dollar(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrency</span><span class="params">()</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;$&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上述代码，我们就使用运算符重载实现了对Money类的加减运算并且加上了汇率转换。</p><p>实际上Kotlin允许我们重载的运算符和关键字多达十几个。，因此下表列出了所有常用的可重载运算符和关键字对应的语法糖表达式，以及它们会被转换成的实际调用函数。如果你想重载其中某一种运算符或关键字，只要参考刚才加号运算符重载的写法去实现就可以了。</p><table><thead><tr><th align="center">语法糖表达式</th><th align="center">实际调用函数</th></tr></thead><tbody><tr><td align="center">a + b</td><td align="center">a.plus(b)</td></tr><tr><td align="center">a - b</td><td align="center">a.minus(b)</td></tr><tr><td align="center">a * b</td><td align="center">a.times(b)</td></tr><tr><td align="center">a &#x2F; b</td><td align="center">a.div(b)</td></tr><tr><td align="center">a % b</td><td align="center">a.rem(b)</td></tr><tr><td align="center">a++</td><td align="center">a.ic()</td></tr><tr><td align="center">a–</td><td align="center">a.dec()</td></tr><tr><td align="center">+a</td><td align="center">a.unaryPlus()</td></tr><tr><td align="center">-a</td><td align="center">a.unaryMinus()</td></tr><tr><td align="center">!a</td><td align="center">a.not()</td></tr><tr><td align="center">a &#x3D;&#x3D; b</td><td align="center">a.equals(b)</td></tr><tr><td align="center">a &gt; b</td><td align="center">a.equals(b)</td></tr><tr><td align="center">a &lt; b</td><td align="center">a.equals(b)</td></tr><tr><td align="center">a &gt;&#x3D; b</td><td align="center">a.equals(b)</td></tr><tr><td align="center">a &lt;&#x3D; b</td><td align="center">a.compareTo(b)</td></tr><tr><td align="center">a..b</td><td align="center">a.rangeTo(b)</td></tr><tr><td align="center">a[b]</td><td align="center">a.get(b)</td></tr><tr><td align="center">a[b] &#x3D; c</td><td align="center">a.set(b, c)</td></tr><tr><td align="center">a in b</td><td align="center">b.contains(b)</td></tr></tbody></table><p>最后一个a in b的语法糖表达式对应的实际调用函数是b.contains(a)，a、b对象的顺序是反过来的。这在语义上很好理解，因为a in b表示判断a是否在b当中，而b.contains(a)表示判断b是否包含a，因此这两种表达方式是等价的。</p><p>例如我们判断 hello中是否包含 he，我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.contains(<span class="string">&quot;he&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;he&quot;</span> <span class="keyword">in</span> <span class="string">&quot;hello&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个写法的效果其实是一致的。</p><p>实践一下，假如我们有一个用于生成随机字符串长度的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> n = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    repeat(n) &#123;</span><br><span class="line">        builder.append(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的核心思想就是将传入的字符串重复n次，如果我们能够使用str * n这种写法来表示让str字符串重复n次，这种语法体验就非常通俗易懂了，而在Kotlin中这又是很容易实现的。</p><p>要让一个字符串可以乘以一个数字，那么肯定要在String类中重载乘号运算符才行，但是String类是系统提供的类，我们无法修改这个类的代码。这个时候就可以借助扩展函数功能向String类中添加新函数了。</p><p>这个时候我们加入代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    repeat(n)&#123;</span><br><span class="line">        builder.append(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该不难理解，这里只讲几个关键的点。首先，operator关键字肯定是必不可少的；然后既然是要重载乘号运算符，参考上表可知，函数名必须是times；最后，由于是定义扩展函数，因此还要在方向名前面加上String.的语法结构。</p><p>另外，必须说明的是，其实Kotlin的String类中已经提供了一个用于将字符串重复n遍的repeat()函数，因此times()函数还可以进一步精简成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">return</span> repeat(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n: <span class="type">Int</span>)</span></span> = repeat(n)</span><br></pre></td></tr></table></figure><hr><h2 id="四、高阶函数详解"><a href="#四、高阶函数详解" class="headerlink" title="四、高阶函数详解"></a>四、高阶函数详解</h2><h3 id="4-1-定义高阶函数"><a href="#4-1-定义高阶函数" class="headerlink" title="4.1 定义高阶函数"></a>4.1 定义高阶函数</h3><p>高阶函数和Lambda的关系是密不可分的。之前几章掌握了一些与集合相关的函数式API的用法，如map、filter函数等。另外，我们之前还学习了Kotlin的标准函数，如run、apply函数等。</p><p>这几个函数有一个共同的特点：它们都会要求我们传入一个Lambda表达式作为参数。像这种接收Lambda参数的函数就可以称为具有函数式编程风格的API，而如果你想要定义自己的函数式API，那就得借助高阶函数来实现了</p><p>首先来看一下高阶函数的定义：<strong>如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数，那么该函数就称为高阶函数。</strong></p><p>一个函数怎么能接收另一个函数作为参数呢？这就涉及另外一个概念了：函数类型。我们知道，编程语言中有整型、布尔型等字段类型，而Kotlin又增加了一个函数类型的概念。如果我们将这种函数类型添加到一个函数的参数声明或者返回值声明当中，那么这就是一个高阶函数了。</p><p>接下来学习一下如何定义一个函数类型。不同于定义一个普通的字段类型，函数类型的语法规则是有点特殊的，基本规则如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String, <span class="built_in">Int</span>)-&gt; <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure><p>看到这个语法规则是不是很懵？不用着急，给大家解释一下：既然是定义一个函数类型，那么最关键的就是要声明该函数接收什么参数，以及它的返回值是什么。因此，-&gt;左边的部分就是用来声明该函数接收什么参数的，多个参数之间使用逗号隔开，如果不接收任何参数，写一对空括号就可以了。而-&gt;右边的部分用于声明该函数的返回值是什么类型，如果没有返回值就使用Unit，它大致相当于Java中的void。</p><p>现在将上述函数类型添加到某个函数的参数声明或者返回值声明上，那么这个函数就是一个高阶函数了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(func: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    func(<span class="string">&quot;hello&quot;</span>, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的example()函数接收了一个函数类型的参数，因此example()函数就是一个高阶函数。而调用一个函数类型的参数，它的语法类似于调用一个普通的函数，只需要在参数名的后面加上一对括号，并在括号中传入必要的参数即可。</p><p>现在已经了解了高阶函数的定义方式，但是这种函数具体有什么用途呢？由于高阶函数的用途实在是太广泛了，这里如果要简单概括一下的话，那就是高阶函数允许让函数类型的参数来决定函数的执行逻辑。即使是同一个高阶函数，只要传入不同的函数类型参数，那么它的执行逻辑和最终的返回结果就可能是完全不同的。为了详细说明这一点，下面我们来举一个具体的例子。</p><p>这里我准备定义一个叫作num1AndNum2()的高阶函数，并让它接收两个整型和一个函数类型的参数。我们会在num1AndNum2()函数中对传入的两个整型参数进行某种运算，并返回最终的运算结果，但是具体进行什么运算是由传入的函数类型参数决定的。</p><p>新建一个HigherOrderFunction.kt文件，然后在这个文件中编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两个函数，并且这两个函数的参数声明和返回值声明都和num1AndNum2()函数中的函数类型参数是完全匹配的。其中，plus()函数将两个参数相加并返回，minus()函数将两个参数相减并返回，分别对应了两种不同的运算操作。有了上述函数之后，我们就可以调用num1AndNum2()函数了，在main()函数中编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result1 = num1AndNum2(num1, num2, ::plus)</span><br><span class="line">    <span class="keyword">val</span> result2 = num1AndNum2(num1, num2, ::minus)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里调用num1AndNum2()函数的方式，第三个参数使用了::plus和::minus这种写法。这是一种函数引用方式的写法，表示将plus()和minus()函数作为参数传递给num1AndNum2()函数。而由于num1AndNum2()函数中使用了传入的函数类型参数来决定具体的运算逻辑，因此这里实际上就是分别使用了plus()和minus()函数来对两个数字进行运算。</p><p>使用这种函数引用的写法虽然能够正常工作，但是如果每次调用任何高阶函数的时候都还得先定义一个与其函数类型参数相匹配的函数，这是不是有些太复杂了？没错，因此Kotlin还支持其他多种方式来调用高阶函数，比如Lambda表达式、匿名函数、成员引用等。其中，Lambda表达式是最常见也是最普遍的高阶函数调用方式，接下来要重点使用lambda表达式进行调用。</p><p>上述代码如果使用Lambda表达式的写法来实现的话，代码如下所示：</p><blockquote><p>⭐注意：</p><p>在 Kotlin 中，如果函数的最后一个参数是一个函数，那么我们可以在函数调用的括号外部传递这个函数。这就是为什么下面例子可以在 <code>num1AndNum2(num1, num2)</code> 后面直接写 <code>&#123;n1, n2 -&gt; n1 % n2&#125;</code>，而不需要把它放在括号里。</p><p>这种语法叫做<strong>尾随 lambda</strong>，它可以让你的代码更加简洁和易读。当你的 lambda 表达式比较长或者包含多行代码时，尾随 lambda 就显得特别有用。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HighOrderFunction</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result1 = num1AndNum2(num1, num2, ::plus)</span><br><span class="line">    <span class="keyword">val</span> result2 = num1AndNum2(num1, num2, ::minus)</span><br><span class="line">    <span class="keyword">val</span> result3 = num1AndNum2(num1, num2) &#123;n1, n2 -&gt;</span><br><span class="line">        n1 % n2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result4 = num1AndNum2(num1, num2) &#123;n1, n2 -&gt;</span><br><span class="line">        n1 * n2</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result3</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result is <span class="variable">$result4</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⭐</p><p>在 Kotlin 中，还可以使用 lambda 表达式来定义一个匿名函数。lambda 表达式的语法格式是 <code>&#123; 参数列表 -&gt; 函数体 &#125;</code>。</p><p>在上面例子中，<code>n1, n2 -&gt; n1 % n2</code> 就是一个 lambda 表达式。它接受两个参数 <code>n1</code> 和 <code>n2</code>，并返回它们的余数。这个 lambda 表达式定义了一个函数，这个函数的功能是计算两个数的余数。</p><p>当我们把这个 lambda 表达式作为参数传递给 <code>num1AndNum2</code> 函数时，<code>num1AndNum2</code> 函数会在内部调用这个 lambda 表达式，就像调用一个普通的函数一样。</p><p>所以，我们可以直接写 <code>n1, n2 -&gt; n1 % n2</code>，因为它就是一个函数，只不过这个函数没有名字，我们称之为匿名函数或者 lambda 函数。</p></blockquote><p>下面我们继续对高阶函数进行探究。回顾之前学习的apply函数，它可以用于给Lambda表达式提供一个指定的上下文，当需要连续调用同一个对象的多个方法时，apply函数可以让代码变得更加精简，比如StringBuilder就是一个典型的例子。接下来我们就使用高阶函数模仿实现一个类似的功能。</p><p>首先我们给StringBuilder加上一个build扩展函数：这个扩展函数接收一个函数类型参数，并且返回值类型也是StringBuilder。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">build</span><span class="params">(block: <span class="type">StringBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span>: StringBuilder&#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⭐注意：</p><p>上述代码使用了 Kotlin 的<strong>扩展函数</strong>和<strong>带接收者的 lambda</strong>。</p><p>首先，<code>StringBuilder.build</code> 是一个扩展函数，它为 <code>StringBuilder</code> 类添加了一个新的方法。这个方法接受一个带接收者的 lambda 作为参数，然后在 <code>StringBuilder</code> 的实例上执行这个 lambda。</p><p>带接收者的 lambda 是一种特殊的 lambda，它的语法格式是 <code>接收者类型.() -&gt; 返回类型</code>。在上述代码中，<code>StringBuilder.() -&gt; Unit</code> 就是一个带接收者的 lambda。这个 lambda 可以在 <code>StringBuilder</code> 的实例上调用方法，就像在 <code>StringBuilder</code> 的内部一样。</p><p>当我们调用 <code>StringBuilder().build</code> 时，可以传递一个带接收者的 lambda。在这个 lambda 中，可以直接调用 <code>StringBuilder</code> 的方法，例如 <code>append</code>。</p></blockquote><p>注意，这个函数类型参数的声明方式和我们前面num1AndNum2的语法有所不同：它在函数类型的前面加上了一StringBuilder. 的语法结构。这是什么意思呢？其实这才是定义高阶函数完整的语法规则，在函数类型的前面加ClassName. 就表示这个函数类型是定义在哪个类当中的。这里将函数类型定义到StringBuilder类当中，那这样有什么好处呢？好处就是当我们调用build函数时传入的Lambda表达式将会自动拥有StringBuilder的上下文，也就是说我们可以直接调用StringBuilder里面的函数，同时这也是apply函数的实现方式。</p><p>接下来尝试调用这个方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> word = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder().build&#123;</span><br><span class="line">        append(<span class="string">&quot;start eating fruits.\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit <span class="keyword">in</span> word)&#123;</span><br><span class="line">            append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;ate all fruits.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 lambda 表达式中：</p><ul><li><code>StringBuilder.</code> 是接收者类型。这意味着这个 lambda 可以在 <code>StringBuilder</code> 的实例上调用方法，就像在 <code>StringBuilder</code> 的内部一样。这就是为什么可以直接调用 <code>append</code> 方法。</li><li><code>()</code> 表示这个 lambda 不接受任何参数。这就是为什么上述 lambda 表达式中没有参数列表。</li><li><code>-&gt; Unit</code> 是这个 lambda 的返回类型。但是，在实际的 lambda 表达式中，不需要写 <code>-&gt; Unit</code>。因为 Kotlin 可以根据代码自动推断出返回类型是 <code>Unit</code>。</li></ul><p>所以，虽然带接收者的 lambda 的类型声明是 <code>StringBuilder.() -&gt; Unit</code>，但在实际的 lambda 表达式中，只需要写函数体，不需要写 <code>-&gt; Unit</code>。</p><p>可以看到，build函数的用法和apply函数基本上是一模一样的，只不过我们编写的build函数目前只能作用在StringBuilder类上面，而apply函数是可以作用在所有类上面的。如果想实现apply函数的这个功能，需要借助于Kotlin的泛型才行</p><h3 id="4-2-内联函数的作用"><a href="#4-2-内联函数的作用" class="headerlink" title="4.2 内联函数的作用"></a>4.2 内联函数的作用</h3><p>为了接下来可以更好地理解内联函数这个知识点，这里简单分析一下高阶函数的实现原理。</p><p>这里使用刚刚编写的num1Andnum2()函数来举例，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result = num1AndNum2(num1, num2) &#123; n1, n2</span><br><span class="line">        n1 + n2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述代码中调用了num1AndNum2()函数，并通过Lambda表达式指定对传入的两个整型参数进行求和。这段代码在Kotlin中非常好理解，因为这是高阶函数最基本的用法。可是我们都知道，Kotlin的代码最终还是要编译成Java字节码的，但Java中并没有高阶函数的概念。</p><p>那么Kotlin究竟使用了什么魔法来让Java支持这种高阶函数的语法呢？这就要归功于Kotlin强大的编译器了。Kotlin的编译器会将这些高阶函数的语法转换成Java支持的语法结构，上述的Kotlin代码大致会被转换成如下Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num1Andnum2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, Function operation)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) operation.invoke(num1, num2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1Andnum2(num1, num2, <span class="keyword">new</span> <span class="title class_">Function</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">invoke</span><span class="params">(Integer n1, Integer n2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n1 + n2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到可读性，我对这段代码进行了些许调整，并不是严格对应了Kotlin转换成的Java代码。可以看到，在这里num1AndNum2()函数的第三个参数变成了一个Function接口，这是一种Kotlin内置的接口，里面有一个待实现的invoke()函数。而num1AndNum2()函数其实就是调用了Function接口的invoke()函数，并把num1和num2参数传了进去。</p><p>在调用num1AndNum2()函数的时候，之前的Lambda表达式在这里变成了Function接口的匿名类实现，然后在invoke()函数中实现了n1 + n2的逻辑，并将结果返回。</p><p>这就是Kotlin高阶函数背后的实现原理。你会发现，原来我们一直使用的Lambda表达式在底层被转换成了匿名类的实现方式。这就表明，我们每调用一次Lambda表达式，都会创建一个新的匿名类实例，当然也会造成额外的内存和性能开销。</p><p>为了解决这个问题，Kotlin提供了内联函数的功能，它可以将使用Lambda表达式带来的运行时开销完全消除。</p><p>内联函数的用法非常简单，只需要在定义高阶函数时加上inline关键字的声明即可，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> operation(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么内联函数的工作原理又是什么呢？其实并不复杂，就是Kotlin编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方，这样也就不存在运行时的开销了。</p><p>首先，Kotlin编译器会将Lambda表达式中的代码替换到函数类型参数调用的地方，如图所示。</p><p><img src="https://pic.ziyuan.wang/2023/11/25/xiheya_b3196f3ebad9a.png" alt="1700895120471.png"></p><p>接下来，再将内联函数中的全部代码替换到函数调用的地方，如图所示。</p><p><img src="https://pic.ziyuan.wang/2023/11/25/xiheya_b528a7d70d9a5.png" alt="1700895298709.png"></p><p>最后代码其实就变成了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> result3 = num1 % num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是如此，内联函数才能完全消除Lambda表达式所带来的运行时开销。</p><h3 id="4-3-noinline-与-crossinline"><a href="#4-3-noinline-与-crossinline" class="headerlink" title="4.3 noinline 与 crossinline"></a>4.3 noinline 与 crossinline</h3><p>接下来我们要讨论一些更加特殊的情况。比如，一个高阶函数中如果接收了两个或者更多函数类型的参数，这时我们给函数加上了inline关键字，那么Kotlin编译器会自动将所有引用的Lambda表达式全部进行内联。</p><p>但是，如果我们只想内联其中的一个Lambda表达式该怎么办呢？这时就可以使用noinline关键字了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">inlineTest</span><span class="params">(block1: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> block2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里使用inline关键字声明了inlineTest()函数，原本block1和block2这两个函数类型参数所引用的Lambda表达式都会被内联。但是我们在block2参数的前面又加上了一个noinline关键字，那么现在就只会对block1参数所引用的Lambda表达式进行内联了。这就是noinline关键字的作用。</p><p>前面我们已经解释了内联函数的好处，那么为什么Kotlin还要提供一个noinline关键字来排除内联功能呢？<strong>这是因为内联的函数类型参数在编译的时候会被进行代码替换，因此它没有真正的参数属性。非内联的函数类型参数可以自由地传递给其他任何函数，因为它就是一个真实的参数，而内联的函数类型参数只允许传递给另外一个内联函数，这也是它最大的局限性。</strong></p><p>另外，内联函数和非内联函数还有一个重要的区别，那就是内联函数所引用的Lambda表达式中是可以使用return关键字来进行函数返回的，而非内联函数只能进行局部返回。为了说明这个问题，我们来看下面的例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(str: <span class="type">String</span>, block: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;printString begin&quot;</span>)</span><br><span class="line">    block(str)</span><br><span class="line">    println(<span class="string">&quot;printString end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    printString(str) &#123;s -&gt;</span><br><span class="line">        println(<span class="string">&quot;lambda start&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span><span class="symbol">@printString</span></span><br><span class="line">        println(s)</span><br><span class="line">        println(<span class="string">&quot;lambda end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个叫作printString()的高阶函数，用于在Lambda表达式中打印传入的字符串参数。但是如果字符串参数为空，那么就不进行打印。注意，Lambda表达式中是不允许直接使用return关键字的，这里使用了return@printString的写法，表示进行局部返回，并且不再执行Lambda表达式的剩余部分代码。</p><p>现在我们就刚好传入一个空的字符串参数，运行程序，打印结果如图所示。</p><p><img src="https://pic.ziyuan.wang/2023/11/25/xiheya_5a0c911452403.png" alt="1700897776694.png"></p><p>可以看到，除了Lambda表达式中return@printString语句之后的代码没有打印，其他的日志是正常打印的，说明return@printString确实只能进行局部返回。</p><p>但是如果我们将printString()函数声明成一个内联函数，那么情况就不一样了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">printString</span><span class="params">(str: <span class="type">String</span>, block: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;printString begin&quot;</span>)</span><br><span class="line">    block(str)</span><br><span class="line">    println(<span class="string">&quot;printString end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    printString(str) &#123;s -&gt;</span><br><span class="line">        println(<span class="string">&quot;lambda start&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span></span><br><span class="line">        println(s)</span><br><span class="line">        println(<span class="string">&quot;lambda end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在printString()函数变成了内联函数，我们就可以在Lambda表达式中使用return关键字了。此时的return代表的是返回外层的调用函数，也就是main()函数，如果想不通为什么的话，可以回顾一下之前讲的内联函数的代码替换过程。</p><p>打印结果如下：</p><p><img src="https://pic.ziyuan.wang/2023/11/25/xiheya_eaeb52005d73e.png" alt="1700897878240.png"></p><p>可以看到，不管是main()函数还是printString()函数，确实都在return关键字之后停止执行了，和我们所预期的结果一致。</p><p>将高阶函数声明成内联函数是一种良好的编程习惯，事实上，绝大多数高阶函数是可以直接声明成内联函数的，但是也有少部分例外的情况。观察下面的代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    runnable.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在没有加上inline关键字声明的时候绝对是可以正常工作的，但是在加上inline关键字之后就会提示如图所示的错误。</p><p><img src="https://pic.ziyuan.wang/2023/11/25/xiheya_5551909e6c42e.png" alt="1700898102099.png"></p><p>首先，在runRunnable()函数中，我们创建了一个Runnable对象，并在Runnable的Lambda表达式中调用了传入的函数类型参数。而Lambda表达式在编译的时候会被转换成匿名类的实现方式，也就是说，上述代码实际上是在匿名类中调用了传入的函数类型参数。</p><p>而内联函数所引用的Lambda表达式允许使用return关键字进行函数返回，但是由于我们是在匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多只能对匿名类中的函数调用进行返回，因此这里就提示了上述错误。</p><p>也就是说，如果我们在高阶函数中创建了另外的Lambda或者匿名类的实现，并且在这些实现中调用函数类型参数，此时再将高阶函数声明成内联函数，就一定会提示错误。</p><p>那在这种情况下该如何使用内联函数呢？其实很简单，借助crossinline关键字就可以很好地解决这个问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">runRunnable</span><span class="params">(<span class="keyword">crossinline</span> block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    runnable.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个crossinline关键字又是什么呢？前面我们已经分析过，之所以会提示图示的错误，就是因为内联函数的Lambda表达式中允许使用return关键字，和高阶函数的匿名类实现中不允许使用return关键字之间造成了冲突。而crossinline关键字就像一个契约，它用于保证在内联函数的Lambda表达式中一定不会使用return关键字，这样冲突就不存在了，问题也就巧妙地解决了。</p><p>声明了crossinline之后，我们就无法在调用runRunnable函数时的Lambda表达式中使用return关键字进行函数返回了，但是仍然可以使用return@runRunnable的写法进行局部返回。总体来说，除了在return关键字的使用上有所区别之外，crossinline保留了内联函数的其他所有特性。</p><hr><h2 id="五、高阶函数的应用"><a href="#五、高阶函数的应用" class="headerlink" title="五、高阶函数的应用"></a>五、高阶函数的应用</h2><p>高阶函数非常适用于简化各种API的调用，一些API的原有用法在使用高阶函数简化之后，不管是在易用性还是可读性方面，都可能会有很大的提升。</p><h3 id="5-1-简化SharedPreferences的用法"><a href="#5-1-简化SharedPreferences的用法" class="headerlink" title="5.1 简化SharedPreferences的用法"></a>5.1 简化SharedPreferences的用法</h3><p>首先来看SharedPreferences的用法。向SharedPreferences中存储数据的过程大致可以分为以下3步：</p><ol><li>调用SharedPreferences的edit()方法获取SharedPreferences.Editor对象；</li><li>向SharedPreferences.Editor对象中添加数据；</li><li>调用apply()方法将添加的数据提交，完成数据存储操作。</li></ol><p>对应代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> editor = getSharePreferences(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE).edit()</span><br><span class="line">editor.putString(<span class="string">&quot;name&quot;</span>, Tom)</span><br><span class="line">editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">editor.putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">editor.apply()</span><br></pre></td></tr></table></figure><p>其实我们可以通过扩展函数的方式向SharedPreference类当中添加一个open函数，并且让他接收一个函数类型的参数，此时open函数就是一个高阶函数了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">open</span><span class="params">(block: <span class="type">SharedPreferences</span>.<span class="type">Editor</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> editor = edit()</span><br><span class="line">    editor.block()</span><br><span class="line">    editor.apply()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们通过扩展函数的方式向SharedPreferences类中添加了一个open函数，并且它还接收一个函数类型的参数，因此open函数自然就是一个高阶函数了。</p><blockquote><p>⭐注意：</p><p>上述代码使用了Kotlin中的<strong>扩展函数</strong>和 <strong>带接收者的lambda</strong></p><p>其中 我们为 <code>SharedPreference</code>类添加了一个新的方法—SharedPreference.open,这个方法接收一个 <strong>带接收者的lambda</strong>作为参数。在上述代码中: <code>SharedPreferences.Editor.() -&gt; Unit</code>是一个 <strong>带接收者的lambda</strong>。在这种 lambda 中，你可以直接调用接收者的方法，就像在接收者的内部一样。这个 lambda可以在 <code>SharedPreference.Editor</code>的实例上调用方法，当我们调用<code>SharedPreferences.open</code>时，可以传递一个带接收者的 lambda。在这个 lambda 中，你可以直接调用 <code>SharedPreferences.Editor</code> 的方法，例如<code>putString</code>。</p><p>📕解析：</p><ul><li><code>SharedPreferences.Editor.</code> 为接收者类型。这意味着这个 lambda 可以在 <code>SharedPreferences.Editor</code> 的实例上调用方法，就像在 <code>SharedPreferences.Editor</code> 的内部一样；</li><li><code>()</code> 表示这个 lambda 不接受任何参数；</li><li><code>-&gt; Unit</code> 表示这个 lambda 的返回类型是 <code>Unit</code>。<code>Unit</code> 在 Kotlin 中类似于 Java 中的 <code>void</code>，表示这个函数没有有意义的返回值。</li></ul></blockquote><p>由于<code>open</code>函数内拥有<code>SharedPreferences</code>的上下文，因此这里可以直接调用<code>edit()</code>方法来获取<code>SharedPreferences.Editor</code>对象。另外<code>open</code>函数接收的是一个<code>SharedPreferences.Editor</code>的函数类型参数，因此这里需要调用<code>editor.block()</code>对函数类型参数进行调用，我们就可以在函数类型参数的具体实现中添加数据了。最后还要调用<code>editor.apply()</code>方法来提交数据，从而完成数据存储操作。</p><p>定义好了open函数之后，我们以后在项目中使用SharedPreferences存储数据（Android）就会更加方便了，写法如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSharedPreferences(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE).<span class="keyword">open</span> &#123;</span><br><span class="line">    putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android中，其实Google提供的KTX扩展库中已经包含了上述SharedPreferences的简化用法，这个扩展库会在Android Studio创建项目的时候自动引入build.gradle的dependencies中。 <code>implementation &#39;androidx.core:core-ktx:版本号&#39;</code>。</p><p>因此，我们实际上可以直接在项目中使用如下写法来向<code>SharedPreferences</code>存储数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSharedPreferences(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE).edit &#123;</span><br><span class="line">    putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-简化ContentValues的用法"><a href="#5-2-简化ContentValues的用法" class="headerlink" title="5.2 简化ContentValues的用法"></a>5.2 简化ContentValues的用法</h3><p>ContentValues主要用于结合SQLiteDatabase的API存储和修改数据库中的数据，具体的用法示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = ContentValues()</span><br><span class="line">values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;剑来&quot;</span>)</span><br><span class="line">values.put(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;烽火戏诸侯&quot;</span>)</span><br><span class="line">values.put(<span class="string">&quot;pages&quot;</span>, <span class="number">60000</span>)</span><br><span class="line">values.put(<span class="string">&quot;price&quot;</span>, <span class="number">60.99</span>)</span><br><span class="line">db.insert(<span class="string">&quot;book&quot;</span>, <span class="literal">null</span>, valuse)</span><br></pre></td></tr></table></figure><p>这段代码可以使用<code>apply</code>函数进行简化。这当然没有错，只是我们其实还可以做到更好。不过在正式开始我们的简化之旅之前，我还得向你介绍一个额外的知识点。之前学过的<code>mapOf()</code>函数的用法。它允许我们使用<code>&quot;Apple&quot; to 1</code>这样的语法结构快速创建一个键值对。<strong>在Kotlin中使用A to B这样的语法结构会创建一个Pair对象。</strong></p><p>有了这个知识前提之后，就可以进行下一步了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cvOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;)</span></span>: ContentValues &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用是构建一个<code>ContentValues</code>对象。首先，<code>cvOf()</code>方法接收了一个<code>Pair</code>参数，也就是使用<code>A to B</code>语法结构创建出来的<strong>参数类型</strong>，但是我们在参数前面加上了一个<code>vararg</code>关键字，这是什么意思呢？其实<code>vararg</code>对应的就是Java中的可变参数列表，我们允许向这个方法传入0个、1个、2个甚至任意多个Pair类型的参数，这些参数都会被赋值到使用<code>vararg</code>声明的这一个变量上面，然后使用<code>for-in</code>循环可以将传入的所有参数遍历出来。</p><p>再来看声明的<code>Pair</code>类型。由于<code>Pair</code>是一种键值对的数据结构，因此需要通过泛型来指定它的键和值分别对应什么类型的数据。值得庆幸的是，<code>ContentValues</code>的所有键都是字符串类型的，这里可以直接将<code>Pair</code>键的泛型指定成<code>String</code>。但<code>ContentValues</code>的值却可以有多种类型（字符串型、整型、浮点型，甚至是null），所以我们需要将<code>Pair</code>值的泛型指定成<code>Any?</code>。这是因为<code>Any</code>是<code>Kotlin</code>中所有类的共同基类，相当于<code>Java</code>中的<code>Object</code>，而<code>Any?</code>则表示允许传入空值。</p><blockquote><p>vararg 关键字是用来表示一个函数的参数可以接受可变数量的值，也就是说，你可以传递任意个数的同类型的值给这个参数。例如，如果你定义了一个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(<span class="keyword">vararg</span> numbers: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> (n <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">     total += n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你可以用不同的方式调用这个函数，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 传递三个值</span></span><br><span class="line">sum(<span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 传递两个值</span></span><br><span class="line">sum() <span class="comment">// 不传递任何值</span></span><br><span class="line">sum(*arrayOf(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)) <span class="comment">// 传递一个数组，需要用 * 号展开</span></span><br></pre></td></tr></table></figure><p>vararg 关键字可以让你的函数更灵活，更方便地处理不确定数量的输入。</p><p>Pair 类是用来表示一对值的，它有两个属性：first 和 second，分别表示第一个值和第二个值。你可以用 Pair 类来存储或返回两个相关的值，而不需要创建一个新的类。例如，如果你想要返回一个函数的最大值和最小值，你可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minMax</span><span class="params">(numbers: <span class="type">IntArray</span>)</span></span>: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"> <span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line"> <span class="keyword">for</span> (n <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt; min) min = n</span><br><span class="line">     <span class="keyword">if</span> (n &gt; max) max = n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Pair(min, max) <span class="comment">// 返回一个 Pair 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以这样调用这个函数，并解构 Pair 对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (min, max) = minMax(intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 解构 Pair 对象，得到 min 和 max</span></span><br><span class="line">println(<span class="string">&quot;The minimum is <span class="variable">$min</span> and the maximum is <span class="variable">$max</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>Pair 类可以让你的代码更简洁，更易于阅读.</p></blockquote><p>接下来我们开始为<code>cvOf()</code>方法实现功能逻辑，核心思路就是先创建一个<code>ContentValues</code>对象，然后遍历<code>pairs</code>参数列表，取出其中的数据并填入<code>ContentValues</code>中，最终将<code>ContentValues</code>对象返回即可。思路并不复杂，但是存在一个问题：<code>Pair</code>参数的值是<code>Any?</code>类型的，我们怎样让它和<code>ContentValues</code>所支持的数据类型对应起来呢？这个确实没有什么好的办法，只能使用<code>when</code>语句一一进行条件判断，并覆盖<code>ContentValues</code>所支持的所有数据类型。结合下面的代码来理解应该更加清楚一些：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cvOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;)</span></span>: ContentValues &#123;</span><br><span class="line">    <span class="keyword">val</span> cv = ContentValues()</span><br><span class="line">    <span class="keyword">for</span> (pair <span class="keyword">in</span> pairs) &#123;</span><br><span class="line">        <span class="keyword">val</span> key = pair.first</span><br><span class="line">        <span class="keyword">val</span> value = pair.second</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> <span class="built_in">Int</span>, <span class="built_in">Long</span>, <span class="built_in">Short</span>, <span class="built_in">Float</span>, <span class="built_in">Double</span>, <span class="built_in">Boolean</span>, String, <span class="built_in">Byte</span>, ByteArray -&gt; cv.put(key, value)</span><br><span class="line">            <span class="keyword">else</span> -&gt; cv.putNull(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述代码基本就是按照刚才所说的思路进行实现的。我们使用<code>for-in</code>循环遍历了<code>pairs</code>参数列表，在循环中取出了<code>key</code>和<code>value</code>，并使用<code>when</code>语句来判断<code>value</code>的类型。注意，这里将<code>ContentValues</code>所支持的所有数据类型全部覆盖了进去，然后将参数中传入的键值对逐个添加到<code>ContentValues</code>中，最终将<code>ContentValues</code>返回。</p><p>另外，这里还使用了<code>Kotlin</code>中的<code>Smart Cast</code>功能。比如<code>when</code>语句进入<code>Int</code>条件分支后，这个条件下面的<code>value</code>会被自动转换成<code>Int</code>类型，而不再是<code>Any?</code>类型，这样我们就不需要像<code>Java</code>中那样再额外进行一次向下转型了，这个功能在<code>if</code>语句中也同样适用。</p><p>有了这个<code>cvOf()</code>方法之后，我们使用<code>ContentValues</code>时就会变得更加简单了，比如向数据库中插入一条数据就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = cvOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;剑来&quot;</span>, <span class="string">&quot;author&quot;</span> to <span class="string">&quot;烽火戏诸侯&quot;</span>, <span class="string">&quot;pages&quot;</span> to <span class="number">60000</span>, <span class="string">&quot;price&quot;</span> to <span class="number">60.99</span>)</span><br><span class="line">db.insert(<span class="string">&quot;book&quot;</span>, <span class="literal">null</span>, valuse)</span><br></pre></td></tr></table></figure><p>虽然<code>cvOf()</code>方法已经非常好用了，但是它和高阶函数却一点关系也没有。因为<code>cvOf()</code>方法接收的参数是Pair类型的可变参数列表，返回值是<code>ContentValues</code>对象，完全没有用到函数类型，这和高阶函数的定义不符。</p><p>从功能性方面，<code>cvOf()</code>方法好像确实用不到高阶函数的知识，但是从代码实现方面，却可以结合高阶函数来进行进一步的优化。比如借助<code>apply</code>函数，<code>cvOf()</code>方法的实现将会变得更加优雅：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ContentValues.<span class="title">cvOf</span><span class="params">(<span class="keyword">vararg</span> pairs: <span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;)</span></span> = apply &#123;</span><br><span class="line">    <span class="keyword">for</span> (pair <span class="keyword">in</span> pairs) &#123;</span><br><span class="line">        <span class="keyword">val</span> key = pair.first</span><br><span class="line">        <span class="keyword">val</span> value = pair.second</span><br><span class="line">        <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> <span class="built_in">Int</span>, <span class="built_in">Long</span>, <span class="built_in">Short</span>, <span class="built_in">Float</span>, <span class="built_in">Double</span>, <span class="built_in">Boolean</span>, String, <span class="built_in">Byte</span>, ByteArray -&gt; put(key, value)</span><br><span class="line">            <span class="keyword">else</span> -&gt; putNull(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>apply</code>函数的返回值就是它的调用对象本身，因此这里我们可以使用单行代码函数的语法糖，用等号替代返回值的声明。另外，<code>apply</code>函数的Lambda表达式中会自动拥有<code>ContentValues</code>的上下文，所以这里可以直接调用<code>ContentValues</code>的各种<code>put</code>方法。</p><p>其实KTX库中也提供了一个具有同样功能的contentValuesOf()方法，用法如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = contentValuesOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;剑来&quot;</span>, <span class="string">&quot;author&quot;</span> to <span class="string">&quot;烽火戏诸侯&quot;</span>, <span class="string">&quot;pages&quot;</span> to <span class="number">60000</span>, <span class="string">&quot;price&quot;</span> to <span class="number">60.99</span>)</span><br><span class="line">db.insert(<span class="string">&quot;book&quot;</span>, <span class="literal">null</span>, valuse)</span><br></pre></td></tr></table></figure><hr><h2 id="六、泛型和委托"><a href="#六、泛型和委托" class="headerlink" title="六、泛型和委托"></a>六、泛型和委托</h2><h3 id="6-1-泛型的基本用法"><a href="#6-1-泛型的基本用法" class="headerlink" title="6.1 泛型的基本用法"></a>6.1 泛型的基本用法</h3><p>准确来讲，泛型并不是什么新鲜的事物。Java早在1.5版本中就引入了泛型的机制，Kotlin自然也就支持了泛型功能。但是Kotlin中的泛型和Java中的泛型有同有异。</p><p>首先解释一下什么是泛型。在一般的编程模式下，我们需要给任何一个变量指定一个具体的类型，而<strong>泛型允许我们在不指定具体类型的情况下进行编程，这样编写出来的代码将会拥有更好的扩展性。</strong></p><p>举个栗子🌰：List是一个可以存放数据的列表，但是List并没有限制我们只能存放整型数据或字符串数据，<strong>因为它没有指定一个具体的类型，而是使用泛型来实现的</strong>。也正是如此，我们才可以使用<code>List&lt;Int&gt;</code>、<code>List&lt;String&gt;</code>之类的语法来构建具体类型的列表。</p><p>那么要怎样才能定义自己的泛型实现呢？这里先来学习一下基本的语法。</p><p>泛型主要有两种定义方式：<strong>一种是定义泛型类</strong>，<strong>另一种是定义泛型方法</strong>，使用的语法结构都是<code>&lt;T&gt;</code>。<strong>当然括号内的T并不是固定要求的，事实上你使用任何英文字母或单词都可以，但是通常情况下，T是一种约定俗成的泛型写法。</strong></p><p>如果我们要定义一个泛型类，就可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的MyClass就是一个泛型类，MyClass中的方法允许使用T类型的参数和返回值。</p><p>我们在调用MyClass类和method()方法的时候，就可以将泛型指定成具体的类型，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myClass = MyClass&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>这里我们将MyClass类的泛型指定成Int类型，于是<code>method()</code>方法就可以接收一个Int类型的参数，并且它的返回值也变成了Int类型。</p><p>而如果我们不想定义一个泛型类，只是想定义一个泛型方法，应该要怎么写呢？也很简单，只需要将定义泛型的语法结构写在方法上面就可以了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的调用方式也需要进行相应的调整：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myClass = MyClass()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method&lt;<span class="built_in">Int</span>&gt;(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>可以看到，现在是在调用method()方法的时候指定泛型类型了。另外，Kotlin还拥有非常出色的<strong>类型推导机制</strong>，例如<strong>我们传入了一个Int类型的参数，它能够自动推导出泛型的类型就是Int型</strong>，因此这里也可以直接省略泛型的指定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myClass = MyClass()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>Kotlin<strong>还允许我们对泛型的类型进行限制</strong>。目前你可以将<code>method()</code>方法的泛型指定成任意类型，但是如果这并不是你想要的话，还<strong>可以通过指定上界的方式来对泛型的类型进行约束</strong>，<strong>比如这里将<code>method()</code>方法的泛型上界设置为Number类型</strong>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Number&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法就表明，<strong>我们只能将method()方法的泛型指定成数字类型</strong>，比如<code>Int</code>、<code>Float</code>、<code>Double</code>等。但是<strong>如果你指定成字符串类型，就肯定会报错，因为它不是一个数字。</strong></p><p>另外，<strong>在默认情况下，所有的泛型都是可以指定成可空类型的</strong>，这是因为在<strong>不手动指定上界的时候</strong>，<strong>泛型的上界默认是<code>Any?</code><strong>。而如果</strong>想要让泛型的类型不可为空</strong>，只需要将泛型的<strong>上界</strong>手动<strong>指定成</strong><code>Any</code>就可以了。</p><p>之前高阶函数那节有编写一个 build函数代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> StringBuilder.<span class="title">build</span><span class="params">(block: <span class="type">StringBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span>: StringBuilder &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用和<code>apply</code>函数基本是一样的，只是<code>build</code>函数只能作用在<code>StringBuilder</code>类上面，而<code>apply</code>函数是可以作用在<strong>所有类</strong>上面的。现在我们就通过本小节所学的泛型知识对build函数进行扩展，让它实现和apply函数完全一样的功能。</p><p>思考一下，其实并不复杂，只需要使用<T>将build函数定义成泛型函数，再将原来所有强制指定StringBuilder的地方都替换成T就可以了。新建一个build.kt文件，并编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">build</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T&#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-类委托和委托属性"><a href="#6-2-类委托和委托属性" class="headerlink" title="6.2 类委托和委托属性"></a>6.2 类委托和委托属性</h3><p><strong>委托是一种设计模式，它的基本理念是：操作对象自己不会去处理某段逻辑，而是会把工作委托给另外一个辅助对象去处理。</strong>这个概念对于Java程序员来讲可能相对比较陌生，因为Java对于委托并没有语言层级的实现，而像C#等语言就对委托进行了原生的支持。Kotlin中也是支持委托功能的，并且将<strong>委托功能分为了两种：类委托和委托属性。</strong>下面我们逐个进行学习。</p><h4 id="6-2-1-类委托"><a href="#6-2-1-类委托" class="headerlink" title="6.2.1 类委托"></a>6.2.1 类委托</h4><p>首先来看<strong>类委托</strong>，<strong>它的核心思想在于将一个类的具体实现委托给另一个类去完成</strong>。我们曾经使用过Set这种数据结构，它和<strong>List</strong>有点类似，只是它所存储的数据是无序的，并且不能存储重复的数据。<strong>Set</strong>是一个接口，如果要使用它的话，需要使用它具体的实现类，比如<strong>HashSet</strong>。而借助于委托模式，我们可以轻松实现一个自己的实现类。比如这里定义一个<strong>MySet</strong>，并让它实现<strong>Set</strong>接口，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = helperSet.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span> = helperSet.isEmpty()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> helperSet.iterator()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helperSet.containsAll(elements)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helperSet.contains(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>MySet</code>的构造函数中接收了一个<code>HashSet</code>参数，这就相当于一个辅助对象。然后在<code>Set</code>接口所有的方法实现中，我们都没有进行自己的实现，而是调用了辅助对象中相应的方法实现，这其实就是一种委托模式。</p><p>那么，这种写法的<strong>好处</strong>是什么呢？既然都是调用辅助对象的方法实现，那还不如直接使用辅助对象得了。这么说确实没错，但如果我们只是让大部分的方法实现调用辅助对象中的方法，少部分的方法实现由自己来重写，甚至加入一些自己独有的方法，那么<code>MySet</code>就会成为一个全新的数据结构类，这就是委托模式的意义所在。</p><p>但是这种写法也有一定的弊端，如果接口中的待实现方法比较少还好，要是有几十甚至上百个方法的话，每个都去这样调用辅助对象中的相应方法实现，那可真是要写哭了。那么这个问题有没有什么解决方案呢？在<code>Java</code>中确实没有，但是在<code>Kotlin</code>中可以通过类委托的功能来解决。</p><p><strong>Kotlin中委托使用的关键字是by</strong>，我们只需要在接口声明的后面使用by关键字，再接上受委托的辅助对象，就可以免去之前所写的一大堆模板式的代码了，如下所示：使用类委派机制：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="keyword">by</span> helperSet&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码在功能上是一样的。它们都定义了一个名为 <code>MySet</code> 的类，这个类实现了 <code>Set</code> 接口，并且使用 <code>HashSet</code> 作为辅助工具来提供 <code>Set</code> 接口的实现。</p><p>然而，它们在实现方式上有所不同：</p><ul><li>第一段代码中，<code>MySet</code> 类显式地实现了 <code>Set</code> 接口的每一个方法。每一个方法的实现都是通过调用 <code>helperSet</code> 的对应方法来完成的。</li><li>第二段代码中，<code>MySet</code> 类使用了 Kotlin 的类委托特性，将 <code>Set</code> 接口的所有方法的实现委托给了 <code>helperSet</code> 对象。这意味着 <code>MySet</code> 类会自动拥有 <code>Set</code> 的所有方法，并且这些方法的实现会直接使用 <code>helperSet</code> 的对应方法。</li></ul><p>所以，虽然这两段代码在功能上是一样的，但是第二段代码更简洁，因为它利用了 Kotlin 的类委托特性，避免了手动实现每一个方法的需要。</p><p>在第二段代码中，如果我们要对某个方法进行重新实现，只需要单独重写那一个方法就可以了，其他的方法仍然可以享受类委托所带来的便利。</p><h4 id="6-2-2-委托属性"><a href="#6-2-2-委托属性" class="headerlink" title="6.2.2 委托属性"></a>6.2.2 委托属性</h4><p>掌握了类委托之后，接下来我们开始学习委托属性。它的基本理念也非常容易理解，真正的难点在于如何灵活地进行应用。</p><p>类委托的核心思想是将一个类的具体实现委托给另一个类去完成，而委托属性的核心思想是将一个属性（字段）的具体实现委托给另一个类去完成。</p><p>我们看一下委托属性的语法结构，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里使用by关键字连接了左边的p属性和右边的<code>Delegate</code>实例，这是什么意思呢？这种写法就代表着将p属性的具体实现委托给了<code>Delegate</code>类去完成。当调用p属性的时候会自动调用<code>Delegate</code>类的<code>getValue()</code>方法，当给p属性赋值的时候会自动调用<code>Delegate</code>类的<code>setValue()</code>方法。</p><p>因此，我们还得对Delegate类进行具体的实现才行，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> propValue : Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> propValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        propValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种标准的代码实现模板，在Delegate类中我们必须实现<code>getValue()</code>和<code>setValue()</code>这两个方法，并且都要使用operator关键字进行声明。</p><p><code>getValue()</code>方法要接收两个参数：第一个参数用于声明该Delegate类的委托功能可以在什么类中使用，这里写成MyClass表示仅可在MyClass类中使用；第二个参数<code>KProperty&lt;*&gt;</code>是Kotlin中的一个属性操作类，可用于获取各种属性相关的值，在当前场景下用不着，但是必须在方法参数上进行声明。另外，<code>&lt;*&gt;</code>这种泛型的写法表示你不知道或者不关心泛型的具体类型，只是为了通过语法编译而已，有点类似于Java中<code>&lt;?&gt;</code>的写法。至于返回值可以声明成任何类型，根据具体的实现逻辑去写就行了，上述代码只是一种示例写法。</p><p><code>setValue()</code>方法也是相似的，只不过它要接收3个参数。前两个参数和<code>getValue()</code>方法是相同的，最后一个参数表示具体要赋值给委托属性的值，这个参数的类型必须和<code>getValue()</code>方法返回值的类型保持一致。</p><p>整个委托属性的工作流程就是这样实现的，现在当我们给<code>MyClass</code>的<code>p</code>属性赋值时，就会调用<code>Delegate</code>类的<code>setValue()</code>方法，当获取<code>MyClass</code>中<code>p</code>属性的值时，就会调用<code>Delegate</code>类的<code>getValue()</code>方法。</p><p>不过，其实还存在一种情况可以不用在<code>Delegate</code>类中实现<code>setValue()</code>方法，那就是<code>MyClass</code>中的p属性是使用<code>val</code>关键字声明的。这一点也很好理解，如果<code>p</code>属性是使用<code>val</code>关键字声明的，那么就意味着<code>p</code>属性是无法在初始化之后被重新赋值的，因此也就没有必要实现<code>setValue()</code>方法，只需要实现<code>getValue()</code>方法就可以了。</p><h4 id="6-2-3-实现一个自己的lazy函数"><a href="#6-2-3-实现一个自己的lazy函数" class="headerlink" title="6.2.3 实现一个自己的lazy函数"></a>6.2.3 实现一个自己的lazy函数</h4><p>我们<strong>初始化变量</strong>时可以把想要延迟执行的代码放到by lazy代码块中，这样代码块中的代码在一开始的时候就不会执行，只有当<strong>变量</strong>首次被调用的时候，代码块中的代码才会执行。</p><p>学习了<code>Kotlin</code>的委托功能之后，我们就可以对<code>by lazy</code>的工作原理进行解密了，它的基本语法结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p <span class="keyword">by</span> lazy &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>by lazy</code>并不是连在一起的关键字，只有<code>by</code>才是Kotlin中的关键字，<code>lazy</code>在这里只是一个高阶函数而已。在<code>lazy</code>函数中会创建并返回一个<code>Delegate</code>对象，当我们调用p属性的时候，其实调用的是<code>Delegate</code>对象的<code>getValue()</code>方法，然后<code>getValue()</code>方法中又会调用<code>lazy</code>函数传入的Lambda表达式，这样表达式中的代码就可以得到执行了，并且调用p属性后得到的值就是Lambda表达式中最后一行代码的返回值。</p><p>这样看来，Kotlin的懒加载技术也并没有那么神秘，掌握了它的实现原理之后，我们也可以实现一个自己的<code>lazy</code>函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">later</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span> = Later(block)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Later</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> block: () -&gt; T) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(any: <span class="type">Any</span>?, prop: <span class="type">KProperty</span>&lt;*&gt;)</span></span> : T &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>)&#123;</span><br><span class="line">            value = block()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> heavyObject <span class="keyword">by</span> later &#123; HeavyObject() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeavyObject</span> &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;HeavyObject is being created.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;HeavyObject is being used.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;main step in&quot;</span>)</span><br><span class="line">    <span class="comment">// 在这里，heavyObject 还没有被创建</span></span><br><span class="line">    <span class="keyword">if</span> (needHeavyObject()) &#123;</span><br><span class="line">        println(<span class="string">&quot;if step in&quot;</span>)</span><br><span class="line">        <span class="comment">// 在这里，heavyObject 被创建</span></span><br><span class="line">        heavyObject.use()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">needHeavyObject</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码演示了如何使用延迟初始化来创建 <code>heavyObject</code>。只有在 <code>heavyObject</code> 第一次被使用时，它才会被创建。这是一种很好的做法，特别是在对象创建代价高昂，且不总是需要该对象的情况下，可以帮助节省资源，提高应用程序的性能。</p><hr><h2 id="七、使用infix函数构建更可读的语法"><a href="#七、使用infix函数构建更可读的语法" class="headerlink" title="七、使用infix函数构建更可读的语法"></a>七、使用infix函数构建更可读的语法</h2><p>在Kotlin中我们可以使用<code>A to B</code>这样的语法结构构建键值对，比如在Kotlin自带的<code>mapOf()</code>函数，这种语法结构的优点是可读性高，相比于调用一个函数，它更接近于使用英语的语法来编写程序。可能你会好奇，这种功能是怎么实现的呢？to是不是Kotlin语言中的一个关键字？</p><p>首先，to并不是Kotlin语言中的一个关键字，之所以我们能够使用<code>A to B</code>这样的语法结构，是因为Kotlin提供了一种高级语法糖特性：<code>infix</code>函数。当然，<code>infix</code>函数也并不是什么难理解的事物，它只是把编程语言函数调用的语法规则调整了一下而已，比如<code>A to B</code>这样的写法，实际上等价于<code>A.to(B)</code>的写法。</p><p>举个栗子🌰：</p><p>String类中有一个<code>startsWith()</code>函数，你一定使用过，它可以用于判断一个字符串是否是以某个指定参数开头的。比如说下面这段代码的判断结果一定会是true：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;Hello Kotlin&quot;</span>.startsWith(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startsWith()函数的用法虽然非常简单，但是借助infix函数，我们可以使用一种更具可读性的语法来表达这段代码。新建一个infix.kt文件，然后编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">beginsWith</span><span class="params">(prefix: <span class="type">String</span>)</span></span> = startsWith(prefix)</span><br></pre></td></tr></table></figure><p>除去最前面的infix关键字不谈，这是一个String类的扩展函数。我们给String类添加了一个<code>beginsWith()</code>函数，它也是用于判断一个字符串是否是以某个指定参数开头的，并且它的内部实现就是调用的String类的<code>startsWith()</code>函数。</p><p>但是加上了infix关键字之后，<code>beginsWith()</code>函数就变成了一个infix函数，这样除了传统的函数调用方式之外，我们还可以用一种特殊的语法糖格式调用<code>beginsWith()</code>函数，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;Hello Kotlin&quot;</span> beginsWith <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子就能看出，infix函数的语法规则并不复杂，上述代码其实就是调用的” Hello Kotlin “这个字符串的<code>beginsWith()</code>函数，并传入了一个”Hello”字符串作为参数。但是infix函数允许我们将函数调用时的小数点、括号等计算机相关的语法去掉，从而使用一种更接近英语的语法来编写程序，让代码看起来更加具有可读性。</p><p>另外，infix函数由于其语法糖格式的特殊性，有两个比较严格的限制：首先，<strong>infix函数是不能定义成顶层函数的，它必须是某个类的成员函数，可以使用扩展函数的方式将它定义到某个类当中</strong>；其次，<strong>infix函数必须接收且只能接收一个参数，至于参数类型是没有限制的</strong>。只有同时满足这两点，infix函数的语法糖才具备使用的条件.</p><p>再举个栗子🌰：</p><p>比如这里有一个集合，如果想要判断集合中是否包括某个指定元素，一般可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (list.contains(<span class="string">&quot;Banana&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单对吗？但我们仍然可以借助infix函数让这段代码变得更加具有可读性。在infix.kt文件中添加如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">has</span><span class="params">(element: <span class="type">T</span>)</span></span> = contains(element)</span><br></pre></td></tr></table></figure><p>可以看到，我们给<code>Collection</code>接口添加了一个扩展函数，这是因为<strong>Collection是Java以及Kotlin所有集合的总接口</strong>，因此给Collection添加一个**has()**函数，那么所有集合的子类就都可以使用这个函数了。</p><p>另外，这里还使用了上一章中学习的泛型函数的定义方法，从而使得<code>has()</code>函数可以接收任意具体类型的参数。而这个函数内部的实现逻辑就相当简单了，只是调用了<code>Collection</code>接口中的<code>contains()</code>函数而已。也就是说，<code>has()</code>函数和<code>contains()</code>函数的功能实际上是一模一样的，只是它多了一个infix关键字，从而拥有了infix函数的语法糖功能。</p><p>现在我们就可以使用如下的语法来判断集合中是否包括某个指定的元素：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (list has <span class="string">&quot;Banana&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析一下 <code>A to B</code>中 中缀函数 <code>to</code> 的实现，其实就只有一段代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure><p>这是Kotlin编程语言中的一种函数声明。我们先分解一下：</p><ol><li><code>public</code>：这是函数的访问修饰符，表示这个函数可以在任何位置被访问。</li><li><code>infix</code>：这是一个在Kotlin中表征中缀函数的关键字。所谓中缀函数，就是可以使用更自然的语言风格调用，并且该函数要满足“它们必须是成员函数或扩展函数、它们必须有一个参数、它们的参数不能接受可变数量的参数且不能有默认值”。</li><li><code>&lt;A, B&gt;</code>：这是泛型参数列表，表明这个函数可以对任意类型的对象进行操作。</li><li><code>A.to(that: B)</code>：这是函数的声明，函数名为<code>to</code>，参数为名为<code>that</code>的<code>B</code>类型对象。</li><li><code>Pair&lt;A, B&gt;</code>：这是函数的返回类型，表示函数返回一个包含两个元素，类型分别为A和B的Pair对象。</li><li><code>Pair(this, that)</code>：这是函数的实现，创建一个新的Pair对象，第一个元素是调用<code>to</code>函数的对象，第二个元素是函数的参数。</li></ol><p>整个函数可以这样理解：对任意类型A的对象，我们定义了一个函数<code>to</code>，它接受一个任意类型B的对象作为参数，并返回一个Pair&lt;A, B&gt;对象。</p><p>举个例子🌰：假设有两个变量a和b：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>那么，我们可以使用中缀函数简洁地构造Pair对象：a to b，代表一对值：1和2</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = a to b</span><br><span class="line"><span class="comment">// pair is Pair&lt;Int, Int&gt;(1, 2)</span></span><br></pre></td></tr></table></figure><hr><h2 id="八、泛型的高级特性"><a href="#八、泛型的高级特性" class="headerlink" title="八、泛型的高级特性"></a>八、泛型的高级特性</h2><p>之前在[6.1](###6.1 泛型的基本用法)中学习了<strong>Kotlin</strong>泛型的基本用法。这些基本用法其实和<strong>Java</strong>中泛型的用法是大致相同的，因此也相对比较好理解。然而实际上，<strong>Kotlin</strong>在泛型方面还提供了不少特有的功能，掌握了这些功能，你将可以更好玩转<strong>Kotlin</strong>，同时还能实现一些不可思议的语法特性。</p><h3 id="8-1-对泛型进行实化"><a href="#8-1-对泛型进行实化" class="headerlink" title="8.1 对泛型进行实化"></a>8.1 对泛型进行实化</h3><p>泛型实化这个功能对于绝大多数<strong>Java</strong>程序员来讲是非常陌生的，因为<strong>Java</strong>中完全没有这个概念。而如果我们想要深刻地理解泛型实化，就要先解释一下<strong>Java</strong>的泛型擦除机制才行。</p><p>在<strong>JDK 1.5</strong>之前，<strong>Java</strong>是没有泛型功能的，那个时候诸如<strong>List</strong>之类的数据结构可以存储任意类型的数据，取出数据的时候也需要手动向下转型才行，这不仅麻烦，而且很危险。比如说我们在同一个<strong>List</strong>中存储了字符串和整型这两种数据，但是在取出数据的时候却无法区分具体的数据类型，如果手动将它们强制转成同一种类型，那么就会抛出类型转换异常。</p><p>于是在<strong>JDK 1.5</strong>中，<strong>Java</strong>终于引入了泛型功能。这不仅让诸如<strong>List</strong>之类的数据结构变得简单好用，也让我们的代码变得更加安全。</p><p>但是实际上，<strong>Java</strong>的泛型功能是通过类型擦除机制来实现的。什么意思呢？就是说泛型对于类型的约束只在编译时期存在，运行的时候仍然会按照<strong>JDK 1.5</strong>之前的机制来运行，JVM是识别不出来我们在代码中指定的泛型类型的。例如，假设我们创建了一个<code>List&lt;String&gt;</code>集合，虽然在编译时期只能向集合中添加字符串类型的元素，但是在运行时期<strong>JVM</strong>并不能知道它本来只打算包含哪种类型的元素，只能识别出来它是个<strong>List</strong>。</p><p>所有基于<strong>JVM</strong>的语言，它们的泛型功能都是通过类型擦除机制来实现的，其中当然也包括了<strong>Kotlin</strong>。这种机制使得我们不可能使用<code>a is T</code>或者<code>T::class.java</code>这样的语法，因为T的实际类型在运行的时候已经被擦除了。</p><p>然而不同的是，<strong>Kotlin</strong>提供了一个内联函数的概念，我们在第[4.2](###4.2 内联函数的作用)中已经学过了这个知识点。内联函数中的代码会在编译的时候自动被替换到调用它的地方，这样的话也就不存在什么泛型擦除的问题了，因为代码在编译之后会直接使用实际的类型来替代内联函数中的泛型声明，其工作原理如下图所示。</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/01/1706065068503_a6941c17468b5.png" alt="1706065068503.png"></p><p>最终代码会被替换成如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// do something with String type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>bar()</code>是一个带有泛型类型的内联函数，<code>foo()</code>函数调用了<code>bar()</code>函数，在代码编译之后，<code>bar()</code>函数中的代码将可以获得泛型的实际类型。<strong>这就意味着，Kotlin中是可以将内联函数中的泛型进行实化的。</strong></p><p>那么具体该怎么写才能将泛型实化呢？<strong>首先，该函数必须是内联函数才行，也就是要用<code>inline</code>关键字来修饰该函数。其次，在声明泛型的地方必须加上<code>reified</code>关键字来表示该泛型要进行实化。</strong>示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数中的泛型<strong>T</strong>就是一个被实化的泛型，因为它满足了内联函数和<strong>reified</strong>关键字这两个前提条件。那么借助泛型实化，到底可以实现什么样的效果呢？从函数名就可以看出来了，这里我们准备实现一个获取泛型实际类型的功能，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> = T::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure><p>虽然只有一行代码，但是这里却实现了一个<strong>Java</strong>中完全不可能实现的功能：<code>getGenericType()</code>函数直接返回了当前指定泛型的实际类型。<code>T.class</code>这样的语法在<strong>Java</strong>中是不合法的，而在<strong>Kotlin</strong>中，借助泛型实化功能就可以使用<code>T::class.java</code>这样的语法了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = getGenericType&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> result2 = getGenericType&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    println(<span class="string">&quot;result1 is <span class="variable">$result1</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;result2 is <span class="variable">$result2</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> = T::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure><p>运行结果打印如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 is class java.lang.String</span><br><span class="line">result2 is class java.lang.Integer</span><br></pre></td></tr></table></figure><p>如果将泛型指定成了<strong>String</strong>，那么就可以得到<code>java.lang.String</code>的类型；如果将泛型指定了<strong>Int</strong>，就可以得到<code>java.lang.Integer</code>的类型。</p><p>接下来学习泛型实化的应用</p><h3 id="8-2-泛型实化的应用"><a href="#8-2-泛型实化的应用" class="headerlink" title="8.2 泛型实化的应用"></a>8.2 泛型实化的应用</h3><p>泛型实化功能允许我们在泛型函数当中获得泛型的实际类型，这也就使得类似于<code>a is T</code>、<code>T::class.java</code>这样的语法成为了可能。而灵活运用这一特性将可以实现一些不可思议的语法结构。在<strong>Android</strong>四大组件当中，除了<strong>ContentProvider</strong>之外，<strong>Activity</strong>、<strong>Service</strong>还有<strong>BroadcastReceiver</strong>都需要结合 <strong>Intent</strong>一起使用。</p><p>就拿启动Activity来说：</p><p>我们可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, TestActivity::<span class="keyword">class</span>.java)</span><br><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure><p>有没有觉得<code>TestActivity::class.java</code>这样的语法很难受呢？当然，如果在没有更好选择的情况下，这种写法也是可以忍受的，但是<strong>Kotlin</strong>的泛型实化功能使得我们拥有了更好的选择。</p><p>新建一个<code>reified.kt</code>文件，然后在里面编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java)</span><br><span class="line">    context.startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个<code>startActivity()</code>函数，该函数接收一个<strong>Context</strong>参数，并同时使用<strong>inline</strong>和<strong>reified</strong>关键字让泛型T成为了一个被实化的泛型。接下来就是神奇的地方了，<strong>Intent</strong>接收的第二个参数本来应该是一个具体<strong>Activity</strong>的<strong>Class</strong>类型，但由于现在<strong>T</strong>已经是一个被实化的泛型了，因此这里我们可以直接传入<code>T::class.java</code>。最后调用<strong>Context</strong>的<code>startActivity()</code>方法来完成<strong>Activity</strong>的启动。</p><p>现在，如果我们要启动<strong>TestActivity</strong>，只需要这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context)</span><br></pre></td></tr></table></figure><p>不过，现在的<code>startActivity()</code>函数其实还是有问题的，因为通常在启用<strong>Activity</strong>的时候还可能会使用<strong>Intent</strong>附带一些参数，比如下面的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, TestActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param2&quot;</span>, <span class="number">123</span>)</span><br><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure><p>而经过刚才的封装之后，我们就无法进行传参了。这个问题也不难解决，只需要借助之前学习的高阶函数就可以轻松搞定。回到<code>reified.kt</code>文件当中，这里添加一个新的<code>startActivity()</code>函数重载，如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>, block: <span class="type">Intent</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java)</span><br><span class="line">    intent.block()</span><br><span class="line">    context.startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这次的<code>startActivity()</code>函数中增加了一个函数类型参数，并且它的函数类型是定义在<strong>Intent</strong>类当中的。在创建完<strong>Intent</strong>的实例之后，随即调用该函数类型参数，并把<strong>Intent</strong>的实例传入，这样调用<code>startActivity()</code>函数的时候就可以在<strong>Lambda</strong>表达式中为<strong>Intent</strong>传递参数了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) &#123;</span><br><span class="line">    putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">    putExtra(<span class="string">&quot;param2&quot;</span>, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-泛型的协变"><a href="#8-3-泛型的协变" class="headerlink" title="8.3 泛型的协变"></a>8.3 泛型的协变</h3><p>在开始学习协变和逆变之前，我们还得先了解一个约定。一个泛型类或者泛型接口中的方法，它的参数列表是接收数据的地方，因此可以称它为<strong>in</strong>位置，而它的返回值是输出数据的地方，因此可以称它为<strong>out</strong>位置，如下图所示。</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/01/1706256361291_697ba5b7d4ec0.png" alt="1706256361291.png"></p><p>有了这个约定前提，接下来继续学习，首先定义如下三个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age)</span><br></pre></td></tr></table></figure><p>这里先定义了一个<strong>Person</strong>类，类中包含<strong>name</strong>和<strong>age</strong>这两个字段。然后又定义了<strong>Student</strong>和<strong>Teacher</strong>这两个类，让它们成为<strong>Person</strong>类的子类。</p><p>如果某个方法接收一个<strong>Person</strong>类型的参数，而我们传入一个<strong>Student</strong>的实例，这样合不合法呢？很显然，因为<strong>Student</strong>是<strong>Person</strong>的子类，学生也是人呀，因此这是一定合法的。</p><p>如果某个方法接收一个<code>List&lt;Person&gt;</code>类型的参数，而我们传入一个<code>List&lt;Student&gt;</code>的实例，这样合不合法呢？看上去好像也挺正确的，但是Java中是不允许这么做的，因为<code>List&lt;Student&gt;</code>不能成为<code>List&lt;Person&gt;</code>的子类，<strong>否则将可能存在类型转换的安全隐患。</strong></p><p>为什么会存在类型转换的安全隐患呢？下面我们通过一个具体的例子进行说明。自定义一个<code>SimpleData</code>类以及一个<code>handleSimpleData(data: SimpleData&lt;Person&gt;)</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: T? = <span class="literal">null</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(t: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span> = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span> : T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleSimpleData</span><span class="params">(<span class="keyword">data</span>: <span class="type">SimpleData</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> teacher = Teacher(<span class="string">&quot;Jack&quot;</span>, <span class="number">35</span>)</span><br><span class="line">    <span class="keyword">data</span>.<span class="keyword">set</span>(teacher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SimpleData</strong>是一个泛型类，它的内部封装了一个泛型<strong>data</strong>字段，调用<code>set()</code>方法可以给<strong>data</strong>字段赋值，调用<code>get()</code>方法可以获取<strong>data</strong>字段的值。</p><p>接着我们假设，如果编程语言允许向某个接收<code>SimpleData&lt;Person&gt;</code>参数的方法传入<code>SimpleData&lt;Student&gt;</code>的实例，那么如下代码就会是合法的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = SimpleData&lt;Student&gt;()</span><br><span class="line">    <span class="keyword">data</span>.<span class="keyword">set</span>(student)</span><br><span class="line">    handleSimpleData(<span class="keyword">data</span>) <span class="comment">//这里会报错</span></span><br><span class="line">    <span class="keyword">val</span> studentData = <span class="keyword">data</span>.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Type mismatch.</p><p>Required:<br>SimpleData<Person><br>Found:<br>SimpleData<Student></p></blockquote><p>可以看到报错信息是类型不匹配，这里需要一个 <code>SimpleData&lt;Person&gt;</code> 而我们却传给了他 <code>SimpleData&lt;Student&gt;</code></p><p>在<code>main()</code>方法中，我们创建了一个<strong>Student</strong>的实例，并将它封装到<code>SimpleData&lt;Student&gt;</code>当中，然后将<code>SimpleData&lt;Student&gt;</code>作为参数传递给<code>handleSimpleData()</code>方法。但是<code>handleSimpleData()</code>方法接收的是一个<strong>SimpleData<Person><strong>参数（这里假设可以编译通过），那么在<code>handleSimpleData()</code>方法中，我们就可以创建一个</strong>Teacher</strong>的实例，并用它来替换<code>SimpleData&lt;Person&gt;</code>参数中的原有数据。<strong>这种操作肯定是合法的，因为Teacher也是Person的子类，所以可以很安全地将Teacher的实例设置进去。</strong></p><p>但是问题马上来了，回到<code>main()</code>方法当中，我们调用<code>SimpleData&lt;Student&gt;</code>的<code>get()</code>方法来获取它内部封装的<strong>Student</strong>数据，<strong>可现在<code>SimpleData&lt;Student&gt;</code>中实际包含的却是一个Teacher的实例，那么此时必然会产生类型转换异常。</strong></p><p>所以，为了杜绝这种安全隐患，<strong>Java</strong>是不允许使用这种方式来传递参数的。换句话说，即使<strong>Student</strong>是<strong>Person</strong>的子类，<code>SimpleData&lt;Student&gt;</code>并不是<code>SimpleData&lt;Person&gt;</code>的子类。</p><p>不过，回顾一下刚才的代码，你会发现问题发生的主要原因是我们在<code>handleSimpleData()</code>方法中向<code>SimpleData&lt;Person&gt;</code>里设置了一个<strong>Teacher</strong>的实例。如果<strong>SimpleData</strong>在泛型T上是只读的话，肯定就没有类型转换的安全隐患了，那么这个时候<code>SimpleData&lt;Student&gt;</code>可不可以成为<code>SimpleData&lt;Person&gt;</code>的子类呢？</p><p>讲到这里，我们终于要引出泛型协变的定义了。<strong>假如定义了一个<code>MyClass&lt;T&gt;</code>的泛型类，其中A是B的子类型，同时<code>MyClass&lt;A&gt;</code>又是<code>MyClass&lt;B&gt;</code>的子类型，那么我们就可以称<code>MyClass</code>在T这个泛型上是协变的。</strong></p><p>但是如何才能让<code>MyClass&lt;A&gt;</code>成为<code>MyClass&lt;B&gt;</code>的子类型呢？刚才已经讲了，<strong>如果一个泛型类在其泛型类型的数据上是只读的话，那么它是没有类型转换安全隐患的。</strong>而要实现这一点，则需要让<code>MyClass&lt;T&gt;</code>类中的<strong>所有方法都不能接收T类型的参数</strong>。换句话说，<strong>T只能出现在out位置上，而不能出现在in位置上。</strong></p><p>现在修改<strong>SimpleData</strong>类的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">out T</span>&gt; (<span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span>: T?) &#123;</span><br><span class="line">    <span class="comment">/*private var data: T? = null</span></span><br><span class="line"><span class="comment">    fun set(t: T?) &#123;</span></span><br><span class="line"><span class="comment">        data = t</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span> : T? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们对<strong>SimpleData</strong>类进行了改造，在泛型T的声明前面加上了一个<strong>out</strong>关键字。这就意味着现在T只能出现在<strong>out</strong>位置上，而不能出现在<strong>in</strong>位置上，同时也意味着<strong>SimpleData</strong>在<strong>泛型T</strong>上是协变的。</p><p>由于<strong>泛型T</strong>不能出现在<strong>in</strong>位置上，因此我们也就不能使用<code>set()</code>方法为<strong>data</strong>参数赋值了，所以这里改成了使用构造函数的方式来赋值。你可能会说，构造函数中的泛型T不也是在<strong>in</strong>位置上的吗？没错，但是由于这里我们使用了<strong>val</strong>关键字，所以构造函数中的<strong>泛型T</strong>仍然是只读的，因此这样写是合法且安全的。另外，即使我们使用了<strong>var</strong>关键字，但只要给它加上<strong>private</strong>修饰符，保证这个泛型T对于外部而言是不可修改的，那么就都是合法的写法。</p><p>经过了这样的修改之后，下面的代码就可以完美编译通过且没有任何安全隐患了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = SimpleData&lt;Student&gt;(student)</span><br><span class="line">    handleSimpleData(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> studentData = <span class="keyword">data</span>.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleSimpleData</span><span class="params">(<span class="keyword">data</span>: <span class="type">SimpleData</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> personData = <span class="keyword">data</span>.<span class="keyword">get</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>SimpleData</strong>类已经进行了协变声明，那么<code>SimpleData&lt;Student&gt;</code>自然就是<code>SimpleData&lt;Person&gt;</code>的子类了，所以这里可以安全地向<code>handleSimpleData()</code>方法中传递参数。</p><p>然后在<code>handleSimpleData()</code>方法中去获取<strong>SimpleData</strong>封装的数据，虽然这里泛型声明的是<strong>Person</strong>类型，实际获得的会是一个<strong>Student</strong>的实例，<strong>但由于Person是Student的父类，向上转型是完全安全的</strong>，所以这段代码没有任何问题。</p><h3 id="8-4-泛型的逆变"><a href="#8-4-泛型的逆变" class="headerlink" title="8.4 泛型的逆变"></a>8.4 泛型的逆变</h3><p>仅从定义上来看，逆变与协变却完全相反。那么这里先引出定义吧，<strong>假如定义了一个MyClass<T>的泛型类，其中A是B的子类型，同时MyClass<B>又是MyClass<A>的子类型，那么我们就可以称MyClass在T这个泛型上是逆变的。</strong>协变和逆变的区别如下图所示：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/01/1706497381453_2f65e27d0d37d.png" alt="1706497381453.png"></p><p>从直观的角度上来思考，逆变的规则好像挺奇怪的，原本<strong>A是B的子类型</strong>，怎么**MyClass<B><strong>能反过来成为</strong>MyClass<A>**的子类型了呢？</p><p>举个栗子🌰：</p><p>先定义一个 <code>Transformer</code> 接口，用于一些转换操作，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Transformer</strong>接口中声明了一个<code>transform()</code>方法，它接收一个T类型的参数，并且返回一个<strong>String</strong>类型的数据，这意味着参数T在经过<code>transform()</code>方法的转换之后将会变成一个字符串。至于具体的转换逻辑是什么样的，则由子类去实现，<strong>Transformer</strong>接口对此并不关心。</p><p>那么现在我们就尝试对<strong>Transformer</strong>接口进行实现，代码如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trans = <span class="keyword">object</span> : Transformer&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">Person</span>)</span></span> : String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">$&#123;t.name&#125;</span> <span class="subst">$&#123;t.age&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleTransformer(trans)  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleTransformer</span><span class="params">(trans: <span class="type">Transformer</span>&lt;<span class="type">Student</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> result = trans.transform(student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们在<code>main()</code>方法中编写了一个<code>Transformer&lt;Person&gt;</code>的匿名类实现，并通过<code>transform()</code>方法将传入的<strong>Person</strong>对象转换成了一个“姓名+年龄”拼接的字符串。而<code>handleTransformer()</code>方法接收的是一个<code>Transformer&lt;Student&gt;</code>类型的参数，这里在<code>handleTransformer()</code>方法中创建了一个<strong>Student</strong>对象，并调用参数的<code>transform()</code>方法将<strong>Student</strong>对象转换成一个字符串。</p><p>这段代码从安全的角度来分析是没有任何问题的，因为<strong>Student</strong>是<strong>Person</strong>的子类，使用<code>Transformer&lt;Person&gt;</code>的匿名类实现将<strong>Student</strong>对象转换成一个字符串也是绝对安全的，并不存在类型转换的安全隐患。但是实际上，在调用<code>handleTransformer()</code>方法的时候却会提示语法错误，原因也很简单，<code>Transformer&lt;Person&gt;</code>并不是<code>Transformer&lt;Student&gt;</code>的子类型。</p><p>那么这个时候逆变就可以派上用场了，它就是专门用于处理这种情况的。修改<strong>Transformer</strong>接口中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(t: <span class="type">T</span>)</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在泛型T的声明前面加上了一个<strong>in</strong>关键字。这就意味着现在<strong>T</strong>只能出现在<strong>in</strong>位置上，而不能出现在<strong>out</strong>位置上，同时也意味着<strong>Transformer</strong>在泛型<strong>T</strong>上是逆变的。</p><p>没错，只要做了这样一点修改，刚才的代码就可以编译通过且正常运行了，因为此时<code>Transformer&lt;Person&gt;</code>已经成为了<code>Transformer&lt;Student&gt;</code>的子类型。</p><p>逆变的用法大概就是这样了，如果你还想再深入思考一下的话，可以想一想为什么逆变的时候泛型<strong>T</strong>不能出现在<strong>out</strong>位置上？为了解释这个问题，我们先假设逆变是允许让泛型T出现在out位置上的，然后看一看可能会产生什么样的安全隐患。修改<strong>Transformer</strong>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transformer</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>)</span></span>: <span class="meta">@UnsafeVariance</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将<code>transform()</code>方法改成了接收<strong>name</strong>和<strong>age</strong>这两个参数，并把返回值类型改成了泛型<strong>T</strong>。由于逆变是不允许泛型<strong>T</strong>出现在<strong>out</strong>位置上的，这里为了能让编译器正常编译通过，所以加上了<code>@UnsafeVariance</code>注解，这和<strong>List</strong>源码中使用的技巧是一样的。</p><p>这个时候会产生什么安全隐患呢？来看看代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> trans = <span class="keyword">object</span> : Transformer&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">return</span> Teacher(name, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleTransformer(trans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleTransformer</span><span class="params">(trans: <span class="type">Transformer</span>&lt;<span class="type">Student</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = trans.transform(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是一个典型的违反逆变规则而造成类型转换异常的例子。在<code>Transformer&lt;Person&gt;</code>的匿名类实现中，我们使用<code>transform()</code>方法中传入的<strong>name</strong>和<strong>age</strong>参数构建了一个<strong>Teacher</strong>对象，并把这个对象直接返回。由于<code>transform()</code>方法的返回值要求是一个<strong>Person</strong>对象，而<strong>Teacher</strong>是<strong>Person</strong>的子类，因此这种写法肯定是合法的。</p><p>但在<code>handleTransformer()</code>方法当中，我们调用了<code>Transformer&lt;Student&gt;</code>的<code>transform()</code>方法，并传入了<strong>name</strong>和<strong>age</strong>这两个参数，期望得到的是一个<strong>Student</strong>对象的返回，然而实际上<code>transform()</code>方法返回的却是一个<strong>Teacher</strong>对象，因此这里必然会造成类型转换异常。</p><p>异常信息如下：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708223607170_02ba4f0d6b5cd.png" alt="1708223607170.png"></p><p>可以看到，提示我们<strong>Teacher</strong>类型是无法转换成<strong>Student</strong>类型的。</p><p>也就是说，<strong>Kotlin</strong>在提供协变和逆变功能时，就已经把各种潜在的类型转换安全隐患全部考虑进去了。只要我们严格按照其语法规则，让泛型在协变时只出现在<strong>out</strong>位置上，逆变时只出现在<strong>in</strong>位置上，就不会存在类型转换异常的情况。虽然<code>@UnsafeVariance</code>注解可以打破这一语法规则，但同时也会带来额外的风险，所以你在使用<code>@UnsafeVariance</code>注解时，必须很清楚自己在干什么才行。</p><p>最后我们再来介绍一下逆变功能在<strong>Kotlin</strong>内置<strong>API</strong>中的应用，比较典型的例子就是<strong>Comparable</strong>的使用。<strong>Comparable</strong>是一个用于比较两个对象大小的接口，其源码定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Comparable</strong>在<strong>T</strong>这个泛型上就是逆变的，<code>compareTo()</code>方法则用于实现具体的比较逻辑。那么这里为什么要让<strong>Comparable</strong>接口是逆变的呢？想象如下场景，如果我们使用<code>Comparable&lt;Person&gt;</code>实现了让两个<strong>Person</strong>对象比较大小的逻辑，那么用这段逻辑去比较两个<strong>Student</strong>对象的大小也一定是成立的，因此让<code>Comparable&lt;Person&gt;</code>成为<code>Comparable&lt;Student&gt;</code>的子类合情合理，这也是逆变非常典型的应用。</p><hr><h2 id="九、使用协程编写高效的并发程序"><a href="#九、使用协程编写高效的并发程序" class="headerlink" title="九、使用协程编写高效的并发程序"></a>九、使用协程编写高效的并发程序</h2><p><strong>协程属于Kotlin中非常有特色的一项技术</strong>，因为大部分编程语言中是没有协程这个概念的。</p><p><strong>那么什么是协程呢？它其实和线程是有点类似的，可以简单地将它理解成一种轻量级的线程。</strong>要知道，我们之前所学习的线程是非常重量级的，它需要依靠操作系统的调度才能实现不同线程之间的切换。而<strong>使用协程却可以仅在编程语言的层面就能实现不同协程之间的切换，从而大大提升了并发编程的运行效率。</strong></p><p>举一个具体点的例子，比如我们有如下**foo()<strong>和</strong>bar()**两个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a()</span><br><span class="line">    b()</span><br><span class="line">    c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x()</span><br><span class="line">    y()</span><br><span class="line">    z()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有开启线程的情况下，先后调用<code>foo()</code>和<code>bar()</code>这两个方法，那么理论上结果一定是<code>a()</code>、<code>b()</code>、<code>c()</code>执行完了以后，<code>x()</code>、<code>y()</code>、<code>z()</code>才能够得到执行。而如果使用了协程，在协程A中去调用<code>foo()</code>方法，协程B中去调用<code>bar()</code>方法，虽然它们仍然会运行在同一个线程当中，但是在执行<code>foo()</code>方法时随时都有可能被挂起转而去执行<code>bar()</code>方法，执行<code>bar()</code>方法时也随时都有可能被挂起转而继续执行<code>foo()</code>方法，最终的输出结果也就变得不确定了。</p><p>可以看出，<strong>协程允许我们在单线程模式下模拟多线程编程的效果，代码执行时的挂起与恢复完全是由编程语言来控制的，和操作系统无关。</strong>这种特性使得高并发程序的运行效率得到了极大的提升，试想一下，开启10万个线程完全是不可想象的事吧？而开启10万个协程就是完全可行的。</p><h3 id="9-1-协程的基本用法"><a href="#9-1-协程的基本用法" class="headerlink" title="9.1 协程的基本用法"></a>9.1 协程的基本用法</h3><p>Kotlin并没有将协程纳入标准库的API当中，而是以依赖库的形式提供的。所以如果我们想要使用协程功能，需要先在app&#x2F;build.gradle文件当中添加如下依赖库：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要面临的第一个问题就是，如何开启一个协程？最简单的方式就是使用<code>Global.launch</code>函数，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GlobalScope.launch</code>函数可以创建一个协程的作用域，这样传递给<strong>launch</strong>函数的代码块（Lambda表达式）就是在协程中运行的了，这里我们只是在代码块中打印了一行日志。那么现在运行<code>main()</code>函数，日志能成功打印出来吗？如果你尝试一下，会发现没有任何日志输出。<strong>这是因为，Global.launch函数每次创建的都是一个顶层协程，这种协程当应用程序运行结束时也会跟着一起结束。</strong>刚才的日志之所以无法打印出来，就是因为代码块中的代码还没来得及运行，应用程序就结束了。</p><p>要解决这个问题也很简单，我们让程序延迟一段时间再结束就行了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用Thread.sleep()方法让主线程阻塞1秒钟，现在重新运行程序，日志就可以打印出来了。</p><p>可是这种写法还是存在问题，如果代码块中的代码在1秒钟之内不能运行结束，那么就会被强制<br>中断。观察如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">        delay(<span class="number">1500</span>)</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope finished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在代码块中加入了一个<code>delay()</code>函数，并在之后又打印了一行日志。<code>delay()</code>函数可以让当前协程延迟指定时间后再运行，但它和<code>Thread.sleep()</code>方法不同。<code>delay()</code>函数是一个非阻塞式的挂起函数，它只会挂起当前协程，并不会影响其他协程的运行。而<code>Thread.sleep()</code>方法会阻塞当前的线程，这样运行在该线程下的所有协程都会被阻塞。注意，<code>delay()</code>函数只能在协程的作用域或其他挂起函数中调用。</p><p>这里我们让协程挂起1.5秒，但是主线程却只阻塞了1秒，最终会是什么结果呢？重新运行程序，你会发现代码块中新增的一条日志并没有打印出来，因为它还没能来得及运行，应用程序就已经结束了。</p><p>那么有没有什么办法能让应用程序在协程中所有代码都运行完了之后再结束呢？当然也是有的，借助<strong>runBlocking</strong>函数就可以实现这个功能：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope&quot;</span>)</span><br><span class="line">        delay(<span class="number">1500</span>)</span><br><span class="line">        println(<span class="string">&quot;codes run in coroutine scope finished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>runBlocking</strong>函数同样会创建一个协程的作用域，但是它可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程。需要注意的是，<strong>runBlocking</strong>函数通常只应该在测试环境下使用，在正式环境中使用容易产生一些性能上的问题。</p><p>虽说现在我们已经能够让代码在协程中运行了，可是好像并没有体会到什么特别的好处。这是因为目前所有的代码都是运行在同一个协程当中的，而一旦涉及高并发的应用场景，协程相比于线程的优势就能体现出来了。</p><p>那么如何才能创建多个协程呢？很简单，使用<strong>launch</strong>函数就可以了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;launch1&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">&quot;launch1 finished&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;launch2 scope&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            println(<span class="string">&quot;launch2 finished&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<strong>launch</strong>函数和我们刚才所使用的<code>GlobalScope.launch</code>函数不同。首先它必须在协程的作用域中才能调用，其次它会在当前协程的作用域下创建子协程。子协程的特点是如果外层作用域的协程结束了，该作用域下的所有子协程也会一同结束。相比而言，<code>GlobalScope.launch</code>函数创建的永远是顶层协程，这一点和线程比较像，因为线程也没有层级这一说，永远都是顶层的。</p><p>这里我们调用了两次<strong>launch</strong>函数，也就是创建了两个子协程。打印结果如下</p><p><img src="https://pic.ziyuan.wang/user/guest/2024/02/1709102783783_31d25f330b374.png" alt="1709102783783.png"></p><p>可以看到，两个子协程中的日志是交替打印的，说明它们确实是像多线程那样并发运行的。然而这两个子协程实际却运行在同一个线程当中，只是由编程语言来决定如何在多个协程之间进行调度，让谁运行，让谁挂起。调度的过程完全不需要操作系统参与，这也就使得协程的并发效率会出奇得高。</p><p>那么具体会有多高呢？接下来做个实验。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">100000</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> end = System.currentTimeMillis()</span><br><span class="line">    println(end - start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<strong>repeat</strong>函数循环创建了10万个协程，不过在协程当中并没有进行什么有意义的操作，只是象征性地打印了一个点，然后记录一下整个操作的运行耗时。现在重新运行一下程序，结果如下：</p><p><img src="https://pic.ziyuan.wang/user/guest/2024/02/1709103029256_9a71690c55802.png" alt="1709103029256.png"></p><p>可以看到，这里仅仅耗时了541毫秒，这足以证明协程有多么高效。试想一下，如果开启的是10万个线程，程序或许已经出现OOM异常了。</p><p>不过，随着<strong>launch</strong>函数中的逻辑越来越复杂，可能你需要将部分代码提取到一个单独的函数中。这个时候就产生了一个问题：我们在<strong>launch</strong>函数中编写的代码是拥有协程作用域的，但是提取到一个单独的函数中就没有协程作用域了，那么我们该如何调用像<code>delay()</code>这样的挂起函数呢？</p><p>为此<strong>Kotlin</strong>提供了一个<strong>suspend</strong>关键字，<strong>使用它可以将任意函数声明成挂起函数，而挂起函数之间都是可以互相调用的</strong>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在<code>printDot()</code>函数中调用<code>delay()</code>函数了。</p><p>但是，<strong>suspend</strong>关键字只能将一个函数声明成挂起函数，是无法给它提供协程作用域的。比如你现在尝试在<code>printDot()</code>函数中调用<strong>launch</strong>函数，一定是无法调用成功的，因为<strong>launch</strong>函数要求必须在协程作用域当中才能调用。</p><p>这个问题可以借助<strong>coroutineScope</strong>函数来解决。<strong>coroutineScope</strong>函数也是一个挂起函数，因此可以在任何其他挂起函数中调用。它的特点是会继承外部的协程的作用域并创建一个子协程，借助这个特性，我们就可以给任意挂起函数提供协程作用域了。示例写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> = coroutineScope &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，现在我们就可以在<code>printDot()</code>这个挂起函数中调用<strong>launch</strong>函数了。另外，<strong>coroutineScope</strong>函数和<strong>runBlocking</strong>函数还有点类似，它可以保证其作用域内的所有代码和子协程在全部执行完之前，外部的协程会一直被挂起。我们来看如下示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">                    println(i)</span><br><span class="line">                    delay(<span class="number">200</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;coroutineScope finished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;runBlocking finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先使用<strong>runBlocking</strong>函数创建了一个协程作用域，然后调用<strong>coroutineScope</strong>函数创建了一个子协程。在<strong>coroutineScope</strong>的作用域中，我们又调用<strong>launch</strong>函数创建了一个子协程，并通过for循环依次打印数字1到10，每次打印间隔一秒钟。最后在<strong>runBlocking</strong>和<strong>coroutineScope</strong>函数的结尾，分别又打印了一行日志。现在重新运行一下程序，结果如图:</p><p><img src="https://pic.ziyuan.wang/user/guest/2024/02/1709104874406_707690775e9a7.png" alt="1709104874406.png"></p><p>你会看到，控制台会以200ms的间隔依次输出数字1到10，然后才会打印<strong>coroutineScope</strong>函数结尾的日志，最后打印<strong>runBlocking</strong>函数结尾的日志。</p><p>由此可见，<strong>coroutineScope</strong>函数确实是将外部协程挂起了，只有当它作用域内的所有代码和子协程都执行完毕之后，<strong>coroutineScope</strong>函数之后的代码才能得到运行。</p><p>虽然看上去<strong>coroutineScope</strong>函数和<strong>runBlocking</strong>函数的作用是有点类似的，但是<strong>coroutineScope</strong>函数只会阻塞当前协程，既不影响其他协程，也不影响任何线程，因此是不会造成任何性能上的问题的。而<strong>runBlocking函数由于会挂起外部线程，如果你恰好又在主线程中当中调用它的话，那么就有可能会导致界面卡死的情况，所以不太推荐在实际项目中使用。</strong></p><h3 id="9-2-更多的作用域构建器"><a href="#9-2-更多的作用域构建器" class="headerlink" title="9.2 更多的作用域构建器"></a>9.2 更多的作用域构建器</h3><p>我们学习了<code>GlobalScope.launch</code>、<code>runBlocking</code>、<code>launch</code>、<code>coroutineScope</code>这几种作用域构建器，它们都可以用于创建一个新的协程作用域。<strong>不过<code>GlobalScope.launch</code>和<code>runBlocking</code>函数是可以在任意地方调用的，<code>coroutineScope</code>函数可以在协程作用域或挂起函数中调用，而<code>launch</code>函数只能在协程作用域中调用。</strong></p><p>前面已经说了，<code>runBlocking</code>由于会阻塞线程，因此只建议在测试环境下使用。而<code>GlobalScope.launch</code>由于每次创建的都是顶层协程，一般也不太建议使用，除非你非常明确就是要创建顶层协程。</p><p>为什么说不太建议使用顶层协程呢？主要还是因为它管理起来成本太高了。举个例子，比如我们在某个<strong>Activity</strong>中使用协程发起了一条网络请求，由于网络请求是耗时的，用户在服务器还没来得及响应的情况下就关闭了当前<strong>Activity</strong>，此时按理说应该取消这条网络请求，或者至少不应该进行回调，因为<strong>Activity</strong>已经不存在了，回调了也没有意义。</p><p>那么协程要怎样取消呢？不管是<code>GlobalScope.launch</code>函数还是<code>launch</code>函数，它们都会返回一个<strong>Job</strong>对象，只需要调用<strong>Job</strong>对象的<code>cancel()</code>方法就可以取消协程了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure><p>但是如果我们每次创建的都是顶层协程，那么当<strong>Activity</strong>关闭时，就需要逐个调用所有已创建协程的<code>cancel()</code>方法，试想一下，这样的代码是不是根本无法维护？</p><p>因此，<code>GlobalScope.launch</code>这种协程作用域构建器，在实际项目中也是不太常用的。下面演示一下实际项目中比较常用的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure><p>可以看到，我们先创建了一个<strong>Job</strong>对象，然后把它传入<code>CoroutineScope()</code>函数当中，注意这里的<code>CoroutineScope()</code>是个函数，虽然它的命名更像是一个类。<code>CoroutineScope()</code>函数会返回一个<strong>CoroutineScope</strong>对象，这种语法结构的设计更像是我们创建了一个<strong>CoroutineScope</strong>的实例，可能也是<strong>Kotlin</strong>有意为之的。有了<strong>CoroutineScope</strong>对象之后，就可以随时调用它的<strong>launch</strong>函数来创建一个协程了。</p><p>现在所有调用<strong>CoroutineScope</strong>的<strong>launch</strong>函数所创建的协程，都会被关联在<strong>Job</strong>对象的作用域下面。这样只需要调用一次<code>cancel()</code>方法，就可以将同一作用域内的所有协程全部取消，从而大大降低了协程管理的成本。</p><p><strong>不过相比之下，<code>CoroutineScope()</code>函数更适合用于实际项目当中，如果只是在<code>main()</code>函数中编写一些学习测试用的代码，还是使用runBlocking函数最为方便。</strong></p><p>我们已经知道了调用<strong>launch</strong>函数可以创建一个新的协程，但是<strong>launch</strong>函数只能用于执行一段逻辑，却不能获取执行的结果，因为它的返回值永远是一个<strong>Job</strong>对象。<strong>那么有没有什么办法能够创建一个协程并获取它的执行结果呢？当然有，使用async函数就可以实现。</strong></p><p><strong>async</strong>函数必须在协程作用域当中才能调用，它会创建一个新的子协程并返回一个<strong>Deferred</strong>对象，如果我们想要获取<strong>async</strong>函数代码块的执行结果，只需要调用<strong>Deferred</strong>对象的<code>await()</code>方法即可，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runBlocking &#123;</span><br><span class="line"><span class="keyword">val</span> result = async &#123;</span><br><span class="line"><span class="number">5</span> + <span class="number">5</span></span><br><span class="line">&#125;.await()</span><br><span class="line">println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在<strong>async</strong>函数的代码块中进行了一个简单的数学运算，然后调用<code>await()</code>方法获取运算结果，最终将结果打印出来。重新运行一下代码，发现控制台会打印一个10。</p><p>不过<strong>async</strong>函数的奥秘还不止于此。事实上，在调用了<strong>async</strong>函数之后，代码块中的代码就会立刻开始执行。<strong>当调用<code>await()</code>方法时，如果代码块中的代码还没执行完，那么<code>await()</code>方法会将当前协程阻塞住，直到可以获得async函数的执行结果。</strong></p><p>做个小实验：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">4</span>+<span class="number">6</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">        println(<span class="string">&quot;result is <span class="subst">$&#123;result1 + result2&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> end = System.currentTimeMillis()</span><br><span class="line">        println(<span class="string">&quot;cost <span class="subst">$&#123;end - start&#125;</span>ms.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里连续使用了两个<strong>async</strong>函数来执行任务，并在代码块中调用<code>delay()</code>方法进行1秒的延迟。按照刚才的理论，<code>await()</code>方法在<strong>async</strong>函数代码块中的代码执行完之前会一直将当前协程阻塞住，那么为了便于验证，我们记录了代码的运行耗时。现在重新运行程序，结果如下：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1709106260693_4f1cc4e6044bf.png" alt="1709106260693.png"></p><p>可以看到，整段代码的运行耗时是2033毫秒，说明这里的两个async函数确实是一种串行的关系，前一个执行完了后一个才能执行。</p><p>但是这种写法明显是非常低效的，因为两个<strong>async</strong>函数完全可以同时执行从而提高运行效率。现在对上述代码使用如下的写法进行修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> result1 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result2 = async &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            <span class="number">4</span>+<span class="number">6</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;result is <span class="subst">$&#123;result1.await() + result2.await()&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> end = System.currentTimeMillis()</span><br><span class="line">        println(<span class="string">&quot;cost <span class="subst">$&#123;end - start&#125;</span>ms.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们不在每次调用<strong>async</strong>函数之后就立刻使用<code>await()</code>方法获取结果了，而是仅在需要用到<strong>async</strong>函数的执行结果时才调用<code>await()</code>方法进行获取，这样两个<strong>async</strong>函数就变成一种并行关系了。重新运行程序，结果如下所示。</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1709106396465_060e075f6b533.png" alt="1709106396465.png"></p><p>可以看到，现在整段代码的运行耗时变成了1013毫秒，运行效率的提升显而易见。</p><p>最后，再来学习一个比较特殊的作用域构建器：<code>withContext()</code>函数。<code>withContext()</code>函数是一个挂起函数，大体可以将它理解成<strong>async</strong>函数的一种简化版写法，示例写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123; </span><br><span class="line">        <span class="keyword">val</span> result = withContext(Dispatchers.Default) &#123;</span><br><span class="line">            <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>withContext()</code>函数之后，会立即执行代码块中的代码，同时将外部协程挂起。当代码块中的代码全部执行完之后，会将最后一行的执行结果作为<code>withContext()</code>函数的返回值返回，因此基本上相当于<code>val result = async&#123; 5 + 5&#125;.await()</code>的写法。唯一不同的是，<code>withContext()</code>函数强制要求我们指定一个线程参数。</p><p>协程是一种轻量级的线程的概念，因此很多传统编程情况下需要开启多线程执行的并发任务，现在只需要在一个线程下开启多个协程来执行就可以了。但是这并不意味着我们就永远不需要开启线程了，<strong>比如说Android中要求网络请求必须在子线程中进行，即使你开启了协程去执行网络请求，假如它是主线程当中的协程，那么程序仍然会出错。这个时候我们就应该通过线程参数给协程指定一个具体的运行线程。</strong></p><p>线程参数主要有以下3种值可选：<code>Dispatchers.Default</code>、<code>Dispatchers.IO</code>和<code>Dispatchers.Main</code>。<code>Dispatchers.Default</code>表示会使用一种<strong>默认低并发的线程策略</strong>，当你要执行的代码属于<strong>计算密集型任务</strong>时，开启过高的并发反而可能会影响任务的运行效率，此时就可以使用<code>Dispatchers.Default</code>。<code>Dispatchers.IO</code>表示会使用一种<strong>较高并发的线程策略</strong>，当你要执行的代码<strong>大多数时间是在阻塞和等待</strong>中，比如说<strong>执行网络请求</strong>时，为了<strong>能够支持更高的并发数量</strong>，此时就可以使用<code>Dispatchers.IO</code>。**<code>Dispatchers.Main</code>则表示不会开启子线程<strong>，而是</strong>在Android主线程中执行代码<strong>，但是</strong>这个值只能在Android项目中使用，纯Kotlin程序使用这种类型的线程参数会出现错误。**</p><p>事实上，在我们刚才所学的协程作用域构建器中，<strong>除了<code>coroutineScope</code>函数之外，其他所有的函数都是可以指定这样一个线程参数的，只不过<code>withContext()</code>函数是强制要求指定的，而其他函数则是可选的</strong>。</p><h3 id="9-3-使用协程简化回调写法"><a href="#9-3-使用协程简化回调写法" class="headerlink" title="9.3 使用协程简化回调写法"></a>9.3 使用协程简化回调写法</h3><p>之前学习了编程语言的回调机制，并使用这个机制实现了获取异步网络请求数据响应的功能。回调机制基本上是依靠匿名类来实现的，但是匿名类的写法通常比较烦琐，比如如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HttpUtil.sendHttpRequest(address, <span class="keyword">object</span> : HttpCallbackListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在多少个地方发起网络请求，就需要编写多少次这样的匿名类实现。还有没有更加简单一点的写法呢？</p><p>在过去，可能确实没有什么更加简单的写法了。不过现在，Kotlin的协程使我们的这种设想成为了可能，只需要借助<code>suspendCoroutine</code>函数就能将传统回调机制的写法大幅简化，下面我们就来具体学习一下。</p><p><code>suspendCoroutine</code>函数必须在协程作用域或挂起函数中才能调用，它接收一个<strong>Lambda</strong>表达式参数，主要作用是将当前协程立即挂起，然后在一个普通的线程中执行<strong>Lambda</strong>表达式中的代码。<strong>Lambda</strong>表达式的参数列表上会传入一个<strong>Continuation</strong>参数，调用它的<code>resume()</code>方法或<code>resumeWithException()</code>可以让协程恢复执行。</p><p>了解了<code>suspendCoroutine</code>函数的作用之后，接下来我们就可以借助这个函数来对传统的回调写法进行优化。首先定义一个<code>request()</code>函数，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(address: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        HttpUtil.sendHttpRequest(address, <span class="keyword">object</span> : HttpCallbackListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>request()</code>函数是一个挂起函数，并且接收一个<strong>address</strong>参数。在<code>request()</code>函数的内部，我们调用了刚刚介绍的<code>suspendCoroutine</code>函数，这样当前协程就会被立刻挂起，而<strong>Lambda</strong>表达式中的代码则会在普通线程中执行。接着我们在<strong>Lambda</strong>表达式中调用<code>HttpUtil.sendHttpRequest()</code>方法发起网络请求，并通过传统回调的方式监听请求结果。如果请求成功就调用<code>Continuation</code>的<code>resume()</code>方法恢复被挂起的协程，并传入服务器响应的数据，该值会成为<code>suspendCoroutine</code>函数的返回值。如果请求失败，就调用<code>Continuation</code>的<code>resumeWithException()</code>恢复被挂起的协程，并传入具体的异常原因。</p><p>可是这里不是仍然使用了传统回调的写法吗？代码怎么就变得更加简化了？这是因为，不管之后我们要发起多少次网络请求，都不需要再重复进行回调实现了。比如说获取百度首页的响应数据，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBaiduResponse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = request(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>getBaiduResponse()</code>是一个挂起函数，因此当它调用了<code>request()</code>函数时，当前的协程就会被立刻挂起，然后一直等待网络请求成功或失败后，当前协程才能恢复运行。这样即使不使用回调的写法，我们也能够获得异步网络请求的响应数据，而如果请求失败，则会直接进入<strong>catch</strong>语句当中。</p><p>可是<code>getBaiduResponse()</code>函数被声明成了挂起函数，这样它也只能在协程作用域或其他挂起函数中调用了，使用起来是不是非常有局限性？确实如此，因为<code>suspendCoroutine</code>函数本身就是要结合协程一起使用的。不过通过合理的项目架构设计，我们可以轻松地将各种协程的代码应用到一个普通的项目当中。</p><p>事实上，<code>suspendCoroutine</code>函数几乎可以用于简化任何回调的写法，比如使用<code>Retrofit</code>来发起网络请求需要这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appService = ServiceCreator.create&lt;AppService&gt;()</span><br><span class="line">appService.getAppData().enqueue(<span class="keyword">object</span> : Callback&lt;List&lt;App&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, response: <span class="type">Response</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>suspendCoroutine</code>函数，我们马上就能对上述写法进行大幅度的简化。由于不同的<code>Service</code>接口返回的数据类型也不同，所以这次我们不能像刚才那样针对具体的类型进行编程了，而是要使用泛型的方式。定义一个<code>await()</code>函数，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Call<span class="type">&lt;T&gt;</span>.<span class="title">await</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123;</span><br><span class="line">        enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123; continuation -&gt;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> body = response.body()</span><br><span class="line">                <span class="keyword">if</span> (body != <span class="literal">null</span>) continuation.resume(body)</span><br><span class="line">                <span class="keyword">else</span> continuation.resumeWithException(RuntimeException(<span class="string">&quot;reponse body is null&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                continuation.resumeWithException(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相比于刚才的<code>request()</code>函数又复杂了一点。首先<code>await()</code>函数仍然是一个挂起函数，然后我们给它声明了一个泛型T，并将<code>await()</code>函数定义成了<code>Call&lt;T&gt;</code>的扩展函数，这样所有返回值是<strong>Call</strong>类型的<code>Retrofit</code>网络请求接口就都可以直接调用<code>await()</code>函数了。</p><p>接着，<code>await()</code>函数中使用了<code>suspendCoroutine</code>函数来挂起当前协程，并且由于扩展函数的原因，我们现在拥有了<strong>Call</strong>对象的上下文，那么这里就可以直接调用<code>enqueue()</code>方法让<code>Retrofit</code>发起网络请求。接下来，使用同样的方式对<code>Retrofit</code>响应的数据或者网络请求失败的情况进行处理就可以了。另外还有一点需要注意，在<code>onResponse()</code>回调当中，我们调用<code>body()</code>方法解析出来的对象是可能为空的。如果为空的话，这里的做法是手动抛出一个异常，你也可以根据自己的逻辑进行更加合适的处理。</p><p>有了<code>await()</code>函数之后，我们调用所有<code>Retrofit</code>的<strong>Service</strong>接口都会变得极其简单，比如刚才同样的功能就可以使用如下写法进行实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAppData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> appList = ServiceCreator.create&lt;Appservice&gt;().getAppdata().await()</span><br><span class="line">        <span class="comment">// 对服务器响应的数据进行处理</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="comment">// 对异常情况进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有了冗长的匿名类实现，只需要简单调用一下await()函数就可以让Retrofit发起网络请求，并直接获得服务器响应的数据，有没有觉得代码变得极其简单？当然你可能会觉得，每次发起网络请求都要进行一次try catch处理也比较麻烦，其实这里我们也可以选择不处理。在不处理的情况下，如果发生了异常就会一层层向上抛出，一直到被某一层的函数处理了为止。因此，我们也可以在某个统一的入口函数中只进行一次try catch，从而让代码变得更加精简。</p><hr><h2 id="十、编写好用的工具方法"><a href="#十、编写好用的工具方法" class="headerlink" title="十、编写好用的工具方法"></a>十、编写好用的工具方法</h2><p>到目前为止，我们已经将<strong>Kotlin</strong>大部分系统性的知识点学习完了。掌握了如此多的<strong>Kotlin</strong>特性，还需要知道该如何对它们进行灵活运用。</p><p>事实上，<strong>Kotlin</strong>提供的丰富语法特性给我们提供了无限扩展的可能，各种复杂的<strong>API</strong>经过特殊的封装处理之后都能变得简单易用。但是最重要的还是我们要能养成对<strong>Kotlin</strong>的各种特性进行灵活运用的意识。</p><h3 id="10-1-求N个数的最大最小值"><a href="#10-1-求N个数的最大最小值" class="headerlink" title="10.1 求N个数的最大最小值"></a>10.1 求N个数的最大最小值</h3><p>两个数比大小这个功能，相信每一位开发者都遇到过。如果我想要获取两个数中较大的那个数，除了使用最基本的if语句之外，还可以借助<strong>Kotlin</strong>内置的<code>max()</code>函数，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">15</span></span><br><span class="line"><span class="keyword">val</span> larger = max(a,b)</span><br></pre></td></tr></table></figure><p>这种代码看上去简单直观，也很容易理解，因此好像并没有什么优化的必要。</p><p>可是现在如果我们想要在3个数中获取最大的那个数，应该怎么写呢？由于max()函数只能接收两个参数，因此需要先比较前两个数的大小，然后再拿较大的那个数和剩余的数进行比较，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">15</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> larger = max(max(a,b),c)</span><br></pre></td></tr></table></figure><p>有没有觉得代码开始变得复杂了呢？3个数中获取最大值就需要使用这种嵌套max()函数的写法<br>了，那如果是4个数、5个数呢？没错，这个时候你就应该意识到，我们是可以对max()函数的<br>用法进行简化的。</p><p>回顾一下，我们之前学过<code>vararg</code>关键字，它允许方法接收任意多个同等类型的参数，正好满足我们这里的需求。那么我们就可以新建一个<code>Max.kt</code>文件，并在其中自定义一个<code>max()</code>函数，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(<span class="keyword">vararg</span> nums: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxNum = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span>(num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        maxNum = kotlin.math.max(maxNum, num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里<code>max()</code>函数的参数声明中使用了<code>vararg</code>关键字，也就是说现在它可以接收任意多个整型参数。接着我们使用了一个<code>maxNum</code>变量来记录所有数的最大值，并在一开始将它赋值成了整型范围的最小值。然后使用<code>for-in</code>循环遍历<strong>nums</strong>参数列表，如果发现当前遍历的数字比<code>maxNum</code>更大，就将<code>maxNum</code>的值更新成这个数，最终将<code>maxNum</code>返回即可。</p><p>仅仅经过这样的一层封装之后，我们在使用<code>max()</code>函数时就会有翻天覆地的变化，比如刚才同样的功能，现在就可以使用如下的写法来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">15</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> largest = max(a, b, c)</span><br></pre></td></tr></table></figure><p>这样我们就彻底摆脱了嵌套函数调用的写法，现在不管是求3个数的最大值还是求N个数的最大值，只需要不断地给<code>max()</code>函数传入参数就可以了。</p><p>不过，目前我们自定义的<code>max()</code>函数还有一个缺点，就是它只能求N个整型数字的最大值，如果我还想求N个浮点型或长整型数字的最大值，该怎么办呢？当然你可以定义很多个<code>max()</code>函数的重载，来接收不同类型的参数，因为<strong>Kotlin</strong>中内置的<code>max()</code>函数也是这么做的。但是这种方案实现起来过于烦琐，而且还会产生大量的重复代码，因此这里我准备使用一种更加巧妙的做法。</p><p>Java中规定，所有类型的数字都是可比较的，因此必须实现<strong>Comparable</strong>接口，这个规则在<strong>Kotlin</strong>中也同样成立。那么我们就可以借助泛型，将<code>max()</code>函数修改成接收任意多个实现<strong>Comparable</strong>接口的参数，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">max</span><span class="params">(<span class="keyword">vararg</span> nums: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty() <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Params can not be empty&quot;</span>))</span><br><span class="line">    <span class="keyword">var</span> maxNum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">            maxNum = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，<code>&lt;T: Comparable&lt;T&gt;&gt;</code> 是一个泛型约束。这表示类型 <code>T</code> 必须实现 <code>Comparable</code> 接口，这样我们才能在函数体内部使用 <code>&gt;</code> 操作符来比较 <code>T</code> 类型的对象。</p><p>在 Kotlin 中，所有的比较操作符（如 <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>）都定义在 <code>Comparable</code> 接口中。因此，如果我们想在一个泛型函数中使用这些操作符，我们就需要确保泛型类型 <code>T</code> 实现了 <code>Comparable</code> 接口。这就是为什么我们需要写 <code>&lt;T: Comparable&lt;T&gt;&gt;</code> 的原因。这样，无论 <code>T</code> 是什么类型，只要它实现了 <code>Comparable</code> 接口，我们就可以在函数中使用比较操作符。这使得我们的函数更加灵活和通用。例如，我们可以使用这个函数来找出一组整数、浮点数或者字符串中的最大值，因为这些类型都实现了 <code>Comparable</code> 接口。</p><p>这里将泛型<code>T</code>的上界指定成了<code>Comparable&lt;T&gt;</code>，<strong>那么参数<code>T</code>就必然是<code>Comparable&lt;T&gt;</code>的子类型了</strong>。接下来，我们判断nums参数列表是否为空，如果为空的话就主动抛出一个异常，提醒调用者<code>max()</code>函数必须传入参数。紧接着将<code>maxNum</code>的值赋值成nums参数列表中第一个参数的值，然后同样是遍历参数列表，如果发现了更大的值就对<code>maxNum</code>进行更新。</p><p>经过这样的修改之后，我们就可以更加灵活地使用<code>max()</code>函数了，比如说求3个浮点型数字的最大值，同样也变得轻而易举：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">3.5</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">3.8</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">4.1</span></span><br><span class="line"><span class="keyword">val</span> largest = max(a, b, c)</span><br></pre></td></tr></table></figure><p>而且现在不管是双精度浮点型、单精度浮点型，还是短整型、整型、长整型，只要是实现Comparable接口的子类型，max()函数全部支持获取它们的最大值，是一种一劳永逸的做法。</p><p>而如果你想获取N个数的最小值，实现的方式也是类似的，只需要定义一个min()函数就可以了:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">min</span><span class="params">(<span class="keyword">vararg</span> nums: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty() <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Params can not be empty&quot;</span>))</span><br><span class="line">    <span class="keyword">var</span> minNum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; minNum) &#123;</span><br><span class="line">            minNum = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-简化Toast的用法"><a href="#10-2-简化Toast的用法" class="headerlink" title="10.2 简化Toast的用法"></a>10.2 简化Toast的用法</h3><p>首先回顾一下Toast的标准用法吧，如果想要在界面上弹出一段文字提示需要这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(context, <span class="string">&quot;this is Toast&quot;</span>, Toast.LENGTH_SHORT).show()</span><br></pre></td></tr></table></figure><p>是不是很长的一段代码？而且曾经不知道有多少人因为忘记调用最后的<code>show()</code>方法，导致Toast无法弹出，从而产生一些千奇百怪的bug。</p><p>由于Toast是非常常用的功能，每次都需要编写这么长的一段代码确实让人很头疼，这个时候你就应该考虑对Toast的用法进行简化了。</p><p>我们来分析一下，Toast的<code>makeText()</code>方法接收3个参数：第一个参数是Toast显示的上下文环境，必不可少；第二个参数是Toast显示的内容，需要由调用方进行指定，可以传入字符串和字符串资源id两种类型；第三个参数是Toast显示的时长，只支持<code>Toast.LENGTH_SHORT</code>和<code>Toast.LENGTH_LONG</code>这两种值，相对来说变化不大。</p><p>那么我们就可以给String类和Int类各添加一个扩展函数，并在里面封装弹出Toast的具体逻辑。这样以后每次想要弹出Toast提示时，只需要调用它们的扩展函数就可以了。</p><p>新建一个Toast.kt文件，并在其中编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">&quot;this is Toast&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">&quot;this is Toast&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分别给String类和Int类新增了一个<code>showToast()</code>函数，并让它们都接收一个Context参数。然后在函数的内部，我们仍然使用了Toast原生API用法，只是将弹出的内容改成了this，另外将Toast的显示时长固定设置成<code>Toast.LENGTH_SHORT</code>。</p><p>以后如果要弹出一段文字提醒，可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is Toast&quot;</span>.showToast(context)</span><br></pre></td></tr></table></figure><p>另外，这只是直接弹出一段字符串文本的写法，如果你想弹出一个定义在<code>strings.xml</code>中的字符串资源，也非常简单，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.string.app_name.showToast(context)</span><br></pre></td></tr></table></figure><p>这两种写法分别调用的就是我们刚才在String类和Int类中添加的<code>showToast()</code>扩展函数。当然，这种写法其实还存在一个问题，就是Toast的显示时长被固定了，如果我现在想要使用<code>Toast.LENGTH_LONG</code>类型的显示时长该怎么办呢？要解决这个问题，其实最简单的做法就是在<code>showToast()</code>函数中再声明一个显示时长参数，但是这样每次调用<code>showToast()</code>函数时都要额外多传入一个参数，无疑增加了使用复杂度。使用给函数设定参数默认值的功能，我们就可以在不增加<code>showToast()</code>函数使用复杂度的情况下，又让它可以支持动态指定显示时长了。修改<code>Toast.kt</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">Toast.makeText(context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">showToast</span><span class="params">(context: <span class="type">Context</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">Toast.makeText(context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们给<code>showToast()</code>函数增加了一个显示时长参数，但同时也给它指定了一个参数默认值。这样我们之前所使用的<code>showToast()</code>函数的写法将完全不受影响，默认会使用<code>Toast.LENGTH_SHORT</code>类型的显示时长。而如果你想要使用<code>Toast.LENGTH_LONG</code>的显示时长，只需要这样写就可以了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is Toast&quot;</span>.showToast(context, Toast.LENGTH_LONG)</span><br></pre></td></tr></table></figure><h3 id="10-3-简化Snackbar的用法"><a href="#10-3-简化Snackbar的用法" class="headerlink" title="10.3 简化Snackbar的用法"></a>10.3 简化Snackbar的用法</h3><p>先来回顾一下Snackbar的常规用法吧，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Snackbar.make(view, <span class="string">&quot;This is Snackbar&quot;</span>, Snackbar.LENGTH_SHORT)</span><br><span class="line">.setAction(<span class="string">&quot;Action&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">.show()</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Snackbar</strong>中<code>make()</code>方法的第一个参数变成了<strong>View</strong>，而<strong>Toast</strong>中<code>makeText()</code>方法的第一个参数是<strong>Context</strong>，另外<strong>Snackbar还可以调用<code>setAction()</code>方法来设置一个额外的点击事件</strong>。除了这些区别之外，<strong>Snackbar</strong>和<strong>Toast</strong>的其他用法都是相似的。</p><p>那么对于这种结构的API，我们该如何进行简化呢？其实简化的方式并不固定。</p><p>由于<code>make()</code>方法接收一个View参数，<strong>Snackbar</strong>会使用这个<strong>View</strong>自动查找最外层的布局，用于展示<strong>Snackbar</strong>。因此，我们就可以给<strong>View</strong>类添加一个扩展函数，并在里面封装显示<strong>Snackbar</strong>的具体逻辑。新建一个<code>Snackbar.kt</code>文件，并编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(text: <span class="type">String</span>, duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Snackbar.make(<span class="keyword">this</span>, text, duration).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(resId: <span class="type">Int</span>, duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Snackbar.make(<span class="keyword">this</span>, resId, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该还是很好理解的，和刚才的showToast()函数比较相似。只是我们将扩展函数添加到了View类当中，并在参数列表上声明了Snackbar要显示的内容以及显示的时长。另外，Snackbar和Toast类似，显示的内容也是支持传入字符串和字符串资源id两种类型的，因此这里我们给showSnackbar()函数进行了两种参数类型的函数重载。</p><p>现在想要使用Snackbar显示一段文本提示，只需要这样写就可以了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.showSnackbar(<span class="string">&quot;This is Snackbar&quot;</span>)</span><br></pre></td></tr></table></figure><p>假如<strong>Snackbar</strong>没有<code>setAction()</code>方法，那么我们的简化工作到这里就可以结束了。但是<code>setAction()</code>方法作为<strong>Snackbar</strong>最大的特色之一，如果不能支持的话，我们编写的<code>showSnackbar()</code>函数也就变得毫无意义了。</p><p>这个时候，神通广大的高阶函数又能派上用场了，我们可以让<code>showSnackbar()</code>函数再额外接收一个函数类型参数，以此来实现<strong>Snackbar</strong>的完整功能支持。修改<code>Snackbar.kt</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    text: <span class="type">String</span>, actionText: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT, block: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> snackbar = Snackbar.make(<span class="keyword">this</span>, text, duration)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionText != <span class="literal">null</span> &amp;&amp; block != <span class="literal">null</span>) &#123;</span><br><span class="line">        snackbar.setAction(actionText) &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showSnackbar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    resId: <span class="type">Int</span>, actionText: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    duration: <span class="type">Int</span> = Snackbar.LENGTH_SHORT, block: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> snackbar = Snackbar.make(<span class="keyword">this</span>, resId, duration)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionText != <span class="literal">null</span> &amp;&amp; block != <span class="literal">null</span>) &#123;</span><br><span class="line">        snackbar.setAction(actionText) &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    snackbar.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，<code>block()</code> 是一个可调用的 lambda 函数。当你调用 <code>showSnackbar</code> 方法并传入一个 lambda 函数作为 <code>block</code> 参数时，这个 lambda 函数就会替换 <code>block()</code>。</p><p>例如，如果你这样调用 <code>showSnackbar</code> 方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.showSnackbar(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;Action&quot;</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;Action clicked!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在 <code>snackbar.setAction(actionText) &#123; block() &#125;</code> 这行代码中，<code>block()</code> 就会被替换为 <code>println(&quot;Action clicked!&quot;)</code>。所以，当用户点击 Snackbar 的操作文本时，控制台就会打印出 “Action clicked!”。</p><p>可以看到，这里我们给两个<code>showSnackbar()</code>函数都增加了一个函数类型参数，并且还增加了一个用于传递给<code>setAction()</code>方法的字符串或字符串资源id。这里我们需要将新增的两个参数都设置成可为空的类型，并将默认值都设置成空，然后只有当两个参数都不为空的时候，我们才去调用<strong>Snackbar</strong>的<code>setAction()</code>方法来设置额外的点击事件。如果触发了点击事件，只需要调用函数类型参数将事件传递给外部的Lambda表达式即可。</p><p>这样<code>showSnackbar()</code>函数就拥有比较完整的<strong>Snackbar</strong>功能了，比如本小节最开始的那段示例代码，现在就可以使用如下写法进行实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.showSnackbar(<span class="string">&quot;This is Snackbar&quot;</span>, <span class="string">&quot;Action&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="十一、使用DSL构建专有的语法结构"><a href="#十一、使用DSL构建专有的语法结构" class="headerlink" title="十一、使用DSL构建专有的语法结构"></a>十一、使用DSL构建专有的语法结构</h2><p><strong>DSL</strong>的全称是领域特定语言（<strong>Domain Specific Language</strong>），它是编程语言赋予开发者的一种特殊能力，通过它我们可以编写出一些看似脱离其原始语法结构的代码，从而构建出一种专有的语法结构。</p><p>毫无疑问，Kotlin也是支持DSL的，并且在Kotlin中实现DSL的实现方式并不固定，比如我们之前使用infix函数构建出的特有语法结构就属于DSL。不过本节课我们的主要学习目标是通过高阶函数的方式来实现DSL，这也是Kotlin中实现DSL最常见的方式。</p><p>当我们想要在项目中添加一些依赖库，需要在build.gradle文件中添加依赖时其实就使用了DSL，例如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation &#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;</span><br><span class="line">implementation &#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle是一种基于Groovy语言的构建工具，因此上述的语法结构其实就是Groovy提供的DSL功能。有没有觉得很神奇？不用吃惊，借助Kotlin的DSL，我们也可以实现类似的语法结构，下面就来具体看一下吧。</p><p>首先新建一个DSL.kt文件，然后在里面定义一个Dependency类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> libraries = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">implementation</span><span class="params">(lib: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        libraries.add(lib)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了一个List集合来保存所有的依赖库，然后又提供了一个<code>implementation()</code>方法，用于向List集合中添加依赖库，代码非常简单。</p><p>接下来再定义一个<code>dependencies</code>高阶函数，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">(block: <span class="type">Dependency</span>.() -&gt; <span class="type">Unit</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> dependency = Dependency()</span><br><span class="line">    dependency.block()</span><br><span class="line">    <span class="keyword">return</span> dependency.libraries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>dependencies</code>函数接收一个函数类型参数，并且该参数是定义到Dependency类中的，因此调用它的时候需要先创建一个Dependency的实例，然后再通过该实例调用函数类型参数，这样传入的Lambda表达式就能得到执行了。最后，我们将Dependency类中保存的依赖库集合返回。</p><p>没错，经过这样的DSL设计之后，我们就可以在项目中使用如下的语法结构了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>dependencies</code>函数接收一个函数类型参数，因此这里我们可以传入一个Lambda表达式。而此时的Lambda表达式中拥有Dependency类的上下文，因此当然就可以直接调用Dependency类中的<code>implementation()</code>方法来添加依赖库了。</p><p>当然，这种语法结构和我们在<code>build.gradle</code>文件中使用的语法结构并不完全相同，这主要是因为Kotlin和Groovy在语法层面还是有一定差别的。</p><p>另外，我们也可以通过<code>dependencies</code>函数的返回值来获取所有添加的依赖库，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> libraries = dependencies &#123;</span><br><span class="line">        implementation(<span class="string">&quot;com.squareup.retrofit2:retrofit:2.6.1&quot;</span>)</span><br><span class="line">        implementation(<span class="string">&quot;com.squareup.retrofit2:converter-gson:2.6.1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (lib <span class="keyword">in</span> libraries) &#123;</span><br><span class="line">        println(lib)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用一个libraries变量接收<code>dependencies</code>函数的返回值，然后使用for-in循环将集合中的依赖库全部打印出来。</p><p>这种语法结构比起直接调用Dependency对象的<code>implementation()</code>方法要更直观一些，而且你会发现，需要添加的依赖库越多，使用DSL写法的优势就会越明显。在实现了一个较为简单的DSL之后，接下来我们再尝试编写一个复杂一点的DSL。</p><p>网页的展示都是由浏览器解析HTML代码来实现的。HTML中定义了很多标签，其中<table>标签用于创建一个表格，<tr>标签用于创建表格的行，<td>标签用于创建单元格。将这3种标签嵌套使用，就可以定制出包含任意行列的表格了。</p><p>那么如果现在有一个需求，要求我们在Kotlin中动态生成表格所对应的HTML代码，你会怎么做呢？最简单直接的方式就是字符串拼接了，但是这种做法显然十分烦琐，而且字符串拼接的代码也难以阅读。</p><p>这个时候DSL又可以大显身手了，借助DSL，我们可以以一种不可思议的语法结构来动态生成表格所对应的HTML代码，下面就来看一下具体应该如何实现吧。</p><p>仍然是在DSL.kt文件中进行编写，首先定义一个Td类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Td</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span> = <span class="string">&quot;\n\t\t&lt;td&gt;<span class="variable">$content</span>&lt;/td&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<td>标签表示一个单元格，其中必然是要包含内容的，因此这里我们使用了一个content字段来存储单元格中显示的内容。另外，还提供了一个html()方法，当调用这个方法时就返回一段<td>标签的HTML代码，并将content中存储的内容拼接进去。注意，为了让最终输出的结果更加直观，我使用了\n和\t转义符来进行换行和缩进，当然可以不加这些转义符，因为浏览器在解析HTML代码时是忽略换行和缩进的。</p><p>完成了Td类，接下来我们再定义一个Tr类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tr</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = ArrayList&lt;Td&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">td</span><span class="params">(block: <span class="type">Td</span>.() -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> td = Td()</span><br><span class="line">        td.content = td.block()</span><br><span class="line">        children.add(td)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">&quot;\n\t&lt;tr&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (childTag <span class="keyword">in</span> children) &#123;</span><br><span class="line">            builder.append(childTag.html())</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">&quot;\n\t&lt;/tr&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tr类相比于Td类就要复杂一些了。由于<tr>标签表示表格的行，它是可以包含多个<td>标签的，因此我们首先创建了一个children集合，用于存储当前Tr所包含的Td对象。接下来提供了一个td()函数，它接收一个定义到Td类中并且返回值是String的函数类型参数。当调用td()函数时，会先创建一个Td对象，接着调用函数类型参数并获取它的返回值，然后赋值到Td类的content字段当中，这样就可以将调用td()函数时传入的Lambda表达式的返回值赋值给content字段了。当然，这里既然创建了一个Td对象，就一定要记得将它添加到children集合当中。</p><p>另外，Tr类中也定义了一个html()方法，它的作用和刚才Td类中的html()方法一致。只是由于每个Tr都可能会包含很多个Td，因此我们需要使用循环来遍历children集合，将所有的子Td都拼接到<tr>标签当中，从而返回一段嵌套的HTML代码。</p><p>定义好了Tr类之后，我们现在就可以使用如下的语法格式来构建表格中的一行数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tr = Tr()</span><br><span class="line">tr.td &#123; <span class="string">&quot;Apple&quot;</span> &#125;</span><br><span class="line">tr.td &#123; <span class="string">&quot;Grape&quot;</span> &#125;</span><br><span class="line">tr.td &#123; <span class="string">&quot;Orange&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>那么接下来继续对DSL进行完善，再定义一个Table类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = ArrayList&lt;Tr&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tr</span><span class="params">(block: <span class="type">Tr</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tr = Tr()</span><br><span class="line">        tr.block()</span><br><span class="line">        children.add(tr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">&quot;&lt;table&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (childTag <span class="keyword">in</span> children) &#123;</span><br><span class="line">            builder.append(childTag)</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">&quot;&lt;/table&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相对就好理解多了，因为和刚才Tr类中的代码是比较相似的。Table类中同样创建了一个children集合，用于存储当前Table所包含的Tr对象。然后定义了一个tr()函数，它接收一个定义到Tr类中的函数类型参数。当调用tr()函数时，会先创建一个Tr对象，接着调用函数类型参数，这样Lambda表达式中的代码就能得到执行。最后，仍然要记得将创建的Tr对象添加到children集合当中。</p><p>除此之外，html()方法中的代码也都是类似的，这里遍历了children集合，将所有的子Tr对象都拼接到了<table>标签当中。</p><p>那么现在，我们就可以使用如下的语法结构来构建一个表格了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> table = Table()</span><br><span class="line">table.tr &#123;</span><br><span class="line">    td &#123; <span class="string">&quot;Apple&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Grape&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Orange&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">table.tr &#123;</span><br><span class="line">    td &#123; <span class="string">&quot;Pear&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Banana&quot;</span> &#125;</span><br><span class="line">    td &#123; <span class="string">&quot;Watermelon&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去已经相当不错了，不过这仍然不是最终版本，我们还可以再进一步对语法结构进行精简。定义一个table()函数，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">table</span><span class="params">(block: <span class="type">Table</span>.() -&gt; <span class="type">Unit</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> table = Table()</span><br><span class="line">    table.block()</span><br><span class="line">    <span class="keyword">return</span> table.html()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>table()</code>函数接收一个定义到Table类中的函数类型参数，当调用<code>table()</code>函数时，会先创建一个Table对象，接着调用函数类型参数，这样Lambda表达式中的代码就能得到执行。最后调用Table的<code>html()</code>方法获取生成的HTML代码，并作为最终的返回值返回。</p><p>编写了这么多代码之后，我们就可以使用如下神奇的语法结构来动态生成一个表格所对应的HTML代码了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/7-15:31</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> html = table &#123;</span><br><span class="line">        tr &#123;</span><br><span class="line">            td &#123; <span class="string">&quot;Apple&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Grape&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Orange&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tr &#123;</span><br><span class="line">            td &#123; <span class="string">&quot;Pear&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Banana&quot;</span> &#125;</span><br><span class="line">            td &#123; <span class="string">&quot;Watermelon&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(html)</span><br><span class="line">    println(html.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在DSL中也可以使用Kotlin的其他语法特性，比如通过循环来批量生成<tr>和<td>标签：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> html1 = table &#123;</span><br><span class="line">        repeat(<span class="number">2</span>) &#123;</span><br><span class="line">            tr &#123;</span><br><span class="line">                <span class="keyword">val</span> fruits = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> (fruit <span class="keyword">in</span> fruits) &#123;</span><br><span class="line">                    td &#123; fruit &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(html1.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>repeat()</code>函数来为表格生成两行数据，每行数据中又使用了<code>for-in</code>循环来遍历List集合，为表格填充具体的单元格数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、标准函数和静态方法&quot;&gt;&lt;a href=&quot;#一、标准函数和静态方法&quot; class=&quot;headerlink&quot; title=&quot;一、标准函数和静态方法&quot;&gt;&lt;/a&gt;一、标准函数和静态方法&lt;/h2&gt;&lt;h3 id=&quot;1-1-标准函数with、run和apply&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-使用网络技术</title>
    <link href="https://icu007work.github.io/archives/4a483fcb.html"/>
    <id>https://icu007work.github.io/archives/4a483fcb.html</id>
    <published>2024-03-13T07:37:24.000Z</published>
    <updated>2024-05-11T07:46:06.282Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在玩手机的时候不能上网，那你一定会感到特别地枯燥乏味。没错，现在早已不是玩单机的时代了，无论是PC、手机、平板，还是电视，都具备上网的功能， 21世纪的确是互联网的时代。</p><p>当然，Android手机肯定也是可以上网的。作为开发者，我们就需要考虑如何利用网络编写出更加出色的应用程序，像QQ、微博、微信等常见的应用都会大量使用网络技术。本章主要讲述如何在手机端使用HTTP和服务器进行网络交互，并对服务器返回的数据进行解析，这也是Android中最常使用到的网络技术，下面就让我们一起来学习一下吧。</p><h2 id="一、WebView的用法"><a href="#一、WebView的用法" class="headerlink" title="一、WebView的用法"></a>一、WebView的用法</h2><p>有时候我们可能会碰到一些比较特殊的需求，比如说在应用程序里展示一些网页。相信每个人都知道，加载和显示网页通常是浏览器的任务，但是需求里又明确指出，不允许打开系统浏览器，我们当然不可能自己去编写一个浏览器出来，这时应该怎么办呢？不用担心，<strong>Android</strong>早就考虑到了这种需求，并提供了一个<strong>WebView</strong>控件，借助它我们就可以在自己的应用程序里嵌入一个浏览器，从而非常轻松地展示各种各样的网页。<strong>WebView</strong>的用法也相当简单。新建一个<strong>WebViewTest</strong>项目，然后修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/webView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在布局文件中使用到了一个新的控件：<strong>WebView</strong>。这个控件就是用来显示网页的，这里的写法很简单，给它设置了一个id，并让它充满整个屏幕。然后修改<strong>MainActivity</strong>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.webviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebViewClient</span><br><span class="line"><span class="keyword">import</span> androidx.viewbinding.ViewBinding</span><br><span class="line"><span class="keyword">import</span> com.ubx.webviewtest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.webView.settings.javaScriptEnabled = <span class="literal">true</span></span><br><span class="line">        mainBinding.webView.webViewClient = WebViewClient()</span><br><span class="line">        mainBinding.webView.loadUrl(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MainActivity</code>中的代码也很短，通过<strong>WebView</strong>的<code>getSettings()</code>方法可以设置一些浏览器的属性，这里我们并没有设置过多的属性，只是调用了<code>setJavaScriptEnabled()</code>方法，让WebView支持JavaScript脚本。</p><p>接下来是比较重要的一个部分，我们调用了<strong>WebView</strong>的<code>setWebViewClient()</code>方法，并传入了一个<strong>WebViewClient</strong>的实例。这段代码的作用是，当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。</p><p>最后一步就非常简单了，调用<strong>WebView</strong>的<code>loadUrl()</code>方法，并将网址传入，即可展示相应网页的内容.</p><p>另外还需要注意，由于本程序使用到了网络功能，而访问网络是需要声明权限的，因此我们还得修改<code>AndroidManifest.xml</code>文件，并加入权限声明，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708236612706_7c011c4f58fe4.png" alt="1708236612706.png"></p><p>可以看到，WebViewTest这个程序现在已经具备了一个简易浏览器的功能，不仅成功将博客的首页展示了出来，还可以通过点击链接浏览更多的网页。</p><hr><h2 id="二、使用HTTP访问网络"><a href="#二、使用HTTP访问网络" class="headerlink" title="二、使用HTTP访问网络"></a>二、使用HTTP访问网络</h2><p>对于<strong>HTTP</strong>，这里只需要稍微了解一些就足够了，它的工作原理特别简单，就是客户端向服务器发出一条<strong>HTTP</strong>请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理就可以了。是不是非常简单？一个浏览器的基本工作原理也就是如此了。<strong>比如说上一节中使用到的WebView控件，其实就是我们向博客的服务器发起了一条HTTP请求，接着服务器分析出我们想要访问的是百度的首页，于是把该网页的HTML代码进行返回，然后WebView再调用手机浏览器的内核对返回的HTML代码进行解析，最终将页面展示出来。</strong></p><p>简单来说，<strong>WebView已经在后台帮我们处理好了发送HTTP请求、接收服务器响应、解析返回数据，以及最终的页面展示这几步工作，只不过它封装得实在是太好了，反而使得我们不能那么直观地看出HTTP到底是如何工作的。因此，接下来就让我们通过手动发送HTTP请求的方式更加深入地理解这个过程。</strong></p><h3 id="2-1-使用HttpURLConnection"><a href="#2-1-使用HttpURLConnection" class="headerlink" title="2.1 使用HttpURLConnection"></a>2.1 使用HttpURLConnection</h3><p>在过去，<strong>Android</strong>上发送<strong>HTTP</strong>请求一般有两种方式：<strong>HttpURLConnection</strong>和<strong>HttpClient</strong>。不过由于<strong>HttpClient</strong>存在API数量过多、扩展困难等缺点，<strong>Android</strong>团队越来越不建议我们使用这种方式。终于在<strong>Android 6.0</strong>系统中，<strong>HttpClient</strong>的功能被完全移除了，标志着此功能被正式弃用，因此本小节我们就学习一下现在官方建议使用的<strong>HttpURLConnection</strong>的用法。</p><p>首先需要获取<strong>HttpURLConnection</strong>的实例，一般只需创建一个<strong>URL</strong>对象，并传入目标的网络地址，然后调用一下<code>openConnection()</code>方法即可，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> url = URL(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> connection = url.openConnection() <span class="keyword">as</span> HttpURLConnection</span><br></pre></td></tr></table></figure><p>在得到了<strong>HttpURLConnection</strong>的实例之后，我们可以设置一下<strong>HTTP</strong>请求所使用的方法。常用的方法主要有两个：<strong>GET</strong>和<strong>POST</strong>。<strong>GET</strong>表示希望从服务器那里获取数据，而<strong>POST</strong>则表示希望提交数据给服务器。写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.requestMethod = <span class="string">&quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>接下来就可以进行一些自由的定制了，比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等。这部分内容根据自己的实际情况进行编写，示例写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.connectTimeout = <span class="number">8000</span></span><br><span class="line">connection.readTimeout = <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>之后再调用<code>getInputStream()</code>方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> input = connection.inputStream</span><br></pre></td></tr></table></figure><p>最后可以调用<code>disconnect()</code>方法将这个<strong>HTTP</strong>连接关闭：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.disconnect()</span><br></pre></td></tr></table></figure><p>下面通过一个具体的例子来真正体验一下<strong>HttpURLConnection</strong>的用法。新建一个<strong>NetworkTest</strong>项目，首先修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/sendRequestBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Send Request&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/sendRequestBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/responseText&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们使用了一个新的控件：<strong>ScrollView</strong>。它是用来做什么的呢？由于手机屏幕的空间一般比较小，有些时候过多的内容一屏是显示不下的，借助<strong>ScrollView</strong>控件，我们就可以以滚动的形式查看屏幕外的内容。另外，布局中还放置了一个<strong>Button</strong>和一个<strong>TextView</strong>，<strong>Button</strong>用于发送<strong>HTTP</strong>请求，<strong>TextView</strong>用于将服务器返回的数据显示出来。</p><p>接着修改 <strong>MainActivity</strong>中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> work.icu007.networktest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.sendRequestBtn.setOnClickListener &#123;</span><br><span class="line">            sendRequestWithHttpURLConnection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithHttpURLConnection</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 开启线程发起网络请求</span></span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = StringBuilder()</span><br><span class="line">                <span class="keyword">val</span> url = URL(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line">                connection = url.openConnection() <span class="keyword">as</span> HttpURLConnection</span><br><span class="line">                connection.connectTimeout = <span class="number">8000</span></span><br><span class="line">                connection.readTimeout = <span class="number">8000</span></span><br><span class="line">                <span class="keyword">val</span> input = connection.inputStream</span><br><span class="line">                <span class="comment">// 下面对获取到的输入流进行读取</span></span><br><span class="line">                <span class="keyword">val</span> reader = BufferedReader(InputStreamReader(input))</span><br><span class="line">                reader.use &#123;</span><br><span class="line">                    reader.forEachLine &#123;</span><br><span class="line">                        response.append(it)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                showResponse(response.toString())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection?.disconnect()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showResponse</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        runOnUiThread &#123;</span><br><span class="line">            <span class="comment">// 在这里进行UI操作，将结果显示到界面上</span></span><br><span class="line">            mainBinding.responseText.text = response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在“Send Request”按钮的点击事件里调用了<code>sendRequestWithHttpURLConnection()</code>方法，在这个方法中先是开启了一个子线程，然后在子线程里使用<strong>HttpURLConnection</strong>发出一条HTTP请求，请求的目标地址就是百度的首页。接着利用<strong>BufferedReader</strong>对服务器返回的流进行读取，并将结果传入<code>showResponse()</code>方法中。而在<code>showResponse()</code>方法里，则是调用了一个<code>runOnUiThread()</code>方法，然后在这个方法的<strong>Lambda</strong>表达式中进行操作，将返回的数据显示到界面上。</p><p>那么这里为什么要用这个<code>runOnUiThread()</code>方法呢？别忘了，<strong>Android</strong>是不允许在子线程中进行UI操作的。我们之前学习了异步消息处理机制的工作原理，而<code>runOnUiThread()</code>方法其实就是对异步消息处理机制进行了一层封装，它背后的工作原理和之前介绍的内容是一模一样的。借助这个方法，我们就可以将服务器返回的数据更新到界面上了。</p><p>完整的流程就是这样。不过在开始运行之前，仍然别忘了要声明一下网络权限。修改<strong>AndroidManifest.xml</strong>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708239819655_f046632467bd0.png" alt="1708239819655.png"></p><p>会将这些代码解析成漂亮的网页后再展示出来。那么如果想要提交数据给服务器应该怎么办呢？其实也不复杂，<strong>只需要将HTTP请求的方法改成POST</strong>，并在获取输入流之前把要提交的数据写出即可。注意，每条数据都要以键值对的形式存在，<strong>数据与数据之间用“&amp;”符号隔开</strong>。比如说我们想要向服务器提交用户名和密码，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.requestMethod = <span class="string">&quot;POST&quot;</span></span><br><span class="line"><span class="keyword">val</span> output = DataOutputStream(connection.outputStream)</span><br><span class="line">output.writeBytes(<span class="string">&quot;username=admin&amp;password=123456&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-使用OkHttp"><a href="#2-2-使用OkHttp" class="headerlink" title="2.2 使用OkHttp"></a>2.2 使用OkHttp</h3><p>当然我们并不是只能使用<strong>HttpURLConnection</strong>，完全没有任何其他选择，事实上在开源盛行的今天，有许多出色的网络通信库都可以替代原生的<strong>HttpURLConnection</strong>，而其中<strong>OkHttp</strong>无疑是做得最出色的一个。</p><p><strong>OkHttp</strong>是由鼎鼎大名的<strong>Square</strong>公司开发的，这个公司在开源事业上贡献良多，除了<strong>OkHttp</strong>之外，还开发了<strong>Retrofit</strong>、<strong>Picasso</strong>等知名的开源项目。<strong>OkHttp</strong>不仅在接口封装上做得简单易用，就连在底层实现上也是自成一派，比起原生的<strong>HttpURLConnection</strong>，可以说是有过之而无不及，现在已经成了广大<strong>Android</strong>开发者首选的网络通信库。那么本小节我们就来学习一下<strong>OkHttp</strong>的用法。<strong>OkHttp</strong>的项目主页地址是：<a href="https://github.com/square/okhttp">OkHttp</a></p><p>在使用<strong>OkHttp</strong>之前，我们需要先在项目中添加<strong>OkHttp</strong>库的依赖。编辑<strong>app&#x2F;build.gradle</strong>文件，在<strong>dependencies</strong>闭包中添加如下内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加上述依赖会自动下载两个库：一个是OkHttp库，一个是Okio库.</p><p>下面我们来看一下<strong>OkHttp</strong>的具体用法，首先需要创建一个<strong>OkHttpClient</strong>的实例，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient()</span><br></pre></td></tr></table></figure><p>接下来如果想要发起一条HTTP请求，就需要创建一个Request对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = Request.Builder().build()</span><br></pre></td></tr></table></figure><p>当然，上述代码只是创建了一个空的<strong>Request</strong>对象，并没有什么实际作用，我们可以在最终的<code>build()</code>方法之前连缀很多其他方法来丰富这个<strong>Request</strong>对象。比如可以通过<code>url()</code>方法来设置目标的网络地址，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">.url(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>之后调用<strong>OkHttpClient</strong>的<code>newCall()</code>方法来创建一个<strong>Call</strong>对象，并调用它的<code>execute()</code>方法来发送请求并获取服务器返回的数据，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> response = client.newCall(request).execute()</span><br></pre></td></tr></table></figure><p><strong>Response对象</strong>就是服务器返回的数据了，我们可以使用如下写法来得到返回的具体内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> responseData = response.body?.string()</span><br></pre></td></tr></table></figure><p>如果是发起一条<strong>POST</strong>请求，会比<strong>GET</strong>请求稍微复杂一点，<strong>我们需要先构建一个<code>Request Body</code>对象来存放待提交的参数，如下所示：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> requestBody = FormBody.Builder()</span><br><span class="line">.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>然后在<strong>Request.Builder</strong>中调用一下<code>post()</code>方法，并将<strong>RequestBody</strong>对象传入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">.url(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line">.post(requestBody)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>接下来的操作就和<strong>GET</strong>请求一样了，调用<code>execute()</code>方法来发送请求并获取服务器返回的数据即可。</p><p>好了，<strong>OkHttp</strong>的基本用法就先学到这里，在本章的稍后部分我们还会学习<strong>OkHttp</strong>结合<strong>Retrofit</strong>的使用方法，到时候再进一步学习。那么现在我们先把<strong>NetworkTest</strong>这个项目改用<strong>OkHttp</strong>的方式再实现一遍吧。</p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request</span><br><span class="line"><span class="keyword">import</span> work.icu007.networktest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.sendRequestBtn.setOnClickListener &#123;</span><br><span class="line">            sendRequestWithHttpURLConnection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithHttpURLConnection</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 开启线程发起网络请求</span></span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*val response = StringBuilder()</span></span><br><span class="line"><span class="comment">                val url = URL(&quot;https://icu007.work&quot;)</span></span><br><span class="line"><span class="comment">                connection = url.openConnection() as HttpURLConnection</span></span><br><span class="line"><span class="comment">                connection.connectTimeout = 8000</span></span><br><span class="line"><span class="comment">                connection.readTimeout = 8000</span></span><br><span class="line"><span class="comment">                val input = connection.inputStream</span></span><br><span class="line"><span class="comment">                // 下面对获取到的输入流进行读取</span></span><br><span class="line"><span class="comment">                val reader = BufferedReader(InputStreamReader(input))</span></span><br><span class="line"><span class="comment">                reader.use &#123;</span></span><br><span class="line"><span class="comment">                    reader.forEachLine &#123;</span></span><br><span class="line"><span class="comment">                        response.append(it)</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                showResponse(response.toString())*/</span></span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    showResponse(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection?.disconnect()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showResponse</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        runOnUiThread &#123;</span><br><span class="line">            <span class="comment">// 在这里进行UI操作，将结果显示到界面上</span></span><br><span class="line">            mainBinding.responseText.text = response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、解析XML格式数据"><a href="#三、解析XML格式数据" class="headerlink" title="三、解析XML格式数据"></a>三、解析XML格式数据</h2><p>通常情况下，每个需要访问网络的应用程序都会有一个自己的服务器，我们可以向服务器提交数据，也可以从服务器上获取数据。不过这个时候就出现了一个问题，这些数据到底要以什么样的格式在网络上传输呢？随便传递一段文本肯定是不行的，因为另一方根本就不知道这段文本的用途是什么。因此，一般我们会在网络上传输一些格式化后的数据，这种数据会有一定的结构规则和语义，当另一方收到数据消息之后，就可以按照相同的结构规则进行解析，从而取出想要的那部分内容。</p><p>在网络上传输数据时最常用的格式有两种：XML和JSON。下面我们就来一个一个地进行学习。本节首先学习一下如何解析XML格式的数据。</p><h3 id="3-0-准备工作-使用Apache服务器"><a href="#3-0-准备工作-使用Apache服务器" class="headerlink" title="3.0 准备工作(使用Apache服务器)"></a>3.0 准备工作(使用Apache服务器)</h3><p>在开始之前，我们还需要先解决一个问题，就是从哪儿才能获取一段XML格式的数据呢？这里我准备教你搭建一个最简单的Web服务器，在这个服务器上提供一段XML文本，然后我们在程序里去访问这个服务器，再对得到的XML文本进行解析。</p><p>搭建Web服务器的过程其实非常简单，也有很多种服务器类型可供选择，我们准备使用Apache服务器。另外，这里只会演示Windows系统下的搭建过程，因为Mac和Ubuntu系统都是默认安装好Apache服务器的，只需要启动一下即可。如果你使用的是这两种系统，可以自行搜索一下具体的操作方法。</p><p>下面来看Window系统下的搭建过程。首先你需要下载一个Apache服务器的安装包，官方下载地址是：<a href="http://httpd.apache.org/">Apache官网</a>。但是在官网下载时我们会发现 <strong>Apache</strong> 本身已经不提供已编译的安装包了，只提供源码。但是他为我们推荐了第三方提供编译的网站：</p><p><a href="https://www.apachelounge.com/download/">Apache VS17 binaries and modules download (apachelounge.com)</a></p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708246917587_4cbfef9c5a33f.png" alt="1708246917587.png"></p><p>下载后解压打开Apache所在目录 conf中的<code>httpd.conf</code>文件有几个地方需要修改</p><ol><li><code>Define SRVROOT</code>： 需要改成自己Apache所在目录；</li><li><code>Listen</code>： 监听端口按需修改</li><li><code>ServerName</code>： 改为 <code>ServerName localhost:监听的端口号</code></li></ol><p>而后用 <strong>cmd</strong> 命令在 <code>Apache/bin/</code>目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\httpd -k install</span><br></pre></td></tr></table></figure><p>出现如下字样且在浏览器打开设置的 ServerName 出现 <code>It works</code> 字样即安装成功</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708247243622_767268653e96e.png" alt="1708247243622.png"></p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708247536605_95af53b42e5b0.png" alt="1708247536605.png"></p><p>后续可以输入指令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">httpd -k start  <span class="comment">#启动</span></span><br><span class="line">httpd -k stop   <span class="comment">#停止</span></span><br></pre></td></tr></table></figure><p>接下来在<code>Apache/htdocs</code>目录下，在这里新建一个名为<code>get_data.xml</code>的文件，然后编辑这个文件，并加入如下XML格式的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">apps</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Google Maps<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Chrome<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>3<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Google Play<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">apps</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时在浏览器中访问<a href="http://servername/get_data.xml">http://ServerName/get_data.xml</a>这个网址，应出现如下所示内容</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708247707227_9f71538b612a7.png" alt="1708247707227.png"></p><h3 id="3-1-Pull解析方式"><a href="#3-1-Pull解析方式" class="headerlink" title="3.1 Pull解析方式"></a>3.1 Pull解析方式</h3><p>解析XML格式的数据其实也有挺多种方式的，本节中我们学习比较常用的两种：<strong>Pull解析</strong>和<strong>SAX解析</strong>。那么简单起见，这里仍然是在<strong>NetworkTest</strong>项目的基础上继续开发，这样我们就可以重用之前网络通信部分的代码，从而把工作的重心放在XML数据解析上。</p><p>既然XML格式的数据已经提供好了，现在要做的就是从中解析出我们想要得到的那部分内容。修改<strong>MainActivity</strong>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory</span><br><span class="line"><span class="keyword">import</span> work.icu007.networktest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.sendRequestBtn.setOnClickListener &#123;</span><br><span class="line"><span class="comment">//            sendRequestWithHttpURLConnection()</span></span><br><span class="line">            sendRequestWithOkHttp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithHttpURLConnection</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 开启线程发起网络请求</span></span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*val response = StringBuilder()</span></span><br><span class="line"><span class="comment">                val url = URL(&quot;https://icu007.work&quot;)</span></span><br><span class="line"><span class="comment">                connection = url.openConnection() as HttpURLConnection</span></span><br><span class="line"><span class="comment">                connection.connectTimeout = 8000</span></span><br><span class="line"><span class="comment">                connection.readTimeout = 8000</span></span><br><span class="line"><span class="comment">                val input = connection.inputStream</span></span><br><span class="line"><span class="comment">                // 下面对获取到的输入流进行读取</span></span><br><span class="line"><span class="comment">                val reader = BufferedReader(InputStreamReader(input))</span></span><br><span class="line"><span class="comment">                reader.use &#123;</span></span><br><span class="line"><span class="comment">                    reader.forEachLine &#123;</span></span><br><span class="line"><span class="comment">                        response.append(it)</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                showResponse(response.toString())*/</span></span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;https://icu007.work&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    showResponse(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection?.disconnect()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;http:/10.0.2.2:8088/get_data.xml&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;sendRequestWithOkHttp: <span class="variable">$responseData</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    parseXMLWithPull(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showResponse</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        runOnUiThread &#123;</span><br><span class="line">            <span class="comment">// 在这里进行UI操作，将结果显示到界面上</span></span><br><span class="line">            mainBinding.responseText.text = response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseXMLWithPull</span><span class="params">(xmlData: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> factory = XmlPullParserFactory.newInstance()</span><br><span class="line">            <span class="keyword">val</span> xmlPullParser = factory.newPullParser()</span><br><span class="line">            xmlPullParser.setInput(StringReader(xmlData))</span><br><span class="line">            <span class="keyword">var</span> eventType = xmlPullParser.eventType</span><br><span class="line">            <span class="keyword">var</span> id = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">var</span> version = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="keyword">val</span> nodeName = xmlPullParser.name</span><br><span class="line">                <span class="keyword">when</span> (eventType) &#123;</span><br><span class="line">                    <span class="comment">// 开始解析某个节点</span></span><br><span class="line">                    XmlPullParser.START_TAG -&gt; &#123;</span><br><span class="line">                        <span class="keyword">when</span> (nodeName) &#123;</span><br><span class="line">                            <span class="string">&quot;id&quot;</span> -&gt; id = xmlPullParser.nextText()</span><br><span class="line">                            <span class="string">&quot;name&quot;</span> -&gt; name = xmlPullParser.nextText()</span><br><span class="line">                            <span class="string">&quot;version&quot;</span> -&gt; version = xmlPullParser.nextText()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 完成解析某个节点</span></span><br><span class="line">                    XmlPullParser.END_TAG -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;app&quot;</span> == nodeName) &#123;</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;id is <span class="variable">$id</span>&quot;</span>)</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;name is <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;version is <span class="variable">$version</span>&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventType = xmlPullParser.next()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>这里首先将HTTP请求的地址改成了<a href="http://10.0.2.2/get_data.xml%EF%BC%8C10.0.2.2">http://10.0.2.2/get_data.xml，10.0.2.2</a>对于模拟器来说就是计算机本机的IP地址</strong>。在得到了服务器返回的数据后，我们不再直接将其展示，而是调用了<code>parseXMLWithPull()</code>方法来解析服务器返回的数据。</p><p>下面就来仔细看下<code>parseXMLWithPull()</code>方法中的代码吧。这里首先要创建一个<strong>XmlPullParserFactory</strong>的实例，并借助这个实例得到<strong>XmlPullParser</strong>对象，然后调用<strong>XmlPullParser</strong>的<code>setInput()</code>方法将服务器返回的XML数据设置进去，之后就可以开始解析了。解析的过程也非常简单，通过<code>getEventType()</code>可以得到当前的解析事件，然后在一个<strong>while</strong>循环中不断地进行解析，如果当前的解析事件不等于<code>XmlPullParser.END_DOCUMENT</code>，说明解析工作还没完成，调用<code>next()</code>方法后可以获取下一个解析事件。</p><p>在<strong>while</strong>循环中，我们通过<code>getName()</code>方法得到了当前节点的名字。如果发现节点名等于<strong>id、name或version</strong>，就调用<code>nextText()</code>方法来获取节点内具体的内容，每当解析完一个<strong>app</strong>节点，就将获取到的内容打印出来。</p><p>好了，整体的过程就是这么简单，不过在程序运行之前还得再进行一项额外的配置。从Android9.0系统开始，应用程序默认只允许使用HTTPS类型的网络请求，HTTP类型的网络请求因为有安全隐患默认不再被支持，而我们搭建的Apache服务器现在使用的就是HTTP。</p><p>那么为了能让程序使用HTTP，我们还要进行如下配置才可以。右击<strong>res目录→New→Directory</strong>，创建一个xml目录，接着<strong>右击xml目录→New→File</strong>，创建一个<code>network_config.xml</code>文件。然后修改<code>network_config.xml</code>文件中的内容，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">&quot;system&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段配置文件的意思就是允许我们以明文的方式在网络上传输数据，而HTTP使用的就是明文传输方式。</p><p>接下来修改<code>AndroidManifest.xml</code>中的代码来启用我们刚才创建的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.NetworkTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:networkSecurityConfig</span>=<span class="string">&quot;@xml/network_config&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行NetworkTest项目，然后点击“Send Request”按钮，观察Logcat中的打印日志.</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2024-02-19 11:21:59.080  7199-7307  MainActivity            work.icu007.networktest              D  id is 1</span><br><span class="line">2024-02-19 11:21:59.080  7199-7307  MainActivity            work.icu007.networktest              D  name is Google Maps</span><br><span class="line">2024-02-19 11:21:59.080  7199-7307  MainActivity            work.icu007.networktest              D  version is 1.0</span><br><span class="line">2024-02-19 11:21:59.080  7199-7307  MainActivity            work.icu007.networktest              D  id is 2</span><br><span class="line">2024-02-19 11:21:59.080  7199-7307  MainActivity            work.icu007.networktest              D  name is Chrome</span><br><span class="line">2024-02-19 11:21:59.080  7199-7307  MainActivity            work.icu007.networktest              D  version is 2.1</span><br><span class="line">2024-02-19 11:21:59.081  7199-7307  MainActivity            work.icu007.networktest              D  id is 3</span><br><span class="line">2024-02-19 11:21:59.081  7199-7307  MainActivity            work.icu007.networktest              D  name is Google Play</span><br><span class="line">2024-02-19 11:21:59.081  7199-7307  MainActivity            work.icu007.networktest              D  version is 2.3</span><br></pre></td></tr></table></figure><p>可以看到，XML数据中的指定内容已经解析出来了。</p><h3 id="3-2-SAX解析方式"><a href="#3-2-SAX解析方式" class="headerlink" title="3.2 SAX解析方式"></a>3.2 SAX解析方式</h3><p><strong>Pull</strong>解析方式虽然非常好用，但它并不是我们唯一的选择。<strong>SAX</strong>解析也是一种特别常用的<strong>XML</strong>解析方式，虽然它的用法比<strong>Pull</strong>解析要复杂一些，但在语义方面会更加清楚。要使用<strong>SAX</strong>解析，通常情况下我们会新建一个类继承自<code>DefaultHandler</code>，并重写父类的5个方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xml.sax.Attributes</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/2/19-11:33</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHandler</span> : <span class="type">DefaultHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startDocument</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.startDocument()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">endDocument</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.endDocument()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        uri: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        localName: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        qName: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        attributes: <span class="type">Attributes</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.startElement(uri, localName, qName, attributes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">endElement</span><span class="params">(uri: <span class="type">String</span>?, localName: <span class="type">String</span>?, qName: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.endElement(uri, localName, qName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">characters</span><span class="params">(ch: <span class="type">CharArray</span>?, start: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.characters(ch, start, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startDocument()</code>方法会在开始<strong>XML</strong>解析的时候调用，<code>startElement()</code>方法会在开始解析某个节点的时候调用，<code>characters()</code>方法会在获取节点中内容的时候调用，<code>endElement()</code>方法会在完成解析某个节点的时候调用，<code>endDocument()</code>方法会在完成整个<strong>XML</strong>解析的时候调用。其中，<code>startElement()</code>、<code>characters()</code>和<code>endElement()</code>这3个方法是有参数的，从<strong>XML</strong>中解析出的数据就会以参数的形式传入这些方法中。需要注意的是，在获取节点中的内容时，<code>characters()</code>方法可能会被调用多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制。</p><p>那么下面就让我们尝试用SAX解析的方式来实现和上一小节同样的功能吧。新建一个<code>ContentHandler</code>类继承自<code>DefaultHandler</code>，并重写父类的5个方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.Attributes</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/2/19-11:33</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentHandler</span> : <span class="type">DefaultHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> nodeName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> id: StringBuilder</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> name: StringBuilder</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> version: StringBuilder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startDocument</span><span class="params">()</span></span> &#123;</span><br><span class="line">        id = StringBuilder()</span><br><span class="line">        name = StringBuilder()</span><br><span class="line">        version = StringBuilder()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">endDocument</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.endDocument()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        uri: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        localName: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        qName: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        attributes: <span class="type">Attributes</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localName != <span class="literal">null</span>)&#123;</span><br><span class="line">            nodeName = localName</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;startElement: uri is <span class="variable">$uri</span>&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;startElement: localName is <span class="variable">$localName</span>&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;startElement: qName is <span class="variable">$qName</span>&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;startElement: attributes is <span class="variable">$attributes</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">endElement</span><span class="params">(uri: <span class="type">String</span>?, localName: <span class="type">String</span>?, qName: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;app&quot;</span> == localName) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;endElement: id is <span class="subst">$&#123;id.toString().trim()&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;endElement: name is <span class="subst">$&#123;name.toString().trim()&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;ContentHandler&quot;</span>, <span class="string">&quot;endElement: version is <span class="subst">$&#123;version.toString().trim()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment">// 最后将StringBuilder清空</span></span><br><span class="line">            id.setLength(<span class="number">0</span>)</span><br><span class="line">            name.setLength(<span class="number">0</span>)</span><br><span class="line">            version.setLength(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">characters</span><span class="params">(ch: <span class="type">CharArray</span>?, start: <span class="type">Int</span>, length: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(nodeName) &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span> -&gt; id.append(ch, start, length)</span><br><span class="line">            <span class="string">&quot;name&quot;</span> -&gt; name.append(ch, start, length)</span><br><span class="line">            <span class="string">&quot;version&quot;</span> -&gt; version.append(ch, start, length)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们首先给<strong>id</strong>、<strong>name</strong>和<strong>version</strong>节点分别定义了一个<strong>StringBuilder</strong>对象，并在<code>startDocument()</code>方法里对它们进行了初始化。每当开始解析某个节点的时候，<code>startElement()</code>方法就会得到调用，其中<strong>localName</strong>参数记录着当前节点的名字，这里我们把它记录下来。接着在解析节点中具体内容的时候就会调用<code>characters()</code>方法，我们会根据当前的节点名进行判断，将解析出的内容添加到哪一个<strong>StringBuilder</strong>对象中。最后在<code>endElement()</code>方法中进行判断，如果app节点已经解析完成，就打印出id、name和version的内容。需要注意的是，目前<strong>id</strong>、<strong>name</strong>和<strong>version</strong>中都可能是包括回车或换行符的，因此在打印之前我们还需要调用一下<code>trim()</code>方法，并且打印完成后要将<strong>StringBuilder</strong>的内容清空，不然的话会影响下一次内容的读取。</p><p>接下来的工作就非常简单了，修改<strong>MainActivity</strong>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.InputSource</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory</span><br><span class="line"><span class="keyword">import</span> work.icu007.networktest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParserFactory</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.sendRequestBtn.setOnClickListener &#123;</span><br><span class="line"><span class="comment">//            sendRequestWithHttpURLConnection()</span></span><br><span class="line">            sendRequestWithOkHttp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;http:/10.0.2.2:8088/get_data.xml&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;sendRequestWithOkHttp: <span class="variable">$responseData</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//                    parseXMLWithPull(responseData)</span></span><br><span class="line">                    parseXMLWithSAX(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseXMLWithSAX</span><span class="params">(xmlData: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> factory = SAXParserFactory.newInstance()</span><br><span class="line">            <span class="keyword">val</span> xmlReader = factory.newSAXParser().xmlReader</span><br><span class="line">            <span class="keyword">val</span> handler = ContentHandler()</span><br><span class="line">            xmlReader.contentHandler = handler</span><br><span class="line">            xmlReader.parse(InputSource(StringReader(xmlData)))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在得到了服务器返回的数据后，我们这次通过调用<code>parseXMLWithSAX()</code>方法来解析XML数据。<code>parseXMLWithSAX()</code>方法中先是创建了一个<strong>SAXParserFactory</strong>的对象，然后再获取<strong>XMLReader</strong>对象，接着将我们编写的<strong>ContentHandler</strong>的实例设置到<strong>XMLReader</strong>中，最后调用<code>parse()</code>方法开始执行解析。观察log会发现结果和Pull解析是一致的。</p><hr><h2 id="四、解析JSON格式数据"><a href="#四、解析JSON格式数据" class="headerlink" title="四、解析JSON格式数据"></a>四、解析JSON格式数据</h2><p>现在你已经掌握了<strong>XML</strong>格式数据的解析方式，那么接下来我们要学习一下如何解析<strong>JSON</strong>格式的数据了。比起<strong>XML</strong>，<strong>JSON</strong>的主要优势在于它的体积更小，在网络上传输的时候更省流量。但缺点在于，它的语义性较差，看起来不如<strong>XML</strong>直观。</p><p>在开始之前，我们还需要在<code>Apache/htdocs</code>目录中新建一个<code>get_data.json</code>的文件，然后编辑这个文件，并加入如下<strong>JSON</strong>格式的内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;5&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;5.5&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Clash of Clans&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;6&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;7.0&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Boom Beach&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;7&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;3.5&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Clash Royale&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="4-1-使用JSONObject"><a href="#4-1-使用JSONObject" class="headerlink" title="4.1 使用JSONObject"></a>4.1 使用JSONObject</h3><p>解析<strong>JSON</strong>数据也有很多种方法，可以使用官方提供的<strong>JSONObject</strong>，也可以使用<strong>Google</strong>的开源库<strong>GSON</strong>。另外，一些第三方的开源库如<strong>Jackson</strong>、<strong>FastJSON</strong>等也非常不错。本节中我们就来学习一下前两种解析方式的用法。</p><p>修改<strong>MainActivity</strong>中的代码，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request</span><br><span class="line"><span class="keyword">import</span> org.json.JSONArray</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.InputSource</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory</span><br><span class="line"><span class="keyword">import</span> work.icu007.networktest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParserFactory</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.sendRequestBtn.setOnClickListener &#123;</span><br><span class="line"><span class="comment">//            sendRequestWithHttpURLConnection()</span></span><br><span class="line">            sendRequestWithOkHttp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;http:/10.0.2.2:8088/get_data.json&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;sendRequestWithOkHttp: <span class="variable">$responseData</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//                    parseXMLWithPull(responseData)</span></span><br><span class="line"><span class="comment">//                    parseXMLWithSAX(responseData)</span></span><br><span class="line">                    parseJSONWithJSONObject(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseJSONWithJSONObject</span><span class="params">(jsonData: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> jsonArray = JSONArray(jsonData)</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until jsonArray.length()) &#123;</span><br><span class="line">                <span class="keyword">val</span> jsonObject = jsonArray.getJSONObject(i)</span><br><span class="line">                <span class="keyword">val</span> id = jsonObject.getString(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> name = jsonObject.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> version = jsonObject.getString(<span class="string">&quot;version&quot;</span>)</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;parseJSONWithJSONObject: id is <span class="variable">$id</span>&quot;</span>)</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;parseJSONWithJSONObject: name is <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;parseJSONWithJSONObject: version is <span class="variable">$version</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将HTTP请求的地址改成<a href="http://10.0.2.2/get_data.json">http://10.0.2.2/get_data.json</a>，然后在得到服务器返回的数据后调用<code>parseJSONWithJSONObject()</code>方法来解析数据。可以看到，解析<strong>JSON</strong>的代码真的非常简单，由于我们在服务器中定义的是一个<strong>JSON</strong>数组，因此这里首先将服务器返回的数据传入一个<strong>JSONArray</strong>对象中。然后循环遍历这个<strong>JSONArray</strong>，从中取出的每一个元素都是一个<strong>JSONObject</strong>对象，每个<strong>JSONObject</strong>对象中又会包含<strong>id、name和version</strong>这些数据。接下来只需要调用<code>getString()</code>方法将这些数据取出，并打印出来即可。</p><p>运行结果如下：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/02/1708323342502_06812d6513a1c.png" alt="1708323342502.png"></p><h3 id="4-2-使用GSON"><a href="#4-2-使用GSON" class="headerlink" title="4.2 使用GSON"></a>4.2 使用GSON</h3><p>使用<strong>JSONObject</strong>来解析<strong>JSON</strong>数据已经非常简单了，但是<strong>Google</strong>提供的<strong>GSON</strong>开源库可以让解析<strong>JSON</strong>数据的工作简单到让你不敢想象的地步。<a href="https://github.com/google/gson">GSON仓库</a></p><p>不过，<strong>GSON</strong>并没有被添加到<strong>Android</strong>官方的<strong>API</strong>中，因此如果想要使用这个功能的话，就必须在项目中添加<strong>GSON</strong>库的依赖。编辑<code>app/build.gradle</code>文件，在<strong>dependencies</strong>闭包中添加如下内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么GSON库究竟是神奇在哪里呢？它的强大之处就在于可以将一段JSON格式的字符串自动映射成一个对象，从而不需要我们再手动编写代码进行解析了。比如说一段JSON格式的数据如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Tom&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那我们就可以定义一个<strong>Person</strong>类，并加入<strong>name</strong>和<strong>age</strong>这两个字段，然后只需简单地调用如下代码就可以将<strong>JSON</strong>数据自动解析成一个<strong>Person</strong>对象了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> gson = Gson()</span><br><span class="line"><span class="keyword">val</span> person = gson.fromJson(jsonData, Person::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>如果需要解析的是一段<strong>JSON</strong>数组，会稍微麻烦一点，比如如下格式的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Tom&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">25</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Lily&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>这个时候，我们需要借助<strong>TypeToken</strong>将期望解析成的数据类型传入<code>fromJson()</code>方法中，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> typeOf = <span class="keyword">object</span> : TypeToken&lt;List&lt;Person&gt;&gt;() &#123;&#125;.type</span><br><span class="line"><span class="keyword">val</span> people = gson.fromJson&lt;List&lt;Person&gt;&gt;(jsonData, typeOf)</span><br></pre></td></tr></table></figure><p>好了，基本的用法就是这样，下面就让我们来真正地尝试一下。首先新增一个App类，并加入id、name和version这3个字段，如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span>(<span class="keyword">val</span> id: String, <span class="keyword">val</span> name: String, <span class="keyword">val</span> version: String)</span><br></pre></td></tr></table></figure><p>然后修改MainActivity中的代码，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.networktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson</span><br><span class="line"><span class="keyword">import</span> com.google.gson.reflect.TypeToken</span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request</span><br><span class="line"><span class="keyword">import</span> org.json.JSONArray</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.InputSource</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory</span><br><span class="line"><span class="keyword">import</span> work.icu007.networktest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader</span><br><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParserFactory</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.sendRequestBtn.setOnClickListener &#123;</span><br><span class="line"><span class="comment">//            sendRequestWithHttpURLConnection()</span></span><br><span class="line">            sendRequestWithOkHttp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;http:/10.0.2.2:8088/get_data.json&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;sendRequestWithOkHttp: <span class="variable">$responseData</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//                    parseXMLWithPull(responseData)</span></span><br><span class="line"><span class="comment">//                    parseXMLWithSAX(responseData)</span></span><br><span class="line"><span class="comment">//                    parseJSONWithJSONObject(responseData)</span></span><br><span class="line">                    parseJSONWithGSON(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseJSONWithGSON</span><span class="params">(jsonData: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> gson = Gson()</span><br><span class="line">        <span class="keyword">val</span> typeOf = <span class="keyword">object</span> : TypeToken&lt;List&lt;App&gt;&gt;() &#123;&#125;.type</span><br><span class="line">        <span class="keyword">val</span> appList = gson.fromJson&lt;List&lt;App&gt;&gt;(jsonData, typeOf)</span><br><span class="line">        <span class="keyword">for</span> (app <span class="keyword">in</span> appList) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;parseJSONWithGSON: id is <span class="subst">$&#123;app.id&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;parseJSONWithGSON: name is <span class="subst">$&#123;app.name&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;parseJSONWithGSON: version is <span class="subst">$&#123;app.version&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察打印日志，与使用JSONObject结果一致。</p><hr><h2 id="五、网络请求回调的实现方式"><a href="#五、网络请求回调的实现方式" class="headerlink" title="五、网络请求回调的实现方式"></a>五、网络请求回调的实现方式</h2><p>目前我们已经掌握了<strong>HttpURLConnection</strong>和<strong>OkHttp</strong>的用法，知道了如何发起<strong>HTTP</strong>请求，以及解析服务器返回的数据，但之前我们的写法其实是很有问题的。因为一个应用程序很可能会在许多地方都使用到网络功能，而发送<strong>HTTP</strong>请求的代码基本是相同的，如果我们每次都去编写一遍发送<strong>HTTP</strong>请求的代码，这显然是非常差劲的做法。</p><p>没错，通常情况下我们应该将这些通用的网络操作提取到一个公共的类里，并提供一个通用方法，当想要发起网络请求的时候，只需简单地调用一下这个方法即可。比如使用如下的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> HttpUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendHttpRequest</span> <span class="params">(address: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> response = StringBuilder()</span><br><span class="line">            <span class="keyword">val</span> url = URL(address)</span><br><span class="line">            connection = url.openConnection() <span class="keyword">as</span> HttpURLConnection</span><br><span class="line">            connection.connectTimeout = <span class="number">8000</span></span><br><span class="line">            connection.readTimeout = <span class="number">8000</span></span><br><span class="line">            <span class="keyword">val</span> input = connection.inputStream</span><br><span class="line">            <span class="keyword">val</span> reader = BufferedReader(InputStreamReader(input))</span><br><span class="line">            reader.use &#123;</span><br><span class="line">                reader.forEachLine &#123;</span><br><span class="line">                    response.append(it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response.toString()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            <span class="keyword">return</span> e.message.toString()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connection?.disconnect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后每当需要发起一条<strong>HTTP</strong>请求的时候，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> address = <span class="string">&quot;https://icu007.work&quot;</span></span><br><span class="line"><span class="keyword">val</span> response = HttpUtil.sendHttpRequest(address)</span><br></pre></td></tr></table></figure><p>在获取到服务器响应的数据后，我们就可以对它进行解析和处理了。但是需要注意，网络请求通常属于耗时操作，而<code>sendHttpRequest()</code>方法的内部并没有开启线程，这样就有可能导致在调用<code>sendHttpRequest()</code>方法的时候主线程被阻塞。</p><p>那在<code>sendHttpRequest()</code>方法内部开启一个线程，不就解决这个问题了吗？其实没有想象中那么容易，因为如果我们在<code>sendHttpRequest()</code>方法中开启一个线程来发起<strong>HTTP</strong>请求，服务器响应的数据是无法进行返回的。这是由于所有的耗时逻辑都是在子线程里进行的，<code>sendHttpRequest()</code>方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据了。</p><p>那么在遇到这种情况时应该怎么办呢？其实解决方法并不难，只需要使用编程语言的回调机制就可以了。下面就来学习一下回调机制到底是如何使用的。</p><p>首先需要定义一个接口，比如将它命名成<code>HttpCallbackListener</code>，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HttpCallbackListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在接口中定义了两个方法：<code>onFinish()</code>方法表示当服务器成功响应我们请求的时候调用，<code>onError()</code>表示当进行网络操作出现错误的时候调用。这两个方法都带有参数，<code>onFinish()</code>方法中的参数代表服务器返回的数据，而<code>onError()</code>方法中的参数记录着错误的详细信息。</p><p>接着修改<code>HttpUtil</code>中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HttpCallbackListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> HttpUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendHttpRequest</span> <span class="params">(address: <span class="type">String</span>, listener: <span class="type">HttpCallbackListener</span>)</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = StringBuilder()</span><br><span class="line">                <span class="keyword">val</span> url = URL(address)</span><br><span class="line">                connection = url.openConnection() <span class="keyword">as</span> HttpURLConnection</span><br><span class="line">                connection.connectTimeout = <span class="number">8000</span></span><br><span class="line">                connection.readTimeout = <span class="number">8000</span></span><br><span class="line">                <span class="keyword">val</span> input = connection.inputStream</span><br><span class="line">                <span class="keyword">val</span> reader = BufferedReader(InputStreamReader(input))</span><br><span class="line">                reader.use &#123;</span><br><span class="line">                    reader.forEachLine &#123;</span><br><span class="line">                        response.append(it)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                listener.onFinish(response.toString())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">                listener.onError(e)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection?.disconnect()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先给<code>sendHttpRequest()</code>方法添加了一个<code>HttpCallbackListener</code>参数，并在方法的内部开启了一个子线程，然后在子线程里执行具体的网络操作。注意，<strong>子线程中是无法通过return语句返回数据的</strong>，因此这里我们将服务器响应的数据传入了<code>HttpCallbackListener</code>的<code>onFinish()</code>方法中，如果出现了异常，就将异常原因传入<code>onError()</code>方法中。</p><p>现在<code>sendHttpRequest()</code>方法接收两个参数，因此我们在调用它的时候还需要将<code>HttpCallbackListener</code>的实例传入，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpUtil.sendHttpRequest(address, <span class="keyword">object</span>: HttpCallbackListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 对异常情况进行处理</span></span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(response: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 得到服务器返回的具体内容</span></span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样当服务器成功响应的时候，我们就可以在<code>onFinish()</code>方法里对响应数据进行处理了。类似地，如果出现了异常，就可以在<code>onError()</code>方法里对异常情况进行处理。如此一来，我们就巧妙地利用回调机制将响应数据成功返回给调用方了。</p><p>不过你会发现，上述使用<code>HttpURLConnection</code>的写法总体来说还是比较复杂的，那么使用<code>OkHttp</code>会变得简单吗？答案是肯定的，而且要简单得多，下面我们来具体看一下。在<code>HttpUtil</code>中加入一个<code>sendOkHttpRequest()</code>方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> HttpUtil &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendOkHttpRequest</span><span class="params">(address: <span class="type">String</span>, callback: <span class="type">okhttp3</span>.<span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">            .url(address)</span><br><span class="line">            .build()</span><br><span class="line">        client.newCall(request).enqueue(callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>sendOkHttpRequest()</code>方法中有一个<code>okhttp3.Callback</code>参数，这个是<code>OkHttp</code>库中自带的回调接口，类似于我们刚才自己编写的<code>HttpCallbackListener</code>。然后在<code>client.newCall()</code>之后没有像之前那样一直调用<code>execute()</code>方法，而是调用了一个<code>enqueue()</code>方法，并把<code>okhttp3.Callback</code>参数传入。OkHttp<code>在</code>enqueue()<code>方法的内部已经帮我们开好子线程了，然后会在子线程中执行HTTP请求，并将最终的请求结果回调到</code>okhttp3.Callback&#96;当中。**</p><p>那么我们在调用<code>sendOkHttpRequest()</code>方法的时候就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpUtil.sendOkHttpRequest(address, <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 得到服务器返回的具体内容</span></span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 进行异常情况处理</span></span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由此可以看出，<code>OkHttp</code>的接口设计得确实非常人性化，它将一些常用的功能进行了很好的封装，使得我们只需编写少量的代码就能完成较为复杂的网络操作。</p><p>另外，需要注意的是，不管是使用<code>HttpURLConnection</code>还是<code>OkHttp</code>，最终的回调接口都还是在子线程中运行的，因此我们不可以在这里执行任何的UI操作，除非借助<code>runOnUiThread()</code>方法来进行类型转换。</p><h2 id="六、最好用的网络库：-Retrofit"><a href="#六、最好用的网络库：-Retrofit" class="headerlink" title="六、最好用的网络库： Retrofit"></a>六、最好用的网络库： Retrofit</h2><p>既然学习<strong>Android</strong>网络技术，那么就不得不提到<code>Retrofit</code>，因为它实在是太好用了。<code>Retrofit</code>同样是一款由<strong>Square</strong>公司开发的网络库，但是它和<code>OkHttp</code>的定位完全不同。<code>OkHttp</code>侧重的是底层通信的实现，而<code>Retrofit</code>侧重的是上层接口的封装。事实上，<code>Retrofit</code>就是<strong>Square</strong>公司在<code>OkHttp</code>的基础上进一步开发出来的应用层网络通信库，使得我们可以用更加面向对象的思维进行网络操作。<code>Retrofit</code>的项目主页地址是：<a href="https://github.com/square/retrofit">GitHub仓库</a></p><h3 id="6-1-Retrofit的基本用法"><a href="#6-1-Retrofit的基本用法" class="headerlink" title="6.1 Retrofit的基本用法"></a>6.1 Retrofit的基本用法</h3><p><code>Retrofit</code>的设计基于以下几个事实：</p><ol><li>同一款应用程序中所发起的网络请求绝大多数指向的是同一个服务器域名。这个很好理解，因为任何公司的产品，客户端和服务器都是配套的，很难想象一个客户端一会去这个服务器获取数据，一会又要去另外一个服务器获取数据吧？</li><li>另外，服务器提供的接口通常是可以根据功能来归类的。比如新增用户、修改用户数据、查询用户数据这几个接口就可以归为一类，上架新书、销售图书、查询可供销售图书这几个接口也可以归为一类。将服务器接口合理归类能够让代码结构变得更加合理，从而提高可阅读性和可维护性。</li><li>最后，开发者肯定更加习惯于“调用一个接口，获取它的返回值”这样的编码方式，但当调用的是服务器接口时，却很难想象该如何使用这样的编码方式。其实大多数人并不关心网络的具体通信细节，但是传统网络库的用法却需要编写太多网络相关的代码。</li></ol><p>而<code>Retrofit</code>的用法就是基于以上几点来设计的，首先我们可以配置好一个根路径，然后在指定服务器接口地址时只需要使用相对路径即可，这样就不用每次都指定完整的<strong>URL</strong>地址了。</p><p>另外，<code>Retrofit</code>允许我们对服务器接口进行归类，将功能同属一类的服务器接口定义到同一个接口文件当中，从而让代码结构变得更加合理。</p><p>最后，我们也完全不用关心网络通信的细节，只需要在接口文件中声明一系列方法和返回值，然后通过注解的方式指定该方法对应哪个服务器接口，以及需要提供哪些参数。当我们在程序中调用该方法时，<code>Retrofit</code>会自动向对应的服务器接口发起请求，并将响应的数据解析成返回值声明的类型。这就使得我们可以用更加面向对象的思维来进行网络操作。</p><p><code>Retrofit</code>的基本设计思想差不多就是这些，下面就通过一个具体的例子来快速体验一下<code>Retrofit</code>的用法。</p><p>要想使用<code>Retrofit</code>，我们需要先在项目中添加必要的依赖库。编辑<code>app/build.gradle</code>文件，在<strong>dependencies</strong>闭包中添加如下内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Retrofit</code>是基于<code>OkHttp</code>开发的，因此添加上述第一条依赖会自动将<code>Retrofit</code>、<code>OkHttp</code>和<code>Okio</code>这几个库一起下载，我们无须再手动引入<code>OkHttp</code>库。另外，<code>Retrofit</code>还会将服务器返回的<strong>JSON</strong>数据自动解析成对象，因此上述第二条依赖就是一个<code>Retrofit</code>的转换库，它是借助<code>GSON</code>来解析<strong>JSON</strong>数据的，所以会自动将<code>GSON</code>库一起下载下来，这样我们也不用手动引入<code>GSON</code>库了。除了<code>GSON</code>之外，<code>Retrofit</code>还支持各种其他主流的<strong>JSON</strong>解析库，包括<code>Jackson</code>、<code>Moshi</code>等，不过毫无疑问<code>GSON</code>是最常用的。</p><p>我们使用之前提供的<strong>JSON</strong>数据接口。由于<code>Retrofit</code>会借助<code>GSON</code>将<strong>JSON</strong>数据转换成对象，因此这里同样需要新增一个<strong>App</strong>类，并加入<strong>id</strong>、<strong>name</strong>和<strong>version</strong>这3个字段，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.retrofittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/2/19-15:23</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> (<span class="keyword">val</span> id: String, <span class="keyword">val</span> name: String, <span class="keyword">val</span> version: String)</span><br></pre></td></tr></table></figure><p>接下来，我们可以根据服务器接口的功能进行归类，创建不同种类的接口文件，并在其中定义对应具体服务器接口的方法。不过由于我们的<strong>Apache</strong>服务器上其实只有一个获取<strong>JSON</strong>数据的接口，因此这里只需要定义一个接口文件，并包含一个方法即可。新建<code>AppService</code>接口，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.retrofittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> retrofit2.Call</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.GET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/2/19-15:26</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AppService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;get_data.json&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAppData</span><span class="params">()</span></span>: Call&lt;List&lt;App&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常<code>Retrofit</code>的接口文件建议以具体的功能种类名开头，并以<code>Service</code>结尾，这是一种比较好的命名习惯。</p><p>上述代码中有两点需要我们注意。第一就是在<code>getAppData()</code>方法上面添加的注解，这里使用了一个<code>@GET</code>注解，<strong>表示当调用<code>getAppData()</code>方法时<code>Retrofit</code>会发起一条GET请求，请求的地址就是我们在<code>@GET</code>注解中传入的具体参数。</strong>注意，<strong>这里只需要传入请求地址的相对路径即可</strong>，根路径我们会在稍后设置。</p><p>第二就是<code>getAppData()</code>方法的返回值必须声明成<code>Retrofit</code>中内置的<strong>Call</strong>类型，并通过泛型来指定服务器响应的数据应该转换成什么对象。由于服务器响应的是一个包含<strong>App</strong>数据的<strong>JSON</strong>数组，因此这里我们将泛型声明成<code>List&lt;App&gt;</code>。当然，<code>Retrofit</code>还提供了强大的<strong>Call</strong> <strong>Adapters</strong>功能来允许我们自定义方法返回值的类型，比如<code>Retrofit</code>结合<code>RxJava</code>使用就可以将返回值声明成<code>Observable</code>、<code>Flowable</code>等类型。</p><p>定义好了<code>AppService</code>接口之后，接下来的问题就是该如何使用它。为了方便测试，我们还得在界面上添加一个按钮才行。修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/getAppDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Get App Data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<strong>MainActivity</strong>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.retrofittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> retrofit2.Call</span><br><span class="line"><span class="keyword">import</span> retrofit2.Callback</span><br><span class="line"><span class="keyword">import</span> retrofit2.Response</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory</span><br><span class="line"><span class="keyword">import</span> work.icu007.retrofittest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        mainBinding.getAppDataBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://10.0.2.2:8088/&quot;</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build()</span><br><span class="line">            <span class="keyword">val</span> appService = retrofit.create(AppService::<span class="keyword">class</span>.java)</span><br><span class="line">            appService.getAppData().enqueue(<span class="keyword">object</span> : Callback&lt;List&lt;App&gt;&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, response: <span class="type">Response</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> list = response.body()</span><br><span class="line">                    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (app <span class="keyword">in</span> list) &#123;</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;onResponse: id is <span class="subst">$&#123;app.id&#125;</span>&quot;</span>)</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;onResponse: name is <span class="subst">$&#123;app.name&#125;</span>&quot;</span>)</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;onResponse: version is <span class="subst">$&#123;app.version&#125;</span>&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">App</span>&gt;&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                    t.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“Get App Data”按钮的点击事件当中，首先使用了<code>Retrofit.Builder</code>来构建一个<code>Retrofit</code>对象，<strong>其中<code>baseUrl()</code>方法用于指定所有<code>Retrofit</code>请求的根路径，<code>addConverterFactory()</code>方法用于指定<code>Retrofit</code>在解析数据时所使用的转换库，这里指定成<code>GsonConverterFactory</code>。注意这两个方法都是必须调用的。</strong></p><p>有了<code>Retrofit</code>对象之后，我们就可以调用它的<code>create()</code>方法，并传入具体<strong>Service</strong>接口所对应的<strong>Class</strong>类型，创建一个该接口的动态代理对象。如果不熟悉什么是动态代理也没有关系，只需要知道<strong>有了动态代理对象之后，我们就可以随意调用接口中定义的所有方法，而<code>Retrofit</code>会自动执行具体的处理</strong>就可以了。</p><p>对应到上述的代码当中，当调用了<code>AppService</code>的<code>getAppData()</code>方法时，会返回一个<code>Call&lt;List&lt;App&gt;&gt;</code>对象，这时我们再调用一下它的<code>enqueue()</code>方法，<code>Retrofit</code>就会根据注解中配置的服务器接口地址去进行网络请求了，服务器响应的数据会回调到<code>enqueue()</code>方法中传入的<strong>Callback</strong>实现里面。需要注意的是，当发起请求的时候，<code>Retrofit</code>会自动在内部开启子线程，当数据回调到<strong>Callback</strong>中之后，<code>Retrofit</code>又会自动切换回主线程，整个操作过程中我们都不用考虑线程切换问题。在<strong>Callback</strong>的<code>onResponse()</code>方法中，调用<code>response.body()</code>方法将会得到<code>Retrofit</code>解析后的对象，也就是<code>List&lt;App&gt;</code>类型的数据，最后遍历List，将其中的数据打印出来即可。</p><p>这里使用的服务器接口仍然是HTTP，因此我们还要进行网络安全配置才行。</p><p>新建<code>network_config.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">&quot;system&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 <code>AndroidManifest.xml</code>如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:networkSecurityConfig</span>=<span class="string">&quot;@xml/network_config&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-处理复杂的接口地址类型"><a href="#6-2-处理复杂的接口地址类型" class="headerlink" title="6.2 处理复杂的接口地址类型"></a>6.2 处理复杂的接口地址类型</h3><p>在上一小节中，我们通过示例程序向一个非常简单的服务器接口地址发送请求：<a href="http://10.0.2.2/8088/get_data.json">http://10.0.2.2/8088/get_data.json</a>，然而在真实的开发环境当中，服务器所提供的接口地址不可能一直如此简单。如果你在使用浏览器上网时观察一下浏览器上的网址，你会发现这些网址可能会是千变万化的，那么本小节我们就来学习一下如何使用<code>Retrofit</code>来应对这些千变万化的情况。</p><p>为了方便举例，这里先定义一个Data类，并包含id和content这两个字段，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>(<span class="keyword">val</span> id: String, <span class="keyword">val</span> content: String)</span><br></pre></td></tr></table></figure><p>然后我们先从最简单的看起，比如服务器的接口地址如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//example.com/get_data.json</span></span><br></pre></td></tr></table></figure><p>这是最简单的一种情况，接口地址是静态的，永远不会改变。那么对应到<code>Retrofit</code>当中，使用如下的写法即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;get_data.json&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是我们在上一小节中已经学过的部分，理解起来应该非常简单吧。</p><p>但是显然服务器不可能总是给我们提供静态类型的接口，在很多场景下，接口地址中的部分内容可能会是动态变化的，比如如下的接口地址：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//example.com/&lt;page&gt;/get_data.json</span></span><br></pre></td></tr></table></figure><p>在这个接口当中，<code>&lt;page&gt;</code>部分代表页数，我们传入不同的页数，服务器返回的数据也会不同。这种接口地址对应到<code>Retrofit</code>当中应该怎么写呢？其实也很简单，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;&#123;page&#125;/get_data.json&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;page&quot;</span>)</span> page: <span class="type">Int</span>)</span></span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>@GET</code>注解指定的接口地址当中，这里使用了一个<code>&#123;page&#125;</code>的占位符，然后又在<code>getData()</code>方法中添加了一个<strong>page</strong>参数，并使用<code>@Path(&quot;page&quot;)</code>注解来声明这个参数。这样当调用<code>getData()</code>方法发起请求时，<code>Retrofit</code>就会自动将<strong>page</strong>参数的值替换到占位符的位置，从而组成一个合法的请求地址。</p><p>另外，很多服务器接口还会要求我们传入一系列的参数，格式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//example.com/get_data.json?u&lt;user&gt;&amp;t=&lt;token&gt;</span></span><br></pre></td></tr></table></figure><p>这是一种标准的带参数<strong>GET</strong>请求的格式。<strong>接口地址的最后使用问号来连接参数部分，每个参数都是一个使用等号连接的键值对，多个参数之间使用“&amp;”符号进行分隔。</strong>那么很显然，在上述地址中，服务器要求我们传入<strong>user</strong>和<strong>token</strong>这两个参数的值。对于这种格式的服务器接口，我们可以使用刚才所学的<code>@Path</code>注解的方式来解决，但是这样会有些麻烦，<code>Retrofit</code>针对这种带参数的<strong>GET</strong>请求，专门提供了一种语法支持：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;get_data.json&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">(<span class="meta">@Query(<span class="string">&quot;u&quot;</span>)</span> user: <span class="type">String</span>, <span class="meta">@Query(<span class="string">&quot;t&quot;</span>)</span> token: <span class="type">String</span>)</span></span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在<code>getData()</code>方法中添加了<strong>user</strong>和<strong>token</strong>这两个参数，并使用<code>@Query</code>注解对它们进行声明。这样当发起网络请求的时候，<code>Retrofit</code>就会自动按照带参数<strong>GET</strong>请求的格式将这两个参数构建到请求地址当中。</p><p>学习了以上内容之后，现在你在一定程度上已经可以应对千变万化的服务器接口地址了。不过<strong>HTTP</strong>并不是只有<strong>GET</strong>请求这一种类型，而是有很多种，其中比较常用的有<strong>GET</strong>、<strong>POST</strong>、<strong>PUT</strong>、<strong>PATCH</strong>、<strong>DELETE</strong>这几种。它们之间的分工也很明确，简单概括的话，<strong>GET</strong>请求用于从服务器获取数据，<strong>POST</strong>请求用于向服务器提交数据，<strong>PUT</strong>和<strong>PATCH</strong>请求用于修改服务器上的数据，<strong>DELETE</strong>请求用于删除服务器上的数据。</p><p>而<code>Retrofit</code>对所有常用的<strong>HTTP</strong>请求类型都进行了支持，使用<code>@GET</code>、<code>@POST</code>、<code>@PUT</code>、<code>@PATCH</code>、<code>@DELETE</code>注解，就可以让<code>Retrofit</code>发出相应类型的请求了。</p><p>比如服务器提供了如下接口地址：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE http:<span class="comment">//example.com/data/&lt;id&gt;</span></span><br></pre></td></tr></table></figure><p>这种接口通常意味着要根据id删除一条指定的数据，而我们在<code>Retrofit</code>当中想要发出这种请求就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@DELETE(<span class="string">&quot;data/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteData</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">String</span>)</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>@DELETE</code>注解来发出<strong>DELETE</strong>类型的请求，并使用了<code>@Path</code>注解来动态指定<strong>id</strong>，这些都很好理解。但是在返回值声明的时候，我们将<strong>Call</strong>的泛型指定成了<strong>ResponseBody</strong>，这是什么意思呢？</p><p>由于<strong>POST</strong>、<strong>PUT</strong> 、<strong>PATCH</strong>、<strong>DELETE</strong>这几种请求类型与<strong>GET</strong>请求不同，它们更多是用于操作服务器上的数据，而不是获取服务器上的数据，所以通常它们对于服务器响应的数据并不关心。这个时候就可以使用<strong>ResponseBody</strong>，表示<strong>Retrofit</strong>能够接收任意类型的响应数据，并且不会对响应数据进行解析。</p><p>那么如果我们需要向服务器提交数据该怎么写呢？比如如下的接口地址：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST http:<span class="comment">//example.com/data/create</span></span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;The description for this data.&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>POST</strong>请求来提交数据，需要将数据放到<strong>HTTP</strong>请求的<strong>body</strong>部分，这个功能在<code>Retrofit</code>中可以借助<code>@Body</code>注解来完成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@POST(<span class="string">&quot;data/create&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createData</span><span class="params">(<span class="meta">@Body</span> <span class="keyword">data</span>: <span class="type">Data</span>)</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们在<code>createData()</code>方法中声明了一个<strong>Data</strong>类型的参数，并给它加上了<code>@Body</code>注解。这样当<code>Retrofit</code>发出<strong>POST</strong>请求时，就会自动将<strong>Data</strong>对象中的数据转换成JSON格式的文本，并放到<strong>HTTP</strong>请求的<strong>body</strong>部分，服务器在收到请求之后只需要从<strong>body</strong>中将这部分数据解析出来即可。这种写法同样也可以用来给<strong>PUT</strong>、<strong>PATCH</strong>、<strong>DELETE</strong>类型的请求提交数据。</p><p>最后，有些服务器接口还可能会要求我们在<strong>HTTP</strong>请求的<strong>header</strong>中指定参数，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//example.com/get_data.json</span></span><br><span class="line">User-Agent: okhttp</span><br><span class="line">Cache-Control: max-age=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这些<strong>header</strong>参数其实就是一个个的键值对，我们可以在<code>Retrofit</code>中直接使用<code>@Headers</code>注解来对它们进行声明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@Header(<span class="string">&quot;User-Agent: okhttp&quot;</span>, <span class="string">&quot;Cache-Control: max-age=0&quot;</span>)</span></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;get_data.json&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法只能进行静态<strong>header</strong>声明，如果想要动态指定<strong>header</strong>的值，则需要使用<code>@Header</code>注解，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;get_data.json&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">(<span class="meta">@Header(<span class="string">&quot;User-Agent&quot;</span>)</span> userAgent: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Header(<span class="string">&quot;Cache-Control&quot;</span>)</span> cacheControl: <span class="type">String</span>)</span></span>: Call &lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当发起网络请求的时候，<code>Retrofit</code>就会自动将参数中传入的值设置到<code>User-Agent</code>和<code>Cache-Control</code>这两个<strong>header</strong>当中，从而实现了动态指定<strong>header</strong>值的功能。</p><h3 id="6-3-Retrofit构建器的最佳写法"><a href="#6-3-Retrofit构建器的最佳写法" class="headerlink" title="6.3 Retrofit构建器的最佳写法"></a>6.3 Retrofit构建器的最佳写法</h3><p>学到这里，其实还有一个问题我们没有正视过，就是获取Service接口的动态代理对象实在是太麻烦了。先回顾一下之前的写法吧，大致代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">.baseUrl(<span class="string">&quot;http:10.0.2.2/8088/&quot;</span>)</span><br><span class="line">.addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">.build()</span><br><span class="line"><span class="keyword">val</span> appService = retrofit.create(AppService::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>我们想要得到<code>AppService</code>的动态代理对象，需要先使用<code>Retrofit.Builder</code>构建出一个<code>Retrofit</code>对象，然后再调用<code>Retrofit</code>对象的<code>create()</code>方法创建动态代理对象。如果只是写一次还好，每次调用任何服务器接口时都要这样写一遍的话，肯定没有人能受得了。</p><p>事实上，确实也没有每次都写一遍的必要，因为构建出的<code>Retrofit</code>对象是全局通用的，<strong>只需要在调用<code>create()</code>方法时针对不同的Service接口传入相应的Class类型即可。</strong>因此，我们可以将通用的这部分功能封装起来，从而简化获取<strong>Service</strong>接口动态代理对象的过程。</p><p>新建一个<code>ServiceCreator</code>单例类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ServiceCreator &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BASE_URL = <span class="string">&quot;http://10.0.2.2/8088&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">    .baseUrl(BASE_URL)</span><br><span class="line">.addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">.build()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">create</span><span class="params">(serviceClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T = retrofit.create(serviceClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用object关键字让<code>ServiceCreator</code>成为了一个单例类，并在它的内部定义了一个<code>BASE_URL</code>常量，用于指定<code>Retrofit</code>的根路径。然后同样是在内部使用<code>Retrofit.Builder</code>构建一个<code>Retrofit</code>对象，注意这些都是用<strong>private</strong>修饰符来声明的，相当于对于外部而言它们都是不可见的。</p><p>最后，我们提供了一个外部可见的<code>create()</code>方法，并接收一个<strong>Class</strong>类型的参数。当在外部调用这个方法时，实际上就是调用了<code>Retrofit</code>对象的<code>create()</code>方法，从而创建出相应<strong>Service</strong>接口的动态代理对象。</p><p>经过这样的封装之后，<code>Retrofit</code>的用法将会变得异常简单，比如我们想获取一个<code>AppService</code>接口的动态代理对象，只需要使用如下写法即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appService = ServiceCreator.create(AppService::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>之后就可以随意调用<code>AppService</code>接口中定义的任何方法了。</p><p>上述代码通过之前学习的学习的泛型实化功能，还可以继续优化。修改<code>ServiceCreator</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ServiceCreator &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T = create(T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们又定义了一个不带参数的<code>create()</code>方法，并使用<strong>inline</strong>关键字来修饰方法，使用<strong>reified</strong>关键字来修饰泛型，这是泛型实化的两大前提条件。接下来就可以使用<code>T::class.java</code>这种语法了，这里调用刚才定义的带有<strong>Class</strong>参数的<code>create()</code>方法即可。</p><p>那么现在我们就又有了一种新的方式来获取<code>AppService</code>接口的动态代理对象，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appService = ServiceCreator.create&lt;AppService&gt;()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你在玩手机的时候不能上网，那你一定会感到特别地枯燥乏味。没错，现在早已不是玩单机的时代了，无论是PC、手机、平板，还是电视，都具备上网的功能， 21世纪的确是互联网的时代。&lt;/p&gt;
&lt;p&gt;当然，Android手机肯定也是可以上网的。作为开发者，我们就需要考虑如何利用网络</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-Material</title>
    <link href="https://icu007work.github.io/archives/a3762f06.html"/>
    <id>https://icu007work.github.io/archives/a3762f06.html</id>
    <published>2024-02-27T07:34:17.000Z</published>
    <updated>2024-05-11T07:46:00.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Material-Design"><a href="#一、什么是Material-Design" class="headerlink" title="一、什么是Material Design"></a>一、什么是Material Design</h2><p><strong>Material Design</strong>是由<strong>Google</strong>的设计工程师们基于传统优秀的设计原则，结合丰富的创意和科学技术所开发的一套全新的界面设计语言，包含了视觉、运动、互动效果等特性。</p><p>不过，在重磅推出之后，<strong>Material Design</strong>的普及程度却不是特别理想。因为这只是一个推荐的设计规范，主要是面向UI设计人员的，而不是面向开发者的。很多开发者可能根本就搞不清楚什么样的界面和效果才叫<strong>Material Design</strong>，就算搞清楚了，实现起来也会很费劲，因为不少<strong>Material Design</strong>的效果是很难实现的，而<strong>Android</strong>中几乎没有提供相应的<strong>API</strong>支持，基本需要靠开发者自己从零写起。</p><p><strong>Google</strong>当然意识到了这个问题，于是在<strong>2015年的Google I&#x2F;O大会上推出了一个DesignSupport库</strong>，这个库将<strong>Material Design</strong>中最具代表性的一些控件和效果进行了封装，使得开发者即使在不了解<strong>Material Design</strong>的情况下，也能非常轻松地将自己的应用<strong>Material</strong>化。后来<strong>Design Support</strong>库又改名成了<strong>Material</strong>库，用于给<strong>Google</strong>全平台类的产品提供<strong>Material Design</strong>的支持。这里我们就将对<strong>Material</strong>库进行深入的学习，并且配合<strong>AndroidX</strong>库中的一些控件来完成一个优秀的<strong>Material Design</strong>应用。</p><h2 id="二、Toolbar"><a href="#二、Toolbar" class="headerlink" title="二、Toolbar"></a>二、Toolbar</h2><p>Toolbar将会是我们本章接触的第一个控件，是由AndroidX库提供的。虽说对于Toolbar暂时比较陌生的，但是对于它的另一个相关控件ActionBar，肯定再熟悉不过了。不过ActionBar由于其设计的原因，被限定只能位于Activity的顶部，从而不能实现一些Material Design的效果，因此官方现在已经不再建议使用ActionBar了。接下来也不再介绍ActionBar的用法了，而是直接讲解现在更加推荐使用的Toolbar。</p><p>Toolbar的强大之处在于，它不仅继承了ActionBar的所有功能，而且灵活性很高，可以配合其他控件完成一些Material Design的效果，下面我们就来具体学习一下。</p><p>首先，任何一个新建的项目，默认都是会显示ActionBar的。那么这个ActionBar到底是从哪里来的呢？其实这是根据项目中指定的主题来显示的。打开AndroidManifest.xml文件看一下，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:networkSecurityConfig</span>=<span class="string">&quot;@xml/network_config&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.RetrofitTest&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里使用<code>android:theme</code>属性指定了一个<strong>AppTheme</strong>的主题。那么这个AppTheme又是在哪里定义的呢？打开<code>res/values/theme.xml</code>文件，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Base.Theme.RetrofitTest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your light theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- &lt;item name=&quot;colorPrimary&quot;&gt;@color/my_light_primary&lt;/item&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.RetrofitTest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.RetrofitTest&quot;</span> /&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里定义了一个叫 <code>Theme.RetrofitTest</code>的主题，其 <strong>parent</strong>主题是 <code>Base.Theme.RetrofitTest</code>，而 <code>Base.Theme.RetrofitTest</code>的 <strong>parent</strong>主题是 <code>Theme.AppCompat.Light.DarkActionBar</code> 这个DarkActionBar是一个深色的ActionBar主题，我们之前所有的项目中自带的ActionBar就是因为指定了这个主题才出现的。</p><p>而现在我们准备使用Toolbar来替代ActionBar，因此需要指定一个不带ActionBar的主题，通常有<code>Theme.AppCompat.NoActionBar</code> 和<code>Theme.AppCompat.Light.NoActionBar</code>这两种主题可选。<strong>其中<code>Theme.AppCompat.NoActionBar</code>表示深色主题，它会将界面的主体颜色设成深色，陪衬颜色设成浅色。而<code>Theme.AppCompat.Light.NoActionBar</code>表示浅色主题，它会将界面的主体颜色设成浅色，陪衬颜色设成深色。</strong></p><p>接下来看一看如何使用Toolbar来替代ActionBar。修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/Theme.AppCompat.Light&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这段代码不长，但是里面着实有不少技术点是需要我们仔细琢磨一下的。首先看一下第4行，这里使用<code>xmlns:app</code>指定了一个新的命名空间。思考一下，正是由于每个布局文件都会使用<code>xmlns:android</code>来指定一个命名空间，我们才能一直使用<code>android:id</code>、<code>android:layout_width</code>等写法。这里指定了<code>xmlns:app</code>，也就是说现在可以使用<code>app:attribute</code>这样的写法了。但是为什么这里要指定一个<code>xmlns:app</code>的命名空间呢？这是由于许多<strong>Material</strong>属性是在新系统中新增的，老系统中并不存在，那么为了能够兼容老系统，我们就不能使用<code>android:attribute</code>这样的写法了，而是应该使用<code>app:attribute</code>。</p><p>接下来定义了一个<strong>Toolbar</strong>控件，这个控件是由<strong>appcompat</strong>库提供的。这里我们给<strong>Toolbar</strong>指定了一个<strong>id</strong>，将它的宽度设置为<strong>match_parent</strong>，高度设置为<strong>actionBar</strong>的高度，背景色设置为<strong>colorPrimary</strong>。不过下面的部分就稍微有点难理解了，<strong>如果在<code>styles.xml</code>中将程序的主题指定成了浅色主题，因此Toolbar现在也是浅色主题，那么Toolbar上面的各种元素就会自动使用深色系，从而和主体颜色区别开。但是之前使用ActionBar时文字都是白色的，现在变成黑色的会很难看。那么为了能让Toolbar单独使用深色主题，这里我们使用了<code>android:theme</code>属性，将Toolbar的主题指定成了<code>ThemeOverlay.AppCompat.Dark.ActionBar</code>。但是这样指定之后又会出现新的问题，如果Toolbar中有菜单按钮，那么弹出的菜单项也会变成深色主题，这样就再次变得十分难看了，于是这里又使用了<code>app:popupTheme</code>属性，单独将弹出的菜单项指定成了浅色主题。</strong></p><p>写完了布局，接下来我们修改MainActivity，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> work.icu007.materialtes.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        setSupportActionBar(mainBinding.toolbar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关键的代码只有一句，调用<code>setSupportActionBar()</code>方法并将<strong>Toolbar</strong>的实例传入，这样我们就做到既使用了<strong>Toolbar</strong>，又让它的外观与功能都和<strong>ActionBar</strong>一致了。</p><p>接下来我们再学习一些<strong>Toolbar</strong>比较常用的功能吧，比如修改标题栏上显示的文字内容。这段文字内容是在<code>AndroidManifest.xml</code>中指定的，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.MaterialTes&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;Fruits&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里给<strong>activity</strong>增加了一个<code>android:label</code>属性，用于指定在<strong>Toolbar</strong>中显示的文字内容，如果没有指定的话，会默认使用<strong>application</strong>中指定的<strong>label</strong>内容，也就是我们的应用名称。</p><p>不过只有一个标题的<strong>Toolbar</strong>看起来太单调了，我们还可以再添加一些<strong>action</strong>按钮来让<strong>Toolbar</strong>更加丰富一些。。现在<code>右击res目录→New→Directory</code>，创建一个<strong>menu</strong>文件夹。然后<code>右击menu文件夹→New→Menu resource file</code>，创建一个<code>toolbar.xml</code>文件，并编写如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;always&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/delete&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_delete&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Delete&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;always&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/settings&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_settings&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Settings&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们通过<code>&lt;item&gt;</code>标签来定义<strong>action</strong>按钮，<code>android:id</code>用于指定按钮的<strong>id</strong>，<code>android:icon</code>用于指定按钮的<strong>图标</strong>，<code>android:title</code>用于指定按钮的<strong>文字</strong>。</p><p>接着使用<code>app:showAsAction</code>来指定按钮的显示位置，这里之所以再次使用了app命名空间，同样是为了能够兼容低版本的系统。<strong>showAsAction</strong>主要有以下几种值可选：<strong>always表示永远显示在Toolbar中，如果屏幕空间不够则不显示；ifRoom表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中；never则表示永远显示在菜单当中。</strong>注意，<strong>Toolbar中的action按钮只会显示图标，菜单中的action按钮只会显示文字。</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        menuInflater.inflate(R.menu.toolbar,menu)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">            R.id.backup -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;u clicked buck up&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            R.id.delete -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;u clicked delete&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            R.id.settings -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;u clicked settings&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、滑动菜单"><a href="#三、滑动菜单" class="headerlink" title="三、滑动菜单"></a>三、滑动菜单</h2><h3 id="3-1-DrawerLayout"><a href="#3-1-DrawerLayout" class="headerlink" title="3.1 DrawerLayout"></a>3.1 DrawerLayout</h3><p>所谓的滑动菜单，就是将一些菜单选项隐藏起来，而不是放置在主屏幕上，然后可以通过滑动的方式将菜单显示出来。这种方式既节省了屏幕空间，又实现了非常好的动画效果，是<code>Material Design</code>中推荐的做法。</p><p>不过，如果我们全靠自己去实现上述功能的话，难度恐怕就很大了。幸运的是，Google在AndroidX库中提供了一个DrawerLayout控件，借助这个控件，实现滑动菜单简单又方便。</p><p>先来简单介绍一下DrawerLayout的用法吧。首先它是一个布局，在布局中允许放入两个直接子控件：第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。因此，我们就可以对activity_main.xml中的代码做如下修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is menu&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里最外层的控件使用了<code>DrawerLayout</code>。<code>DrawerLayout</code>中放置了两个直接子控件：第一个子控件是<code>FrameLayout</code>，用于作为主屏幕中显示的内容，当然里面还有我们刚刚定义的Toolbar；第二个子控件是一个TextView，用于作为滑动菜单中显示的内容，其实使用什么都可以，<code>DrawerLayout</code>并没有限制只能使用固定的控件。</p><p>但是关于第二个子控件有一点需要注意，<code>layout_gravity</code>这个属性是必须指定的，因为我们需要告诉<code>DrawerLayout</code>滑动菜单是在屏幕的左边还是右边，指定left表示滑动菜单在左边，指定right表示滑动菜单在右边。这里我指定了start，表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边。</p><p>向左滑动菜单，或者点击一下菜单以外的区域，都可以让滑动菜单关闭，从而回到主界面。无论是展示还是隐藏滑动菜单，都有非常流畅的动画过渡。可以看到，我们只是稍微改动了一下布局文件，就能实现如此炫酷的效果，是不是觉得挺激动呢？ 不过现在的滑动菜单还有点问题，因为只有在屏幕的左侧边缘进行拖动时才能将菜单拖出来，而很多用户可能根本就不知道有这个功能，那么该怎么提示他们呢？</p><p><code>Material Design</code>建议的做法是在<strong>Toolbar</strong>的最左边加入一个导航按钮，点击按钮也会将滑动菜单的内容展示出来。这样就相当于给用户提供了两种打开滑动菜单的方式，防止一些用户不知道屏幕的左侧边缘是可以拖动的。</p><p>下面我们来实现这个功能。修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        setSupportActionBar(mainBinding.toolbar)</span><br><span class="line">        supportActionBar?.let &#123;</span><br><span class="line">            it.setDisplayHomeAsUpEnabled(<span class="literal">true</span>)</span><br><span class="line">            it.setHomeAsUpIndicator(R.drawable.ic_menu)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">            ...</span><br><span class="line">            android.R.id.home -&gt; mainBinding.drawerLayout.openDrawer(GravityCompat.START)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>getSupportActionBar()</code>方法得到了<strong>ActionBar</strong>的实例，虽然这个<strong>ActionBar</strong>的具体实现是由<strong>Toolbar</strong>来完成的。接着在<strong>ActionBar</strong>不为空的情况下调用<code>setDisplayHomeAsUpEnabled()</code>方法让导航按钮显示出来，调用<code>setHomeAsUpIndicator()</code>方法来设置一个导航按钮图标。实际上，<strong>Toolbar</strong>最左侧的这个按钮就叫作<strong>Home</strong>按钮，它默认的图标是一个返回的箭头，含义是返回上一个<strong>Activity</strong>。很明显，这里我们将它默认的样式和作用都进行了修改。</p><p>接下来，在<code>onOptionsItemSelected()</code>方法中对<strong>Home</strong>按钮的点击事件进行处理，<strong>Home</strong>按钮的id永远都是<code>android.R.id.home</code>。然后调用DrawerLayout的<code>openDrawer()</code>方法将滑动菜单展示出来，注意，<code>openDrawer()</code>方法要求传入一个<strong>Gravity</strong>参数，为了保证这里的行为和XML中定义的一致，我们传入了<code>GravityCompat.START</code>。</p><h3 id="3-2-NavigationView"><a href="#3-2-NavigationView" class="headerlink" title="3.2 NavigationView"></a>3.2 NavigationView</h3><p>我们可以在滑动菜单页面定制任意的布局，不过Google给我们提供了一种更好的方法——使用<code>NavigationView</code>。<code>NavigationView</code>是<strong>Material</strong>库中提供的一个控件，它不仅是严格按照<code>Material Design</code>的要求来设计的，而且可以将滑动菜单页面的实现变得非常简单。接下来我们就学习一下<code>NavigationView</code>的用法。</p><p>首先，既然这个控件是<strong>Material</strong>库中提供的，那么我们就需要将这个库引入项目中才行。打开<code>app/build.gradle</code>文件，在<strong>dependencies</strong>闭包中添加如下内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;com.google.android.material:material:1.11.0&quot;)</span><br><span class="line">    implementation(&quot;de.hdodenhof:circleimageview:3.1.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加了两行依赖关系：第一行就是<strong>Material</strong>库，第二行是一个开源项目<code>CircleImageView</code>，它可以用来轻松实现图片圆形化的功能，我们待会就会用到它。</p><p>需要注意的是，当你引入了<strong>Material</strong>库之后，还需要将res&#x2F;values&#x2F;styles.xml文件中AppTheme的parent主题改成<code>Theme.MaterialComponents.Light.NoActionBar</code>，否则在使用接下来的一些控件时可能会遇到崩溃问题。</p><p>在开始使用<code>NavigationView</code>之前，我们还需要准备好两个东西：<strong>menu和headerLayout。menu是用来在NavigationView中显示具体的菜单项的，headerLayout则是用来在NavigationView中显示头部布局的。</strong></p><p>先来准备menu。<code>右击menu文件夹→New→Menu resource file</code>，创建一个<code>nav_menu.xml</code>文件，并编写如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">&quot;single&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/navCall&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_call&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Call&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/navFriends&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_friends&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Friends&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/navLocation&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_location&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Location&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/navMail&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_mail&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Mail&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/navTask&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_task&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Tasks&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们首先在<code>&lt;menu&gt;</code>中嵌套了一个<code>&lt;group&gt;</code>标签，然后将group的<code>checkableBehavior</code>属性指定为<strong>single</strong>。<strong>group表示一个组，<code>checkableBehavior</code>指定为single表示组中的所有菜单项只能单选。</strong></p><p>下面我们来看一下这些菜单项吧。这里一共定义了5个item，分别使用<code>android:id</code>属性指定菜单项的id，<code>android:icon</code>属性指定菜单项的图标，<code>android:title</code>属性指定菜单项显示的文字。就是这么简单，现在我们已经把menu准备好了。接下来应该准备<code>headerLayout</code>了，这是一个可以随意定制的布局，不过我并不想将它做得太复杂。这里简单起见，我们就在<code>headerLayout</code>中放置头像、用户名、邮箱地址这3项内容吧。</p><p>然后<code>右击layout文件夹→New→Layout resource file</code>，创建一个<code>nav_header.xml</code>文件。修改其中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;180dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">de.hdodenhof.circleimageview.CircleImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/iconImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;70dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;70dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/nav_icon&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mailText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;tonygreendev@gmail.com&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;14sp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/userText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/mailText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Tony Green&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;14sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，布局文件的最外层是一个<code>RelativeLayout</code>，我们将它的宽度设为<code>match_parent</code>，高度设为180 dp，这是一个<code>NavigationView</code>比较适合的高度，然后指定它的背景色为colorPrimary。</p><p>在<code>RelativeLayout</code>中我们放置了3个控件，<code>CircleImageView</code>是一个用于将图片圆形化的控件，它的用法非常简单，基本和ImageView是完全一样的，这里给它指定了一张图片作为头像，然后设置为居中显示。另外两个TextView分别用于显示用户名和邮箱地址，它们都用到了一些<code>RelativeLayout</code>的定位属性，相信肯定难不倒你吧？</p><p>现在menu和headerLayout都准备好了，我们终于可以使用<code>NavigationView</code>了。修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.navigation.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/navView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:menu</span>=<span class="string">&quot;@menu/nav_menu&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:headerLayout</span>=<span class="string">&quot;@layout/nav_header&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们将之前的TextView换成了<code>NavigationView</code>，这样滑动菜单中显示的内容也就变成<code>NavigationView</code>了。这里又通过<code>app:menu</code>和<code>app:headerLayout</code>属性将我们刚才准备好的menu和headerLayout设置了进去，这样<code>NavigationView</code>就定义完成了。<code>NavigationView</code>虽然定义完成了，但是我们还要处理菜单项的点击事件才行。修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        setSupportActionBar(mainBinding.toolbar)</span><br><span class="line">        supportActionBar?.let &#123;</span><br><span class="line">            it.setDisplayHomeAsUpEnabled(<span class="literal">true</span>)</span><br><span class="line">            it.setHomeAsUpIndicator(R.drawable.ic_menu)</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.navView.setCheckedItem(R.id.navCall)</span><br><span class="line">        mainBinding.navView.setNavigationItemSelectedListener &#123;</span><br><span class="line">            mainBinding.drawerLayout.closeDrawers()</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码还是比较简单的，这里我们首先调用了<code>NavigationView</code>的<code>setCheckedItem()</code>方法将Call菜单项设置为默认选中。接着调用了<code>setNavigationItemSelectedListener()</code>方法来设置一个菜单项选中事件的监听器，当用户点击了任意菜单项时，就会回调到传入的Lambda表达式当中，我们可以在这里编写具体的逻辑处理。<strong>这里调用了<code>DrawerLayout</code>的<code>closeDrawers()</code>方法将滑动菜单关闭，并返回true表示此事件已被处理。</strong></p><h2 id="四、悬浮按钮和可交互提示"><a href="#四、悬浮按钮和可交互提示" class="headerlink" title="四、悬浮按钮和可交互提示"></a>四、悬浮按钮和可交互提示</h2><p>立面设计是<code>Material Design</code>中一条非常重要的设计思想，也就是说，按照<code>Material Design</code>的理念，应用程序的界面不仅仅是一个平面，而应该是有立体效果的。在官方给出的示例中，最简单且最具代表性的立面设计就是悬浮按钮了，这种按钮不属于主界面平面的一部分，而是位于另外一个维度的，因此就会给人一种悬浮的感觉。</p><p>本节中我们会对这个悬浮按钮的效果进行学习，另外还会学习一种可交互式的提示工具。关于提示工具，我们之前一直使用的是Toast，但是Toast只能用于告知用户某事已经发生了，用户却不能对此做出任何的响应，那么今天我们就将在这一方面进行扩展。</p><h3 id="4-1-FloatingActionButton"><a href="#4-1-FloatingActionButton" class="headerlink" title="4.1 FloatingActionButton"></a>4.1 FloatingActionButton</h3><p><code>FloatingActionButton</code>是<strong>Material</strong>库中提供的一个控件，这个控件可以帮助我们比较轻松地实现悬浮按钮的效果。其实在之前的图12.2中，我们就已经预览过悬浮按钮的样子了，它默认会使用<code>colorAccent</code>作为按钮的颜色，我们还可以通过给按钮指定一个图标来表明这个按钮的作用是什么。</p><p>然后修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.navigation.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/navView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:menu</span>=<span class="string">&quot;@menu/nav_menu&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:headerLayout</span>=<span class="string">&quot;@layout/nav_header&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里我们在主屏幕布局中加入了一个<code>FloatingActionButton</code>。这个控件的用法并没有什么特别的地方，layout_width和layout_height属性都指定成wrap_content，layout_gravity属性指定将这个控件放置于屏幕的右下角。其中end的工作原理和之前的start是一样的，即如果系统语言是从左往右的，那么end就表示在右边，如果系统语言是从右往左的，那么end就表示在左边。然后通过<code>layout_margin</code>属性给控件的四周留点边距，紧贴着屏幕边缘肯定是不好看的，最后通过<code>src</code>属性给<code>FloatingActionButton</code>设置了一个图标。</p><p><code>FloatingActionButton</code>是悬浮在当前界面上的，既然是悬浮，那么理所应当会有投影，<strong>Material</strong>库连这种细节都帮我们考虑到了。说到悬浮，其实我们还可以指定<code>FloatingActionButton</code>的悬浮高度，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:elevation</span>=<span class="string">&quot;8dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用<code>app:elevation</code>属性给<code>FloatingActionButton</code>指定一个高度值。高度值越大，投影范围也越大，但是投影效果越淡；高度值越小，投影范围也越小，但是投影效果越浓。当然这些效果的差异其实并不怎么明显。</p><p>接下来我们看一下<code>FloatingActionButton</code>是如何处理点击事件的，毕竟，一个按钮首先要能点击才有意义。修改<code>MainActivity</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line">        mainBinding.fab.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;FAB clicked&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FloatingActionButton</code>并没有什么特殊用法，它和普通的<strong>Button</strong>其实没什么两样，都是调用<code>setOnClickListener()</code>方法来设置按钮的点击事件，这里我们只是弹出了一个Toast。</p><h3 id="4-2-Snackbar"><a href="#4-2-Snackbar" class="headerlink" title="4.2 Snackbar"></a>4.2 Snackbar</h3><p>首先我们要明确，Snackbar并不是Toast的替代品，它们有着不同的应用场景。Toast的作用是告诉用户现在发生了什么事情，但用户只能被动接收这个事情，因为没有什么办法能让用户进行选择。而Snackbar则在这方面进行了扩展，它允许在提示中加入一个可交互按钮，当用户点击按钮的时候，可以执行一些额外的逻辑操作。打个比方，如果我们在执行删除操作的时候只弹出一个Toast提示，那么用户要是误删了某个重要数据的话，肯定会十分抓狂吧，但是如果我们增加一个Undo按钮，就相当于给用户提供了一种弥补措施，从而大大降低了事故发生的概率，提升了用户体验。</p><p>Snackbar的用法也非常简单，它和Toast是基本相似的，只不过可以额外增加一个按钮的点击事件。修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line">        mainBinding.fab.setOnClickListener &#123; view -&gt;</span><br><span class="line">            Snackbar.make(view, <span class="string">&quot;Data deleted&quot;</span>, Snackbar.LENGTH_SHORT)</span><br><span class="line">                .setAction(<span class="string">&quot;Undo&quot;</span>) &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;Data restored&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">                .show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里调用了Snackbar的<code>make()</code>方法来创建一个Snackbar对象。<code>make()</code>方法的第一个参数需要传入一个View，只要是当前界面布局的任意一个View都可以，Snackbar会使用这个View自动查找最外层的布局，用于展示提示信息；第二个参数就是Snackbar中显示的内容；第三个参数是Snackbar显示的时长，这些和Toast都是类似的。</p><p>接着这里又调用了一个<code>setAction()</code>方法来设置一个动作，从而让Snackbar不仅仅是一个提示，而是可以和用户进行交互的。简单起见，我们在动作按钮的点击事件里面弹出一个Toast提示。最后调用<code>show()</code>方法让Snackbar显示出来。</p><p>我们会发现这个Snackbar竟然将我们的悬浮按钮给遮挡住了。虽说也不是什么重大的问题，因为Snackbar过一会儿就会自动消失，但这种用户体验总归是不友好的。这时候只需要借助CoordinatorLayout就可以轻松解决。</p><h3 id="4-3-CoordinatorLayout"><a href="#4-3-CoordinatorLayout" class="headerlink" title="4.3 CoordinatorLayout"></a>4.3 CoordinatorLayout</h3><p><code>CoordinatorLayout</code>可以说是一个加强版的FrameLayout，由AndroidX库提供。它在普通情况下的作用和FrameLayout基本一致，但是它拥有一些额外的Material能力。</p><p>事实上，<code>CoordinatorLayout</code>可以监听其所有子控件的各种事件，并自动帮助我们做出最为合理的响应。举个简单的例子，刚才弹出的Snackbar提示将悬浮按钮遮挡住了，而如果我们能让<code>CoordinatorLayout</code>监听到Snackbar的弹出事件，那么它会自动将内部的<code>FloatingActionButton</code>向上偏移，从而确保不会被Snackbar遮挡。</p><p>至于<code>CoordinatorLayout</code>的使用也非常简单，我们只需要将原来的FrameLayout替换一下就可以了。修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:elevation</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于<code>CoordinatorLayout</code>本身就是一个加强版的FrameLayout，因此这种替换不会有任何的副作用。</p><p>可以看到，悬浮按钮自动向上偏移了Snackbar的同等高度，从而确保不会被遮挡。当Snackbar消失的时候，悬浮按钮会自动向下偏移回到原来的位置。</p><p>另外，悬浮按钮的向上和向下偏移也是伴随着动画效果的，且和Snackbar完全同步，整体效果看上去特别赏心悦目。</p><p>不过我们回过头来再思考一下，刚才说的是<code>CoordinatorLayout</code>可以监听其所有子控件的各种事件，但是Snackbar好像并不是<code>CoordinatorLayout</code>的子控件吧，为什么它却可以被监听到呢？</p><p>其实道理很简单，<strong>我们在Snackbar的make()方法中传入的第一个参数就是用来指定Snackbar是基于哪个View触发的，刚才我们传入的是FloatingActionButton本身，而FloatingActionButton是CoordinatorLayout中的子控件，因此这个事件就理所应当能被监听到了。</strong>如果给Snackbar的make()方法传入一个DrawerLayout，那么Snackbar就会再次遮挡悬浮按钮，因为DrawerLayout不是<code>CoordinatorLayout</code>的子控件，<code>CoordinatorLayout</code>也就无法监听到Snackbar的弹出和隐藏事件了。</p><h2 id="五、卡片式布局"><a href="#五、卡片式布局" class="headerlink" title="五、卡片式布局"></a>五、卡片式布局</h2><p>虽然现在MaterialTest中已经应用了非常多的Material Design效果，不过你会发现，界面上最主要的一块区域还处于空白状态。这块区域通常用来放置应用的主体内容，接下来我们将使用一些精美的水果图片来填充这部分区域。</p><p>为了要让水果图片也能Material化，我们将会学习如何实现卡片式布局的效果。卡片式布局也是Materials Design中提出的一个新概念，它可以让页面中的元素看起来就像在卡片中一样，并且还能拥有圆角和投影，下面我们就开始具体学习一下。</p><h3 id="5-1-MaterialCardView"><a href="#5-1-MaterialCardView" class="headerlink" title="5.1 MaterialCardView"></a>5.1 MaterialCardView</h3><p><code>MaterialCardView</code>是用于实现卡片式布局效果的重要控件，由Material库提供。实际上，<code>MaterialCardView</code>也是一个FrameLayout，只是额外提供了圆角和阴影等效果，看上去会有立体的感觉。</p><p>先来看一下MaterialCardView的基本用法吧，其实非常简单，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:cardCornerRadius</span>=<span class="string">&quot;4dp&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">app:elevation</span>=<span class="string">&quot;5dp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/infoText&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里定义了一个<code>MaterialCardView</code>布局，我们可以通过<code>app:cardCornerRadius</code>属性指定卡片圆角的弧度，数值越大，圆角的弧度也越大。另外，还可以通过app:elevation属性指定卡片的高度：高度值越大，投影范围也越大，但是投影效果越淡；高度值越小，投影范围也越小，但是投影效果越浓。这一点和<code>FloatingActionButton</code>是一致的。</p><p>然后，我们在<code>MaterialCardView</code>布局中放置了一个TextView，那么这个TextView就会显示在一张卡片当中了，就是这么简单。</p><p>但是，我们显然不可能在如此宽阔的一块空白区域内只放置一张卡片。为了能够充分利用屏幕的空间，这里我准备综合运用一下第4章中学到的知识，使用<code>RecyclerView</code>填充<strong>MaterialTest</strong>项目的主界面部分。还记得之前实现过的水果列表效果吗？这次我们将升级一下，实现一个高配版的水果列表效果。</p><p>然后，由于我们还需要用到<code>RecyclerView</code>，因此必须在app&#x2F;build.gradle文件中声明库的依赖：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;androidx.recyclerview:recyclerview:1.3.2&quot;)</span><br><span class="line">    implementation(&quot;com.github.bumptech.glide:glide:4.16.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述声明的第二行是添加了Glide库的依赖。Glide是一个超级强大的开源图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF图片甚至是本地视频。最重要的是，Glide的用法非常简单，只需几行代码就能轻松实现复杂的图片加载功能，因此这里我们准备用它来加载水果图片。Glide的项目主页地址是：<a href="https://github.com/bumptech/glide">GitHub - bumptech&#x2F;glide: An image loading and caching library for Android focused on smooth scrolling</a></p><p>接下来开始具体的代码实现，修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:elevation</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码中的 <code>AppBarLayout</code> 是一个垂直的 <code>LinearLayout</code>，它实现了许多特性，使得 <code>Toolbar</code> 和其他视图（如 <code>TabLayout</code>）能够正确响应滚动事件。<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code> 是一个指示，告诉 <code>RecyclerView</code> 它需要与 <code>AppBarLayout</code> 协同工作，以确保所有的滚动事件都能被正确处理。这样，当你向上滚动 <code>RecyclerView</code> 时，<code>Toolbar</code> 就会保持在顶部，而不会被覆盖。这里我们在<code>CoordinatorLayout</code>中添加了一个<code>RecyclerView</code>，给它指定一个id，然后将宽度和高度都设置为match_parent，这样RecyclerView就占满了整个布局的空间。</p><p>接着定义一个实体类Fruit，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/5-10:23</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> imageId: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>Fruit类中只有两个字段：name表示水果的名字，imageId表示水果对应图片的资源id。</p><p>然后需要为<code>RecyclerView</code>的子项指定一个我们自定义的布局，在layout目录下新建<code>fruit_item.xml</code>，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardCornerRadius</span>=<span class="string">&quot;4dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用了<code>MaterialCardView</code>来作为子项的最外层布局，从而使得RecyclerView中的每个元素都是在卡片当中的。由于<code>MaterialCardView</code>是一个FrameLayout，因此它没有什么方便的定位方式，这里我们只好在<code>MaterialCardView</code>中再嵌套一个LinearLayout，然后在LinearLayout中放置具体的内容。</p><p>内容倒也没有什么特殊的地方，就是定义了一个ImageView用于显示水果的图片，又定义了一个TextView用于显示水果的名称，并让TextView在水平方向上居中显示。注意，在ImageView中我们使用了一个scaleType属性，这个属性可以指定图片的缩放模式。由于各张水果图片的长宽比例可能会不一致，为了让所有的图片都能填充满整个ImageView，这里使用了centerCrop模式，它可以让图片保持原有比例填充满ImageView，并将超出屏幕的部分裁剪掉。</p><p>接下来需要为<code>RecyclerView</code>准备一个适配器，新建<code>FruitAdapter</code>类，让这个适配器继承自<code>RecyclerView.Adapter</code>，并将泛型指定为<code>FruitAdapter.ViewHolder</code>，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.Glide</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/5-10:43</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(<span class="keyword">val</span> context: Context, <span class="keyword">val</span> fruitList: List&lt;Fruit&gt;) :</span><br><span class="line">    RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">            <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">            <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(context).inflate(R.layout.fruit_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fruitList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        holder.fruitName.text = fruit.name</span><br><span class="line">        Glide.with(context).load(fruit.imageId).into(holder.fruitImage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onBindViewHolder()</code>方法中我们使用了Glide来加载水果图片。</p><p>那么这里就顺便来看一下Glide的用法吧，其实并没有太多好讲的，因为Glide的用法实在是太简单了。首先调用<code>Glide.with()</code>方法并传入一个Context、Activity或Fragment参数，然后调用<code>load()</code>方法加载图片，可以是一个URL地址，也可以是一个本地路径，或者是一个资源id，最后调用<code>into()</code>方法将图片设置到具体某一个ImageView中就可以了。</p><p>那么我们为什么要使用Glide而不是传统的设置图片方式呢？因为这些水果图片像素非常高，如果不进行压缩就直接展示的话，很容易引起内存溢出。而使用Glide就完全不需要担心这回事，Glide在内部做了许多非常复杂的逻辑操作，其中就包括了图片压缩，我们只需要安心按照Glide的标准用法去加载图片就可以了。</p><p>这样我们将<code>RecyclerView</code>的适配器也准备好了，最后修改<code>MainActivity</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.Menu</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.GravityCompat</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.GridLayoutManager</span><br><span class="line"><span class="keyword">import</span> com.google.android.material.snackbar.Snackbar</span><br><span class="line"><span class="keyword">import</span> work.icu007.materialtes.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruits = mutableListOf(</span><br><span class="line">        Fruit(<span class="string">&quot;Apple&quot;</span>, R.drawable.apple),</span><br><span class="line">        Fruit(<span class="string">&quot;Banana&quot;</span>, R.drawable.banana),</span><br><span class="line">        Fruit(<span class="string">&quot;Orange&quot;</span>, R.drawable.orange),</span><br><span class="line">        Fruit(<span class="string">&quot;Watermelon&quot;</span>, R.drawable.watermelon),</span><br><span class="line">        Fruit(<span class="string">&quot;Pear&quot;</span>, R.drawable.pear),</span><br><span class="line">        Fruit(<span class="string">&quot;Grape&quot;</span>, R.drawable.grape),</span><br><span class="line">        Fruit(<span class="string">&quot;Pineapple&quot;</span>, R.drawable.pineapple),</span><br><span class="line">        Fruit(<span class="string">&quot;Strawberry&quot;</span>, R.drawable.strawberry),</span><br><span class="line">        Fruit(<span class="string">&quot;Cherry&quot;</span>, R.drawable.cherry),</span><br><span class="line">        Fruit(<span class="string">&quot;Mango&quot;</span>, R.drawable.mango),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        initFruits()</span><br><span class="line">        <span class="keyword">val</span> layoutManager = GridLayoutManager(<span class="keyword">this</span>, <span class="number">2</span>)</span><br><span class="line">        mainBinding.recyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(<span class="keyword">this</span>, fruitList)</span><br><span class="line">        mainBinding.recyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fruitList.clear()</span><br><span class="line">        repeat(<span class="number">520</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> index = (<span class="number">0</span> until fruits.size).random()</span><br><span class="line">            fruitList.add(fruits[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>MainActivity</code>中，我们首先定义了一个水果集合，集合里面存放了很多个Fruit的实例，每个实例都代表一种水果。然后在<code>initFruits()</code>方法中，先是清空了一下fruitList中的数据，接着使用一个随机函数，从刚才定义的Fruit数组中随机挑选一个水果放入fruitList当中，这样每次打开程序看到的水果数据都会是不同的。另外，为了让界面上的数据多一些，这里使用了<code>repeat()</code>函数，随机挑选50个水果。</p><p>之后的用法就是RecyclerView的标准用法了，不过这里使用了GridLayoutManager这种布局方式。GridLayoutManager的用法并没有什么特别之处，它的构造函数接收两个参数：第一个是Context，第二个是列数。这里我们希望每一行中会有两列数据。</p><h3 id="5-2-AppBarLayout"><a href="#5-2-AppBarLayout" class="headerlink" title="5.2 AppBarLayout"></a>5.2 AppBarLayout</h3><p>我们的<strong>Toolbar</strong>怎么不见了！仔细观察一下原来是被<code>RecyclerView</code>给挡住了。这个问题又该怎么解决呢？这就需要借助另外一个工具了——<code>AppBarLayout</code>。</p><p>首先，我们来分析一下为什么<code>RecyclerView</code>会把<strong>Toolbar</strong>给遮挡住吧。其实并不难理解，由于<code>RecyclerView</code>和<strong>Toolbar</strong>都是放置在<code>CoordinatorLayout</code>中的，而前面已经说过，<code>CoordinatorLayout</code>就是一个加强版的<code>FrameLayout</code>，那么<code>FrameLayout</code>中的所有控件在不进行明确定位的情况下，默认都会摆放在布局的左上角，从而产生了遮挡的现象。</p><p>既然已经找到了问题的原因，那么该如何解决呢？在传统情况下，使用偏移是唯一的解决办法，即让<code>RecyclerView</code>向下偏移一个<strong>Toolbar</strong>的高度，从而保证不会遮挡到<strong>Toolbar</strong>。不过我们使用的并不是普通的<code>FrameLayout</code>，而是<code>CoordinatorLayout</code>，因此自然会有一些更加巧妙的解决办法。</p><p>这里我准备使用<strong>Material</strong>库中提供的另外一个工具——<code>AppBarLayout</code>。<code>AppBarLayout</code>实际上是一个垂直方向的<code>LinearLayout</code>，它在内部做了很多滚动事件的封装，并应用了一些<code>Material Design</code>的设计理念。</p><p>那么我们怎样使用<code>AppBarLayout</code>才能解决前面的遮挡问题呢？其实只需要两步就可以了，第一步将<strong>Toolbar</strong>嵌套到<code>AppBarLayout</code>中，第二步给<code>RecyclerView</code>指定一个布局行为。修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:elevation</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们首先定义了一个<code>AppBarLayout</code>，并将Toolbar放置在了<code>AppBarLayout</code>里面，然后在<code>RecyclerView</code>中使用<code>app:layout_behavior</code>属性指定了一个布局行为。其中<code>appbar_scrolling_view_behavior</code>这个字符串也是由<br><strong>Material</strong>库提供的。</p><p>虽说使用<code>AppBarLayout</code>已经成功解决了<code>RecyclerView</code>遮挡Toolbar的问题，刚才提到过，<code>AppBarLayout</code>中应用了一些<code>Material Design</code>的设计理念，当<code>RecyclerView</code>滚动的时候就已经将滚动事件通知给<code>AppBarLayout</code>了，只是我们还没进行处理而已。那么下面就让我们来进一步优化，看看<code>AppBarLayout</code>到底能实现什么样的<code>Material Design</code>效果。</p><p>当<code>AppBarLayout</code>接收到滚动事件的时候，它内部的子控件其实是可以指定如何去响应这些事件的，通过<code>app:layout_scrollFlags</code>属性就能实现。修改<code>activity_main.xml</code>中的代码，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:background</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll|enterAlways|snap&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:elevation</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里在<strong>Toolbar</strong>中添加了一个<code>app:layout_scrollFlags</code>属性，并将这个属性的值指定成了<code>scroll|enterAlways|snap</code>。其中，<strong>scroll</strong>表示当<code>RecyclerView</code>向上滚动的时候，<strong>Toolbar</strong>会跟着一起向上滚动并实现隐藏；<code>enterAlways</code>表示当<code>RecyclerView</code>向下滚动的时候，<strong>Toolbar</strong>会跟着一起向下滚动并重新显示；<strong>snap</strong>表示当<strong>Toolbar</strong>还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示。</p><h2 id="六、下拉刷新"><a href="#六、下拉刷新" class="headerlink" title="六、下拉刷新"></a>六、下拉刷新</h2><p>下拉刷新这种功能早就不是什么新鲜的东西了，所有的应用里都会有这个功能。不过市面上现有的下拉刷新功能在风格上各不相同，并且和<code>Material Design</code>还有些格格不入的感觉。因此，<strong>Google</strong>为了让Android的下拉刷新风格能有一个统一的标准，在<code>Material Design</code>中制定了一个官方的设计规范。当然，我们并不需要深入了解这个规范到底是什么样的，因为<strong>Google</strong>早就提供好了现成的控件，我们在项目中直接使用就可以了。</p><p><code>SwipeRefreshLayout</code>就是用于实现下拉刷新功能的核心类，我们把想要实现下拉刷新功能的控件放置到<code>SwipeRefreshLayout</code>中，就可以迅速让这个控件支持下拉刷新。那么在<code>MaterialTest</code>项目中，应该支持下拉刷新功能的控件自然就是<code>RecyclerView</code>了。</p><p>使用<code>SwipeRefreshLayout</code>之前首先需要在<code>app/build.gradle</code>文件中添加如下依赖：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>SwipeRefreshLayout</code>的用法也比较简单，下面我们就直接开始使用了。修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/drawerLayout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/swipeRefresh&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里我们在<code>RecyclerView</code>的外面又嵌套了一层<code>SwipeRefreshLayout</code>，这样<code>RecyclerView</code>就自动拥有下拉刷新功能了。另外需要注意，由于<code>RecyclerView</code>现在变成了<code>SwipeRefreshLayout</code>的子控件，因此之前使用<code>app:layout_behavior</code>声明的布局行为现在也要移到<code>SwipeRefreshLayout</code>中才行。</p><p>不过这还没有结束，虽然<code>RecyclerView</code>已经支持下拉刷新功能了，但是我们还要在代码中处理具体的刷新逻辑才行。修改<code>MainActivity</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line">        mainBinding.swipeRefresh.setColorSchemeColors(R.color.colorPrimary)</span><br><span class="line">        mainBinding.swipeRefresh.setOnRefreshListener &#123;</span><br><span class="line">            refreshFruits(adapter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshFruits</span><span class="params">(adapter: <span class="type">FruitAdapter</span>)</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            runOnUiThread &#123;</span><br><span class="line">                initFruits()</span><br><span class="line">                adapter.notifyDataSetChanged()</span><br><span class="line">                mainBinding.swipeRefresh.isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该还是比较好理解的，首先调用<code>SwipeRefreshLayout</code>的<code>setColorSchemeResources()</code>方法来设置下拉刷新进度条的颜色，这里我们就使用主题中的<code>colorPrimary</code>作为进度条的颜色了。接着调用<code>setOnRefreshListener()</code>方法来设置一个下拉刷新的监听器，当用户进行了下拉刷新操作时，就会回调到Lambda表达式当中，然后我们在这里去处理具体的刷新逻辑就可以了。</p><p>通常情况下，当触发了下拉刷新事件，应该是去网络上请求最新的数据，然后再将这些数据展示出来。这里简单起见，我们就不和网络进行交互了，而是调用一个<code>refreshFruits()</code>方法进行本地刷新操作。<code>refreshFruits()</code>方法中先是开启了一个线程，然后将线程沉睡两秒钟。之所以这么做，是因为本地刷新操作速度非常快，如果不将线程沉睡的话，刷新立刻就结束了，从而看不到刷新的过程。沉睡结束之后，这里使用了<code>runOnUiThread()</code>方法将线程切换回主线程，然后调用<code>initFruits()</code>方法重新生成数据，接着再调用<code>FruitAdapter</code>的<code>notifyDataSetChanged()</code>方法通知数据发生了变化，最后调用<code>SwipeRefreshLayout</code>的<code>setRefreshing()</code>方法并传入false，表示刷新事件结束，并隐藏刷新进度条。</p><h2 id="七、可折叠式标题栏"><a href="#七、可折叠式标题栏" class="headerlink" title="七、可折叠式标题栏"></a>七、可折叠式标题栏</h2><p>我们现在的标题栏是使用<strong>Toolbar</strong>来编写的，不过它看上去和传统的<strong>ActionBar</strong>没什么两样，只不过可以响应<code>RecyclerView</code>的滚动事件来进行隐藏和显示。而<code>Material Design</code>中并没有限定标题栏必须是长这个样子的，事实上，我们可以根据自己的喜好随意定制标题栏的样式。那么本节中我们就来实现一个可折叠式标题栏的效果，这需要借助<code>CollapsingToolbarLayout</code>这个工具。</p><h3 id="7-1-CollapsingToolbarLayout"><a href="#7-1-CollapsingToolbarLayout" class="headerlink" title="7.1 CollapsingToolbarLayout"></a>7.1 CollapsingToolbarLayout</h3><p>顾名思义，<code>CollapsingToolbarLayout</code>是一个作用于<strong>Toolbar</strong>基础之上的布局，它也是由<strong>Material</strong>库提供的。<code>CollapsingToolbarLayout</code>可以让<strong>Toolbar</strong>的效果变得更加丰富，不仅仅是展示一个标题栏，而且能够实现非常华丽的效果。</p><p>不过，<code>CollapsingToolbarLayout</code>是不能独立存在的，它在设计的时候就被限定只能作为<strong>AppBarLayout</strong>的直接子布局来使用。而<strong>AppBarLayout</strong>又必须是<code>CoordinatorLayout</code>的子布局，因此本节中我们要实现的功能其实需要综合运用前面所学的各种知识。那么话不多说，这就开始吧。</p><p>首先我们需要一个额外的<strong>Activity</strong>作为水果的详情展示界面，<code>右击work.icu007.materialtest包→New→Activity→Empty Activity</code>，创建一个<code>FruitActivity</code>，并将布局名指定成<code>activity_fruit.xml</code>，然后我们开始编写水果详情展示界面的布局。</p><p>由于整个布局文件比较复杂，这里准备采用分段编写的方式。<code>activity_fruit.xml</code>中的内容主要分为两部分，一个是水果标题栏，一个是水果内容详情，我们来一步步实现。</p><p>首先实现标题栏部分，这里使用<code>CoordinatorLayout</code>作为最外层布局，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着我们在<code>CoordinatorLayout</code>中嵌套一个<code>AppBarLayout</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/appBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;250dp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前为止也没有什么难理解的地方，我们给<code>AppBarLayout</code>定义了一个id，将它的宽度指定为<strong>match_parent</strong>，高度指定为250 dp.</p><p>接下来我们在<code>AppBarLayout</code>中再嵌套一个<code>CollapsingToolbarLayout</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/appBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;250dp&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/collapsingToolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:contentScrim</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll|exitUntilCollapsed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们使用了新的布局<code>CollapsingToolbarLayout</code>。其中，<strong>id、layout_width和layout_height</strong>这几个属性比较简单，我就不解释了。<strong>android:theme属性指定了一个<code>ThemeOverlay.AppCompat.Dark.ActionBar</code>的主题</strong>，其实对于这部分我们也并不陌生，因为之前在activity_main.xml中给Toolbar指定的也是这个主题，只不过<strong>这里要实现更加高级的Toolbar效果，因此需要将这个主题的指定提到上一层来</strong>。**<code>app:contentScrim</code>属性用于指定<code>CollapsingToolbarLayout</code>在趋于折叠状态以及折叠之后的背景色<strong>，其实<code>CollapsingToolbarLayout</code>在折叠之后就是一个普通的</strong>Toolbar<strong>，那么背景色肯定应该是colorPrimary了，具体的效果我们待会儿就能看到。<code>app:layout_scrollFlags</code>属性我们也是见过的，只不过之前是给Toolbar指定的，现在也移到外面来了。其中，</strong><code>scroll</code>表示<code>CollapsingToolbarLayout</code>会随着水果内容详情的滚动一起滚动，<code>exitUntilCollapsed</code>表示当<code>CollapsingToolbarLayout</code>随着滚动完成折叠之后就保留在界面上，不再移出屏幕。**</p><p>接下来，我们在<code>CollapsingToolbarLayout</code>中定义标题栏的具体内容，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/appBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;250dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/collapsingToolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:contentScrim</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll|exitUntilCollapsed&quot;</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImageView&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_collapseMode</span>=<span class="string">&quot;parallax&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_collapseMode</span>=<span class="string">&quot;pin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们在<code>CollapsingToolbarLayout</code>中定义了一个<strong>ImageView</strong>和一个<strong>Toolbar</strong>，也就意味着，这个高级版的标题栏将是由普通的标题栏加上图片组合而成的。这里定义的大多数属性我们是已经见过的，就不再解释了，只有一个<code>app:layout_collapseMode</code>比较陌生。它用于指定当前控件在<code>CollapsingToolbarLayout</code>折叠过程中的折叠模式，<strong>其中Toolbar指定成pin，表示在折叠的过程中位置始终保持不变</strong>，<strong>ImageView指定成parallax，表示会在折叠的过程中产生一定的错位偏移，这种模式的视觉效果会非常好。</strong></p><p>这样我们就将水果标题栏的界面编写完成了，下面开始编写水果内容详情部分。继续修改<code>activity_fruit.xml</code>中的代码，如下所示：</p><p>水果内容详情的最外层布局使用了一个<code>NestedScrollView</code>，注意它和<code>AppBarLayout</code>是平级的。<code>ScrollView</code>使用滚动的方式来查看屏幕以外的数据，而<code>NestedScrollView</code>在此基础之上还增加了嵌套响应滚动事件的功能。由于<code>CoordinatorLayout</code>本身已经可以响应滚动事件了，因此我们在它的内部就需要使用<code>NestedScrollView</code>或<code>RecyclerView</code>这样的布局。另外，这里还通过<code>app:layout_behavior</code>属性指定了一个布局行为，这和之前在<code>RecyclerView</code>中的用法是一模一样的。</p><p>不管是<code>ScrollView</code>还是<code>NestedScrollView</code>，它们的内部都只允许存在一个直接子布局。因此,如果我们想要在里面放入很多东西的话，通常会先嵌套一个<code>LinearLayout</code>，然后再在<code>LinearLayout</code>中放入具体的内容就可以了，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们嵌套了一个垂直方向的<code>LinearLayout</code>，并将<strong>layout_width</strong>设置为<strong>match_parent</strong>，将<strong>layout_height</strong>设置为<strong>wrap_content</strong>。</p><p>接下来在<code>LinearLayout</code>中放入具体的内容，这里准备使用一个TextView来显示水果的内容详情，并将TextView放在一个卡片式布局当中，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;35dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardCornerRadius</span>=<span class="string">&quot;4dp&quot;</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitContentText&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码也没有什么难理解的地方，都是我们学过的知识。需要注意的是，这里为了让界面更加美观，我在<code>MaterialCardView</code>和<code>TextView</code>上都加了一些边距。其中，<code>MaterialCardView</code>的<code>marginTop</code>加了<code>35 dp</code>的边距，这是为下面要编写的东西留出空间。</p><p>好的，这样就把水果标题栏和水果内容详情的界面都编写完了，不过我们还可以在界面上再添加一个悬浮按钮。这个悬浮按钮并不是必需的，根据具体的需求添加就可以了，如果加入的话，我们将获得一些额外的动画效果。</p><p>为了做出示范，我就准备在<code>activity_fruit.xml</code>中加入一个悬浮按钮了。这个界面是一个水果详情展示界面，那么我就加入一个表示评论作用的悬浮按钮吧。首先需要提前准备好一个图标，这里我放置了一张<code>ic_comment.png</code>到<code>drawable-xxhdpi</code>目录下。然后修改<code>activity_fruit.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/appBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;250dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_comment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_anchor</span>=<span class="string">&quot;@id/appBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_anchorGravity</span>=<span class="string">&quot;bottom|end&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里加入了一个<code>FloatingActionButton</code>，它和<code>AppBarLayout</code>以及<code>NestedScrollView</code>是平级的。<code>FloatingActionButton</code>中使用<code>app:layout_anchor</code>属性指定了一个锚点，我们将锚点设置为AppBarLayout，这样悬浮按钮就会出现在水果标题栏的区域内，接着又使用<code>app:layout_anchorGravity</code>属性将悬浮按钮定位在标题栏区域的右下角。其他一些属性比较简单，就不再进行解释了。</p><p>好了，现在我们终于将整个<code>activity_fruit.xml</code>布局都编写完了，内容虽然比较长，但由于是分段编写的，并且每一步我都进行了详细的说明，相信你应该看得很明白吧。</p><p>界面完成了之后，接下来我们开始编写功能逻辑，修改<code>FruitActivity</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.Glide</span><br><span class="line"><span class="keyword">import</span> work.icu007.materialtes.databinding.ActivityFruitBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> FRUIT_NAME = <span class="string">&quot;fruit_name&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> FRUIT_IMAGE_ID = <span class="string">&quot;fruit_image_id&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> fruitBinding: ActivityFruitBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        fruitBinding = ActivityFruitBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(fruitBinding.root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> fruitName = intent.getStringExtra(FRUIT_NAME) ?: <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">val</span> fruitImageId = intent.getIntExtra(FRUIT_IMAGE_ID, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        setSupportActionBar(fruitBinding.toolbar)</span><br><span class="line">        supportActionBar?.setDisplayHomeAsUpEnabled(<span class="literal">true</span>)</span><br><span class="line">        fruitBinding.collapsingToolbar.title = fruitName</span><br><span class="line">        Glide.with(<span class="keyword">this</span>).load(fruitImageId).into(fruitBinding.fruitImageView)</span><br><span class="line">        fruitBinding.fruitContentText.text == generateFruitContent(fruitName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">            android.R.id.home -&gt; &#123;</span><br><span class="line">                finish()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">generateFruitContent</span><span class="params">(fruitName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> fruitName.repeat(<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FruitActivity</code>中的代码并不是很复杂。首先，在<code>onCreate()</code>方法中，我们通过<strong>Intent</strong>获取了传入的水果名和水果图片的资源id。接着使用了<strong>Toolbar</strong>的标准用法，将它作为<strong>ActionBar</strong>显示，并启用<strong>Home</strong>按钮。由于<strong>Home</strong>按钮的默认图标就是一个返回箭头，这正是我们所期望的，因此就不用额外设置别的图标了。</p><p>接下来开始填充界面上的内容，调用<code>CollapsingToolbarLayout</code>的<code>setTitle()</code>方法，将水果名设置成当前界面的标题，然后使用<strong>Glide</strong>加载传入的水果图片，并设置到标题栏的<strong>ImageView</strong>上面。接着需要填充水果的内容详情，由于这只是一个示例程序，并不需要什么真实的数据，所以我使用了一个<code>generateFruitContent()</code>方法将水果名循环拼接500次，从而生成了一个比较长的字符串，将它设置到了<code>TextView</code>上面。</p><p>最后，我们在<code>onOptionsItemSelected()</code>方法中处理了Home按钮的点击事件，当点击这个按钮时，就调用<code>finish()</code>方法关闭当前的<strong>Activity</strong>，从而返回上一个<strong>Activity</strong>。</p><p>所有工作都完成了吗？其实还差最关键的一步，就是处理<code>RecyclerView</code>的点击事件，不然的话，我们根本就无法打开<code>FruitActivity</code>。修改<code>FruitAdapter</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(<span class="keyword">val</span> context: Context, <span class="keyword">val</span> fruitList: List&lt;Fruit&gt;) :</span><br><span class="line">    RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(context).inflate(R.layout.fruit_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> holder = ViewHolder(view)</span><br><span class="line">        holder.itemView.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> position = holder.bindingAdapterPosition</span><br><span class="line">            <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, FruitActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">                putExtra(FruitActivity.FRUIT_NAME, fruit.name)</span><br><span class="line">                putExtra(FruitActivity.FRUIT_IMAGE_ID, fruit.imageId)</span><br><span class="line">            &#125;</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的一步其实也是最简单的，这里我们给fruit_item.xml的最外层布局注册了一个点击事件监听器，然后在点击事件中获取当前点击项的水果名和水果图片资源id，把它们传入Intent中，最后调用startActivity()方法启动FruitActivity。</p><h3 id="7-2-充分利用系统状态栏空间"><a href="#7-2-充分利用系统状态栏空间" class="headerlink" title="7.2 充分利用系统状态栏空间"></a>7.2 充分利用系统状态栏空间</h3><p>虽说现在水果详情展示界面的效果已经非常华丽了，但这并不代表我们不能再进一步地提升。观察一下图12.17，你会发现水果的背景图片和系统的状态栏总有一些不搭的感觉，如果我们能将背景图和状态栏融合到一起，那这个视觉体验绝对能提升好几个档次。</p><p>不过，在Android 5.0系统之前，我们是无法对状态栏的背景或颜色进行操作的，那个时候也还没有Material Design的概念，但是Android 5.0及之后的系统都是支持这个功能的。恰好我们整本书的所有代码最低兼容的就是Android 5.0系统，因此这里完全可以进一步地提升视觉体验。</p><p>想要让背景图能够和系统状态栏融合，需要借助<code>android:fitsSystemWindows</code>这个属性来实现。在<code>CoordinatorLayout</code>、<code>AppBarLayout</code>、<code>CollapsingToolbarLayout</code>这种嵌套结构的布局中，将控件的<code>android:fitsSystemWindows</code>属性指定成<strong>true</strong>，就表示该控件会出现在系统状态栏里。对应到我们的程序，那就是水果标题栏中的<code>ImageView</code>应该设置这个属性了。不过只给ImageView设置这个属性是没有用的，我们必须将ImageView布局结构中的所有父布局都设置上这个属性才可以，修改<code>activity_fruit.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FruitActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/appBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;250dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/collapsingToolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;235dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:contentScrim</span>=<span class="string">&quot;@color/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll|exitUntilCollapsed&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImageView&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_collapseMode</span>=<span class="string">&quot;parallax&quot;</span>/&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>android:fitsSystemWindows</code>属性都设置好了之后还必须在程序的主题中将状态栏颜色指定成透明色才行。指定成透明色的方法很简单，在主题中将<code>android:statusBarColor</code>属性的值指定成<code>@android:color/transparent</code>就可以了。</p><p>打开 <code>res/values/theme.xml</code> 文件，对主题的内容进行修改，如下所示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Base.Theme.MaterialTest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.Material3.DayNight.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your light theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- &lt;item name=&quot;colorPrimary&quot;&gt;@color/my_light_primary&lt;/item&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.MaterialTest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.MaterialTest&quot;</span> /&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.FruitActivity&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.MaterialTest&quot;</span> &gt;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">    </span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们定义了一个<code>FruitActivity</code>主题，它是专门给<code>FruitActivity</code>使用的。<code>FruitActivity</code>的父主题是<code>Base.Theme.MaterialTest</code>，也就是说，它继承了<code>Base.Theme.MaterialTest</code>中的所有特性。在此基础之上，我们将<code>FruitActivityTheme</code>中的状态栏的颜色指定成透明色。最后，还需要让<code>FruitActivity</code>使用这个主题才可以，修改<code>AndroidManifest.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.MaterialTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.FruitActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.FruitActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是Material-Design&quot;&gt;&lt;a href=&quot;#一、什么是Material-Design&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Material Design&quot;&gt;&lt;/a&gt;一、什么是Material Design&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-高级技巧</title>
    <link href="https://icu007work.github.io/archives/6c099795.html"/>
    <id>https://icu007work.github.io/archives/6c099795.html</id>
    <published>2024-02-04T07:31:01.000Z</published>
    <updated>2024-05-11T07:45:56.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、全局获取Context的技巧"><a href="#一、全局获取Context的技巧" class="headerlink" title="一、全局获取Context的技巧"></a>一、全局获取Context的技巧</h2><p>在Android开发过程中很多地方都需要用到Context，弹出Toast的时候需要，启动Activity的时候需要，发送广播的时候需要，操作数据库的时候需要，使用通知的时候需要……</p><p>当应用程序的架构逐渐开始复杂起来的时候，很多逻辑代码将脱离Activity类，但此时我们又恰恰需要使用Context，这个时候就会感到有些伤脑筋了。</p><p>Android提供了一个Application类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的Application类，以便于管理程序内一些全局的状态信息，比如全局Context。</p><p>定制一个自己的Application其实并不复杂，首先需要创建一个MyApplication类继承自Application，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        context = applicationContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，MyApplication中的代码非常简单。这里我们在companion object中定义了一个context变量，然后重写父类的onCreate()方法，并将调用getApplicationContext()方法得到的返回值赋值给context变量，这样我们就可以以静态变量的形式获取Context对象了。</p><p>需要注意的是，将Context设置成静态变量很容易会产生内存泄漏的问题，所以这是一种有风险的做法。</p><p>但是由于这里获取的不是Activity或Service中的Context，而是Application中的Context，它全局只会存在一份实例，并且在整个应用程序的生命周期内都不会回收，因此是不存在内存泄漏风险的。那么我们可以使用如下注解，让Android Studio忽略上述警告提示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="string">&quot;StaticFieldLeak&quot;</span>)</span></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们还需要告知系统，当程序启动的时候应该初始化<code>MyApplication</code>类，而不是默认的<code>Application</code>类。这一步也很简单，在<code>AndroidManifest.xml</code>文件的<code>&lt;application&gt;</code>标签下进行指定就可以了，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.MyApplication&quot;</span>// <span class="attr">这里指定初始化MyApplication类</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.MaterialTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们就实现了一种全局获取Context的机制，之后不管你想在项目的任何地方使用Context，只需要调用一下<code>MyApplication.context</code>就可以了。那么接下来我们再对<code>showToast()</code>方法进行优化，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/19-10:48</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Toast.makeText(MyApplication.context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">showToast</span><span class="params">(duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Toast.makeText(MyApplication.context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>showToast()</code>方法不需要再通过传递参数的方式得到Context对象，而是调用一下<code>MyApplication.context</code>就可以了。这样<code>showToast()</code>方法的用法也得到了进一步的精简，现在只需要使用如下写法就能弹出一段文字提示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;toast test&quot;</span>.showToast()</span><br></pre></td></tr></table></figure><h2 id="二、使用Intent传递对象"><a href="#二、使用Intent传递对象" class="headerlink" title="二、使用Intent传递对象"></a>二、使用Intent传递对象</h2><p>我们可以借助<strong>Intent</strong>来<strong>启动Activity</strong>、<strong>启动Service</strong>、<strong>发送广播</strong>等。在进行上述操作的时候，我们还可以在<strong>Intent</strong>中添加一些附加数据，以达到传值的效果，比如在<code>FirstActivity</code>中添加如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;string_data&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;int_data&quot;</span>, <span class="number">100</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>这里调用了<strong>Intent</strong>的<code>putExtra()</code>方法来添加要传递的数据，之后在<code>SecondActivity</code>中就可以得到这些值了，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.getStringExtra(<span class="string">&quot;string_data&quot;</span>)</span><br><span class="line">intent.getIntExtra(<span class="string">&quot;int_data&quot;</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>putExtra()</code>方法中所支持的数据类型是有限的，虽然常用的一些数据类型是支持的，但是当你想去传递一些自定义对象的时候，就会发现无从下手。</p><h3 id="2-1-Serializable方式"><a href="#2-1-Serializable方式" class="headerlink" title="2.1 Serializable方式"></a>2.1 Serializable方式</h3><p>使用Intent来传递对象通常有两种实现方式：<code>Serializable</code>和<code>Parcelable</code>。</p><p><code>Serializable</code>是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方法非常简单，只需要让一个类去实现<code>Serializable</code>这个接口就可以了。</p><p>比如说有一个Person类，其中包含了name和age这两个字段，如果想要将他序列化，就可以这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="type">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们让Person类实现了Serializable接口，这样所有的Person对象都是可序列化的了。</p><p>然后在FirstActivity中只需要这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br><span class="line">person.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">person.age = <span class="number">20</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;person_data&quot;</span>, person)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>这里我们创建了一个<strong>Person</strong>的实例，并将它直接传入了<strong>Intent</strong>的<code>putExtra()</code>方法中。由于Person类实现了<code>Serializable</code>接口，所以才可以这样写。</p><p>接下来在<code>SecondActivity</code>中获取这个对象也很简单，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = intent.getSerializableExtra(<span class="string">&quot;person_data&quot;</span>) <span class="keyword">as</span> Person</span><br></pre></td></tr></table></figure><p>这里调用了Intent的getSerializableExtra()方法来获取通过参数传递过来的序列化对象，接着再将它向下转型成Person对象，这样我们就成功实现了使用Intent传递对象的功能。需要注意的是，这种传递对象的工作原理是先将一个对象序列化成可存储或可传输的状态，传递给另外一个Activity后再将其反序列化成一个新的对象。虽然这两个对象中存储的数据完全一致，但是它们实际上是不同的对象.</p><h3 id="2-2-Parcelable方式"><a href="#2-2-Parcelable方式" class="headerlink" title="2.2 Parcelable方式"></a>2.2 Parcelable方式</h3><p>除了<code>Serializable</code>之外，使用 <code>Parcelable</code> 也可以实现相同的效果，不过不同于将对象进行序列化， <code>Parcelable</code>方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样就能实现传递对象的功能了。</p><p>下面来看一下 <code>Parcelable</code>的实现方式，修改Person中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="type">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        parcel.writeString(name)<span class="comment">// 写出name</span></span><br><span class="line">        parcel.writeInt(age)<span class="comment">// 写出age</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Parcelable.Creator&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">val</span> person = Person</span><br><span class="line">            person.name = parcel.readString() ?: <span class="string">&quot;&quot;</span><span class="comment">// 读取name</span></span><br><span class="line">            person.age = parcel.readInt()<span class="comment">// 读取age</span></span><br><span class="line">            <span class="keyword">return</span> person</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;Person?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls)size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parcelable</code>的实现方式要稍微复杂一些。可以看到，首先我们让Person类实现了<code>Parcelable</code>接口，这样就必须重写<code>describeContents()</code>和<code>writeToParcel()</code>这两个方法。其中<code>describeContents()</code>方法直接返回0就可以了，而在<code>writeToParcel()</code>方法中，我们需要调用Parcel的<code>writeXxx()</code>方法，将Person类中的字段一一写出。<strong>注意，字符串型数据就调用<code>writeString()</code>方法，整型数据就调用<code>writeInt()</code>方法，以此类推。</strong></p><p>除此之外，<strong>我们还必须在Person类中提供一个名为CREATOR的匿名类实现。</strong>这里创建了<code>Parcelable.Creator</code>接口的一个实现，并将泛型指定为Person。接着需要重写<code>createFromParcel()</code>和<code>newArray()</code>这两个方法，在<code>createFromParcel()</code>方法中，我们要创建一个Person对象进行返回，并读取刚才写出的name和age字段。其中name和age都是调用Parcel的<code>readXxx()</code>方法读取到的，注意这里读取的顺序一定要和刚才写出的顺序完全相同。而<code>newArray()</code>方法中的实现就简单多了，只需要调用<code>arrayOfNulls()</code>方法，并使用参数中传入的size作为数组大小，创建一个空的Person数组即可。</p><p>接下来，在<code>FirstActivity</code>中我们仍然可以使用相同的代码来传递Person对象，只不过在<code>SecondActivity</code>中获取对象的时候需要稍加改动，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = intent.getParcelableExtra(<span class="string">&quot;person_data&quot;</span>) <span class="keyword">as</span> Person</span><br></pre></td></tr></table></figure><p>这里不再是调用<code>getSerializableExtra()</code>方法，而是调用<code>getParcelableExtra()</code>方法来获取传递过来的对象，其他的地方完全相同。</p><p>不过，这种实现方式写起来确实比较复杂，为此Kotlin给我们提供了另外一种更加简便的用法，但前提是要传递的所有数据都必须封装在对象的主构造函数中才行。</p><p>修改Person类中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age:<span class="built_in">Int</span>) : Parcelable</span><br></pre></td></tr></table></figure><p>没错，就是这么简单。将name和age这两个字段移动到主构造函数中，然后给Person类添加一个@Parcelize注解即可.</p><p>对比一下，Serializable的方式较为简单，但由于会把整个对象进行序列化，因此效率会比Parcelable方式低一些，所以在通常情况下，还是更加推荐使用Parcelable的方式来实现Intent传递对象的功能。</p><h2 id="三、定制自己的日志工具"><a href="#三、定制自己的日志工具" class="headerlink" title="三、定制自己的日志工具"></a>三、定制自己的日志工具</h2><p>虽然Android中自带的日志工具功能非常强大，但也不能说完全没有缺点，例如在打印日志的控制方面就做得不够好。</p><p>打个比方，你正在编写一个比较庞大的项目，期间为了方便调试，在代码的很多地方打印了大量的日志。最近项目已经基本完成了，但是却有一个非常让人头疼的问题，之前用于调试的那些日志，在项目正式上线之后仍然会照常打印，这样不仅会降低程序的运行效率，还有可能将一些机密性的数据泄露出去。</p><p>那该怎么办呢？难道要一行一行地把所有打印日志的代码都删掉吗？显然这不是什么好点子，不仅费时费力，而且以后你继续维护这个项目的时候可能还会需要这些日志。因此，最理想的情况是能够自由地控制日志的打印，当程序处于开发阶段时就让日志打印出来，当程序上线之后就把日志屏蔽掉。</p><p>看起来好像是挺高级的一个功能，其实并不复杂，我们只需要定制一个自己的日志工具就可以轻松完成了。新建一个LogUtil单例类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.materialtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/19-11:42</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> LogUtil &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> VERBOSE = <span class="number">1</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DEBUG = <span class="number">2</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> INFO= <span class="number">3</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> WARN = <span class="number">4</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ERROR = <span class="number">5</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> level = VERBOSE</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= VERBOSE) &#123;</span><br><span class="line">            Log.v(tag,msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= DEBUG) &#123;</span><br><span class="line">            Log.d(tag,msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">i</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= INFO) &#123;</span><br><span class="line">            Log.i(tag,msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">w</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= WARN) &#123;</span><br><span class="line">            Log.w(tag,msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= ERROR) &#123;</span><br><span class="line">            Log.e(tag,msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在LogUtil中首先定义了VERBOSE、DEBUG、INFO、WARN、ERROR这5个整型常量，并且它们对应的值都是递增的。然后又定义了一个静态变量level，可以将它的值指定为上面5个常量中的任意一个。接下来，我们提供了v()、d()、i()、w()、e()这5个自定义的日志方法，在其内部分别调用了<strong>Log.v()、Log.d()、Log.i()、Log.w()、Log.e()这5个方法来打印日志</strong>，只不过在这些自定义的方法中都加入了一个if判断，只有当level的值小于或等于对应日志级别值的时候，才会将日志打印出来。这样就把一个自定义的日志工具创建好了，之后在项目里，我们可以像使用普通的日志工具一样使用LogUtil。比如打印一行DEBUG级别的日志可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LogUtil.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;debug log&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一行WARN级别的日志可以这样写：</span></span><br><span class="line"></span><br><span class="line">LogUtil.w(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;warn log&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们只需要通过修改level变量的值，就可以自由地控制日志的打印行为。比如让level等于VERBOSE就可以把所有的日志都打印出来，让level等于ERROR就可以只打印程序的错误日志。</p><p>使用了这种方法之后，刚才所说的那个问题也就不复存在了</p><h2 id="四、深色主题"><a href="#四、深色主题" class="headerlink" title="四、深色主题"></a>四、深色主题</h2><p>当我们打开我们自己编写的应用程序，会发现目前界面的风格还是使用的浅色主题模式，这就和系统的主题风格不同了，说明我们需要对此进行适配。</p><p>最简单的一种适配方式就是使用<code>Force Dark</code>，它是一种能让应用程序快速适配深色主题，并且几乎不用编写额外代码的方式。<code>Force Dark</code>的工作原理是系统会分析浅色主题应用下的每一层View，并且在这些View绘制到屏幕之前，自动将它们的颜色转换成更加适合深色主题的颜色。注意，只有原本使用浅色主题的应用才能使用这种方式，如果你的应用原本使用的就是深色主题，<code>Force Dark</code>将不会起作用。</p><p>现在Meterial 项目都有自动适配深色主题的功能，在 <code>values--&gt; themes.xml</code>文件中修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Base.Theme.MaterialTest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.Material3.DayNight.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your light theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- &lt;item name=&quot;colorPrimary&quot;&gt;@color/my_light_primary&lt;/item&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.MaterialTest&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.MaterialTest&quot;</span> /&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.FruitActivity&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.MaterialTest&quot;</span> &gt;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml">    </span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Theme.Material3.DayNight.NoActionBar</code>这是一种<code>DayNight</code>主题。因此，在普通情况下<code>MaterialTest</code>项目仍然会使用浅色主题，和之前并没有什么区别，但是一旦用户在系统设置中开启了深色主题，<code>MaterialTest</code>项目就会自动使用相应的深色主题。</p><p>我们还需要修改 <code>values-night</code>目录下的 <code>colors.xml</code>文件，接着在这个文件中指定深色主题下的颜色值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>#303030<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryDark&quot;</span>&gt;</span>#232323<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;colorAccent&quot;</span>&gt;</span>#008577<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话，在普通情况下，系统仍然会读取<code>values/colors.xml</code>文件中的颜色值，而一旦用户开启了深色主题，系统就会去读取<code>values-night/colors.xml</code>文件中的颜色值了。</p><p>另外，或许你还会有一些特殊的需求，比如要在浅色主题和深色主题下分别执行不同的代码逻辑。对此Android也是支持的，你可以使用如下代码在任何时候判断当前系统是否是深色主题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isDarkTheme</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> flag = context.resources.configuration.uiMode and</span><br><span class="line">    Configuration.UI_MODE_NIGHT_MASK</span><br><span class="line">    <span class="keyword">return</span> flag == Configuration_UI_MODE_NIGHT_YES</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>isDarkTheme ()</code>方法，判断当前系统是浅色主题还是深色主题，然后根据返回值执行不同的代码逻辑即可。</p><p>另外，<strong>由于Kotlin取消了按位运算符的写法，改成了使用英文关键字，因此上述代码中的and关键字其实就对应了Java中的&amp;运算符，而Kotlin中的or关键字对应了Java中的|运算符，xor关键字对应了Java中的^运算符</strong>，非常好理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、全局获取Context的技巧&quot;&gt;&lt;a href=&quot;#一、全局获取Context的技巧&quot; class=&quot;headerlink&quot; title=&quot;一、全局获取Context的技巧&quot;&gt;&lt;/a&gt;一、全局获取Context的技巧&lt;/h2&gt;&lt;p&gt;在Android开发过程中很</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-Jetpack</title>
    <link href="https://icu007work.github.io/archives/f8eec5a0.html"/>
    <id>https://icu007work.github.io/archives/f8eec5a0.html</id>
    <published>2024-01-24T07:28:13.000Z</published>
    <updated>2024-05-11T07:45:50.636Z</updated>
    
    <content type="html"><![CDATA[<p>长久以来，Android官方并没有制定一个项目架构的规范，只要能够实现功能，代码怎么编写都是你的自由。但是不同的人技术水平不同，最终编写出来的代码质量是千差万别的。</p><p>由于Android官方没有制定规范，为了追求更高的代码质量，慢慢就有第三方的社区和开发者将一些更加高级的项目架构引入到了Android平台上，如MVP、MVVM等。使用这些架构开发出来的应用程序，在代码质量、可读性、易维护性等方面都有着更加出色的表现，于是这些架构渐渐成为了主流。</p><p>后来Google或许意识到了这个情况，终于在2017年，推出了一个官方的架构组件库——Architecture Components，旨在帮助开发者编写出更加符合高质量代码规范、更具有架构设计的应用程序。2018年，Google又推出了一个全新的开发组件工具集Jetpack，并将Architecture Components作为Jetpack的一部分纳入其中。当然，Jetpack并没有就此定版，2019年又有许多新的组件被加入Jetpack当中，未来的Jetpack还会不断地继续扩充。</p><h2 id="一、Jetpack简介"><a href="#一、Jetpack简介" class="headerlink" title="一、Jetpack简介"></a>一、Jetpack简介</h2><p>Jetpack是一个开发组件工具集，它的主要目的是帮助我们编写出更加简洁的代码，并简化我们<br>的开发过程。Jetpack中的组件有一个特点，它们大部分不依赖于任何Android系统版本，这意<br>味着这些组件通常是定义在AndroidX库当中的，并且拥有非常好的向下兼容性。</p><p>我们先来看一张Jetpack的全家桶</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/03/1709689101811_fc8539c126cff.png" alt="1709689101811.png"></p><p>Jetpack的家族还是非常庞大的，主要由<strong>基础、架构、行为和界面</strong>这4个部分组成。你会发现，里面有许多东西是我们已经学过的，像通知、权限、Fragment都属于Jetpack。由此可见，Jetpack并不全是些新东西，<strong>只要是能够帮助开发者更好更方便地构建应用程序的组件，Google都将其纳入了Jetpack。</strong></p><p>显然这里我们不可能将Jetpack中的每一个组件都进行学习，那将会是一个极大的工程。事实上，在这么多的组件当中，最需要我们关注的其实还是架构组件。目前Android官方最为推荐的项目架构就是MVVM，因而Jetpack中的许多架构组件是专门为MVVM架构量身打造的。</p><h2 id="二、ViewModel"><a href="#二、ViewModel" class="headerlink" title="二、ViewModel"></a>二、ViewModel</h2><p><code>ViewModel</code>应该可以算是Jetpack中最重要的组件之一了。其实Android平台上之所以会出现诸如MVP、MVVM之类的项目架构，就是因为在传统的开发模式下，Activity的任务实在是太重了，既要负责逻辑处理，又要控制UI展示，甚至还得处理网络回调，等等。在一个小型项目中这样写或许没有什么问题，但是如果在大型项目中仍然使用这种写法的话，那么这个项目将会变得非常臃肿并且难以维护，因为没有任何架构上的划分。</p><p>而<code>ViewModel</code>的一个重要作用就是可以帮助Activity分担一部分工作，它是专门用于存放与界面相关的数据的。也就是说，只要是界面上能看得到的数据，它的相关变量都应该存放在<code>ViewModel</code>中，而不是Activity中，这样可以在一定程度上减少Activity中的逻辑。</p><p>另外，<code>ViewModel</code>还有一个非常重要的特性。我们都知道，当手机发生横竖屏旋转的时候，Activity会被重新创建，同时存放在Activity中的数据也会丢失。而<code>ViewModel</code>的生命周期和Activity不同，它可以保证在手机屏幕发生旋转的时候不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，将与界面相关的变量存放在<code>ViewModel</code>当中，这样即使旋转手机屏幕，界面上显示的数据也不会丢失。<code>ViewModel</code>的生命周期如图所示。</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/03/1709689679027_f2eea1d3aa775.png" alt="1709689679027.png"></p><h3 id="2-1-ViewModel的基本用法"><a href="#2-1-ViewModel的基本用法" class="headerlink" title="2.1 ViewModel的基本用法"></a>2.1 ViewModel的基本用法</h3><p>由于Jetpack中的组件通常是以<code>AndroidX</code>库的形式发布的，因此一些常用的Jetpack组件会在创建Android项目时自动被包含进去。不过如果我们想要使用<code>ViewModel</code>组件，还需要在<code>app/build.gradle</code>文件中添加如下依赖：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;androidx.lifecycle:lifecycle-extensions:2.2.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常来讲，<strong>比较好的编程规范是给每一个Activity和Fragment都创建一个对应的ViewModel</strong>，因此这里我们就为<code>MainActivity</code>创建一个对应的<code>MainViewModel</code>类，并让它继承自<code>ViewModel</code>，我们要实现一个计数器的功能，就可以在ViewModel中加入一个counter变量用于计数。代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-10:00</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要在界面上添加一个按钮，每点击一次按钮就让计数器加1，并且把最新的计数显示在界面上。修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/infoText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/plusOneBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/infoText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Plus one&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着我们开始实现计数器的逻辑，修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"><span class="keyword">import</span> work.icu007.jetpacktest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> TAG = MainActivity::<span class="keyword">class</span>.java.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: MainViewModel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        viewModel = ViewModelProvider(<span class="keyword">this</span>)[MainViewModel::<span class="keyword">class</span>.java]</span><br><span class="line"></span><br><span class="line">        mainBinding.plusOneBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.counter++</span><br><span class="line">            refreshCounter()</span><br><span class="line">        &#125;</span><br><span class="line">        refreshCounter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mainBinding.infoText.text = viewModel.counter.toString()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;refreshCounter: &quot;</span> + viewModel.counter.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最需要注意的是，我们绝对不可以直接去创建<code>ViewModel</code>的实例，而是一定要通过<code>ViewModelProvider</code>来获取<code>ViewModel</code>的实例，具体语法规则如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProvider(&lt;你的Activity或Fragment实例&gt;).<span class="keyword">get</span>(&lt;你的ViewModel&gt;::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，我们可以使用 <code>get</code> 方法的索引运算符形式 <code>[]</code> 来获取 ViewModel。这是因为在 <code>ViewModelProvider</code> 类中，<code>get</code> 方法被定义为一个操作符函数。在 Kotlin 中，你可以为任何函数定义一个操作符，这样就可以使用相应的符号来调用这个函数。</p><p>具体来说，<code>ViewModelProvider</code> 类中的 <code>get</code> 方法的定义大概是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">get</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">get</span>(modelClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个定义中，<code>operator</code> 关键字表示这个函数可以作为一个操作符使用。因此，你可以使用 <code>[]</code> 来调用这个函数，就像这样：<code>viewModel = ViewModelProvider(this)[MainViewModel::class.java]</code>。</p><p>之所以要这么写，是因为<code>ViewModel</code>有其独立的生命周期，并且其生命周期要长于Activity。如果我们在<code>onCreate()</code>方法中创建<code>ViewModel</code>的实例，那么每次<code>onCreate()</code>方法执行的时候，<code>ViewModel</code>都会创建一个新的实例，这样当手机屏幕发生旋转的时候，就无法保留其中的数据了。</p><p>除此之外的其他代码应该都是非常好理解的，我们提供了一个<code>refreshCounter()</code>方法用来显示当前的计数，然后每次点击按钮的时候对计数器加1，并调用<code>refreshCounter()</code>方法刷新计数。</p><p>虽然这个例子非常简单，但这就是<code>ViewModel</code>的基本用法</p><h3 id="2-2-向ViewModel传递参数"><a href="#2-2-向ViewModel传递参数" class="headerlink" title="2.2 向ViewModel传递参数"></a>2.2 向ViewModel传递参数</h3><p>上一小节中创建的<code>MainViewModel</code>的构造函数中没有任何参数，但是思考一下，如果我们确实需要通过构造函数来传递一些参数，应该怎么办呢？由于所有<code>ViewModel</code>的实例都是通过<code>ViewModelProvider</code>来获取的，因此我们没有任何地方可以向<code>ViewModel</code>的构造函数中传递参数。</p><p>当然，这个问题也不难解决，只需要借助<code>ViewModelProvider.Factory</code>就可以实现了。下面我们还是通过具体的示例来学习一下。</p><p>现在的计数器虽然在屏幕旋转的时候不会丢失数据，但是如果退出程序之后再重新打开，那么之前的计数就会被清零了。接下来我们就对这一功能进行升级，保证即使在退出程序后又重新打开的情况下，数据仍然不会丢失。</p><p>相信你已经猜到了，实现这个功能需要在退出程序的时候对当前的计数进行保存，然后在重新打开程序的时候读取之前保存的计数，并传递给<code>MainViewModel</code>。因此，这里修改<code>MainViewModel</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-10:00</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = countReserved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们给<code>MainViewModel</code>的构造函数添加了一个<code>countReserved</code>参数，这个参数用于记录之前保存的计数值，并在初始化的时候赋值给counter变量。</p><p>接下来的问题就是如何向<code>MainViewModel</code>的构造函数传递数据了，前面已经说了需要借助<code>ViewModelProvider.Factory</code>，下面我们就来看看具体应该如何实现。新建一个<code>MainViewModelFactory</code>类，并让它实现<code>ViewModelProvider.Factory</code>接口，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-10:50</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModelFactory</span>(<span class="keyword">private</span> <span class="keyword">val</span> countReserved: <span class="built_in">Int</span>) : ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> MainViewModel(countReserved) <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>MainViewModelFactory</code>的构造函数中也接收了一个<code>countReserved</code>参数。另外<code>ViewModelProvider.Factory</code>接口要求我们必须实现<code>create()</code>方法，因此这里在<code>create()</code>方法中我们创建了<code>MainViewModel</code>的实例，并将<code>countReserved</code>参数传了进去。为什么这里就可以创建<code>MainViewModel</code>的实例了呢？因为<code>create()</code>方法的执行时机和Activity的生命周期无关，所以不会产生之前提到的问题。</p><p>另外，我们还得在界面上添加一个清零按钮，方便用户手动将计数器清零。修改<code>activity_main.xml</code>中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/infoText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/plusOneBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/infoText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Plus one&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/clearBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/plusOneBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Clear&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 <code>MainActivity</code>中代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.edit</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"><span class="keyword">import</span> work.icu007.jetpacktest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: MainViewModel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sp: SharedPreferences</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        sp = getPreferences(Context.MODE_PRIVATE)</span><br><span class="line">        <span class="keyword">val</span> countReserved = sp.getInt(<span class="string">&quot;count_reserved&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        viewModel =</span><br><span class="line">            ViewModelProvider(<span class="keyword">this</span>, MainViewModelFactory(countReserved))[MainViewModel::<span class="keyword">class</span>.java]</span><br><span class="line"></span><br><span class="line">        mainBinding.plusOneBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.counter++</span><br><span class="line">            refreshCounter()</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.clearBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.counter = <span class="number">0</span></span><br><span class="line">            refreshCounter()</span><br><span class="line">        &#125;</span><br><span class="line">        refreshCounter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        sp.edit &#123;</span><br><span class="line">            putInt(<span class="string">&quot;count_reserved&quot;</span>, viewModel.counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mainBinding.infoText.text = viewModel.counter.toString()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;refreshCounter: &quot;</span> + viewModel.counter.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onCreate()</code>方法中，我们首先获取了<code>SharedPreferences</code>的实例，然后读取之前保存的计数值，如果没有读到的话，就使用0作为默认值。接下来<strong>在<code>ViewModelProvider</code>中，额外传入了一个<code>MainViewModelFactory</code>参数，这里将读取到的计数值传给了<code>MainViewModelFactory</code>的构造函数。注意，这一步是非常重要的，只有用这种写法才能将计数值最终传递给<code>MainViewModel</code>的构造函数。</strong></p><p>剩下的代码就比较简单了，我们在“Clear”按钮的点击事件中对计数器进行清零，并且在onPause()方法中对当前的计数进行保存，这样可以保证不管程序是退出还是进入后台，计数都不会丢失。</p><h3 id="2-3-Lifecycles"><a href="#2-3-Lifecycles" class="headerlink" title="2.3 Lifecycles"></a>2.3 Lifecycles</h3><p>在编写Android应用程序的时候，可能会经常遇到需要感知Activity生命周期的情况。比如说，某个界面中发起了一条网络请求，但是当请求得到响应的时候，界面或许已经关闭了，这个时候就不应该继续对响应的结果进行处理。因此，我们需要能够时刻感知到Activity的生命周期，以便在适当的时候进行相应的逻辑控制。</p><p>感知Activity的生命周期并不复杂，早在第3章的时候我们就学习过Activity完整的生命周期流程。但问题在于，在一个Activity中去感知它的生命周期非常简单，而如果要在一个非Activity的类中去感知Activity的生命周期，应该怎么办呢？</p><p>这种需求是广泛存在的，同时也衍生出了一系列的解决方案，比如通过在Activity中嵌入一个隐藏的Fragment来进行感知，或者通过手写监听器的方式来进行感知，等等。</p><p>下面的代码演示了如何通过手写监听器的方式来对Activity的生命周期进行感知：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">activityStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">activityStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> observer: MyObserver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        observer = MyObserver()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        observer.activityStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        observer.activityStop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们为了让<code>MyObserver</code>能够感知到Activity的生命周期，需要专门在<code>MainActivity</code>中重写相应的生命周期方法，然后再通知给<code>MyObserver</code>。这种实现方式虽然是可以正常工作的，但是不够优雅，需要在Activity中编写太多额外的逻辑。</p><p>而<code>Lifecycles</code>组件就是为了解决这个问题而出现的，<strong>它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。</strong></p><p>下面我们就通过具体的例子来学习Lifecycles组件的用法。新建一个<code>MyObserver</code>类，并让它实现<code>DefaultLifecycleObserver</code>接口，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.DefaultLifecycleObserver</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LifecycleOwner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-11:57</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span> : <span class="type">DefaultLifecycleObserver</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyObserver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop(owner)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultLifecycleObserver</code> 是一个接口，它定义了一组与生命周期事件对应的方法，我们可以在自己的类中重写这些方法来响应特定的生命周期事件。</p><p>但是代码写到这里还是无法正常工作的，因为当Activity的生命周期发生变化的时候并没有人去通知<code>MyObserver</code>，而我们又不想像刚才一样在Activity中去一个个手动通知。这个时候就得借助<code>LifecycleOwner</code>这个好帮手了，它可以使用如下的语法结构让<code>MyObserver</code>得到通知：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lifecycleOwner.lifecycle.addObserver(MyObserver())</span><br></pre></td></tr></table></figure><p>首先调用<code>LifecycleOwner</code>的<code>getLifecycle()</code>方法，得到一个Lifecycle对象，然后调用它的<code>addObserver()</code>方法来观察<code>LifecycleOwner</code>的生命周期，再把<code>MyObserver</code>的实例传进去就可以了。</p><p>那么接下来的问题就是，<code>LifecycleOwner</code>又是什么呢？怎样才能获取一个<code>LifecycleOwner</code>的实例？</p><p>当然，我们可以自己去实现一个<code>LifecycleOwner</code>，但通常情况下这是完全没有必要的。因为只要你的Activity是继承自<code>AppCompatActivity</code>的，或者你的Fragment是继承自<code>androidx.fragment.app.Fragment</code>的，那么它们本身就是一个<code>LifecycleOwner</code>的实例，这部分工作已经由<code>AndroidX</code>库自动帮我们完成了。也就是说，在<code>MainActivity</code>当中就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.edit</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"><span class="keyword">import</span> work.icu007.jetpacktest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: MainViewModel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sp: SharedPreferences</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">val</span> myObserver = MyObserver()</span><br><span class="line">        lifecycle.addObserver(myObserver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错只需要添加：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myObserver = MyObserver()</span><br><span class="line">lifecycle.addObserver(myObserver)</span><br></pre></td></tr></table></figure><p>这样两行代码，<code>MyObserver</code>就能自动感知到Activity的生命周期了</p><p>这些就是<code>Lifecycles</code>组件最常见的用法了。不过目前<code>MyObserver</code>虽然能够感知到Activity的生命周期发生了变化，却没有办法主动获知当前的生命周期状态。要解决这个问题也不难，只需要在<code>MyObserver</code>的构造函数中将<code>Lifecycle</code>对象传进来即可，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span>(<span class="keyword">val</span> lifecycle: Lifecycle) : DefaultLifecycleObserver &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Lifecycle对象之后，我们就可以在任何地方调用<code>lifecycle.currentState</code>来主动获知当前的生命周期状态。<code>lifecycle.currentState</code>返回的生命周期状态是一个枚举类型，一共有<code>INITIALIZED</code>、<code>DESTROYED</code>、<code>CREATED</code>、<code>STARTED</code>、<code>RESUMED</code>这5种状态类型，它们与Activity的生命周期回调所对应的关系如图：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/03/1709707350291_709eb39fa93bf.png" alt="1709707350291.png"></p><p>也就是说，当获取的生命周期状态是<code>CREATED</code>的时候，说明<code>onCreate()</code>方法已经执行了，但是<code>onStart()</code>方法还没有执行。当获取的生命周期状态是<code>STARTED</code>的时候，说明<code>onStart()</code>方法已经执行了，但是<code>onResume()</code>方法还没有执行，以此类推。</p><h3 id="2-4-LiveData"><a href="#2-4-LiveData" class="headerlink" title="2.4 LiveData"></a>2.4 LiveData</h3><p><strong><code>LiveData</code>是Jetpack提供的一种响应式编程组件，它可以包含任何类型的数据，并在数据发生变化的时候通知给观察者。</strong><code>LiveData</code>特别适合与<code>ViewModel</code>结合在一起使用，虽然它也可以单独用在别的地方，但是在绝大多数情况下，它是使用在<code>ViewModel</code>当中的。</p><h4 id="2-4-1-LiveData的基本用法"><a href="#2-4-1-LiveData的基本用法" class="headerlink" title="2.4.1 LiveData的基本用法"></a>2.4.1 LiveData的基本用法</h4><p>之前我们编写的那个计数器虽然功能非常简单，但其实是存在问题的。目前的逻辑是，当<strong>每次点击“Plus One”按钮时，都会先给<code>ViewModel</code>中的计数加1，然后立即获取最新的计数。</strong>这种方式在单线程模式下确实可以正常工作，但<strong>如果<code>ViewModel</code>的内部开启了线程去执行一些耗时逻辑，那么在点击按钮后就立即去获取最新的数据，得到的肯定还是之前的数据。</strong></p><p>我们一直使用的都是在Activity中手动获取<code>ViewModel</code>中的数据这种交互方式，但是<code>ViewModel</code>却无法将数据的变化主动通知给Activity。</p><p>那么把Activity的实例传给<code>ViewModel</code>，这样<code>ViewModel</code>就能主动对Activity进行通知了，这样做可行吗？注意，千万不可以这么做。不要忘了，<code>ViewModel</code>的生命周期是长于Activity的，如果把Activity的实例传给<code>ViewModel</code>，就很有可能会因为Activity无法释放而造成内存泄漏，这是一种非常错误的做法。</p><p>而这个问题的解决方案也是显而易见的，就是使用我们本节即将学习的<code>LiveData</code>。正如前面所描述的一样，<code>LiveData</code>可以包含任何类型的数据，并在数据发生变化的时候通知给观察者。也就是说，如果我们将计数器的计数使用<code>LiveData</code>来包装，然后在Activity中去观察它，就可以主动将数据变化通知给Activity了。</p><p>介绍完了工作原理，接下来我们开始编写具体的代码，修改<code>MainViewModel</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> counter = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        counter.value = countReserved</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">plusOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> count = counter.value ?: <span class="number">0</span></span><br><span class="line">        counter.value = count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        counter.value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将counter变量修改成了一个<code>MutableLiveData</code>对象，并指定它的泛型为Int，表示它包含的是整型数据。<code>MutableLiveData</code>是一种可变的<code>LiveData</code>，它的用法很简单，主要有3种读写数据的方法，分别是<code>getValue()</code>、<code>setValue()</code>和<code>postValue()</code>方法。<code>getValue()</code>方法用于获取<code>LiveData</code>中包含的数据；<code>setValue()</code>方法用于给<code>LiveData</code>设置数据，但是只能在主线程中调用；<code>postValue()</code>方法用于在非主线程中给<code>LiveData</code>设置数据。而上述代码其实就是调用<code>getValue()</code>和<code>setValue()</code>方法对应的语法糖写法。</p><p>可以看到，这里在<code>init</code>结构体中给<code>counter</code>设置数据，这样之前保存的计数值就可以在初始化的时候得到恢复。接下来我们新增了<code>plusOne()</code>和<code>clear()</code>这两个方法，分别用于给计数加1以及将计数清零。<code>plusOne()</code>方法中的逻辑是先获取<code>counter</code>中包含的数据，然后给它加1，再重新设置到<code>counter</code>当中。注意调用<code>LiveData</code>的<code>getValue()</code>方法所获得的数据是可能为空的，因此这里使用了一个<code>?:</code>操作符，当获取到的数据为空时，就用0来作为默认计数。</p><p>这样我们就借助<code>LiveData</code>将<code>MainViewModel</code>的写法改造完了，接下来开始改造<code>MainActivity</code>，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: MainViewModel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sp: SharedPreferences</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        ...</span><br><span class="line">        mainBinding.plusOneBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.plusOne()</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.clearBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.counter.observe(<span class="keyword">this</span>, Observer &#123; count -&gt;</span><br><span class="line">            mainBinding.infoText.text = count.toString()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">val</span> myObserver = MyObserver(lifecycle)</span><br><span class="line">        lifecycle.addObserver(myObserver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        sp.edit &#123;</span><br><span class="line">            putInt(<span class="string">&quot;count_reserved&quot;</span>, viewModel.counter.value ?: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，在“Plus One”按钮的点击事件中我们应该去调用<code>MainViewModel</code>的<code>plusOne()</code>方法，而在“Clear”按钮的点击事件中应该去调用<code>MainViewModel</code>的<code>clear()</code>方法。另外，在<code>onPause()</code>方法中，我们将获取当前计数的写法改造了一下，这部分内容还是很好理解的。</p><p>接下来到最关键的地方了，这里调用了<code>viewModel.counter</code>的<code>observe()</code>方法来观察数据的变化。经过对<code>MainViewModel</code>的改造，现在<code>counter</code>变量已经变成了一个<code>LiveData</code>对象，任何<code>LiveData</code>对象都可以调用它的<code>observe()</code>方法来观察数据的变化。<code>observe()</code>方法接收两个参数：第一个参数是一个<code>LifecycleOwner</code>对象，有没有觉得很熟悉？没错，Activity本身就是一个<code>LifecycleOwner</code>对象，因此直接传this就好；第二个参数是一个<code>Observer</code>接口，当<code>counter</code>中包含的数据发生变化时，就会回调到这里，因此我们在这里将最新的计数更新到界面上即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewModel.counter.observe(<span class="keyword">this</span>, Observer &#123; count -&gt;</span><br><span class="line">    mainBinding.infoText.text = count.toString()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里使用了高阶函数和 lambda 表达式。在 Kotlin 中，如果一个函数的最后一个参数是函数，那么你可以将一个 lambda 表达式传递给这个函数。并且，如果这个 lambda 表达式是这个函数调用的唯一参数，那么你可以在函数名和 lambda 表达式之间省略括号。</p><p>如果一个接口只有一个未实现的方法（我们称之为函数式接口），那么可以使用 lambda 表达式来代替这个接口的匿名类实例。</p><p>在上述代码中，<code>Observer</code> 是一个函数式接口，它只有一个未实现的方法：<code>onChanged</code>。因此，我们可以使用一个 lambda 表达式 <code>count -&gt; &#123; ... &#125;</code> 来代替 <code>Observer</code> 的匿名类实例。在这个 lambda 表达式中，<code>count</code> 是 <code>onChanged</code> 方法的参数，<code>&#123; ... &#125;</code> 是 <code>onChanged</code> 方法的主体。</p><p>所以，当 <code>observe</code> 方法需要一个 <code>Observer</code> 参数时，我们可以直接传入一个 lambda 表达式。当被观察的数据发生变化时，这个 lambda 表达式就会被调用，就像 <code>onChanged</code> 方法被调用一样。</p><p>现在我们的代码更科学，也更合理，而且不用担心<code>ViewModel</code>的内部会不会开启线程执行耗时逻辑。不过需要注意的是，如果你需要在子线程中给<code>LiveData</code>设置数据，一定要调用<code>postValue()</code>方法，而不能再使用<code>setValue()</code>方法，否则会发生崩溃。</p><p>另外，关于<code>LiveData</code>的<code>observe()</code>方法，我还想再多说几句，因为我当初在学习这部分内容时也产生过疑惑。<code>observe()</code>方法是一个Java方法，如果你观察一下<code>Observer</code>接口，会发现这是一个单抽象方法接口，只有一个待实现的<code>onChanged()</code>方法。既然是单抽象方法接口，为什么在调用<code>observe()</code>方法时却没有使用我们之前学习的Java函数式API的写法呢？</p><p>这是一种非常特殊的情况，因为<code>observe()</code>方法接收的另一个参数<code>LifecycleOwner</code>也是一个单抽象方法接口。当一个Java方法同时接收两个单抽象方法接口参数时，要么同时使用函数式API的写法，要么都不使用函数式API的写法。由于我们第一个参数传的是this，因此第二个参数就无法使用函数式API的写法了。</p><p>不过在2019年的Google I&#x2F;O大会上，Android团队官宣了Kotlin First，并且承诺未来会在Jetpack中提供更多专门面向Kotlin语言的API。其中，<code>lifecycle-livedata-ktx</code>就是一个专门为Kotlin语言设计的库，这个库在2.2.0版本中加入了对<code>observe()</code>方法的语法扩展。我们只需要在<code>app/build.gradle</code>文件中添加如下依赖：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.7.0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用如下语法结构的<code>observe()</code>方法了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewModel.counter.observe(<span class="keyword">this</span>) &#123; count -&gt;</span><br><span class="line">    mainBinding.infoText.text = count.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>LiveData</code>的基本用法。虽说现在的写法可以正常工作，但其实这仍然不是最规范的<code>LiveData</code>用法，主要的问题就在于我们将counter这个可变的<code>LiveData</code>暴露给了外部。这样即使是在<code>ViewModel</code>的外面也是可以给counter设置数据的，从而破坏了<code>ViewModel</code>数据的封装性，同时也可能带来一定的风险。</p><p>比较推荐的做法是，永远只暴露不可变的<code>LiveData</code>给外部。这样在非<code>ViewModel</code>中就只能观察<code>LiveData</code>的数据变化，而不能给<code>LiveData</code>设置数据。下面我们就看一下如何改造<code>MainViewModel</code>来实现这样的功能：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> counter: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _counter</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _counter = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        _counter.value = countReserved</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">plusOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> count = counter.value ?: <span class="number">0</span></span><br><span class="line">        _counter.value = count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _counter.value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，我们可以在属性声明的同时定义自定义的 getter 方法。这就是为什么 <code>get() = _counter</code> 可以直接跟在 <code>val counter: LiveData&lt;Int&gt;</code> 声明后面。</p><p>当你这样声明一个属性时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counter: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">    <span class="keyword">get</span>() = _counter</span><br></pre></td></tr></table></figure><p>我们实际上做了两件事情：</p><ol><li>声明了一个名为 <code>counter</code> 的只读属性，它的类型是 <code>LiveData&lt;Int&gt;</code>。</li><li>为 <code>counter</code> 属性定义了一个自定义的 getter 方法，这个方法返回 <code>_counter</code> 的值。</li></ol><p>所以，每次访问 <code>counter</code> 属性时，实际上调用的是这个自定义的 getter 方法，返回的是 <code>_counter</code> 的值。</p><p>这种语法是 Kotlin 中属性声明的一部分，它使得我们可以在声明属性的同时定义自定义的 getter 或 setter 方法。</p><p>可以看到，这里先将原来的counter变量改名为_counter变量，并给它加上private修饰符，这样_counter变量对于外部就是不可见的了。然后我们又新定义了一个counter变量，将它的类型声明为不可变的<code>LiveData</code>，并在它的<code>get()</code>属性方法中返_counter变量。这样，当外部调用counter变量时，实际上获得的就是_counter的实例，但是无法给counter设置数据，从而保证了<code>ViewModel</code>的数据封装性。</p><p>目前这种写法可以说是非常规范了，这也是Android官方最为推荐的写法.</p><h4 id="2-4-2-map和switchMap"><a href="#2-4-2-map和switchMap" class="headerlink" title="2.4.2 map和switchMap"></a>2.4.2 map和switchMap</h4><p><code>LiveData</code>的基本用法虽说可以满足大部分的开发需求，但是当项目变得复杂之后，可能会出现一些更加特殊的需求。<code>LiveData</code>为了能够应对各种不同的需求场景，提供了两种转换方法：<code>map()</code>和<code>switchMap()</code>方法。下面我们就学习这两种转换方法的具体用法和使用场景。</p><p>先来看<code>map()</code>方法，这个方法的作用是将实际包含数据的<code>LiveData</code>和仅用于观察数据的<code>LiveData</code>进行转换。那么什么情况下会用到这个方法呢？下面我来举一个例子。</p><p>比如说有一个User类，User中包含用户的姓名和年龄，定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> firstName: String, <span class="keyword">var</span> lastName: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>我们可以在ViewModel中创建一个相应的LiveData来包含User类型的数据，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> userLiveData = MutableLiveData&lt;User&gt;()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，这和我们在上一小节中学习的内容并没有什么区别。可是如果<code>MainActivity</code>中明确只会显示用户的姓名，而完全不关心用户的年龄，那么这个时候还将整个User类型的<code>LiveData</code>暴露给外部，就显得不那么合适了。</p><p>而<code>map()</code>方法就是专门用于解决这种问题的，它可以将User类型的<code>LiveData</code>自由地转型成任意其他类型的<code>LiveData</code>，下面我们来看一下具体的用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userLiveData = MutableLiveData&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userName: LiveData&lt;String&gt; = userLiveData.map &#123; user -&gt;</span><br><span class="line">        <span class="string">&quot;<span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，<code>userName</code> 是一个 <code>LiveData&lt;String&gt;</code> 类型的属性，它的值是由 <code>userLiveData</code> 映射（<code>map</code>）得到的。</p><p><code>userLiveData</code> 是一个 <code>MutableLiveData&lt;User&gt;</code> 类型的属性，它的值可以改变，而且每次值改变时，所有观察 <code>userLiveData</code> 的观察者都会收到通知。</p><p><code>map</code> 是一个扩展函数，它接受一个 lambda 表达式作为参数，这个 lambda 表达式定义了如何将 <code>userLiveData</code> 的值转换为 <code>userName</code> 的值。在这个例子中，lambda 表达式是 <code>&#123; user -&gt; &quot;$&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot; &#125;</code>，它将 <code>User</code> 对象转换为一个字符串，这个字符串是 <code>User</code> 对象的 <code>firstName</code> 和 <code>lastName</code> 属性的拼接。</p><p>所以，每次 <code>userLiveData</code> 的值改变时，<code>userName</code> 的值也会相应地改变。例如，如果 <code>userLiveData</code> 的值改变为 <code>User(&quot;John&quot;, &quot;Doe&quot;, 30)</code>，那么 <code>userName</code> 的值就会改变为 <code>&quot;John Doe&quot;</code>。</p><p>可以看到，这里我们调用了<code>MutableLiveData</code>的<code>map()</code>方法来对<code>LiveData</code>的数据类型进行转换。<code>map()</code>方法接收一个参数，这个参数是一个转换函数，我们在转换函数里编写具体的转换逻辑即可。这里的逻辑也很简单，就是将User对象转换成一个只包含用户姓名的字符串。</p><p>另外，我们还将<code>userLiveData</code>声明成了private，以保证数据的封装性。外部使用的时候只要观察<code>userName</code>这个<code>LiveData</code>就可以了。当<code>userLiveData</code>的数据发生变化时，<code>map()</code>方法会监听到变化并执行转换函数中的逻辑，然后再将转换之后的数据通知给<code>userName</code>的观察者。</p><p>这就是<code>map()</code>方法的用法和使用场景，非常好理解。</p><p>接下来，我们开始学习<code>switchMap()</code>方法，虽然它的使用场景非常固定，但是可能比<code>map()</code>方法要更加常用。</p><p>前面我们所学的所有内容都有一个前提：<code>LiveData</code>对象的实例都是在<code>ViewModel</code>中创建的。然而在实际的项目中，不可能一直是这种理想情况，很有可能<code>ViewModel</code>中的某个<code>LiveData</code>对象是调用另外的方法获取的。</p><p>下面就来模拟一下这种情况，新建一个<code>Repository</code>单例类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Repository &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> liveData = MutableLiveData&lt;User&gt;()</span><br><span class="line">        liveData.value = User(userId, userId, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> liveData</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在Repository类中添加了一个<code>getUser()</code>方法，这个方法接收一个userId参数。按照正常的编程逻辑，我们应该根据传入的userId参数去服务器请求或者到数据库中查找相应的User对象，但是这里只是模拟示例，因此每次将传入的userId当作用户姓名来创建一个新的User对象即可。</p><p>需要注意的是，<code>getUser()</code>方法返回的是一个包含User数据的<code>LiveData</code>对象，而且每次调用<code>getUser()</code>方法都会返回一个新的<code>LiveData</code>实例。</p><p>然后我们在<code>MainViewModel</code>中也定义一个<code>getUser()</code>方法，并且让它调用Repository的<code>getUser()</code>方法来获取<code>LiveData</code>对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userLiveData = MutableLiveData&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userName: LiveData&lt;String&gt; = userLiveData.map &#123; user -&gt;</span><br><span class="line">        <span class="string">&quot;<span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Repository.getUser(userId)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的问题就是，在Activity中如何观察<code>LiveData</code>的数据变化呢？既然<code>getUser()</code>方法返回的就是一个<code>LiveData</code>对象，那么我们可不可以直接在Activity中使用如下写法呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viewModel.getUser(userId).observe(<span class="keyword">this</span>) &#123; user -&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这么做是完全错误的。因为每次调用<code>getUser()</code>方法返回的都是一个新的<code>LiveData</code>实例，而上述写法会一直观察老的<code>LiveData</code>实例，从而根本无法观察到数据的变化。你会发现，这种情况下的<code>LiveData</code>是不可观察的。</p><p>这个时候，<code>switchMap()</code>方法就可以派上用场了。正如前面所说，它的使用场景非常固定：如果<code>ViewModel</code>中的某个<code>LiveData</code>对象是调用另外的方法获取的，那么我们就可以借助<code>switchMap()</code>方法，将这个<code>LiveData</code>对象转换成另外一个可观察的<code>LiveData</code>对象。</p><p>修改<code>MainViewModel</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LiveData</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.MutableLiveData</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.map</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.switchMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-10:00</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userIdLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user: LiveData&lt;User&gt; = userIdLiveData.switchMap &#123; userId -&gt;</span><br><span class="line">        Repository.getUser(userId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        userIdLiveData.value = userId</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个新的<code>userIdLiveData</code>对象，用来观察<code>userId</code>的数据变化，然后调用了<code>MutableLiveData</code>的<code>switchMap()</code>方法，用来对另一个可观察的<code>LiveData</code>对象进行转换。</p><p><code>switchMap()</code>方法同样接收一个参数：这个参数是一个转换函数，注意，我们必须在这个转换函数中返回一个<code>LiveData</code>对象，因为<code>switchMap()</code>方法的工作原理就是要将转换函数中返回的<code>LiveData</code>对象转换成另一个可观察的<code>LiveData</code>对象。那么很显然，我们只需要在转换函数中调用Repository的<code>getUser()</code>方法来得到<code>LiveData</code>对象，并将它返回就可以了。</p><p>为了能更清晰地理解<code>switchMap()</code>的用法，我们再来梳理一遍它的整体工作流程。首先，当外部调用<code>MainViewModel</code>的<code>getUser()</code>方法来获取用户数据时，并不会发起任何请求或者函数调用，只会将传入的<code>userId</code>值设置到<code>userIdLiveData</code>当中。一旦<code>userIdLiveData</code>的数据发生变化，那么观察<code>userIdLiveData</code>的<code>switchMap()</code>方法就会执行，并且调用我们编写的转换函数。然后在转换函数中调用<code>Repository.getUser()</code>方法获取真正的用户数据。同时，<code>switchMap()</code>方法会将<code>Repository.getUser()</code>方法返回的<code>LiveData</code>对象转换成一个可观察的<code>LiveData</code>对象，对于Activity而言，只要去观察这个<code>LiveData</code>对象就可以了。</p><p>下面我们就来测试一下，修改activity_main.xml文件，在里面新增一个“Get User”按钮：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/getUserBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/clearBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Get User&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: MainViewModel</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sp: SharedPreferences</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line">        mainBinding.getUserBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> userId = (<span class="number">0.</span><span class="number">.10000</span>).random().toString()</span><br><span class="line">            viewModel.getUser(userId)</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.user.observe(<span class="keyword">this</span>) &#123; user -&gt;</span><br><span class="line">            mainBinding.infoText.text = user.lastName</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCreate: <span class="subst">$&#123;user.firstName&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的用法就是这样了，我们在“Get User”按钮的点击事件中使用随机函数生成了一个<code>userId</code>，然后调用<code>MainViewModel</code>的<code>getUser()</code>方法来获取用户数据，但是这个方法现在不会有任何返回值了。等数据获取完成之后，可观察<code>LiveData</code>对象的<code>observe()</code>方法将会得到通知，我们在这里将获取的用户名显示到界面上。</p><p>。在刚才的例子当中，我们调<br>用<code>MainViewModel</code>的<code>getUser()</code>方法时传入了一个<code>userId</code>参数，为了能够观察这个参数的数据变化，又构建了一个<code>userIdLiveData</code>，然后在<code>switchMap()</code>方法中再去观察这个<code>LiveData</code>对象就可以了。但是<code>ViewModel</code>中某个获取数据的方法有可能是没有参数的，这个时候代码应该怎么写呢？</p><p>其实这个问题并没有想象中复杂，写法基本上和原来是相同的，只是在没有可观察数据的情况下，我们需要创建一个空的<code>LiveData</code>对象，示例写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> refreshLiveData = MutableLiveData&lt;Any?&gt;()</span><br><span class="line">    <span class="keyword">val</span> refreshResult = refreshLiveData.switchMap &#123;</span><br><span class="line">        Repository.refresh()<span class="comment">// 假设Repository中已经定义了refresh()方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">refresh</span><span class="params">()</span></span> &#123;</span><br><span class="line">        refreshLiveData.value = refreshLiveData.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们定义了一个不带参数的<code>refresh()</code>方法，又对应地定义了一个<code>refreshLiveData</code>，但是它不需要指定具体包含的数据类型，因此这里我们将<code>LiveData</code>的泛型指定成Any?即可。</p><p>接下来就是点睛之笔的地方了，在<code>refresh()</code>方法中，我们只是将<code>refreshLiveData</code>原有的数据取出来（默认是空），再重新设置到<code>refreshLiveData</code>当中，这样就能触发一次数据变化。是的，<code>LiveData</code>内部不会判断即将设置的数据和原有数据是否相同，只要调用了<code>setValue()</code>或<code>postValue()</code>方法，就一定会触发数据变化事件。</p><p>然后我们在Activity中观察<code>refreshResult</code>这个<code>LiveData</code>对象即可，这样只要调用了<code>refresh()</code>方法，观察者的回调函数中就能够得到最新的数据。</p><p>学到现在，只看到了<code>LiveData</code>与<code>ViewModel</code>结合在一起使用，好像和上一节的Lifecycles组件没什么关系嘛。</p><p>其实并不是这样的，<code>LiveData</code>之所以能够成为Activity与<code>ViewModel</code>之间通信的桥梁，并且还不会有内存泄漏的风险，靠的就是Lifecycles组件。<code>LiveData</code>在内部使用了Lifecycles组件来自我感知生命周期的变化，从而可以在Activity销毁的时候及时释放引用，避免产生内存泄漏的问题。</p><p>另外，由于要减少性能消耗，当Activity处于不可见状态的时候（比如手机息屏，或者被其他的Activity遮挡），如果<code>LiveData</code>中的数据发生了变化，是不会通知给观察者的。只有当Activity重新恢复可见状态时，才会将数据通知给观察者，而<code>LiveData</code>之所以能够实现这种细节的优化，依靠的还是Lifecycles组件。</p><p>还有一个小细节，如果在Activity处于不可见状态的时候，<code>LiveData</code>发生了多次数据变化，当Activity恢复可见状态时，只有最新的那份数据才会通知给观察者，前面的数据在这种情况下相当于已经过期了，会被直接丢弃。</p><h3 id="2-5-Room"><a href="#2-5-Room" class="headerlink" title="2.5 Room"></a>2.5 Room</h3><p>之前学习了SQLite数据库的使用方法，不过当时仅仅是使用了一些原生的API来进行数据的增删改查操作。这些原生API虽然简单易用，但是如果放到大型项目当中的话，会非常容易让项目的代码变得混乱，除非你进行了很好的封装。为此市面上出现了诸多专门为Android数据库设计的ORM框架。</p><p>ORM（Object Relational Mapping）也叫<em>对象关系映射</em>。<strong>简单来讲，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是ORM了。</strong></p><p>那么使用ORM框架有什么好处呢？它赋予了我们一个强大的功能，就是可以用面向对象的思维来和数据库进行交互，绝大多数情况下不用再和SQL语句打交道了，同时也不用担心操作数据库的逻辑会让项目的整体代码变得混乱。</p><p>由于许多大型项目中会用到数据库的功能，为了帮助我们编写出更好的代码，Android官方推出了一个ORM框架，并将它加入了Jetpack当中，就是Room。</p><h4 id="2-5-1-使用Room进行增删改查"><a href="#2-5-1-使用Room进行增删改查" class="headerlink" title="2.5.1 使用Room进行增删改查"></a>2.5.1 使用Room进行增删改查</h4><p>先来看一下Room的整体结构。它主要由<strong>Entity、Dao和Database</strong>这3部分组成，每个部分都有明确的职责，详细说明如下。</p><ul><li><strong>Entity</strong>:用于定义封装实际数据的实体类，每个实体类都会在数据库中有一张对应的表，并且表中的列是根据实体类中的字段自动生成的。</li><li><strong>Dao</strong>:Dao是数据访问对象的意思，通常会在这里对数据库的各项操作进行封装，在实际编程的时候，逻辑层就不需要和底层数据库打交道了，直接和Dao层进行交互即可。</li><li><strong>Database</strong>:用于定义数据库中的关键信息，包括数据库的版本号、包含哪些实体类以及提供Dao层的访问实例。</li></ul><p>首先要使用Room，需要在<code>app/build.gradle</code>文件中添加如下的依赖：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;com.android.application&quot;)</span><br><span class="line">    id(&quot;org.jetbrains.kotlin.android&quot;)</span><br><span class="line">    id(&quot;kotlin-android&quot;)</span><br><span class="line">    id(&quot;kotlin-parcelize&quot;)</span><br><span class="line">    id(&quot;kotlin-kapt&quot;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    val room<span class="built_in">_</span>version = &quot;2.6.1&quot;</span><br><span class="line">    implementation(&quot;androidx.room:room-runtime:<span class="built_in">$</span>room<span class="built_in">_</span>version&quot;)</span><br><span class="line">    kapt(&quot;androidx.room:room-compiler:<span class="built_in">$</span>room<span class="built_in">_</span>version&quot;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里新增了一个<code>kotlin-kapt</code>插件，同时在dependencies闭包中添加了两个Room的依赖库。由于Room会根据我们在项目中声明的注解来动态生成代码，因此这里一定要使用<code>kapt</code>引入Room的编译时注解库，而启用编译时注解功能则一定要先添加<code>kotlin-kapt</code>插件。注意，**<code>kapt</code>只能在Kotlin项目中使用，如果是Java项目的话，使用<code>annotationProcessor</code>即可。**下面我们就按照刚才介绍的Room的3个组成部分一一来进行实现，首先是定义Entity，也就是实体类。</p><p>好消息是<code>JetpackTest</code>项目中已经存在一个实体类了，就是我们在学习<code>LiveData</code>时创建的User类。然而User类目前只包含<strong>firstName、lastName和age</strong>这3个字段，但是一个良好的数据库编程建议是，给每个实体类都添加一个id字段，并将这个字段设为主键。于是我们对User类进行如下改造，并完成实体类的声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> firstName: String, <span class="keyword">var</span> lastName: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们在User的类名上使用@Entity注解，将它声明成了一个实体类，然后在User类中添加了一个id字段，并使用@PrimaryKey注解将它设为了主键，再把autoGenerate参数指定成true，使得主键的值是自动生成的。</p><p>这样实体类部分就定义好了，不过这里简单起见，只定义了一个实体类，在实际项目当中，你可能需要根据具体的业务逻辑定义很多个实体类。当然，每个实体类定义的方式都是差不多的，最多添加一些实体类之间的关联。接下来开始定义Dao，这部分也是Room用法中最关键的地方，因为所有访问数据库的操作都是在这里封装的。</p><p>访问数据库的操作无非就是增删改查这4种，但是业务需求却是千变万化的。而Dao要做的事情就是覆盖所有的业务需求，使得业务方永远只需要与Dao层进行交互，而不必和底层的数据库打交道。</p><p>那么下面我们就来看一下一个Dao具体是如何实现的。新建一个UserDao接口，注意必须使用接口，这点和Retrofit是类似的，然后在接口中编写如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.room.Dao</span><br><span class="line"><span class="keyword">import</span> androidx.room.Delete</span><br><span class="line"><span class="keyword">import</span> androidx.room.Insert</span><br><span class="line"><span class="keyword">import</span> androidx.room.Query</span><br><span class="line"><span class="keyword">import</span> androidx.room.Update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-18:12</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span>: <span class="built_in">Long</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;select * from User&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUser</span><span class="params">()</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;delete from User where lastName = :lastName&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteUserByLastName</span><span class="params">(lastName: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserDao</code>接口的上面使用了一个<code>@Dao</code>注解，这样Room才能将它识别成一个Dao。<code>UserDao</code>的内部就是根据业务需求对各种数据库操作进行的封装。数据库操作通常有增删改查这4种，因此Room也提供了<code>@Insert</code>、<code>@Delete</code>、<code>@Update</code>和<code>@Query</code>这4种相应的注解。</p><p>可以看到，**<code>insertUser()</code>方法上面使用了<code>@Insert</code>注解，表示会将参数中传入的User对象插入数据库中，插入完成后还会将自动生成的主键id值返回。<code>updateUser()</code>方法上面使用了<code>@Update</code>注解，表示会将参数中传入的User对象更新到数据库当中。<code>deleteUser()</code>方法上面使用了<code>@Delete</code>注解，表示会将参数传入的User对象从数据库中删除。**以上几种数据库操作都是直接使用注解标识即可，不用编写SQL语句。</p><p>但是如果想要从数据库中查询数据，或者使用非实体类参数来增删改数据，那么就必须编写SQL语句了。比如说我们在<code>UserDao</code>接口中定义了一个<code>loadAllUsers()</code>方法，用于从数据库中查询所有的用户，如果只使用一个<code>@Query</code>注解，Room将无法知道我们想要查询哪些数据，因此必须在<code>@Query</code>注解中编写具体的SQL语句才行。我们还可以将方法中传入的参数指定到SQL语句当中，比如<code>loadUsersOlderThan()</code>方法就可以查询所有年龄大于指定参数的用户。另外，如果是使用非实体类参数来增删改数据，那么也要编写SQL语句才行，而且这个时候不能使用<code>@Insert</code>、<code>@Delete</code>或<code>@Update</code>注解，而是都要使用<code>@Query</code>注解才行，参考<code>deleteUserByLastName()</code>方法的写法。</p><p>这样我们就大体定义了添加用户、修改用户数据、查询用户、删除用户这几种数据库操作接口，在实际项目中你根据真实的业务需求来进行定义即可。</p><p>虽然使用Room需要经常编写SQL语句这一点不太友好，但是SQL语句确实可以实现更加多样化的逻辑，而且Room是支持在编译时动态检查SQL语句语法的。也就是说，如果我们编写的SQL语句有语法错误，编译的时候就会直接报错，而不会将错误隐藏到运行的时候才发现，也算是大大减少了很多安全隐患吧。</p><p>接下来我们进入最后一个环节：定义Database。这部分内容的写法是非常固定的，只需要定义好3个部分的内容：数据库的版本号、包含哪些实体类，以及提供Dao层的访问实例。新建一个<code>AppDatabase.kt</code>文件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.jetpacktest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.room.Database</span><br><span class="line"><span class="keyword">import</span> androidx.room.Room</span><br><span class="line"><span class="keyword">import</span> androidx.room.RoomDatabase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liam</span></span><br><span class="line"><span class="comment"> * Time: 2024/3/6-19:59</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Database(version = 1, entities = [User::class])</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDatabase &#123;</span><br><span class="line">            instance?.let &#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(</span><br><span class="line">                context.applicationContext,</span><br><span class="line">                AppDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">                <span class="string">&quot;app_database&quot;</span>)</span><br><span class="line">                .build().apply &#123; </span><br><span class="line">                    instance = <span class="keyword">this</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们在<code>AppDatabase</code>类的头部使用了<code>@Database</code>注解，并在注解中声明了数据库的版本号以及包含哪些实体类，多个实体类之间用逗号隔开即可。另外，<code>AppDatabase</code>类必须继承自<code>RoomDatabase</code>类，并且一定要使用abstract关键字将它声明成抽象类，然后提供相应的抽象方法，用于获取之前编写的Dao的实例，比如这里提供的<code>userDao()</code>方法。不过我们只需要进行方法声明就可以了，具体的方法实现是由Room在底层自动完成的。</p><p>紧接着，我们在companion object结构体中编写了一个单例模式，因为原则上全局应该只存在一份<code>AppDatabase</code>的实例。这里使用了instance变量来缓存<code>AppDatabase</code>的实例，然后在<code>getDatabase()</code>方法中判断：如果instance变量不为空就直接返回，否则就调用<code>Room.databaseBuilder()</code>方法来构建一个<code>AppDatabase</code>的实例。<code>databaseBuilder()</code>方法接收3个参数，注意第一个参数一定要使用<code>applicationContext</code>，而不能使用普通的context，否则容易出现内存泄漏的情况，关于<code>applicationContext</code>的详细内容我们将会在第14章中学习。第二个参数是<code>AppDatabase</code>的Class类型，第三个参数是数据库名，这些都比较简单。最后调用build()方法完成构建，并将创建出来的实例赋值给instance变量，然后返回当前实例即可。</p><p>这样我们就把Room所需要的一切都定义好了，接下来要做的事情就是对它进行测试。修改<code>activity_main.xml</code>中的代码，在里面加入用于增删改查的4个按钮：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/getUserBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/clearBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Get User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/addDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/getUserBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Add Data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/updateDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/addDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Update Data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/deleteDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/updateDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Delete Data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/queryDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/deleteDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Query Data&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后修改<code>MainActivity</code>中的代码，分别在这4个按钮的点击事件中实现增删改查的逻辑，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">val</span> userDao = AppDatabase.getDatabase(<span class="keyword">this</span>).userDao()</span><br><span class="line">        <span class="keyword">val</span> user1 = User(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Brady&quot;</span>, <span class="number">40</span>)</span><br><span class="line">        <span class="keyword">val</span> user2 = User(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Hanks&quot;</span>, <span class="number">63</span>)</span><br><span class="line">        </span><br><span class="line">        mainBinding.addDataBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                user1.id = userDao.insertUser(user1)</span><br><span class="line">                user2.id = userDao.insertUser(user2)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.updateDataBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                user1.age = <span class="number">42</span></span><br><span class="line">                userDao.updateUser(user1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.deleteDataBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                userDao.deleteUserByLastName(<span class="string">&quot;Hanks&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.queryDataBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                <span class="keyword">for</span> (user <span class="keyword">in</span> userDao.loadAllUser()) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;onCreate: <span class="variable">$user</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑还是很简单的。首先获取了<code>UserDao</code>的实例，并创建两个User对象。然后在“Add Data”按钮的点击事件中，我们调用了<code>UserDao</code>的<code>insertUser()</code>方法，将这两个User对象插入数据库中，并将<code>insertUser()</code>方法返回的主键id值赋值给原来的User对象。</p><p>之所以要这么做，是因为使用<code>@Update</code>和<code>@Delete</code>注解去更新和删除数据时都是基于这个id值来操作的。</p><p>然后在“Update Data”按钮的点击事件中，我们将user1的年龄修改成了42岁，并调用<code>UserDao</code>的<code>updateUser()</code>方法来更新数据库中的数据。在“Delete Data”按钮的点击事件中，我们调用了<code>UserDao</code>的<code>deleteUserByLastName()</code>方法，删除所有<code>lastName</code>是Hanks的用户。在“Query Data”按钮的点击事件中，我们调用了<code>UserDao</code>的<code>loadAllUsers()</code>方法，查询并打印数据库中所有的用户。</p><p>另外，由于数据库操作属于耗时操作，Room默认是不允许在主线程中进行数据库操作的，因此上述代码中我们将增删改查的功能都放到了子线程中。不过为了方便测试，Room还提供了一个更加简单的方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Room.databaseBuilder(</span><br><span class="line">    context.applicationContext,</span><br><span class="line">    AppDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">    <span class="string">&quot;app_database&quot;</span></span><br><span class="line">)</span><br><span class="line">.allowMainThreadQueries()</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>在构建<code>AppDatabase</code>实例的时候，加入一个<code>allowMainThreadQueries()</code>方法，这样Room就允许在主线程中进行数据库操作了，这个方法建议只在测试环境下使用。</p><h4 id="2-5-2-Room的数据库升级"><a href="#2-5-2-Room的数据库升级" class="headerlink" title="2.5.2 Room的数据库升级"></a>2.5.2 Room的数据库升级</h4><p>数据库结构不可能在设计好了之后就永远一成不变，随着需求和版本的变更，数据库也是需要升级的。不过遗憾的是，Room在数据库升级方面设计得非常烦琐，基本上没有比使用原生的<code>SQLiteDatabase</code>简单到哪儿去，每一次升级都需要手动编写升级逻辑才行。</p><p>不过，如果只是在开发测试阶段，不想编写那么烦琐的数据库升级逻辑，Room倒也提供了一个简单粗暴的方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Room.databaseBuilder(context.applicationContext, AppDatabase::<span class="keyword">class</span>.java, <span class="string">&quot;app_database&quot;</span>)</span><br><span class="line">.fallbackToDestructiveMigration()</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>在构建<code>AppDatabase</code>实例的时候，加入一个<code>fallbackToDestructiveMigration()</code>方法。这样只要数据库进行了升级，Room就会将当前的数据库销毁，然后再重新创建，随之而来的副作用就是之前数据库中的所有数据就全部丢失了。假如产品还在开发和测试阶段，这个方法是可以使用的，但是一旦产品对外发布之后，如果造成了用户数据丢失，那可是严重的事故。因此接下来我们还是老老实实学习一下在Room中升级数据库的正规写法。</p><p>随着业务逻辑的升级，现在我们打算在数据库中添加一张Book表，那么首先要做的就是创建一个Book的实体类，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Book</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> pages: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Book类中包含了主键id、书名、页数这几个字段，并且我们还使用@Entity注解将它声明成了一个实体类。</p><p>然后创建一个<code>BookDao</code>接口，并在其中随意定义一些API：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertBook</span><span class="params">(book: <span class="type">Book</span>)</span></span>: <span class="built_in">Long</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllBooks</span><span class="params">()</span></span>: List&lt;Book&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改<code>AppDatabase</code>中的代码，在里面编写数据库升级的逻辑，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(version = 2, entities = [User::class, Book::class], exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">bookDao</span><span class="params">()</span></span>: BookDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> MIGRATION_1_2 = <span class="keyword">object</span> : Migration(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">migrate</span><span class="params">(database: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                database.execSQL(<span class="string">&quot;create table Book (id integer primary key autoincrement not null, name text not null, pages integer not null)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDatabase &#123;</span><br><span class="line">            instance?.let &#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(context.applicationContext, AppDatabase::<span class="keyword">class</span>.java, <span class="string">&quot;app_database&quot;</span>)</span><br><span class="line">                .addMigrations(MIGRATION_1_2)</span><br><span class="line">                .build().apply &#123;</span><br><span class="line">                    instance = <span class="keyword">this</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在@Database注解中，我们将版本号升级成了2，并将Book类添加到了实体类声明中，然后又提供了一个<code>bookDao()</code>方法用于获取<code>BookDao</code>的实例。</p><p>接下来就是关键的地方了，<strong>在companion object结构体中，我们实现了一个Migration的匿名类，并传入了1和 2这两个参数，表示当数据库版本从1升级到2的时候就执行这个匿名类中的升级逻辑。</strong>匿名类实例的变量命名也比较有讲究，这里命名成MIGRATION_1_2，可读性更高。由于我们要新增一张Book表，所以需要在migrate()方法中编写相应的建表语句。另外必须注意的是，<strong>Book表的建表语句必须和Book实体类中声明的结构完全一致，否则Room就会抛出异常。</strong></p><p>最后在构建<code>AppDatabase</code>实例的时候，加入一个<code>addMigrations()</code>方法，并把MIGRATION_1_2传入即可。</p><p>现在当我们进行任何数据库操作时，Room就会自动根据当前数据库的版本号执行这些升级逻辑，从而让数据库始终保证是最新的版本。</p><p>不过，每次数据库升级并不一定都要新增一张表，也有可能是向现有的表中添加新的列。这种情况只需要使用alter语句修改表结构就可以了，我们来看一下具体的操作过程。</p><p>现在Book的实体类中只有id、书名、页数这几个字段，而我们想要再添加一个作者字段，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Book</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> pages: <span class="built_in">Int</span>, <span class="keyword">var</span> author: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然实体类的字段发生了变动，那么对应的数据库表也必须升级了，所以这里修改AppDatabase中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(version = 3, entities = [User::class, Book::class], exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">bookDao</span><span class="params">()</span></span>: BookDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> MIGRATION_1_2 = <span class="keyword">object</span> : Migration(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">migrate</span><span class="params">(database: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                database.execSQL(<span class="string">&quot;create table Book (id integer primary key autoincrement not null, name text not null, pages integer not null)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> MIGRATION_2_3 = <span class="keyword">object</span> : Migration(<span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">migrate</span><span class="params">(database: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                database.execSQL(<span class="string">&quot;alter table Book add column author text not null default &#x27;unknown&#x27;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDatabase &#123;</span><br><span class="line">            instance?.let &#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(context.applicationContext, AppDatabase::<span class="keyword">class</span>.java, <span class="string">&quot;app_database&quot;</span>)</span><br><span class="line">                .addMigrations(MIGRATION_1_2, MIGRATION_2_3)</span><br><span class="line">                .build().apply &#123;</span><br><span class="line">                    instance = <span class="keyword">this</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-WorkManager"><a href="#2-6-WorkManager" class="headerlink" title="2.6 WorkManager"></a>2.6 WorkManager</h3><p>Android的后台机制是一个很复杂的话题，在很早之前，Android系统的后台功能是非常开放的，Service的优先级也很高，仅次于Activity，那个时候可以在Service中做很多事情。但由于后台功能太过于开放，每个应用都想无限地占用后台资源，导致手机的内存越来越紧张，耗电越来越快，也变得越来越卡。为了解决这些情况，基本上Android系统每发布一个新版本，后台权限都会被进一步收紧。</p><p>从4.4系统开始<code>AlarmManager</code>的触发时间由原来的精准变为不精准，5.0系统中加入了<code>JobScheduler</code>来处理后台任务，6.0系统中引入了Doze和App Standby模式用于降低手机被后台唤醒的频率，从8.0系统开始直接禁用了Service的后台功能，只允许使用前台Service。当然，还有许许多多小细节的修改，我没能全部列举出来。</p><p>这么频繁的功能和API变更，让开发者就很难受了，到底该如何编写后台代码才能保证应用程序在不同系统版本上的兼容性呢？为了解决这个问题，Google推出了<code>WorkManager</code>组件。<code>WorkManager</code>很适合用于处理一些要求定时执行的任务，它可以根据操作系统的版本自动选择底层是使用<code>AlarmManager</code>实现还是<code>JobScheduler</code>实现，从而降低了我们的使用成本。另外，它还支持周期性任务、链式任务处理等功能，是一个非常强大的工具。</p><p>不过，我们还得先明确一件事情：**<code>WorkManager</code>和Service并不相同，也没有直接的联系。Service是Android系统的四大组件之一，它在没有被销毁的情况下是一直保持在后台运行的。而<code>WorkManager</code>只是一个处理定时任务的工具，它可以保证即使在应用退出甚至手机重启的情况下，之前注册的任务仍然将会得到执行，因此<code>WorkManager</code>很适合用于执行一些定期和服务器进行交互的任务，比如周期性地同步数据，等等。**</p><p>另外，使用<code>WorkManager</code>注册的周期性任务不能保证一定会准时执行，这并不是bug，而是系统为了减少电量消耗，可能会将触发时间临近的几个任务放在一起执行，这样可以大幅度地减少CPU被唤醒的次数，从而有效延长电池的使用时间。</p><p>那么下面我们就开始学习<code>WorkManager</code>的具体用法。</p><h4 id="2-6-1-WorkManager的基本用法"><a href="#2-6-1-WorkManager的基本用法" class="headerlink" title="2.6.1 WorkManager的基本用法"></a>2.6.1 WorkManager的基本用法</h4><p>要想使用<code>WorkManager</code>，需要先在<code>app/build.gradle</code>文件中添加如下的依赖：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation(&quot;androidx.work:work-runtime:2.9.0&quot;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WorkManager</code>的基本用法其实非常简单，主要分为以下3步：</p><ol><li>定义一个后台任务，并实现具体的任务逻辑；</li><li>配置该后台任务的运行条件和约束信息，并构建后台任务请求；</li><li>将该后台任务请求传入<code>WorkManager</code>的<code>enqueue()</code>方法中，系统会在合适的时间运行。</li></ol><p>第一步要定义一个后台任务，这里创建一个<code>SimpleWorker</code>类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWorker</span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SimpleWorker&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;doWork: &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台任务的写法非常固定，也很好理解。首先每一个后台任务都必须继承自Worker类，并调用它唯一的构造函数。然后重写父类中的<code>doWork()</code>方法，在这个方法中编写具体的后台任务逻辑即可。</p><p><code>doWork()</code>方法不会运行在主线程当中，因此你可以放心地在这里执行耗时逻辑，不过这里简单起见只是打印了一行日志。另外，<code>doWork()</code>方法要求返回一个Result对象，用于表示任务的运行结果，成功就返回<code>Result.success()</code>，失败就返回<code>Result.failure()</code>。除此之外，还有一个<code>Result.retry()</code>方法，它其实也代表着失败，只是可以结合<code>WorkRequest.Builder</code>的<code>setBackoffCriteria()</code>方法来重新执行任务，我们稍后会进行学习。</p><p>没错，就是这么简单，这样一个后台任务就定义好了。接下来可以进入第二步，配置该后台任务的运行条件和约束信息。</p><p>这一步其实也是最复杂的一步，因为可配置的内容非常多，不过目前我们还只是学习<code>WorkManager</code>的基本用法，因此只进行最基本的配置就可以了，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = OneTimeWorkRequest.Builder(SimpleWorker::<span class="keyword">class</span>.java).build()</span><br></pre></td></tr></table></figure><p>可以看到，只需要把刚才创建的后台任务所对应的Class对象传入<code>OneTimeWorkRequest.Builder</code>的构造函数中，然后调用<code>build()</code>方法即可完成构建。</p><p><code>OneTimeWorkRequest.Builder</code>是<code>WorkRequest.Builder</code>的子类，用于构建单次运行的后台任务请求。<code>WorkRequest.Builder</code>还有另外一个子类<code>PeriodicWorkRequest.Builder</code>，可用于构建周期性运行的后台任务请求，但是为了降低设备性能消耗，<code>PeriodicWorkRequest.Builder</code>构造函数中传入的运行周期间隔不能短于15分钟，示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = PeriodicWorkRequest.Builder(SimpleWorker::<span class="keyword">class</span>.java, <span class="number">15</span>, TimeUnit.MINUTES).build()</span><br></pre></td></tr></table></figure><p>最后一步，将构建出的后台任务请求传入<code>WorkManager</code>的<code>enqueue()</code>方法中，系统就会在合适的时间去运行了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(context).enqueue(request)</span><br></pre></td></tr></table></figure><p>在<code>activity_main.xml</code>中新增一个“Do Work”按钮，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/doWorkBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/queryDataBtn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Do Work&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来修改<code>MainActivity</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mainBinding.doWorkBtn.setOnClickListener &#123; </span><br><span class="line">            <span class="keyword">val</span> request = OneTimeWorkRequest.Builder(SimpleWorker::<span class="keyword">class</span>.java).build()</span><br><span class="line">            WorkManager.getInstance(<span class="keyword">this</span>).enqueue(request)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“Do Work”按钮的点击事件中构建后台任务请求，并将请求传入<code>WorkManager</code>的<code>enqueue()</code>方法中。后台任务的具体运行时间是由我们所指定的约束以及系统自身的一些优化所决定的，由于这里没有指定任何约束，因此后台任务基本上会在点击按钮之后立刻运行。</p><h4 id="2-6-2-使用WorkManager处理复杂的任务"><a href="#2-6-2-使用WorkManager处理复杂的任务" class="headerlink" title="2.6.2 使用WorkManager处理复杂的任务"></a>2.6.2 使用WorkManager处理复杂的任务</h4><p>在上一小节中，虽然我们成功运行了一个后台任务，但是由于不能控制它的具体运行时间，因此并没有什么太大的实际用处。当然，<code>WorkManager</code>是不可能没有提供这样的接口的，事实上除了运行时间之外，<code>WorkManager</code>还允许我们控制许多其他方面的东西，下面就来具体看一下吧。</p><p>首先从最简单的看起，让后台任务在指定的延迟时间后运行，只需要借助<code>setInitialDelay()</code>方法就可以了，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = OneTimeWorkRequest.Builder(SimpleWorker::<span class="keyword">class</span>.java)</span><br><span class="line">.setInitialDelay(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>这就表示我们希望让<code>SimpleWorker</code>这个后台任务在5分钟后运行。你可以自由选择时间的单位，毫秒、秒、分钟、小时、天都可以。</p><p>可以控制运行时间之后，我们再增加一些别的功能，比如说给后台任务请求添加标签：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = OneTimeWorkRequest.Builder(SimpleWorker::<span class="keyword">class</span>.java)</span><br><span class="line">...</span><br><span class="line">.addTag(<span class="string">&quot;simple&quot;</span>)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>那么添加了标签有什么好处呢？最主要的一个功能就是我们可以通过标签来取消后台任务请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).cancelAllWorkByTag(<span class="string">&quot;simple&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然，即使没有标签，也可以通过id来取消后台任务请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).cancelWorkById(request.id)</span><br></pre></td></tr></table></figure><p>但是，使用id只能取消单个后台任务请求，而使用标签的话，则可以将同一标签名的所有后台任务请求全部取消，这个功能在逻辑复杂的场景下尤其有用。</p><p>除此之外，我们也可以使用如下代码来一次性取消所有后台任务请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).cancelAllWork()</span><br></pre></td></tr></table></figure><p>另外，我们在上一小节中讲到，如果后台任务的<code>doWork()</code>方法中返回了<code>Result.retry()</code>，那么是可以结合<code>setBackoffCriteria()</code>方法来重新执行任务的，具体代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = OneTimeWorkRequest.Builder(SimpleWork::<span class="keyword">class</span>.java)</span><br><span class="line">...</span><br><span class="line">.setBackoffCriteria(BackoffPolicy.LINEAR, <span class="number">10</span>, TimeUint.SECONDS)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p><code>setBackoffCriteria()</code>方法接收3个参数：第二个和第三个参数用于指定在多久之后重新执行任务，时间最短不能少于10秒钟；第一个参数则用于指定如果任务再次执行失败，下次重试的时间应该以什么样的形式延迟。这其实很好理解，假如任务一直执行失败，不断地重新执行似乎并没有什么意义，只会徒增设备的性能消耗。而随着失败次数的增多，下次重试的时间也应该进行适当的延迟，这才是更加合理的机制。<strong>第一个参数的可选值有两种，分别是<code>LINEAR</code>和<code>EXPONENTIAL</code>，前者代表下次重试时间以线性的方式延迟，后者代表下次重试时间以指数的方式延迟。</strong></p><p>了解了<code>Result.retry()</code>的作用之后，你一定还想知道，<code>doWork()</code>方法中返回<code>Result.success()</code>和<code>Result.failure()</code>又有什么作用？这两个返回值其实就是用于通知任务运行结果的，我们可以使用如下代码对后台任务的运行结果进行监听：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="keyword">this</span>)</span><br><span class="line">.getWorkInfoByIdLiveData(request.id)</span><br><span class="line">.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workInfo.state == WorkInfo.State.SUCCEEDED) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;do work succeeded&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workInfo.state == WorkInfo.State.FAILED) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;do work failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里调用了<code>getWorkInfoByIdLiveData()</code>方法并传入后台任务请求的id，会返回一个<code>LiveData</code>对象。然后我们就可以调用<code>LiveData</code>对象的<code>observe()</code>方法来观察数据变化了，以此监听后台任务的运行结果。</p><p>另外，你也可以调用<code>getWorkInfosByTagLiveData()</code>方法，监听同一标签名下所有后台任务请求的运行结果，用法是差不多的，这里就不再进行解释了。接下来，我们再来看一下<code>WorkManager</code>中比较有特色的一个功能——链式任务。</p><p>假设这里定义了3个独立的后台任务：同步数据、压缩数据和上传数据。现在我们想要实现先同步、再压缩、最后上传的功能，就可以借助链式任务来实现，代码示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sync = ...</span><br><span class="line"><span class="keyword">val</span> compress = ...</span><br><span class="line"><span class="keyword">val</span> upload = ...</span><br><span class="line">WorkManager.getInstance(<span class="keyword">this</span>) </span><br><span class="line">.beginWith(sync)</span><br><span class="line">.then(compress)</span><br><span class="line">.then(upload)</span><br><span class="line">.enqueue()</span><br></pre></td></tr></table></figure><p><code>beginWith()</code>方法用于开启一个链式任务，至于后面要接上什么样的后台任务，只需要使用<code>then()</code>方法来连接即可。另外<code>WorkManager</code>还要求，必须在前一个后台任务运行成功之后，下一个后台任务才会运行。也就是说，如果某个后台任务运行失败，或者被取消了，那么接下来的后台任务就都得不到运行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;长久以来，Android官方并没有制定一个项目架构的规范，只要能够实现功能，代码怎么编写都是你的自由。但是不同的人技术水平不同，最终编写出来的代码质量是千差万别的。&lt;/p&gt;
&lt;p&gt;由于Android官方没有制定规范，为了追求更高的代码质量，慢慢就有第三方的社区和开发者将一些</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-Service</title>
    <link href="https://icu007work.github.io/archives/4928ca7e.html"/>
    <id>https://icu007work.github.io/archives/4928ca7e.html</id>
    <published>2024-01-11T07:23:01.000Z</published>
    <updated>2024-05-11T07:45:46.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Service"><a href="#一、什么是Service" class="headerlink" title="一、什么是Service"></a>一、什么是Service</h2><p><code>Service</code>是Android中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而且还要求长期运行的任务。<code>Service</code>的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，<code>Service</code>仍然能够保持正常运行。不过需要注意的是，**<code>Service</code>并不是运行在一个独立的进程当中的，而是依赖于创建<code>Service</code>时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的<code>Service</code>也会停止运行。**</p><p>另外，也不要被Service的后台概念所迷惑，实际上<strong>Service并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在Service的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。</strong></p><hr><h2 id="二、Android多线程编程"><a href="#二、Android多线程编程" class="headerlink" title="二、Android多线程编程"></a>二、Android多线程编程</h2><p>当我们需要执行一些耗时操作，比如发起一条网络请求时，考虑到网速等其他原因，服务器未必能够立刻响应我们的请求，如果不将这类操作放在子线程里运行，就会导致主线程被阻塞，从而影响用户对软件的正常使用。</p><h3 id="2-1-多线程的基本用法"><a href="#2-1-多线程的基本用法" class="headerlink" title="2.1 多线程的基本用法"></a>2.1 多线程的基本用法</h3><p>Android多线程编程其实并不比Java多线程编程特殊，基本是使用相同的语法。比如，定义一个线程只需要新建一个类继承自Thread，然后重写父类的run()方法，并在里面编写耗时逻辑即可，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>: <span class="type">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么该如何启动这个线程呢？其实很简单，只需要创建<code>MyThread</code>的实例，然后调用它的<code>start()</code>方法即可，这样<code>run()</code>方法中的代码就会在子线程当中运行了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread().start()</span><br></pre></td></tr></table></figure><p>当然，使用继承的方式耦合性有点高，我们会更多地选择使用实现<code>Runnable</code>接口的方式来定义一个线程，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>: <span class="type">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = MyThread()</span><br><span class="line">Thread(myThread).start()</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Thread的构造函数接收一个<code>Runnable</code>参数</strong>，而我们创建的<code>MyThread</code>实例正是一个实现了<code>Runnable</code>接口的对象，所以可以直接将它传入<code>Thread</code>的构造函数里。接着调用<code>Thread</code>的<code>start()</code>方法，<code>run()</code>方法中的代码就会在子线程当中运行了。</p><p>当然，如果你不想专门再定义一个类去实现<code>Runnable</code>接口，也可以使用<code>Lambda</code>的方式，这种写法更为常见，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><p>以上几种线程的使用方式你应该不会感到陌生，因为在Java中创建和启动线程也是使用同样的方式。而Kotlin还给我们提供了一种更加简单的开启线程的方式，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的thread是一个Kotlin内置的顶层函数，我们只需要在Lambda表达式中编写具体的逻辑就可以了，连start()方法都不用调用，thread函数在内部帮我们全部都处理好了。</p><h3 id="2-2-在子线程中更新UI"><a href="#2-2-在子线程中更新UI" class="headerlink" title="2.2 在子线程中更新UI"></a>2.2 在子线程中更新UI</h3><p>和许多其他的GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，必须在主线程中进行，否则就会出现异常。</p><p>举个栗子🌰：</p><p>我们增加两个控件，一个<code>Text View</code>，一个<code>Button</code>。我们在捕获到<code>Button</code>的点击事件后开启一个线程，在线程中更新<code>Text View</code>的内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.androidthread</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> work.icu007.androidthread.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        mainBinding.changeTextBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                <span class="comment">// 在子线程中更新UI将会导致crash</span></span><br><span class="line">                <span class="comment">// Only the original thread that created a view hierarchy can touch its views. Expected: main Calling: Thread-3</span></span><br><span class="line">                mainBinding.textView.text = <span class="string">&quot;Nice to meet u&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序会发现，程序会崩溃，报错信息为：</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/01/1705904581604_916aaaa5a848e.png" alt="1705904581604.png"></p><p>可以看出是由于在子线程中更新UI所导致，由此证实了Android确实是不允许在子线程中进行UI操作的。但是有些时候，我们必须在子线程里执行一些耗时任务，然后根据任务的执行结果来更新相应的UI控件，该怎么办呢。</p><p>Android提供了一套异步消息处理机制，完美地解决了在子线程中进行UI操作的问题。</p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.androidthread</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.Handler</span><br><span class="line"><span class="keyword">import</span> android.os.Looper</span><br><span class="line"><span class="keyword">import</span> android.os.Message</span><br><span class="line"><span class="keyword">import</span> work.icu007.androidthread.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> updateText: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> handler = <span class="keyword">object</span> : Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">when</span>(msg.what) &#123;</span><br><span class="line">                    updateText -&gt; mainBinding.textView.text = <span class="string">&quot;Nice to Meet U&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.changeTextBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                <span class="keyword">val</span> msg = Message()</span><br><span class="line">                msg.what = updateText</span><br><span class="line">                handler.sendMessage(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先是定义了一个整型变量<code>updateText</code>，用于表示更新<code>TextView</code>这个动作。然后新增一个Handler对象，并重写父类的<code>handleMessage()</code>方法，在这里对具体的Message进行处理。如果发现Message的what字段的值等于<code>updateText</code>，就将<code>TextView</code>显示的内容改成“Nice to meet you”。下面再来看一下“Change Text”按钮的点击事件中的代码。可以看到，这次我们并没有在子线程里直接进行UI操作，而是创建了一个<code>Message（android.os.Message）</code>对象，并将它的<code>what</code>字段的值指定为<code>updateText</code>，然后调用<code>Handler</code>的<code>sendMessage()</code>方法将这条Message发送出去。很快，<code>Handler</code>就会收到这条<code>Message</code>，并在<code>handleMessage()</code>方法中对它进行处理。<strong>注意此时<code>handleMessage()</code>方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行UI操作。</strong>接下来对<code>Message</code>携带的<code>what</code>字段的值进行判断，<strong>如果等于<code>updateText</code>，就将<code>TextView</code>显示的内容改成“Nice to meet you”。</strong></p><p>来分析一下<code>Android</code>异步消息处理机制到底是如何工作的。</p><h3 id="2-3-解析异步消息处理机制"><a href="#2-3-解析异步消息处理机制" class="headerlink" title="2.3 解析异步消息处理机制"></a>2.3 解析异步消息处理机制</h3><p>Android中的异步消息处理主要由4个部分组成：<code>Message</code>、<code>Handler</code>、<code>MessageQueue</code>和<code>Looper</code>。其中<code>Message</code>和<code>Handler</code>在上一小节中我们已经接触过了，<code>MessageQueue</code>和<code>Looper</code>相对来说还是全新的概念。</p><ol><li><p><strong>Message</strong></p><p><strong>Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间传递数据。</strong>上一小节中我们使用到了Message的what字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用<code>obj</code>字段携带一个<code>Object</code>对象。</p></li><li><p><strong>Handler</strong></p><p><strong>Handler顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。</strong>发送消息一般是使用Handler的<code>sendMessage()</code>方法、<code>post()</code>方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的<code>handleMessage()</code>方法中。</p></li><li><p><strong>MessageQueue</strong></p><p><strong><code>MessageQueue</code>是消息队列的意思，它主要用于存放所有通过Handler发送的消息。</strong>这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个<code>MessageQueue</code>对象。</p></li><li><p><strong>Looper</strong></p><p><strong>Looper是每个线程中的<code>MessageQueue</code>的管家，调用Looper的<code>loop()</code>方法后，就会进入一个无限循环当中，然后每当发现<code>MessageQueue</code>中存在一条消息时，就会将它取出，并传递到Handler的<code>handleMessage()</code>方法中。</strong>每个线程中只会有一个Looper对象。</p><p>了解了<strong>Message、Handler、MessageQueue以及Looper</strong>的基本概念后，我们再来把异步消息处理的整个流程梳理一遍。</p><ul><li><p>首先需要在主线程当中创建一个Handler对象，并重写<code>handleMessage()</code>方法。然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去。</p></li><li><p>之后这条消息会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage()方法中。</p></li><li><p>由于Handler的构造函数中我们传入了<code>Looper.getMainLooper()</code>，所以此时<code>handleMessage()</code>方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行UI操作了。</p></li></ul><p>整个异步消息处理机制的流程如下图所示。</p><p><img src="https://pic.ziyuan.wang/user/xiheya/2024/01/1705905983755_52e55f9c353f2.png" alt="1705905983755.png"></p><p>一条Message经过以上流程的辗转调用后，也就从子线程进入了主线程，从不能更新UI变成了可以更新UI，整个异步消息处理的核心思想就是如此。</p><blockquote><p>异步消息处理在 Android 中主要涉及到四个部分：Message, Handler, MessageQueue 和 Looper。</p><ol><li><strong>Message</strong> 当我们需要执行一个新的任务时，首先我们会创建一个 Message 对象。这个对象包含了我们在将来需要处理的内容。</li><li><strong>Handler</strong> 接下来我们会通过 Handler 对象来把这个 Message 对象加入到任务队列中。Handler 主要有两个功能：一是添加任务到任务队列，二是处理任务队列中的任务。Handler 依赖于它被创建时所在的线程的 Looper 对象。</li><li><strong>MessageQueue</strong> MessageQueue 是一个等待处理的Message对象的队列。它由 Looper 维护，Handler 添加任务就是向 MessageQueue 中添加 Message 对象。</li><li><strong>Looper</strong> Looper 是一个循环，它从 MessageQueue 中取出 Message 并通过 Handler 进行处理。每个线程最多有一个 Looper 对象，主线程（UI 线程）会自动创建 Looper 对象，非主线程需要手动创建 Looper 对象。并在异步操作完毕之后，发送消息给 Looper，这时Looper 把要处理的消息交给相应的 Handler 进行处理。</li></ol><p>总结一下流程就是：当我们需要执行一个新的异步任务时，我们创建一个 Message 对象，然后通过 Handler 对象把这个 Message 发送到 MessageQueue。Looper 在循环中从 MessageQueue 中取出 Message，交给相应的 Handler 进行处理。这就是在 Android 中异步消息处理的基本流程。</p><p>在Android系统中，Looper的循环运行、取出MessageQueue中的Message交给对应的Handler处理的过程是在Looper的loop()方法中进行的。这一部分通常被看做是Android系统完成的，开发者负责的是创建Message、Handler以及调用Handler的sendMessage方法将Message放入队列等操作。</p><p>在之前的代码中，handler.sendMessage(msg)将Message放入MessageQueue队列。然后由运行在主线程的Looper自动将MessageQueue中的Message提取出来并交给对应的Handler处理。</p><p>Looper.loop()方法的大概运行逻辑如下（这个一般在Thread中被调用）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = queue.next(); <span class="comment">// 从MessageQueue中获取Message</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果Message为null，代表MessageQueue已经无消息，退出循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用Handler的handleMessage进行处理</span></span><br><span class="line">        msg.target.handleMessage(msg);</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，每生成一个Message对象，就调用Handler的handleMessage方法进行处理。在之前代码中，msg.what值为updateText时，就会执行mainBinding.textView.text &#x3D; “Nice to Meet U”这个操作。</p></blockquote></li></ol><h3 id="2-4-使用AsyncTask"><a href="#2-4-使用AsyncTask" class="headerlink" title="2.4 使用AsyncTask"></a>2.4 使用AsyncTask</h3><p>为了更加方便我们在子线程中对UI进行操作，Android还提供了另外一些好用的工具，比如AsyncTask。借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask背后的实现原理也是基于异步消息处理机制的，只是Android帮我们做了很好的封装而已。</p><p>首先来看一下AsyncTask的基本用法。由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须创建一个子类去继承它。在继承时我们可以为AsyncTask类指定3个泛型参数，这3个参数的用途如下。</p><ul><li>Params。在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li><li>Progress。在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li><li>Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li></ul><p>因此，一个最简单的自定义AsyncTask就可以写成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Unit, Int, Boolean</span>&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把AsyncTask的第一个泛型参数指定为Unit，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Int，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。</p><p>当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要重写AsyncTask中的几个方法才能完成对任务的定制。经常需要重写的方法有以下4个。</p><ol><li><p><strong>onPreExecute()</strong></p><p>这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示<br>一个进度条对话框等。</p></li><li><p><strong>doInBackground(Params…)</strong></p><p><strong>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。</strong>任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果。<strong>注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress (Progress…)方法来完成。</strong></p></li><li><p><strong>onProgressUpdate(Progress…)</strong></p><p><strong>当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。</strong>在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p></li><li><p><strong>onPostExecute(Result)</strong></p><p><strong>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。</strong>返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执行的结果，以及关闭进度条对话框等。</p><p>因此，一个比较完整的自定义AsyncTask就可以写成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Unit, Int, Boolean</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreExecute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        progressDialog.show() <span class="comment">// 显示进度对话框</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> params: <span class="type">Unit</span>?)</span></span> = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> downloadPercent = doDownload() <span class="comment">// 这是一个虚构的方法</span></span><br><span class="line">            publishProgress(downloadPercent)</span><br><span class="line">            <span class="keyword">if</span> (downloadPercent &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressUpdate</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在这里更新下载进度</span></span><br><span class="line">        progressDialog.setMessage(<span class="string">&quot;Downloaded <span class="subst">$&#123;values[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostExecute</span><span class="params">(result: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        progressDialog.dismiss() <span class="comment">// 关闭对话框</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 下载成功后动作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下载失败后动作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在这个DownloadTask中，我们在<code>doInBackground()</code>方法里<strong>执行具体的下载任务</strong>。<strong>这个方法里的代码都是在子线程中运行的，因而不会影响主线程的运行</strong>。注意，这里虚构了一个doDownload()方法，用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了，<strong>由于doInBackground()方法是在子线程中运行的，在这里肯定不能进行UI操作，所以我们可以调用publishProgress()方法并传入当前的下载进度，这样onProgressUpdate()方法就会很快被调用，在这里就可以进行UI操作了。</strong></p><p>当下载完成后，doInBackground()方法会返回一个布尔型变量，这样onPostExecute()方法就会很快被调用，这个方法也是在主线程中运行的。然后，在这里我们会根据下载的结果弹出相应的Toast提示，从而完成整个DownloadTask任务。</p><p>简单来说，使用AsyncTask的诀窍就是，<strong>在doInBackground()方法中执行具体的耗时任务，在onProgressUpdate()方法中进行UI操作，在onPostExecute()方法中执行一些任务的收尾工作。</strong></p><p>如果想要启动这个任务，只需编写以下代码即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DownloadTask().execute()</span><br></pre></td></tr></table></figure><p>当然，你也可以给<code>execute()</code>方法传入任意数量的参数，这些参数将会传递到<code>DownloadTask</code>的<code>doInBackground()</code>方法当中。</p><h2 id="三、Service的基本用法"><a href="#三、Service的基本用法" class="headerlink" title="三、Service的基本用法"></a>三、Service的基本用法</h2><h3 id="3-1-定义一个Service"><a href="#3-1-定义一个Service" class="headerlink" title="3.1 定义一个Service"></a>3.1 定义一个Service</h3><p>新建一个<code>Service</code>，新建<code>Service</code>时的<code>Exported</code>属性表示是否将这个<code>Service</code>暴露给外部其他程序访问，<code>Enabled</code>属性表示是否启用这个<code>Service</code>。</p><p>观察一下<code>MyService</code>的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyService</code>是继承自系统的<code>Service</code>类的。目前<code>MyService</code>中可以算是空空如也，但有一个<code>onBind()</code>方法特别醒目。<strong>这个方法是<code>Service</code>中唯一的抽象方法，所以必须在子类里实现。</strong></p><p>我们还可以重写Service中的另外一些方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们又重写了<code>onCreate()</code>、<code>onStartCommand()</code>和<code>onDestroy()</code>这3个方法，它们是每个<code>Service</code>中最常用到的3个方法了。其中<code>onCreate()</code>方法会在<code>Service</code>创建的时候调用，<code>onStartCommand()</code>方法会在每次<code>Service</code>启动的时候调用，<code>onDestroy()</code>方法会在<code>Service</code>销毁的时候调用。</p><p>通常情况下，如果我们希望<code>Service</code>一旦启动就立刻去执行某个动作，就可以将逻辑写在<code>onStartCommand()</code>方法里。而当<code>Service</code>销毁时，我们又应该在<code>onDestroy()</code>方法中回收那些不再使用的资源。</p><p>另外需要注意，每一个<code>Service</code>都需要在<code>AndroidManifest.xml</code>文件中进行注册才能生效，这是Android四大组件共有的特点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.ServiceTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MyService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-启动和停止Service"><a href="#3-2-启动和停止Service" class="headerlink" title="3.2 启动和停止Service"></a>3.2 启动和停止Service</h3><p>启动和停止Service主要是借助Intent来实现的。下面来尝试一下,在布局文件中新增两个button。分别用于启动和停止Service：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> work.icu007.servicetest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        mainBinding.startServiceBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.stopServiceBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            stopService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“Start Service”按钮的点击事件里，我们构建了一个Intent对象，并调用<code>startService()</code>方法来启动<code>MyService</code>。在“Stop Service”按钮的点击事件里，我们同样构建了一个<code>Intent</code>对象，并调用<code>stopService()</code>方法来停止MyService。<code>startService()</code>和<code>stopService()</code>方法都是定义在<code>Context</code>类中的，所以我们在<code>Activity</code>里可以直接调用这两个方法。另外，<code>Service</code>也可以自我停止运行，只需要在<code>Service</code>内部调用<code>stopSelf()</code>方法即可。</p><h3 id="3-3-Activity和Service进行通信"><a href="#3-3-Activity和Service进行通信" class="headerlink" title="3.3 Activity和Service进行通信"></a>3.3 Activity和Service进行通信</h3><p>我们在<code>Activity</code>里调用了<code>startService()</code>方法来启动<code>MyService</code>，然后<code>MyService</code>的<code>onCreate()</code>和<code>onStartCommand()</code>方法就会得到执行。之后<code>Service</code>会一直处于运行状态，但具体运行的是什么逻辑，<code>Activity</code>就控制不了了。这就类似于<code>Activity</code>通知了<code>Service</code>一下：“你可以启动了！”然后<code>Service</code>就去忙自己的事情了，但<code>Activity</code>并不知道<code>Service</code>到底做了什么事情，以及完成得如何。</p><p>那么可不可以让<code>Activity</code>和<code>Service</code>的关系更紧密一些呢？例如在<code>Activity</code>中指挥<code>Service</code>去干什么，<code>Service</code>就去干什么。当然可以，这就需要借助我们刚刚忽略的<code>onBind()</code>方法了。</p><p>比如说，目前我们希望在<code>MyService</code>里提供一个下载功能，然后在<code>Activity</code>中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的<code>Binder</code>对象来对下载功能进行管理。修改<code>MyService</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.os.Binder</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DownloadBinder</span> : <span class="type">Binder</span>() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownload</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;startDownload: executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;getProgress: executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">        TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate: executed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStartCommand: executed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy: executed&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> TAG: String = MyService.javaClass.simpleName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们新建了一个<code>DownloadBinder</code>类，并让它继承自<code>Binder</code>，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功能，我们在这两个方法中分别打印了一行日志。</p><p>接着，在<code>MyService</code>中创建了<code>DownloadBinder</code>的实例，然后在<code>onBind()</code>方法里返回了这个实例，这样<code>MyService</code>中的工作就全部完成了。</p><p>下面就要看一看在<code>Activity</code>中如何调用<code>Service</code>里的这些方法了。修改代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> work.icu007.servicetest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> downloadBinder : MyService.DownloadBinder</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">            downloadBinder = service <span class="keyword">as</span> MyService.DownloadBinder</span><br><span class="line">            downloadBinder.startDownload()</span><br><span class="line">            downloadBinder.getProgress()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mainBinding.startServiceBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.stopServiceBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            stopService(intent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.bindServiceBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent, connection, Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.unbindServiceBtn.setOnClickListener &#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们首先创建了一个<code>ServiceConnection</code>的匿名类实现，并在里面重写了<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法。<code>onServiceConnected()</code>方法方法会在<code>Activity</code>与<code>Service</code>成功绑定的时候调用，而<code>onServiceDisconnected()</code>方法只有<strong>在Service的创建进程崩溃或者被杀掉的时候才会调用</strong>，这个方法不太常用。那么在<code>onServiceConnected()</code>方法中，我们又通过向下转型得到了<code>DownloadBinder</code>的实例，有了这个实例，<code>Activity</code>和<code>Service</code>之间的关系就变得非常紧密了。<strong>现在我们可以在<code>Activity</code>中根据具体的场景来调用<code>DownloadBinder</code>中的任何public方法，即实现了指挥<code>Service</code>干什么<code>Service</code>就去干什么的功能。</strong>这里仍然只是做了个简单的测试，在<code>onServiceConnected()</code>方法中调用了<code>DownloadBinder</code>的<code>startDownload()</code>和<code>getProgress()</code>方法。</p><p>当然，现在<code>Activity</code>和<code>Service</code>其实还没进行绑定呢，这个功能是在“<code>Bind Service</code>”按钮的点击事件里完成的。可以看到，这里我们仍然构建了一个<code>Intent</code>对象，然后调用<code>bindService()</code>方法将<code>MainActivity</code>和<code>MyService</code>进行绑定。<code>bindService()</code>方法接收3个参数，<strong>第一个参数就是刚刚构建出的Intent对象，第二个参数是前面创建出的<code>ServiceConnection</code>的实例，第三个参数则是一个标志位，这里传入<code>BIND_AUTO_CREATE</code>表示在Activity和Service进行绑定后自动创建Service。这会使得MyService中的<code>onCreate()</code>方法得到执行，但<code>onStartCommand()</code>方法不会执行。</strong></p><p>如果我们想解除Activity和Service之间的绑定该怎么办呢？调用一下<code>unbindService()</code>方法就可以了，这也是“Unbind Service”按钮的点击事件里实现的功能。</p><h3 id="3-4-Service的生命周期"><a href="#3-4-Service的生命周期" class="headerlink" title="3.4 Service的生命周期"></a>3.4 Service的生命周期</h3><p>之前有了解过<strong>Activity</strong>以及<strong>Fragment</strong>的生命周期。类似地，<strong>Service</strong>也有自己的生命周期，前面我们使用到的<code>onCreate()</code>、<code>onStartCommand()</code>、<code>onBind()</code>和<code>onDestroy()</code>等方法都是在Service的生命周期内可能回调的方法。</p><p>一旦在项目的任何位置调用了<strong>Context</strong>的<code>startService()</code>方法，相应的<strong>Service</strong>就会启动，并回调<code>onStartCommand()</code>方法。如果这个<strong>Service</strong>之前还没有创建过，<code>onCreate()</code>方法会先于<code>onStartCommand()</code>方法执行。<strong>Service启动了之后会一直保持运行状态，直到<code>stopService()</code>或<code>stopSelf()</code>方法被调用，或者被系统回收。</strong>注意，<strong>虽然每调用一次<code>startService()</code>方法，<code>onStartCommand()</code>就会执行一次，但实际上每个Service只会存在一个实例。</strong>所以不管你调用了多少次<code>startService()</code>方法，只需调用一次<code>stopService()</code>或<code>stopSelf()</code>方法，<code>Service</code>就会停止。另外，<strong>还可以调用Context的<code>bindService()</code>来获取一个Service的持久连接，这时就会回调Service中的<code>onBind()</code>方法。类似地，如果这个Service之前还没有创建过，<code>onCreate()</code>方法会先于<code>onBind()</code>方法执行。之后，调用方可以获取到<code>onBind()</code>方法里返回的IBinder对象的实例，这样就能自由地和Service进行通信了。</strong>只要调用方和Service之间的连接没有断开，Service就会一直保持运行状态，直到被系统回收。</p><p>当调用了<code>startService()</code>方法后，再去调用<code>stopService()</code>方法。这时<strong>Service</strong>中的<code>onDestroy()</code>方法就会执行，表示<strong>Service</strong>已经销毁了。类似地，当调用了<code>bindService()</code>方法后，再去调用<code>unbindService()</code>方法，<code>onDestroy()</code>方法也会执行，这两种情况都很好理解。但是需要注意，<strong>我们是完全有可能对一个Service既调用了<code>startService()</code>方法，又调用了<code>bindService()</code>方法的，在这种情况下该如何让Service销毁呢？根据Android系统的机制，一个Service只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件同时不满足，Service才能被销毁。所以，这种情况下要同时调用<code>stopService()</code>和<code>unbindService()</code>方法，<code>onDestroy()</code>方法才会执行。</strong></p><h3 id="3-5-Service的更多技巧"><a href="#3-5-Service的更多技巧" class="headerlink" title="3.5 Service的更多技巧"></a>3.5 Service的更多技巧</h3><h4 id="3-5-1-使用前台Service"><a href="#3-5-1-使用前台Service" class="headerlink" title="3.5.1 使用前台Service"></a>3.5.1 使用前台Service</h4><p><strong>从Android 8.0系统开始，只有当应用保持在前台可见状态的情况下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时都有可能被系统回收。</strong>而如果你希望<strong>Service</strong>能够一直保持运行状态，就可以考虑使用前台<strong>Service</strong>。前台<strong>Service</strong>和普通<strong>Service</strong>最大的区别就在于，它一直会有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。</p><p>来看一下如何才能创建一个前台<code>Service</code>，其实并不复杂，修改<code>MyService</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.NotificationChannel</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent</span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.os.Binder</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DownloadBinder</span> : <span class="type">Binder</span>() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownload</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;startDownload: executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;getProgress: executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">        TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate: executed&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">val</span> channel = NotificationChannel(<span class="string">&quot;my_service&quot;</span>, <span class="string">&quot;前台Service通知&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="comment">// A12 之后必须指定最后一个参数 flags 为 PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE</span></span><br><span class="line">        <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, PendingIntent.FLAG_IMMUTABLE)</span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;my_service&quot;</span>)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;this is content title&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;this is content text&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_launcher_background)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.ic_launcher_foreground))</span><br><span class="line">            .setContentIntent(pi)</span><br><span class="line">            .build()</span><br><span class="line">        startForeground(<span class="number">1</span>, notification)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStartCommand: executed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy: executed&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> TAG: String = MyService.javaClass.simpleName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在<code>onCreate()</code>方法中创建了通知，但是构建<strong>Notification</strong>对象后并没有使用<strong>NotificationManager</strong>将通知显示出来，而是调用了<code>startForeground()</code>方法。这个方法接收两个参数：第一个参数是通知的id，类似于<code>notify()</code>方法的第一个参数；第二个参数则是构建的<strong>Notification</strong>对象。调用<code>startForeground()</code>方法后就会让<strong>MyService</strong>变成一个前台Service，并在系统状态栏显示出来。</p><p>另外，从Android 9.0系统开始，使用前台<strong>Service</strong>必须在<code>AndroidManifest.xml</code>文件中进行权限声明才行，通知权限也需要申请，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.POST_NOTIFICATIONS&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">&quot;ProtectedPermissions&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以在<strong>MainActivity</strong>中申请权限：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AlertDialog</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationManagerCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.ContextCompat</span><br><span class="line"><span class="keyword">import</span> work.icu007.servicetest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        <span class="keyword">if</span> (!NotificationManagerCompat.from(<span class="keyword">this</span>).areNotificationsEnabled()) &#123;</span><br><span class="line">            <span class="comment">// 如果没有权限，向用户显示一个对话框，引导他们去设置中开启</span></span><br><span class="line">            AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">                .setTitle(<span class="string">&quot;需要通知权限&quot;</span>)</span><br><span class="line">                .setMessage(<span class="string">&quot;此应用需要您允许通知权限才能正常工作。请点击“设置”按钮，然后在设置中开启通知权限。&quot;</span>)</span><br><span class="line">                .setPositiveButton(<span class="string">&quot;设置&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                    <span class="keyword">val</span> intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                    <span class="keyword">val</span> uri = Uri.fromParts(<span class="string">&quot;package&quot;</span>, packageName, <span class="literal">null</span>)</span><br><span class="line">                    intent.<span class="keyword">data</span> = uri</span><br><span class="line">                    startActivity(intent)</span><br><span class="line">                &#125;</span><br><span class="line">                .setNegativeButton(<span class="string">&quot;取消&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                    <span class="comment">/*这个方法需要两个参数（一个 DialogInterface 对象和一个表示哪个按钮被点击的 int 值），</span></span><br><span class="line"><span class="comment">                    但是我们不关心这两个参数的具体值，所以我们用下划线 _ 来代替它们*/</span></span><br><span class="line">                    <span class="comment">// 用户点击取消，结束应用</span></span><br><span class="line">                    finish()</span><br><span class="line">                &#125;</span><br><span class="line">                .show()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mainBinding.startServiceBtn.setOnClickListener &#123;</span><br><span class="line">                <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">                startService(intent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-2-使用IntentService"><a href="#3-5-2-使用IntentService" class="headerlink" title="3.5.2 使用IntentService"></a>3.5.2 使用IntentService</h4><p><strong>Service</strong>中的代码都是默认运行在主线程当中的，如果直接在<strong>Service</strong>里处理一些耗时的逻辑，就很容易出现<strong>ANR</strong>（<strong>Application Not Responding</strong>）的情况。所以这个时候就需要用到<strong>Android</strong>多线程编程的技术了，我们应该在<strong>Service</strong>的每个具体的方法里开启一个子线程，然后在这里处理那些耗时的逻辑。因此，一个比较标准的<strong>Service</strong>就可以写成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="comment">// 处理具体的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种<strong>Service</strong>一旦启动，就会一直处于运行状态，必须调用<code>stopService()</code>或<code>stopSelf()</code>方法，或者被系统回收，<strong>Service</strong>才会停止。所以，如果想要实现让一个<strong>Service</strong>在执行完毕后自动停止的功能，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>, flags : <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="comment">// 处理具体的逻辑</span></span><br><span class="line">            stopSelf()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽说这种写法并不复杂，但是总会有一些程序员忘记开启线程，或者忘记调用<code>stopSelf()</code>方法。为了可以简单地创建一个异步的、会自动停止的<strong>Service</strong>，<strong>Android</strong>专门提供了一个<strong>IntentService</strong>类，这个类就很好地解决了前面所提到的两种尴尬，下面我们就来看一下它的用法。<br>新建一个<strong>MyIntentService</strong>类继承自<strong>IntentService</strong>，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIntentService</span> : <span class="type">IntentService</span>(<span class="string">&quot;MyIntentService&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHandleIntent</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 打印当前线程id</span></span><br><span class="line">        Log.d(<span class="string">&quot;MyIntentService&quot;</span>, <span class="string">&quot;Thread id is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        Log.d(<span class="string">&quot;MyIntentService&quot;</span>, <span class="string">&quot;onDestroy executed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先要求必须先调用父类的构造函数，并传入一个字符串，这个字符串可以随意指定，只在调试的时候有用。然后要在子类中实现<code>onHandleIntent()</code>这个抽象方法，这个方法中可以处理一些耗时的逻辑，而不用担心<strong>ANR</strong>的问题，因为这个方法已经是在子线程中运行的了。这里为了证实一下，我们在<code>onHandleIntent()</code>方法中打印了当前线程名。另外，根据<strong>IntentService</strong>的特性，这个<strong>Service</strong>在运行结束后应该是会自动停止的，所以我们又重写了<code>onDestroy()</code>方法，在这里也打印了一行日志，以证实<strong>Service</strong>是不是停止了。</p><p>新增一个<strong>Button</strong>用于启动<strong>MyIntentService</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.servicetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AlertDialog</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationManagerCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.ContextCompat</span><br><span class="line"><span class="keyword">import</span> work.icu007.servicetest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mainBinding.startIntentServiceBtn.setOnClickListener &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCreate: Thread id is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyIntentService::<span class="keyword">class</span>.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察日志打印：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2024-01-24 09:32:15.416 26117-26117 MainActivity            work.icu007.servicetest              D  onCreate: Thread id is main</span><br><span class="line">2024-01-24 09:32:15.456 26117-26152 MyIntentService         work.icu007.servicetest              D  onHandleIntent: Thread id is IntentService[MyIntentService]</span><br><span class="line">2024-01-24 09:32:15.466 26117-26117 MyIntentService         work.icu007.servicetest              D  onDestroy: executed</span><br></pre></td></tr></table></figure><p>可以看到，不仅<strong>MyIntentService</strong>和<strong>MainActivity</strong>所在的线程名不一样，而且<code>onDestroy()</code>方法也得到了执行，说明<strong>MyIntentService</strong>在运行完毕后确实自动停止了。集开启线程和自动停止于一身，<strong>IntentService</strong>还是博得了不少程序员的喜爱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是Service&quot;&gt;&lt;a href=&quot;#一、什么是Service&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Service&quot;&gt;&lt;/a&gt;一、什么是Service&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Service&lt;/code&gt;是Android中实</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-运用手机多媒体</title>
    <link href="https://icu007work.github.io/archives/3c95749.html"/>
    <id>https://icu007work.github.io/archives/3c95749.html</id>
    <published>2023-12-26T07:18:10.000Z</published>
    <updated>2024-05-11T07:48:32.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用通知"><a href="#一、使用通知" class="headerlink" title="一、使用通知"></a>一、使用通知</h2><p>通知（notification）是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。发出一条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。Android的通知功能自推出以来就大获成功，连iOS系统也在5.0版本之后加入了类似的功能。</p><h3 id="1-1-创建通知渠道"><a href="#1-1-创建通知渠道" class="headerlink" title="1.1 创建通知渠道"></a>1.1 创建通知渠道</h3><p>Android 8.0系统引入了通知渠道这个概念。什么是通知渠道呢？顾名思义，就是每条通知都要属于一个对应的渠道。每个应用程序都可以自由地创建当前应用拥有哪些通知渠道，但是这些通知渠道的控制权是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动或者是否要关闭这个渠道的通知。</p><p>拥有了这些控制权之后，用户就再也不用害怕那些垃圾通知的打扰了，因为用户可以自主地选择关心哪些通知、不关心哪些通知。</p><p>而我们的应用程序如果想要发出通知，也必须创建自己的通知渠道才行，下面我们就来学习一下创建通知渠道的详细步骤。</p><p>首先需要一个<code>NotificationManager</code>对通知进行管理，可以通过调用Context的<code>getSystemService()</code>方法获取。<code>getSystemService()</code>方法接收一个字符串参数用于确定获取系统的哪个服务，这里我们传入<code>Context.NOTIFICATION_SERVICE</code>即可。因此，获取<code>NotificationManager</code>的实例就可以写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br></pre></td></tr></table></figure><p>接下来要使用<code>NotificationChannel</code>类构建一个通知渠道，并调用<code>NotificationManager</code>的<code>createNotificationChannel()</code>方法完成创建。由于<code>NotificationChannel</code>类和<code>createNotificationChannel()</code>方法都是Android 8.0系统中新增的API，因此我们在使用的时候还需要进行版本判断才可以，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODE.O) &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = NotificationChannel(channelId, channelName, importance)</span><br><span class="line">    manager.createNotificationChannel(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个通知渠道至少需要<strong>渠道ID</strong>、<strong>渠道名称</strong>以及<strong>重要等级</strong>这<strong>3个参数</strong>，其中<strong>渠道ID可以随便定义，只要保证全局唯一性就可以</strong>。<strong>渠道名称是给用户看的，需要可以清楚地表达这个渠道的用途</strong>。<strong>通知的重要等级主要有IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN这几种，对应的重要程度依次从高到低</strong>。不同的重要等级会决定通知的不同行为，后面我们会通过具体的例子进行演示。当然这里只是初始状态下的重要等级，用户可以随时手动更改某个通知渠道的重要等级，开发者是无法干预的。</p><p>下面来看一下通知的使用方法。通知的用法还是比较灵活的，既可以在<code>Activity</code>里创建，也可以在<code>BroadcastReceiver</code>里创建，当然还可以在后面我们即将学习的<code>Service</code>里创建。相比于<code>BroadcastReceiver</code>和<code>Service</code>，在<code>Activity</code>里创建通知的场景还是比较少的，因为一般只有当程序进入后台的时候才需要使用通知。</p><h3 id="1-2-通知的基本用法"><a href="#1-2-通知的基本用法" class="headerlink" title="1.2 通知的基本用法"></a>1.2 通知的基本用法</h3><p>不过，无论是在哪里创建通知，整体的步骤都是相同的，下面我们就来看一下创建通知的详细步骤。</p><p>首先需要使用一个<code>Builder</code>构造器来创建<code>Notification</code>对象，但问题在于，Android系统的每一个版本都会对通知功能进行或多或少的修改，API不稳定的问题在通知上凸显得尤其严重，比方说刚刚介绍的通知渠道功能在Android 8.0系统之前就是没有的。那么该如何解决这个问题呢？其实解决方案我们之前已经见过好几回了，<strong>就是使用<code>AndroidX</code>库中提供的兼容API。<code>AndroidX</code>库中提供了一个<code>NotificationCompat</code>类，使用这个类的构造器创建<code>Notification</code>对象，就可以保证我们的程序在所有Android系统版本上都能正常工作了，代码如下所示</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.Builder(context, channelId).build()</span><br></pre></td></tr></table></figure><p><code>NotificationCompat.Builder</code>的构造函数中接收两个参数：<strong>第一个参数是context</strong>，这个没什么好说的；<strong>第二个参数是渠道ID</strong>，需要和我们在创建通知渠道时指定的渠道ID相匹配才行。</p><p>当然，上述代码只是创建了一个空的Notification对象，并没有什么实际作用，我们可以在最终的<code>build()</code>方法之前连缀任意多的设置方法来创建一个丰富的Notification对象，先来看一些最基本的设置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.Builder(context, channelId)</span><br><span class="line">.setContentTitle(<span class="string">&quot;this is content title&quot;</span>).setContentText(<span class="string">&quot;This is content text&quot;</span>)</span><br><span class="line">.setSmallIcon(R.drawable.small_icon)</span><br><span class="line">.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.large_icon))</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>上述代码中一共调用了4个设置方法，下面我们来一一解析一下。<code>setContentTitle()</code>方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。<code>setContentText()</code>方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。<code>setSmallIcon()</code>方法用于设置通知的小图标，注意，只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上。<code>setLargeIcon()</code>方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。</p><p>以上工作都完成之后，只需要调用<code>NotificationManager</code>的<code>notify()</code>方法就可以让通知显示出来了。<code>notify()</code>方法接收两个参数：<strong>第一个参数是id</strong>，要保证为每个通知指定的id都是不同的；<strong>第二个参数则是<code>Notification</code>对象</strong>，这里直接将我们刚刚创建好的Notification对象传入即可。因此，显示一个通知就可以写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.notify(<span class="number">1</span>,notification)</span><br></pre></td></tr></table></figure><p>下面就让我们通过一个具体的例子来看看通知到底是长什么样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.notificationtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.NotificationChannel</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AlertDialog</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationManagerCompat</span><br><span class="line"><span class="keyword">import</span> com.ubx.notificationtest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> kotlin.random.Random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        <span class="comment">// 获取NotificationManager实例</span></span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        <span class="comment">// 判断安卓版本是否为Android 8.0+</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="comment">// 安卓版本为 8.0+ 则使用NotificationChannel类构建一个通知渠道，</span></span><br><span class="line">            <span class="comment">// 并调用NotificationManager的createNotificationChannel()方法完成创建</span></span><br><span class="line">            <span class="keyword">val</span> channel =</span><br><span class="line">                NotificationChannel(<span class="string">&quot;normal&quot;</span>, <span class="string">&quot;Normal&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.sendNotice.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 检查是否已经有了通知权限</span></span><br><span class="line">            <span class="keyword">if</span> (!NotificationManagerCompat.from(<span class="keyword">this</span>).areNotificationsEnabled()) &#123;</span><br><span class="line">                <span class="comment">// 如果没有权限，向用户显示一个对话框，引导他们去设置中开启</span></span><br><span class="line">                AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">                    .setTitle(<span class="string">&quot;需要通知权限&quot;</span>)</span><br><span class="line">                    .setMessage(<span class="string">&quot;此应用需要您允许通知权限才能正常工作。请点击“设置”按钮，然后在设置中开启通知权限。&quot;</span>)</span><br><span class="line">                    .setPositiveButton(<span class="string">&quot;设置&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                        <span class="keyword">val</span> intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                        <span class="keyword">val</span> uri = Uri.fromParts(<span class="string">&quot;package&quot;</span>, packageName, <span class="literal">null</span>)</span><br><span class="line">                        intent.<span class="keyword">data</span> = uri</span><br><span class="line">                        startActivity(intent)</span><br><span class="line">                    &#125;</span><br><span class="line">                    .setNegativeButton(<span class="string">&quot;取消&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                        <span class="comment">/*这个方法需要两个参数（一个 DialogInterface 对象和一个表示哪个按钮被点击的 int 值），</span></span><br><span class="line"><span class="comment">                        但是我们不关心这两个参数的具体值，所以我们用下划线 _ 来代替它们*/</span></span><br><span class="line">                        <span class="comment">// 用户点击取消，结束应用</span></span><br><span class="line">                        finish()</span><br><span class="line">                    &#125;</span><br><span class="line">                    .show()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已经有权限，可以进行下一步操作</span></span><br><span class="line">                <span class="comment">// AndroidX库中提供了一个NotificationCompat类，使用这个类的构造器创建</span></span><br><span class="line">                <span class="comment">// Notification对象，就可以保证我们的程序在所有Android系统版本上都能正常工作了</span></span><br><span class="line">                <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">                    <span class="comment">// setContentTitle()方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。</span></span><br><span class="line">                    .setContentTitle(<span class="string">&quot;this is content title&quot;</span>)</span><br><span class="line">                    <span class="comment">// setContentText()方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。</span></span><br><span class="line">                    .setContentText(<span class="string">&quot;this is content text&quot;</span>.repeat(Random.nextInt(<span class="number">5</span>, <span class="number">10</span>)))</span><br><span class="line">                    <span class="comment">// setSmallIcon()方法</span></span><br><span class="line">                    <span class="comment">//用于设置通知的小图标，注意，只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上</span></span><br><span class="line">                    .setSmallIcon(R.drawable.small_icon)</span><br><span class="line">                    <span class="comment">// setLargeIcon()方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。</span></span><br><span class="line">                    .setLargeIcon(</span><br><span class="line">                        BitmapFactory.decodeResource(</span><br><span class="line">                            resources,</span><br><span class="line">                            R.drawable.large_icon</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="comment">// 调用NotificationManager的notify()方法就可以让通知显示出来了。notify()方法接收两个参数：</span></span><br><span class="line">                <span class="comment">// 第一个参数是id，要保证为每个通知指定的id都是不同的；第二个参数则是Notification对象，</span></span><br><span class="line">                <span class="comment">// 这里直接将我们刚刚创建好的Notification对象传入即可。</span></span><br><span class="line">                manager.notify(<span class="number">1</span>, notification)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用过Android手机，此时应该会下意识地认为这条通知是可以点击的。但是当你去点击它的时候，会发现没有任何效果。不对啊，每条通知被点击之后都应该有所反应呀。其实要想实现通知的点击效果，我们还需要在代码中进行相应的设置，这就涉及了一个新的概念——<code>PendingIntent</code>。</p><p><code>PendingIntent</code>从名字上看起来就和Intent有些类似，它们确实存在不少共同点。比如它们都可以指明某一个“意图”，都可以用于启动Activity、启动Service以及发送广播等。不同的是，<code>Intent</code>倾向于立即执行某个动作，而<code>PendingIntent</code>倾向于在某个合适的时机执行某个动作。所以，也可以把<code>PendingIntent</code>简单地理解为**延迟执行的<code>Intent</code>**。</p><p><code>PendingIntent</code>的用法同样很简单，它主要提供了几个静态方法用于获取<code>PendingIntent</code>的实例，可以根据需求来选择是使用<code>getActivity()</code>方法、<code>getBroadcast()</code>方法，还是<code>getService()</code>方法。这几个方法所接收的参数都是相同的：第一个参数依旧是<code>Context</code>，不用多做解释；第二个参数一般用不到，传入0即可；第三个参数是一个<code>Intent</code>对象，我们可以通过这个对象构建出<code>PendingIntent</code>的“意图”；第四个参数用于确定<code>PendingIntent</code>的行为，有<code>FLAG_ONE_SHOT</code>、<code>FLAG_NO_CREATE</code>、<code>FLAG_CANCEL_CURRENT</code>和<code>FLAG_UPDATE_CURRENT</code>这4种标志可选.这些标志是用来控制 <code>PendingIntent</code> 行为的。下面是每个标志的含义：</p><ol><li><code>FLAG_ONE_SHOT</code>：这个标志表示返回的 <code>PendingIntent</code> 只能使用一次。如果后续还需要执行相同的操作，你需要再次获取一个新的 <code>PendingIntent</code>。</li><li><code>FLAG_NO_CREATE</code>：如果当前的 <code>PendingIntent</code> 不存在，那么简单地返回 <code>null</code>，而不是创建一个新的 <code>PendingIntent</code>。</li><li><code>FLAG_CANCEL_CURRENT</code>：这个标志表示当前的 <code>PendingIntent</code> 会被取消，然后创建一个新的 <code>PendingIntent</code>。这意味着旧的 <code>PendingIntent</code> 不再有效，所有的等待的 <code>Intent</code> 都会被取消。</li><li><code>FLAG_UPDATE_CURRENT</code>：如果相同的 <code>PendingIntent</code> 已经存在，那么保持它不变，但是替换它的 <code>Intent</code> 数据。这意味着新的 <code>Intent</code> 数据会被用来更新已经存在的 <code>PendingIntent</code>。</li></ol><p>从 Android 12（API 级别 31）开始，创建 <code>PendingIntent</code> 时必须指定 <code>FLAG_IMMUTABLE</code> 或 <code>FLAG_MUTABLE</code>。这是因为 Android 12 对 <code>PendingIntent</code> 的行为进行了更改，以提高应用的安全性。</p><ul><li><p><code>FLAG_IMMUTABLE</code>：这个标志表示 <code>PendingIntent</code> 是不可变的，也就是说，一旦创建，就不能更改。这是推荐的选项，因为它可以防止潜在的安全问题。</p></li><li><p><code>FLAG_MUTABLE</code>：这个标志表示 <code>PendingIntent</code> 是可变的，也就是说，可以在创建后进行更改。只有在某些功能依赖于 <code>PendingIntent</code> 的可变性时，才应该使用这个选项，例如，需要与内联回复或气泡一起使用。</p></li></ul><p>对<code>PendingIntent</code>有了一定的了解后，我们再回过头来看一下<code>NotificationCompat.Builder</code>。这个构造器还可以连缀一个<code>setContentIntent()</code>方法，接收的参数正是一个<code>PendingIntent</code>对象。因此，这里就可以通过<code>PendingIntent</code>构建一个延迟执行的“意图”，当用户点击这条通知时就会执行相应的逻辑。</p><p>现在我们来优化一下<code>NotificationTest</code>项目，给刚才的通知加上点击功能，让用户点击它的时候可以启动另一个Activity。</p><ul><li><code>FLAG_IMMUTABLE</code>：这个标志表示 <code>PendingIntent</code> 是不可变的，也就是说，一旦创建，就不能更改。这是推荐的选项，因为它可以防止潜在的安全问题。</li><li><code>FLAG_MUTABLE</code>：这个标志表示 <code>PendingIntent</code> 是可变的，也就是说，可以在创建后进行更改。只有在某些功能依赖于 <code>PendingIntent</code> 的可变性时，才应该使用这个选项，例如，需要与内联回复或气泡一起使用。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.notificationtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.NotificationChannel</span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AlertDialog</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationManagerCompat</span><br><span class="line"><span class="keyword">import</span> com.ubx.notificationtest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> kotlin.random.Random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        <span class="comment">// 获取NotificationManager实例</span></span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        <span class="comment">// 判断安卓版本是否为Android 8.0+</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="comment">// 安卓版本为 8.0+ 则使用NotificationChannel类构建一个通知渠道，</span></span><br><span class="line">            <span class="comment">// 并调用NotificationManager的createNotificationChannel()方法完成创建</span></span><br><span class="line">            <span class="keyword">val</span> channel =</span><br><span class="line">                NotificationChannel(<span class="string">&quot;normal&quot;</span>, <span class="string">&quot;Normal&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.sendNotice.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 检查是否已经有了通知权限</span></span><br><span class="line">            <span class="keyword">if</span> (!NotificationManagerCompat.from(<span class="keyword">this</span>).areNotificationsEnabled()) &#123;</span><br><span class="line">                <span class="comment">// 如果没有权限，向用户显示一个对话框，引导他们去设置中开启</span></span><br><span class="line">                AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">                    .setTitle(<span class="string">&quot;需要通知权限&quot;</span>)</span><br><span class="line">                    .setMessage(<span class="string">&quot;此应用需要您允许通知权限才能正常工作。请点击“设置”按钮，然后在设置中开启通知权限。&quot;</span>)</span><br><span class="line">                    .setPositiveButton(<span class="string">&quot;设置&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                        <span class="keyword">val</span> intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                        <span class="keyword">val</span> uri = Uri.fromParts(<span class="string">&quot;package&quot;</span>, packageName, <span class="literal">null</span>)</span><br><span class="line">                        intent.<span class="keyword">data</span> = uri</span><br><span class="line">                        startActivity(intent)</span><br><span class="line">                    &#125;</span><br><span class="line">                    .setNegativeButton(<span class="string">&quot;取消&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                        <span class="comment">/*这个方法需要两个参数（一个 DialogInterface 对象和一个表示哪个按钮被点击的 int 值），</span></span><br><span class="line"><span class="comment">                        但是我们不关心这两个参数的具体值，所以我们用下划线 _ 来代替它们*/</span></span><br><span class="line">                        <span class="comment">// 用户点击取消，结束应用</span></span><br><span class="line">                        finish()</span><br><span class="line">                    &#125;</span><br><span class="line">                    .show()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, NotificationActivity::<span class="keyword">class</span>.java)</span><br><span class="line">                <span class="comment">// 从 Android 12（API 级别 31）开始，创建 PendingIntent 时必须指定 FLAG_IMMUTABLE 或 FLAG_MUTABLE。</span></span><br><span class="line">                <span class="comment">// 这是因为 Android 12 对 PendingIntent 的行为进行了更改，以提高应用的安全性。</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * </span></span><br><span class="line"><span class="comment">                * FLAG_IMMUTABLE：这个标志表示 PendingIntent 是不可变的，也就是说，一旦创建，就不能更改。这是推荐的选项，因为它可以防止潜在的安全问题。</span></span><br><span class="line"><span class="comment">                * FLAG_MUTABLE：这个标志表示 PendingIntent 是可变的，也就是说，可以在创建后进行更改。只有在某些功能依赖于 PendingIntent 的可变性时，才应该使用这个选项，例如，需要与内联回复或气泡一起使用。</span></span><br><span class="line"><span class="comment">                * */</span></span><br><span class="line">                <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)</span><br><span class="line">                <span class="comment">// 已经有权限，可以进行下一步操作</span></span><br><span class="line">                <span class="comment">// AndroidX库中提供了一个NotificationCompat类，使用这个类的构造器创建</span></span><br><span class="line">                <span class="comment">// Notification对象，就可以保证我们的程序在所有Android系统版本上都能正常工作了</span></span><br><span class="line">                <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">                    <span class="comment">// setContentTitle()方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。</span></span><br><span class="line">                    .setContentTitle(<span class="string">&quot;this is content title&quot;</span>)</span><br><span class="line">                    <span class="comment">// setContentText()方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。</span></span><br><span class="line">                    .setContentText(<span class="string">&quot;this is content text&quot;</span>.repeat(Random.nextInt(<span class="number">5</span>, <span class="number">10</span>)))</span><br><span class="line">                    <span class="comment">// setSmallIcon()方法</span></span><br><span class="line">                    <span class="comment">//用于设置通知的小图标，注意，只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上</span></span><br><span class="line">                    .setSmallIcon(R.drawable.small_icon)</span><br><span class="line">                    <span class="comment">// setLargeIcon()方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。</span></span><br><span class="line">                    .setLargeIcon(</span><br><span class="line">                        BitmapFactory.decodeResource(</span><br><span class="line">                            resources,</span><br><span class="line">                            R.drawable.large_icon</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                    .setContentIntent(pi)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="comment">// 调用NotificationManager的notify()方法就可以让通知显示出来了。notify()方法接收两个参数：</span></span><br><span class="line">                <span class="comment">// 第一个参数是id，要保证为每个通知指定的id都是不同的；第二个参数则是Notification对象，</span></span><br><span class="line">                <span class="comment">// 这里直接将我们刚刚创建好的Notification对象传入即可。</span></span><br><span class="line">                manager.notify(<span class="number">1</span>, notification)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们没有在代码中对该通知进行取消，它就会一直显示在系统的状态栏上。解决的方法有两种：一种是在<code>NotificationCompat.Builder</code>中再连缀一个<code>setAutoCancel()</code>方法，一种是显式地调用<code>NotificationManager</code>的<code>cancel()</code>方法将它取消。两种方法我们都学习一下。</p><p>第一种方法写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">...</span><br><span class="line">.setAutoCancel(<span class="literal">true</span>)</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p><code>setAutoCancel()</code>方法传入true，就表示当点击这个通知的时候，通知会自动取消。</p><p>第二种方法写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.notificationtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.NotificationManager</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotificationActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_notification)</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        manager.cancel(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在<code>cancel()</code>方法中传入了1，当时我们给这条通知设置的id就是1。因此，如果你想取消哪条通知，在<code>cancel()</code>方法中传入该通知的id就行了。</p><h3 id="1-3-通知的进阶技巧"><a href="#1-3-通知的进阶技巧" class="headerlink" title="1.3 通知的进阶技巧"></a>1.3 通知的进阶技巧</h3><p>当我们想在通知中显示较长的富文本时会发现，Android会将通知中的长文本折叠起来。那么有没有什么办法把富文本全部显示出来呢？实际上，<code>NotificationCompat.Builder</code>中提供了非常丰富的API，以便我们创建出更加多样的通知效果。先来看看<code>setStyle()</code>方法，这个方法允许我们构建出富文本的通知内容。也就是说，通知中不光可以有文字和图标，还可以包含更多的东西。<code>setStyle()</code>方法接收一个<code>NotificationCompat.Style</code>参数，这个参数就是用来构建具体的富文本信息的，如长文字、图片等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">...</span><br><span class="line">.setStyle(NotificationCompat.BigTextStyle().bigText(<span class="string">&quot;Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android.&quot;</span>))</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>这里使用了<code>setStyle()</code>方法替代<code>setContentText()</code>方法。在<code>setStyle()</code>方法中，我们创建了一个<code>NotificationCompat.BigTextStyle</code>对象，这个对象就是用于封装长文字信息的，只要调用它的<code>bigText()</code>方法并将文字内容传入就可以了。</p><p>除了显示长文字之外，通知里还可以显示一张大图片，具体用法是基本相似的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">...</span><br><span class="line">.setStyle(NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(resources, R.drawable.big_image)))</span><br><span class="line">.build()</span><br></pre></td></tr></table></figure><p>可以看到，这里仍然是调用的<code>setStyle()</code>方法，这次我们在参数中创建了一个<code>NotificationCompat.BigPictureStyle</code>对象，这个对象就是用于设置大图片的，然后调用它的<code>bigPicture()</code>方法并将图片传入。这里使用事先准备好的一张图片，通过<code>BitmapFactory</code>的<code>decodeResource()</code>方法将图片解析成<code>Bitmap</code>对象，再传入<code>bigPicture()</code>方法中就可以了。</p><p>接下来来学习一下不同重要等级的通知渠道对通知的行为具体有什么影响。其实简单来讲，就是通知渠道的重要等级越高，发出的通知就越容易获得用户的注意。比如高重要等级的通知渠道发出的通知可以弹出横幅、发出声音，而低重要等级的通知渠道发出的通知不仅可能会在某些情况下被隐藏，而且可能会被改变显示的顺序，将其排在更重要的通知之后。但需要注意的是，开发者只能在创建通知渠道的时候为它指定初始的重要等级，如果用户不认可这个重要等级的话，可以随时进行修改，开发者对此无权再进行调整和变更，因为通知渠道一旦创建就不能再通过代码修改了。</p><p>虽然无法更改之前创建的通知渠道，但是我们可以创建一个新的通知渠道，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">val</span> channel2 = NotificationChannel(<span class="string">&quot;important&quot;</span>, <span class="string">&quot;Important&quot;</span>, NotificationManager.IMPORTANCE_HIGH)</span><br><span class="line">            manager.createNotificationChannel(channel2)</span><br><span class="line">        &#125;</span><br><span class="line">        sendNotice.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, NotificationActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;important&quot;</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、调用摄像头和相册"><a href="#二、调用摄像头和相册" class="headerlink" title="二、调用摄像头和相册"></a>二、调用摄像头和相册</h2><p>我们平时在使用QQ或微信的时候经常要和别人分享图片，这些图片可以是用手机摄像头拍的，也可以是从相册中选取的。这样的功能实在是太常见了，几乎是应用程序必备的功能，那么本节我们就学习一下调用摄像头和相册方面的知识。</p><h3 id="2-1-调用摄像头拍照"><a href="#2-1-调用摄像头拍照" class="headerlink" title="2.1 调用摄像头拍照"></a>2.1 调用摄像头拍照</h3><p>首先在布局文件中添加两个控件：一个Button和一个ImageView。Button是用于打开摄像头进行拍照的，而ImageView则是用于将拍到的图片显示出来。</p><p>开始编写调用摄像头的具体逻辑，修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.cameraalbumtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapShader</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint</span><br><span class="line"><span class="keyword">import</span> android.graphics.Shader</span><br><span class="line"><span class="keyword">import</span> android.media.ExifInterface</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.ActivityResultLauncher</span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.FileProvider</span><br><span class="line"><span class="keyword">import</span> com.ubx.cameraalbumtest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> imageUri: Uri</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> outputImage: File</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> takePhoto: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        takePhoto = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">            <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">                <span class="comment">// 在这里处理图片捕获成功的情况</span></span><br><span class="line">                <span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri))</span><br><span class="line">                <span class="keyword">if</span> (bitmap != <span class="literal">null</span>)&#123;</span><br><span class="line">                    mainBinding.imageView.setImageBitmap(rotateIfRequired(bitmap))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onCreate: take Photo error&quot;</span>)</span><br><span class="line">                <span class="comment">// 在这里处理图片捕获失败的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.takePhotoBtn.setOnClickListener &#123;</span><br><span class="line">            outputImage = File(externalCacheDir, <span class="string">&quot;output_image.jpg&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (outputImage.exists()) &#123;</span><br><span class="line">                outputImage.delete()</span><br><span class="line">            &#125;</span><br><span class="line">            outputImage.createNewFile()</span><br><span class="line">            imageUri = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">                FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">&quot;work.icu007.cameraalbumtest.fileprovider&quot;</span>, outputImage)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Uri.fromFile(outputImage)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经被弃用</span></span><br><span class="line">            <span class="comment">/*val intent = Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;)</span></span><br><span class="line"><span class="comment">            intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)</span></span><br><span class="line"><span class="comment">            startActivityForResult(intent, takePhoto)*/</span></span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="string">&quot;android.media.action.IMAGE_CAPTURE&quot;</span>)</span><br><span class="line">            intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)</span><br><span class="line">            takePhoto.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">rotateIfRequired</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">val</span> exif = ExifInterface(outputImage.path)</span><br><span class="line">        <span class="keyword">val</span> orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,</span><br><span class="line">            ExifInterface.ORIENTATION_NORMAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (orientation) &#123;</span><br><span class="line">            ExifInterface.ORIENTATION_ROTATE_90 -&gt; rotateBitmap(bitmap, <span class="number">90</span>)</span><br><span class="line">            ExifInterface.ORIENTATION_ROTATE_180 -&gt; rotateBitmap(bitmap, <span class="number">180</span>)</span><br><span class="line">            ExifInterface.ORIENTATION_ROTATE_270 -&gt; rotateBitmap(bitmap, <span class="number">270</span>)</span><br><span class="line">            <span class="keyword">else</span> -&gt; bitmap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">rotateBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>, degree: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">        matrix.postRotate(degree.toFloat())</span><br><span class="line">        <span class="keyword">val</span> rotatedBitmap = Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height,</span><br><span class="line">            matrix, <span class="literal">true</span>)</span><br><span class="line">        bitmap.recycle() <span class="comment">// 将不再需要的Bitmap对象回收</span></span><br><span class="line">        <span class="keyword">return</span> rotatedBitmap</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>MainActivity</code>中要做的第一件事自然是给Button注册点击事件，然后就是实例化 <code>takePhoto</code> 对象，并且注册返回结果的处理函数。紧接着在点击事件里开始处理调用摄像头的逻辑:</p><p>首先这里创建了一个<code>File</code>对象，用于存放摄像头拍下的图片，这里我们把图片命名为<code>output_image.jpg</code>，并存放在手机SD卡的应用关联缓存目录下。什么叫作应用关联缓存目录呢？就是指SD卡中专门用于存放当前应用缓存数据的位置，调用<code>getExternalCacheDir()</code>方法可以得到这个目录，具体的路径是<code>/sdcard/Android/data/&lt;package name&gt;/cache</code>。那么为什么要使用应用关联缓存目录来存放图片呢？因为从<code>Android 6.0</code>系统开始，读写SD卡被列为了危险权限，如果将图片存放在SD卡的任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步。另外，从Android 10.0系统开始，公有的SD卡目录已经不再允许被应用程序直接访问了，而是要使用作用域存储才行。</p><p>接着会进行一个判断，如果运行设备的系统版本低于Android 7.0，就调用Uri的<code>fromFile()</code>方法将File对象转换成Uri对象，这个Uri对象标识着<code>output_image.jpg</code>这张图片的本地真实路径。否则，就调用<code>FileProvider</code>的<code>getUriForFile()</code>方法将File对象转换成一个封装过的Uri对象。<code>getUriForFile()</code>方法接收3个参数：第一个参数要求传入Context对象，第二个参数可以是任意唯一的字符串，第三个参数则是我们刚刚创建的File对象。之所以要进行这样一层转换，是因为从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出一个<code>FileUriExposedException</code>异常。而<code>FileProvider</code>则是一种特殊的<code>ContentProvider</code>，它使用了和<code>ContentProvider</code>类似的机制来对数据进行保护，可以选择性地将封装过的Uri共享给外部，从而提高了应用的安全性。</p><p>接下来构建了一个<code>Intent</code>对象，并将这个<code>Intent</code>的<code>action</code>指定为<code>android.media.action.IMAGE_CAPTURE</code>，再调用<code>Intent</code>的<code>putExtra()</code>方法指定图片的输出地址，这里填入刚刚得到的Uri对象，最后调用<code>ActivityResultLauncher</code>对象的<code>launch()</code>方法来启动相机应用进行捕获图片。</p><p>调用照相机程序去拍照有可能会在一些手机上发生照片旋转的情况。这是因为这些手机认为打开摄像头进行拍摄时手机就应该是横屏的，因此回到竖屏的情况下就会发生90度的旋转。为此，这里我们又加上了判断图片方向的代码，如果发现图片需要进行旋转，那么就先将图片旋转相应的角度，然后再显示到界面上。</p><p>刚才提到了<code>ContentProvider</code>，那么我们自然要在<code>AndroidManifest.xml</code>中对它进行注册才行，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.CameraAlbumTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">&quot;work.icu007.cameraalbumtest.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:name</code>属性的值是固定的，而<code>android:authorities</code>属性的值必须和刚才<code>FileProvider.getUriForFile()</code>方法中的第二个参数一致。另外，这里还在<code>&lt;provider&gt;</code>标签的内部使用<code>&lt;meta-data&gt;</code>指定Uri的共享路径，并引用了一个<code>@xml/file_paths</code>资源。当然，这个资源现在还是不存在的，下面我们就来创建它。</p><p>右击res目录→New→Directory，创建一个xml目录，接着右击xml目录→New→File，创建一个<code>file_paths.xml</code>文件。然后修改<code>file_paths.xml</code>文件中的内容，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;my_images&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>external-path</code>就是用来指定Uri共享路径的，<code>name</code>属性的值可以随便填，<code>path</code>属性的值表示共享的具体路径。这里使用一个单斜线表示将<strong>整个SD卡进行共享</strong>，当然你也可以仅共享存放output_image.jpg这张图片的路径。</p><h3 id="2-2-从相册选择图片"><a href="#2-2-从相册选择图片" class="headerlink" title="2.2 从相册选择图片"></a>2.2 从相册选择图片</h3><p>还是在 2.1 项目基础上修改，新增一个<code>button</code>用于从相册中选择图片。</p><p>修改<code>mainActivity</code>代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.cameraalbumtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapShader</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint</span><br><span class="line"><span class="keyword">import</span> android.graphics.Shader</span><br><span class="line"><span class="keyword">import</span> android.media.ExifInterface</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.ActivityResultLauncher</span><br><span class="line"><span class="keyword">import</span> androidx.activity.result.contract.ActivityResultContracts</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.FileProvider</span><br><span class="line"><span class="keyword">import</span> com.ubx.cameraalbumtest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> imageUri: Uri</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> outputImage: File</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> takePhoto: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> fromAlbum: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        fromAlbum = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123;result -&gt;</span><br><span class="line">            <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK &amp;&amp; result.<span class="keyword">data</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">                result.<span class="keyword">data</span>!!.<span class="keyword">data</span>?.let &#123; uri -&gt;</span><br><span class="line">                    <span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(uri))</span><br><span class="line">                    mainBinding.imageView.setImageBitmap(bitmap)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        mainBinding.fromAlbumBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)</span><br><span class="line">            intent.addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">            intent.type = <span class="string">&quot;image/*&quot;</span></span><br><span class="line">            fromAlbum.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“<code>From Album</code>”按钮的点击事件里，我们先构建了一个<code>Intent</code>对象，并将它的<code>action</code>指定为<code>Intent.ACTION_OPEN_DOCUMENT</code>，表示打开系统的文件选择器。接着给这个<code>Intent</code>对象设置一些条件过滤，只允许可打开的图片文件显示出来，然后调用<code>fromAlbum.launch(intent)</code>，打开文件选择器。</p><ol><li><code>registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123;result -&gt;...&#125;</code>：在这段代码中，使用registerForActivityResult方法注册了一个回调函数。这个方法接收两个参数，一个是要启动的Activity的类型描述，另一个是回调函数。此处的ActivityResultContracts.StartActivityForResult()表示启动的Activity是为了返回数据。在回调函数中，参数<code>result</code>即代表启动Activity的结果。</li><li>在回调函数中，首先检查了<code>result.resultCode == Activity.RESULT_OK &amp;&amp; result.data != null</code>，这也是常见的模式，意味着返回的结果有效且有返回数据。在此条件满足的情况下，<code>result.data!!.data?.let &#123; uri -&gt;...&#125;</code> 这段代码解释了对返回的数据<code>result.data.data</code>即图片的URI的处理。使用<code>let</code>是Kotlin语言中的函数式编程风格，当<code>result.data!!.data</code>不为空时，执行其代码块，此处的uri即代表图片的URI。</li><li><code>val bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(uri))</code>这段代码使用BitmapFactory解码stream得到一个bitmap，而stream是使用contentResolver从图片的uri中获取到的。</li><li><code>mainBinding.imageView.setImageBitmap(bitmap)</code>将解码得到的bitmap设为imageView的图像显示。</li></ol><h2 id="三、播放多媒体文件"><a href="#三、播放多媒体文件" class="headerlink" title="三、播放多媒体文件"></a>三、播放多媒体文件</h2><p>手机上最常见的休闲方式毫无疑问就是听音乐和看电影了，随着移动设备的普及，越来越多的人可以随时享受优美的音乐，观看精彩的电影。Android在播放音频和视频方面做了相当不错的支持，它提供了一套较为完整的API，使得开发者可以很轻松地编写出一个简易的音频或视频播放器，下面我们就来具体地学习一下。</p><h3 id="3-1-播放音频"><a href="#3-1-播放音频" class="headerlink" title="3.1 播放音频"></a>3.1 播放音频</h3><p>在Android中播放音频文件一般是使用<code>MediaPlayer</code>类实现的，它对多种格式的音频文件提供了非常全面的控制方法，从而使播放音乐的工作变得十分简单。下表列出了<code>MediaPlayer</code>类中一些较为常用的控制方法。</p><table><thead><tr><th align="center">方法名</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">setDataSource()</td><td align="center">设置要播放的音频文件的位置</td></tr><tr><td align="center">prepare()</td><td align="center">在开始播放之前调用，以完成准备工作</td></tr><tr><td align="center">start()</td><td align="center">开始或继续播放音频</td></tr><tr><td align="center">pause()</td><td align="center">暂停播放音频</td></tr><tr><td align="center">reset()</td><td align="center">将MediaPlayer对象重置到刚刚创建的状态</td></tr><tr><td align="center">seekTo()</td><td align="center">从指定的位置开始播放音频</td></tr><tr><td align="center">stop()</td><td align="center">停止播放音频。调用后的MediaPlayer对象无法再播放音频</td></tr><tr><td align="center">release()</td><td align="center">释放与MediaPlayer对象相关的资源</td></tr><tr><td align="center">isPlaying()</td><td align="center">判断当前MediaPlayer是否正在播放音频</td></tr><tr><td align="center">getDuration()</td><td align="center">获取载入的音频文件的时长</td></tr></tbody></table><p>简单了解了上述方法后，我们再来梳理一下<code>MediaPlayer</code>的工作流程。首先需要创建一个<code>MediaPlayer</code>对象，然后调用<code>setDataSource()</code>方法设置音频文件的路径，再调用<code>prepare()</code>方法使<code>MediaPlayer</code>进入准备状态，接下来调用<code>start()</code>方法就可以开始播放音频，调用<code>pause()</code>方法就会暂停播放，调用<code>reset()</code>方法就会停止播放。下面就让我们通过一个具体的例子来学习一下，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.playaudiotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.media.MediaPlayer</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> work.icu007.playaudiotest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mediaPlayer = MediaPlayer()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        initMediaPlayer()</span><br><span class="line">        mainBinding.play.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mediaPlayer.isPlaying) &#123;</span><br><span class="line">                mediaPlayer.start()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.pause.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mediaPlayer.isPlaying) &#123;</span><br><span class="line">                mediaPlayer.pause()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.stop.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mediaPlayer.isPlaying) &#123;</span><br><span class="line">                mediaPlayer.reset()</span><br><span class="line">                initMediaPlayer()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initMediaPlayer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> assetManager = assets</span><br><span class="line">        <span class="keyword">val</span> fd = assetManager.openFd(<span class="string">&quot;人生浪费指南 - 夏日入侵企画.mp3&quot;</span>)</span><br><span class="line">        mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length)</span><br><span class="line">        mediaPlayer.prepare()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        mediaPlayer.stop()</span><br><span class="line">        mediaPlayer.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类初始化的时候，我们就先创建了一个<code>MediaPlayer</code>的实例，然后在<code>onCreate()</code>方法中调用<code>initMediaPlayer()</code>方法，为<code>MediaPlayer</code>对象进行初始化操作。在<code>initMediaPlayer()</code>方法中，首先通过<code>getAssets()</code>方法得到了一个<code>AssetManager</code>的实例，<code>AssetManager</code>可用于读取assets目录下的任何资源。接着我们调用了<code>openFd()</code>方法将音频文件句柄打开，后面又依次调用了<code>setDataSource()</code>方法和<code>prepare()</code>方法，为<code>MediaPlayer</code>做好了播放前的准备。</p><p>当点击“Play”按钮时会进行判断，如果当前<code>MediaPlayer</code>没有正在播放音频，则调用<code>start()</code>方法开始播放。当点击“Pause”按钮时会判断，如果当前<code>MediaPlayer</code>正在播放音频，则调用<code>pause()</code>方法暂停播放。当点击“Stop”按钮时会判断，如果当前<code>MediaPlayer</code>正在播放音频，则调用<code>reset()</code>方法将<code>MediaPlayer</code>重置为刚刚创建的状态，然后重新调用一遍<code>initMediaPlayer()</code>方法。最后在<code>onDestroy()</code>方法中，我们还需要分别调用<code>stop()</code>方法和<code>release()</code>方法，将与<br><code>MediaPlayer</code>相关的资源释放掉。</p><h3 id="3-2-播放视频"><a href="#3-2-播放视频" class="headerlink" title="3.2 播放视频"></a>3.2 播放视频</h3><p>播放视频文件其实并不比播放音频文件复杂，主要是使用<code>VideoView</code>类来实现的。这个类将视频的显示和控制集于一身，我们仅仅借助它就可以完成一个简易的视频播放器。<code>VideoView</code>的用法和<code>MediaPlayer</code>也比较类似，常用方法如下表所示。</p><table><thead><tr><th align="center">方法名</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">setVideoPath()</td><td align="center">设置要播放的视频文件的位置</td></tr><tr><td align="center">start()</td><td align="center">开始或继续播放视频</td></tr><tr><td align="center">pause()</td><td align="center">暂停播放视频</td></tr><tr><td align="center">resume()</td><td align="center">将视频从头开始播放</td></tr><tr><td align="center">seekTo()</td><td align="center">从指定的位置开始播放视频</td></tr><tr><td align="center">isPlaying()</td><td align="center">判断当前是否正在播放视频</td></tr><tr><td align="center">getDuration()</td><td align="center">获取载入的视频文件的时长</td></tr><tr><td align="center">suspend()</td><td align="center">释放ViedoView所占用的资源</td></tr></tbody></table><p>编辑布局文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/play&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Play&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@id/pause&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/videoView&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/pause&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Pause&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/play&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@id/reply&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/videoView&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/reply&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Reply&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/pause&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/videoView&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">VideoView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/videoView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/pause&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而后修改MainActivity中的代码，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.playvideotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.MediaController</span><br><span class="line"><span class="keyword">import</span> work.icu007.playvideotest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        <span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;android.resource://<span class="variable">$packageName</span>/<span class="subst">$&#123;R.raw.video&#125;</span>&quot;</span>)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate: uri: <span class="variable">$uri</span>&quot;</span>)</span><br><span class="line">        mainBinding.videoView.setVideoURI(uri)</span><br><span class="line">        <span class="keyword">val</span> mediaController = MediaController(<span class="keyword">this</span>)</span><br><span class="line">        mainBinding.videoView.setMediaController(mediaController)</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        mainBinding.play.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mainBinding.videoView.isPlaying)&#123;</span><br><span class="line">                mainBinding.videoView.start()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.pause.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mainBinding.videoView.isPlaying)&#123;</span><br><span class="line">                mainBinding.videoView.pause()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mainBinding.reply.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mainBinding.videoView.isPlaying)&#123;</span><br><span class="line">                mainBinding.videoView.resume()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        mainBinding.videoView.<span class="keyword">suspend</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> TAG = <span class="keyword">this</span>.javaClass.simpleName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在<code>onCreate()</code>方法中调用了<code>Uri.parse()</code>方法，将raw目录下的video.mp4文件解析成了一个Uri对象，这里使用的写法是Android要求的固定写法。然后调用<code>VideoView</code>的<code>setVideoURI()</code>方法将刚才解析出来的Uri对象传入，这样<code>VideoView</code>就初始化完成了。</p><p>当点击“Play”按钮时会判断，如果当前没有正在播放视频，则调用<code>start()</code>方法开始播放。当点击“Pause”按钮时会判断，如果当前视频正在播放，则调用<code>pause()</code>方法暂停播放。当点击“Replay”按钮时会判断，如果当前视频正在播放，则调用<code>resume()</code>方法从头播放视频。最后在<code>onDestroy()</code>方法中，我们还需要调用一下<code>suspend()</code>方法，将VideoView所占用的资源释放掉。还添加了一个<code>MediaController</code>。<code>MediaController</code>可以提供一套控制面板，用户可以用它来播放、暂停和快进视频。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、使用通知&quot;&gt;&lt;a href=&quot;#一、使用通知&quot; class=&quot;headerlink&quot; title=&quot;一、使用通知&quot;&gt;&lt;/a&gt;一、使用通知&lt;/h2&gt;&lt;p&gt;通知（notification）是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-ContentProvider</title>
    <link href="https://icu007work.github.io/archives/149564e1.html"/>
    <id>https://icu007work.github.io/archives/149564e1.html</id>
    <published>2023-12-09T07:15:08.000Z</published>
    <updated>2024-05-11T07:48:38.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ContentProvider简介"><a href="#一、ContentProvider简介" class="headerlink" title="一、ContentProvider简介"></a>一、ContentProvider简介</h2><p><code>ContentProvider</code>主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。目前，使用<code>ContentProvider</code>是<code>Android</code>实现跨程序共享数据的标准方式。</p><p>不同于文件存储和<code>SharedPreferences</code>存储中的两种全局可读写操作模式，<code>ContentProvider</code>可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险。</p><p>在正式开始学习<code>ContentProvider</code>之前，我们需要先掌握另外一个非常重要的知识——<strong>Android运行时权限</strong>，以后我们的开发过程中会经常使用运行时权限，因此必须能够牢牢掌握它才行。</p><hr><h2 id="二、运行时权限"><a href="#二、运行时权限" class="headerlink" title="二、运行时权限"></a>二、运行时权限</h2><p>Android开发团队在Android 6.0系统中引入了运行时权限这个功能，从而更好地保护了用户的安全和隐私。</p><h3 id="2-1-Android权限机制详解"><a href="#2-1-Android权限机制详解" class="headerlink" title="2.1 Android权限机制详解"></a>2.1 Android权限机制详解</h3><p>当我们需要监听开机广播时，我们需要在AndroidManifest.xml文件中添加这样一句权限声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">package</span>=<span class="string">&quot;com.example.broadcasttest&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上这句权限声明之后，如果用户在低于Android 6.0系统的设备上安装该程序，会在安装界面给出提醒。这样用户就可以清楚地知晓该程序一共申请了哪些权限，从而决定是否要安装这个程序。另外，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况。这样该程序申请的所有权限就尽收眼底，什么都瞒不过用户的眼睛，以此保证应用程序不会出现各种滥用权限的情况。</p><p>这种权限机制的设计思路其实非常简单，就是用户如果认可你所申请的权限，就会安装你的程序，如果不认可你所申请的权限，那么拒绝安装就可以了。</p><p>Android开发团队在Android 6.0系统中加入了运行时权限功能。也就是说，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。比如一款相机应用在运行时申请了地理位置定位权限，就算我拒绝了这个权限，也应该可以使用这个应用的其他功能，而不是像之前那样直接无法安装它。</p><p>当然，并不是所有权限都需要在运行时申请，对于用户来说，不停地授权也很烦琐。Android现在将常用的权限大致归成了两类，一类是普通权限，一类是危险权限。<strong>普通权限</strong>指的是那些<strong>不会直接威胁到用户的安全和隐私的权限</strong>，对于这部分权限申请，系统会自动帮我们进行授权，不需要用户手动操作。<strong>危险权限</strong>则表示那些<strong>可能会触及用户隐私或者对设备安全性造成影响的权限</strong>，如<strong>获取设备联系人信息、定位设备的地理位置</strong>等，对于这部分权限申请，必须由用户手动授权才可以，否则程序就无法使用相应的功能。</p><p>但是Android中一共有上百种权限，我们怎么从中区分哪些是普通权限，哪些是危险权限呢？其实并没有那么难，因为危险权限总共就那么些，除了危险权限之外，剩下的大多就是普通权限了。</p><p>下表列出了 Android 10 系统为止的危险权限。</p><table><thead><tr><th align="center">权限组名</th><th align="center">权限名</th></tr></thead><tbody><tr><td align="center">CALENDAR</td><td align="center">READ_CALENDAR<br />WRITE_CALENDAR</td></tr><tr><td align="center">CALL_LOG</td><td align="center">READ_CALL_LOG<br />WRITE_CALL_LOG<br />PROCESS_OUTGOING_CALLS</td></tr><tr><td align="center">CAMERA</td><td align="center">CAMERA</td></tr><tr><td align="center">CONTACTS</td><td align="center">READ_CONTACTS<br />WRITE_CONTACTS<br />GET_ACCOUNTS</td></tr><tr><td align="center">LOCATION</td><td align="center">ACCESS_FINE_LOCATION<br />ACCESS_COARSE_LOCATION<br />ACCESS_BACKGROUND_LOCATION</td></tr><tr><td align="center">MICROPHONE</td><td align="center">RECORD_AUDIO</td></tr><tr><td align="center">PHONE</td><td align="center">READ_PHONE_STATE<br />READ_PHONE_NUMBE RS<br />CALL_PHONE<br />ANSWER_PHONE_CALLS<br />ADD_VOICEMAIL<br />USE_SIP<br />ACCEPT_HANDOVER</td></tr><tr><td align="center">SENSORS</td><td align="center">BODY_SENSORS</td></tr><tr><td align="center">ACTIVITY_RECOGNITION</td><td align="center">ACTIVITY_RECOGNITION</td></tr><tr><td align="center">SMS</td><td align="center">SEND_SMS<br />RECEIVE_SMS<br />READ_SMS<br />RECEIVE_WAP_PUSH<br />RECEIVE_MMS</td></tr><tr><td align="center">STORAGE</td><td align="center">READ_EXTERNAL_STORAGE<br />WRITE_EXTERNAL_STORAG<br />EACCESS_MEDIA_LOCATION</td></tr></tbody></table><p>每当要使用一个权限时，可以先到这张表中查一下，如果是这张表中的权限，就需要进行运行时权限处理，否则，只需要在<code>AndroidManifest.xml</code>文件中添加一下权限声明就可以了。</p><p>另外注意，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名。原则上，用户一旦同意了某个权限申请之后，同组的其他权限也会被系统自动授权。但是请谨记，不要基于此规则来实现任何功能逻辑，因为Android系统随时有可能调整权限的分组。</p><h3 id="2-2-在程序运行时申请权限"><a href="#2-2-在程序运行时申请权限" class="headerlink" title="2.2 在程序运行时申请权限"></a>2.2 在程序运行时申请权限</h3><p>示例使用CALL_PHONE权限编写拨打电话功能的程序，<code>Intent.ACTION_CALL</code>则表示直接拨打电话，因此必须声明权限。</p><p>修改<code>AndroidManifest.xml</code> 声明如下权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.telephony&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CALL_PHONE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.RuntimePermissionTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来实现逻辑部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.runtimepermissiontest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.ContextCompat</span><br><span class="line"><span class="keyword">import</span> com.ubx.runtimepermissiontest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        mainBinding.makeCall.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, android.Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                ActivityCompat.requestPermissions(<span class="keyword">this</span>, arrayOf(android.Manifest.permission.CALL_PHONE), <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                call()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    call()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;u denied the permission&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(Intent.ACTION_CALL)</span><br><span class="line">            intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;tel:10086&quot;</span>)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: SecurityException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步就是要先判断用户是不是已经给过我们授权了，借助的是<code>ContextCompat.checkSelfPermission()</code>方法。<code>checkSelfPermission(</code>)方法接收两个参数：第一个参数是Context，这个没什么好说的；第二个参数是具体的权限名，比如打电话的权限名就是<code>android.Manifest.permission.CALL_PHONE</code>。然后我们使用方法的返回值和<code>PackageManager.PERMISSION_GRANTED</code>做比较，相等就说明用户已经授权，不等就表示用户没有授权。</p><p>如果已经授权的话就简单了，直接执行拨打电话的逻辑操作就可以了，这里我们把拨打电话的逻辑封装到了<code>call()</code>方法当中。如果没有授权的话，则需要调用<code>ActivityCompat.requestPermissions()</code>方法向用户申请授权。<code>requestPermissions()</code>方法接收3个参数：第一个参数要求是Activity的实例；第二个参数是一个String数组，我们把要申请的权限名放在数组中即可；第三个参数是请求码，只要是唯一值就可以了，这里传入了1。</p><p>调用完<code>requestPermissions()</code>方法之后，系统会弹出一个权限申请的对话框，用户可以选择同意或拒绝我们的权限申请。不论是哪种结果，最终都会回调到<code>onRequestPermissionsResult()</code>方法中，而授权的结果则会封装在<code>grantResults</code>参数当中。这里我们只需要判断一下最后的授权结果：如果用户同意的话，就调用<code>call()</code>方法拨打电话；如果用户拒绝的话，我们只能放弃操作，并且弹出一条失败提示。</p><hr><h2 id="三、访问其他程序中的数据"><a href="#三、访问其他程序中的数据" class="headerlink" title="三、访问其他程序中的数据"></a>三、访问其他程序中的数据</h2><p><code>ContentProvider</code>的用法一般有两种：一种是使用现有的<code>ContentProvider</code>读取和操作相应程序中的数据；另一种是创建自己的<code>ContentProvider</code>，给程序的数据提供外部访问接口。</p><p>如果一个应用程序通过<code>ContentProvider</code>对其数据提供了外部访问接口，那么任何其他的应用程序都可以对这部分数据进行访问。Android系统中自带的通讯录、短信、媒体库等程序都提供了类似的访问接口，这就使得第三方应用程序可以充分地利用这部分数据实现更好的功能。</p><h3 id="3-1-ContentProvider的基本用法"><a href="#3-1-ContentProvider的基本用法" class="headerlink" title="3.1 ContentProvider的基本用法"></a>3.1 ContentProvider的基本用法</h3><p>对于每一个应用程序来说，如果想要访问<code>ContentProvider</code>中共享的数据，就一定要借助<code>ContentResolver</code>类，可以通过Context中的<code>getContentResolver()</code>方法获取该类的实例。<code>ContentResolver</code>中提供了一系列的方法用于对数据进行增删改查操作，其中<code>insert()</code>方法用于添加数据，<code>update()</code>方法用于更新数据，<code>delete()</code>方法用于删除数据，<code>query()</code>方法用于查询数据。有没有似曾相识的感觉？没错，<code>SQLiteDatabase</code>中也是使用这几个方法进行增删改查操作的，只不过它们在方法参数上稍微有一些区别。</p><p>不同于<code>SQLiteDatabase</code>，<code>ContentResolver</code>中的增删改查方法都是不接收表名参数的，而是使用一个Uri参数代替，这个参数被称为内容URI。内容URI给<code>ContentProvider</code>中的数据建立了唯一标识符，它主要由两部分组成：authority和path。authority是用于对不同的应用程序做区分的，一般为了避免冲突，会采用应用包名的方式进行命名。比如某个应用的包名是<code>com.example.app</code>，那么该应用对应的authority就可以命名为<code>com.example.app.provider</code>。path则是用于对同一应用程序中不同的表做区分的，通常会添加到authority的后面。比如某个应用的数据库里存在两张表table1和table2，这时就可以将path分别命名为&#x2F;table1和&#x2F;table2，然后把authority和path进行组合，内容URI就变成了<code>com.example.app.provider/table1</code>和<code>com.example.app.provider/table2</code>。不过，目前还很难辨认出这两个字符串就是两个内容URI，我们还需要在字符串的头部加上协议声明。因此，内容URI最标准的格式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table1</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table2</span></span><br></pre></td></tr></table></figure><p>内容URI可以非常清楚地表达我们想要访问哪个程序中哪张表里的数据。也正是因此，<code>ContentResolver</code>中的增删改查方法才都接收Uri对象作为参数。如果使用表名的话，系统将无法得知我们期望访问的是哪个应用程序里的表。</p><p>在得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。解析的方法也相当简单，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;content://com.example.app.provider/table1&quot;</span>)</span><br></pre></td></tr></table></figure><p>只需要调用<code>Uri.parse()</code>方法，就可以将内容URI字符串解析成Uri对象了。</p><p>现在就可以使用这个Uri对象查询table1表中的数据了，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cursor = contentResolver.query(</span><br><span class="line">    uri,</span><br><span class="line">    projection,</span><br><span class="line">    selection,</span><br><span class="line">    selectionArgs,</span><br><span class="line">    sortOrder</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这些参数和<code>SQLiteDatabase</code>中<code>query()</code>方法里的参数很像，但总体来说要简单一些，毕竟这是在访问其他程序中的数据，没必要构建过于复杂的查询语句。下表对使用到的这部分参数进行了详细的解释。</p><table><thead><tr><th align="center">query()方法参数</th><th align="center">对应SQL部分</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uri</td><td align="center">from table_name</td><td align="center">指定查询某个应用程序下的某一张表</td></tr><tr><td align="center">projection</td><td align="center">select column1, column2</td><td align="center">指定查询的列名</td></tr><tr><td align="center">selection</td><td align="center">where column &#x3D; value</td><td align="center">指定where的约束条件</td></tr><tr><td align="center">selectionArgs</td><td align="center">-</td><td align="center">为where中的占位符提供具体的值</td></tr><tr><td align="center">sortOrder</td><td align="center">order by column1, column2</td><td align="center">指定查询结果的排序方式</td></tr></tbody></table><p>查询完成后返回的仍然是一个Cursor对象，这时我们就可以将数据从Cursor对象中逐个读取出来了。读取的思路仍然是通过移动游标的位置遍历Cursor的所有行，然后取出每一行中相应列的数据，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">    <span class="keyword">val</span> column1 = cursor.getString(cursor.getColumnIndex(<span class="string">&quot;column1&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> column2 = cursor.getString(cursor.getColumnIndex(<span class="string">&quot;column2&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure><p>table1表中添加一条数据，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = contentValueOf(<span class="string">&quot;column1&quot;</span> to <span class="string">&quot;text&quot;</span>, <span class="string">&quot;column2&quot;</span> to <span class="number">1</span>)</span><br><span class="line">contentResolver.insert(uri, values)</span><br></pre></td></tr></table></figure><p>仍然是将待添加的数据组装到<code>ContentValues</code>中，然后调用<code>ContentResolver</code>的<code>insert()</code>方法，将<code>Uri</code>和<code>ContentValues</code>作为参数传入即可。</p><p>如果我们想要更新这条新添加的数据，把<code>column1</code>的值清空，可以借助<code>ContentResolver</code>的<code>update()</code>方法实现，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = contentValueOf(<span class="string">&quot;column1&quot;</span> to <span class="string">&quot;&quot;</span>)</span><br><span class="line">contentResolver.update(uri, values, <span class="string">&quot;column1 = ? and column2 = ?&quot;</span>, arrayOf(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure><p>上述代码使用了<code>selection</code>和<code>selectionArgs</code>参数来对想要更新的数据进行约束，以防止所有的行都会受影响。</p><p>最后，可以调用<code>ContentResolver</code>的<code>delete()</code>方法将这条数据删除掉，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contentResolver.delete(uri, <span class="string">&quot;column2 = ?&quot;</span>, arrayOf(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="3-2-读取系统联系人"><a href="#3-2-读取系统联系人" class="headerlink" title="3.2 读取系统联系人"></a>3.2 读取系统联系人</h3><p>权限声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.contectstest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.SuppressLint</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.ContactsContract</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.ContextCompat</span><br><span class="line"><span class="keyword">import</span> com.ubx.contectstest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> contactsList = ArrayList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter: ArrayAdapter&lt;String&gt;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line">        adapter = ArrayAdapter(<span class="keyword">this</span>, android.R.layout.simple_list_item_1, contactsList)</span><br><span class="line">        mainBinding.contactsView.adapter = adapter</span><br><span class="line">        <span class="comment">// 检查是否获得读取联系人权限</span></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, android.Manifest.permission.READ_CONTACTS)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                arrayOf(android.Manifest.permission.READ_CONTACTS), <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            readContacts()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults.isNotEmpty()</span><br><span class="line">                    &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    readContacts()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;u denied the permission&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;Range&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readContacts</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 查询联系人数据</span></span><br><span class="line">        contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,</span><br><span class="line">            <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)?.apply &#123;</span><br><span class="line">                <span class="keyword">while</span> (moveToNext()) &#123;</span><br><span class="line">                    <span class="comment">// 获取联系人姓名</span></span><br><span class="line">                    <span class="keyword">val</span> displayName = getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))</span><br><span class="line">                    <span class="comment">// 获取联系人手机号</span></span><br><span class="line">                    <span class="keyword">val</span> number = getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))</span><br><span class="line">                    <span class="comment">// 将获取到的联系人添加到contactList中</span></span><br><span class="line">                    contactsList.add(<span class="string">&quot;<span class="variable">$displayName</span>\n<span class="variable">$number</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            adapter.notifyDataSetChanged()</span><br><span class="line">            close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onCreate()</code>方法中，我们首先按照<code>ListView</code>的标准用法对其初始化，然后开始调用运行时权限的处理逻辑，因为<code>READ_CONTACTS</code>权限属于危险权限。这里我们在用户授权之后，调用<code>readContacts()</code>方法读取系统联系人信息。<br>下面重点看一下<code>readContacts()</code>方法，可以看到，这里使用了<code>ContentResolver</code>的<code>query()</code>方法查询系统的联系人数据。不过传入的Uri参数怎么有些奇怪啊？为什么没有调用<code>Uri.parse()</code>方法去解析一个内容URI字符串呢？这是因为<code>ContactsContract.CommonDataKinds.Phone</code>类已经帮我们做好了封装，提供了一个<code>CONTENT_URI</code>常量，而这个常量就是使用<code>Uri.parse()</code>方法解析出来的结果。接着我们对<code>query()</code>方法返回的<code>Cursor</code>对象进行遍历，这里使用了?.操作符和apply函数来简化遍历的代码。在apply函数中将联系人姓名和手机号逐个取出，<strong>联系人姓名</strong>这一列对应的常量是**<code>ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME</code><strong>，</strong>联系人手机号<strong>这一列对应的常量是</strong><code>ContactsContract.CommonDataKinds.Phone.NUMBER</code>**。将两个数据取出后进行拼接，并且在中间加上换行符，然后将拼接后的数据添加到<code>ListView</code>的数据源里，并通知刷新一下<code>ListView</code>，最后千万不要忘记将<code>Cursor</code>对象关闭。</p><hr><h2 id="四、创建自己的ContentProvider"><a href="#四、创建自己的ContentProvider" class="headerlink" title="四、创建自己的ContentProvider"></a>四、创建自己的ContentProvider</h2><h3 id="4-1-创建ContentProvider的步骤"><a href="#4-1-创建ContentProvider的步骤" class="headerlink" title="4.1 创建ContentProvider的步骤"></a>4.1 创建ContentProvider的步骤</h3><p>如果想要实现跨程序共享数据的功能，可以通过新建一个类去继承<code>ContentProvider</code>的方式来实现。<code>ContentProvider</code>类中有6个抽象方法，我们在使用子类继承它的时候，需要将这6个方法全部重写。观察下面的代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProvider</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(uri: <span class="type">Uri</span>, projection: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, sortOrder: <span class="type">String</span>?)</span></span>: Cursor? &#123;</span><br><span class="line">        retutn <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?)</span></span>: Uri? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(uri: <span class="type">Uri</span>, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>onCreate()</code>。初始化<code>ContentProvider</code>的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示<code>ContentProvider</code>初始化成功，返回false则表示失败。</li><li><code>query()</code>。从<code>ContentProvider</code>中查询数据。<code>uri</code>参数用于确定查询哪张表，<code>projection</code>参数用于确定查询哪些列，<code>selection</code>和<code>selectionArgs</code>参数用于约束查询哪些行，<code>sortOrder</code>参数用于对结果进行排序，查询的结果存放在<code>Cursor</code>对象中返回。</li><li><code>insert()</code>。向<code>ContentProvider</code>中添加一条数据。<code>uri</code>参数用于确定要添加到的表，待添加的数据保存在<code>values</code>参数中。添加完成后，返回一个用于表示这条新记录的URI。</li><li><code>update()</code>。更新<code>ContentProvider</code>中已有的数据。<code>uri</code>参数用于确定更新哪一张表中的数据，新数据保存在<code>values</code>参数中，<code>selection</code>和<code>selectionArgs</code>参数用于约束更新哪些行，受影响的行数将作为返回值返回。</li><li><code>delete()</code>。从<code>ContentProvider</code>中删除数据。<code>uri</code>参数用于确定删除哪一张表中的数据，<code>selection</code>和<code>selectionArgs</code>参数用于约束删除哪些行，被删除的行数将作为返回值返回。</li><li><code>getType()</code>。根据传入的内容URI返回相应的MIME类型。</li></ol><p>可以看到，很多方法里带有<code>uri</code>这个参数，这个参数也正是调用<code>ContentResolver</code>的增删改查方法时传递过来的。而现在我们需要对传入的<code>uri</code>参数进行解析，从中分析出调用方期望访问的表和数据。</p><p>回顾一下，一个标准的内容URI写法是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table1</span></span><br></pre></td></tr></table></figure><p>这就表示调用方期望访问的是<code>com.example.app</code>这个应用的table1表中的数据。</p><p>除此之外，我们还可以在这个内容URI的后面加上一个id，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table1/1</span></span><br></pre></td></tr></table></figure><p>这就表示调用方期望访问的是<code>com.example.app</code>这个应用的table1表中id为1的数据。</p><p>内容URI的格式主要就只有以上两种，以路径结尾表示期望访问该表中所有的数据，以id结尾表示期望访问该表中拥有相应id的数据。我们可以使用通配符分别匹配这两种格式的内容URI，规则如下。</p><ul><li><em>*<em><strong>表示</strong>匹配任意长度的任意</em>字符**</em>。</li><li><strong>#<strong>表示</strong>匹配任意长度的任意<em>数字</em></strong>。</li></ul><p>所以，一个能够匹配任意表的内容URI格式就可以写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/*</span></span><br></pre></td></tr></table></figure><p>一个能够匹配table1表中任意一行数据的内容URI格式就可以写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table1/#</span></span><br></pre></td></tr></table></figure><p>接着，我们再借助<code>UriMatcher</code>这个类就可以轻松地实现匹配内容URI的功能。<code>UriMatcher</code>中提供了一个<code>addURI()</code>方法，这个方法接收3个参数，可以分别把<code>authority</code>、<code>path</code>和一个自定义代码传进去。这样，当调用<code>UriMatcher</code>的<code>match()</code>方法时，就可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。修改<code>MyProvider</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProvider</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table1Dir = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table1Item = <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table2Dir = <span class="number">2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> table2Item = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> uriMatcher = UriMatcher(UriMatcher.NO_MATCH)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        uriMatcher.addURI(<span class="string">&quot;com.example.app.provider &quot;</span>, <span class="string">&quot;table1&quot;</span>, table1Dir)</span><br><span class="line">        uriMatcher.addURI(<span class="string">&quot;com.example.app.provider &quot;</span>, <span class="string">&quot;table1/#&quot;</span>, table1Item)</span><br><span class="line">        uriMatcher.addURI(<span class="string">&quot;com.example.app.provider &quot;</span>, <span class="string">&quot;table2&quot;</span>, table2Dir)</span><br><span class="line">        uriMatcher.addURI(<span class="string">&quot;com.example.app.provider &quot;</span>, <span class="string">&quot;table2/#&quot;</span>, table2Item)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(uri: <span class="type">Uri</span>, projection: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, sortOrder: <span class="type">String</span>?)</span></span>: Cursor? &#123;</span><br><span class="line">        <span class="keyword">when</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            table1Dir -&gt; &#123;</span><br><span class="line">                <span class="comment">// 查询table1表中的所有数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            table1Item -&gt; &#123;</span><br><span class="line">                <span class="comment">// 查询table1表中的单条数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            table2Dir -&gt; &#123;</span><br><span class="line">                <span class="comment">// 查询table2表中的所有数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            table2Item -&gt; &#123;</span><br><span class="line">                <span class="comment">// 查询table2表中的单条数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>MyProvider</code>中新增了4个整型变量，其中<code>table1Dir</code>表示访问<code>table1</code>表中的所有数据，<code>table1Item</code>表示访问<code>table1</code>表中的单条数据，<code>table2Dir</code>表示访问<code>table2</code>表中的所有数据，<code>table2Item</code>表示访问<code>table2</code>表中的单条数据。接着我们在<code>MyProvider</code>类实例化的时候立刻创建了<code>UriMatcher</code>的实例，并调用<code>addURI()</code>方法，将期望匹配的内容URI格式传递进去，注意这里传入的路径参数是可以使用通配符的。然后当<code>query()</code>方法被调用的时候，就会通过<code>UriMatcher</code>的<code>match()</code>方法对传入的Uri对象进行匹配，如果发现<code>UriMatcher</code>中某个内容URI格式成功匹配了该Uri对象，则会返回相应的自定义代码，然后我们就可以判断出调用方期望访问的到底是什么数据了。</p><p>上述代码只是以<code>query()</code>方法为例做了个示范，其实<code>insert()</code>、<code>update()</code>、<code>delete()</code>这几个方法的实现是差不多的，它们都会携带<code>uri</code>这个参数，然后同样利用<code>UriMatcher</code>的<code>match()</code>方法判断出调用方期望访问的是哪张表，再对该表中的数据进行相应的操作就可以了。</p><p>除此之外，还有一个方法你可能会比较陌生，即<code>getType()</code>方法。它是所有的<code>ContentProvider</code>都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。<strong>一个内容URI所对应的MIME字符串主要由3部分组成</strong>，Android对这3个部分做了如下格式规定。</p><ul><li>必须以<code>vnd</code>开头。</li><li>如果内容URI以路径结尾，则后接<code>android.cursor.dir/</code>；如果内容URI以id结尾，则后接<code>android.cursor.item/</code>。</li><li>最后接上<code>vnd.&lt;authority&gt;.&lt;path&gt;</code>。</li></ul><p>所以，对于<code>content://com.example.app.provider/table1</code>这个内容URI，它所对应的MIME类型就可以写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnd.android.cursor.dir/vnd.com.example.app.provider.table1</span><br></pre></td></tr></table></figure><p>对于<code>content://com.example.app.provider/table1/1</code>这个内容URI，它所对应的MIME类型就可以写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnd.android.cursor.item/vnd.com.example.app.provider.table1</span><br></pre></td></tr></table></figure><p>现在我们可以继续完善<code>MyProvider</code>中的内容了，这次来实现<code>getType()</code>方法中的逻辑，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProvider</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span> = <span class="keyword">when</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">        table1Dir -&gt; <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table1&quot;</span></span><br><span class="line">        table1Item -&gt; <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.app.provider.table1&quot;</span></span><br><span class="line">        table2Dir -&gt; <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table2&quot;</span></span><br><span class="line">        table2Item -&gt; <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.app.provider.table2&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，一个完整的<code>ContentProvider</code>就创建完成了，现在任何一个应用程序都可以使用<code>ContentResolver</code>访问我们程序中的数据。那么，如何才能保证隐私数据不会泄漏出去呢？其实多亏了<code>ContentProvider</code>的良好机制，这个问题在不知不觉中已经被解决了。因为所有的增删改查操作都一定要匹配到相应的内容URI格式才能进行，而我们当然不可能向<code>UriMatcher</code>中添加隐私数据的URI，所以这部分数据根本无法被外部程序访问，安全问题也就不存在了。</p><h3 id="4-2-实现跨程序数据共享"><a href="#4-2-实现跨程序数据共享" class="headerlink" title="4.2 实现跨程序数据共享"></a>4.2 实现跨程序数据共享</h3><p>在之前的<code>DatabaseTest</code>项目中创建一个<code>ContentProvider</code>，</p><p>右击<code>work.icu007.databasetest</code>包 → New → Other → Content Provider。</p><p>将<code>ContentProvider</code>命名为<code>DatabaseProvider</code>，将<code>authority</code>指定为 <code>work.icu007.databasetest.provider</code>，<code>Exported</code>属性表示是否允许外部程序访问我们的<code>ContentProvider</code>，<code>Enabled</code>属性表示是否启用这个<code>ContentProvider</code>。将两个属性都勾中，点击“Finish”完成创建。</p><p>修改<code>DatabaseProvider</code>中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.databasetest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentProvider</span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues</span><br><span class="line"><span class="keyword">import</span> android.content.UriMatcher</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBaseProvider</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bookDir = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bookItem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> categoryDir = <span class="number">2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> categoryItem = <span class="number">3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> authority = <span class="string">&quot;work.icu007.databasetest.provider&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dbHelper: MyDatabaseHelper? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> uriMatcher <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        <span class="keyword">val</span> matcher = UriMatcher(UriMatcher.NO_MATCH)</span><br><span class="line">        matcher.addURI(authority, <span class="string">&quot;book&quot;</span>, bookDir)</span><br><span class="line">        matcher.addURI(authority, <span class="string">&quot;book/#&quot;</span>, bookItem)</span><br><span class="line">        matcher.addURI(authority, <span class="string">&quot;category&quot;</span>, categoryDir)</span><br><span class="line">        matcher.addURI(authority, <span class="string">&quot;category/#&quot;</span>, categoryItem)</span><br><span class="line">        matcher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(uri: <span class="type">Uri</span>, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?)</span></span> = dbHelper?.let &#123;</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">val</span> db = it.writableDatabase</span><br><span class="line">        <span class="keyword">val</span> deletedRows = <span class="keyword">when</span> (uriMatcher.match(uri))&#123;</span><br><span class="line">            bookDir -&gt; db.delete(<span class="string">&quot;Book&quot;</span>, selection, selectionArgs)</span><br><span class="line">            bookItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> bookId = uri.pathSegments[<span class="number">1</span>]</span><br><span class="line">                db.delete(<span class="string">&quot;Category&quot;</span>, <span class="string">&quot;id = ?&quot;</span>, arrayOf(bookId))</span><br><span class="line">            &#125;</span><br><span class="line">            categoryDir -&gt; db.delete(<span class="string">&quot;Category&quot;</span>, selection, selectionArgs)</span><br><span class="line">            categoryItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> categoryId = uri.pathSegments[<span class="number">1</span>]</span><br><span class="line">                db.delete(<span class="string">&quot;Category&quot;</span>, <span class="string">&quot;id = ?&quot;</span>, arrayOf(categoryId))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        deletedRows</span><br><span class="line">    &#125; ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span> = <span class="keyword">when</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">        bookDir -&gt; <span class="string">&quot;vnd.android.cursor.dir/vnd.work.icu007.databasetest.provider.book&quot;</span></span><br><span class="line">        bookItem -&gt; <span class="string">&quot;vnd.android.cursor.dir/vnd.work.icu007.databasetest.provider.book&quot;</span></span><br><span class="line">        categoryDir -&gt; <span class="string">&quot;vnd.android.cursor.dir/vnd.work.icu007.databasetest.provider.category&quot;</span></span><br><span class="line">        categoryItem -&gt; <span class="string">&quot;vnd.android.cursor.dir/vnd.work.icu007.databasetest.provider.category&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?)</span></span> = dbHelper?.let &#123;</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">val</span> db = it.writableDatabase</span><br><span class="line">        <span class="keyword">val</span> uriReturn = <span class="keyword">when</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            bookDir, bookItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> newBookId = db.insert(<span class="string">&quot;Book&quot;</span>, <span class="literal">null</span>, values)</span><br><span class="line">                Uri.parse(<span class="string">&quot;content://<span class="variable">$authority</span>/book/<span class="variable">$newBookId</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            categoryDir, categoryItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> newCategoryId = db.insert(<span class="string">&quot;Category&quot;</span>, <span class="literal">null</span>, values)</span><br><span class="line">                Uri.parse(<span class="string">&quot;content://<span class="variable">$authority</span>/category/<span class="variable">$newCategoryId</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        uriReturn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> = context?.let &#123;</span><br><span class="line">        dbHelper = MyDatabaseHelper(it, <span class="string">&quot;BookStore.db&quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; ?: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        uri: <span class="type">Uri</span>, projection: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, selection: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?, sortOrder: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = dbHelper?.let &#123;</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        <span class="keyword">val</span>  db = it.writableDatabase</span><br><span class="line">        <span class="keyword">val</span> cursor = <span class="keyword">when</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            bookDir -&gt; db.query(<span class="string">&quot;Book&quot;</span>, projection, selection, selectionArgs, <span class="literal">null</span>, <span class="literal">null</span>, sortOrder)</span><br><span class="line">            bookItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> bookId = uri.pathSegments[<span class="number">1</span>]</span><br><span class="line">                db.query(<span class="string">&quot;Book&quot;</span>, projection, <span class="string">&quot;id = ?&quot;</span>, arrayOf(bookId), <span class="literal">null</span>, <span class="literal">null</span>, sortOrder)</span><br><span class="line">            &#125;</span><br><span class="line">            categoryDir -&gt; db.query(<span class="string">&quot;Category&quot;</span>, projection, selection, selectionArgs, <span class="literal">null</span>, <span class="literal">null</span>, sortOrder)</span><br><span class="line">            categoryItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> categoryId = uri.pathSegments[<span class="number">1</span>]</span><br><span class="line">                db.query(<span class="string">&quot;Category&quot;</span>, projection, <span class="string">&quot;id = ?&quot;</span>, arrayOf(categoryId), <span class="literal">null</span>, <span class="literal">null</span>, sortOrder)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        cursor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?, selection: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        selectionArgs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = dbHelper?.let &#123;</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        <span class="keyword">val</span> db = it.writableDatabase</span><br><span class="line">        <span class="keyword">val</span> updateRows = <span class="keyword">when</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">            bookDir -&gt; db.update(<span class="string">&quot;Book&quot;</span>, values, selection, selectionArgs)</span><br><span class="line">            bookItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> bookId = uri.pathSegments[<span class="number">1</span>]</span><br><span class="line">                db.update(<span class="string">&quot;Book&quot;</span>, values, <span class="string">&quot;id = ?&quot;</span>, arrayOf(bookId))</span><br><span class="line">            &#125;</span><br><span class="line">            categoryDir -&gt; db.update(<span class="string">&quot;Category&quot;</span>, values, selection, selectionArgs)</span><br><span class="line">            categoryItem -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> categoryId = uri.pathSegments[<span class="number">1</span>]</span><br><span class="line">                db.update(<span class="string">&quot;Category&quot;</span>, values, <span class="string">&quot;id = ?&quot;</span>, arrayOf(categoryId))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        updateRows</span><br><span class="line">    &#125; ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的一开始，同样是定义了4个变量，分别用于表示<strong>访问Book表中的所有数据</strong>、<strong>访问Book表中的单条数据</strong>、<strong>访问Category表中的所有数据</strong>和访问<strong>Category表中的单条数据</strong>。然后在一个<code>by lazy</code>代码块里对<code>UriMatcher</code>进行了初始化操作，将期望匹配的几种URI格式添加了进去。</p><p><code>by lazy</code>代码块是<code>Kotlin</code>提供的一种<strong>懒加载技术</strong>，<strong>代码块中的代码一开始并不会执行</strong>，只有当<code>uriMatcher</code>变量<strong>首次被调用的时候才会执行</strong>，并且会将代码块中<strong>最后一行代码的返回值赋给<code>uriMatcher</code></strong></p><p>接下来就是每个抽象方法的具体实现：</p><ul><li><code>delete()</code>方法：是先获取<code>SQLiteDatabase</code>的实例，然后根据传入的<code>uri</code>参数判断用户想要删除哪张表里的数据，再调用<code>SQLiteDatabase</code>的delete()方法进行删除，被删除的行数将作为返回值返回。</li><li><code>getType()</code>方法：完全是按照上一节中介绍的格式规则编写的，1. 以<code>vnd</code>开头。如果内容URI以路径结尾，则后接<code>android.cursor.dir/</code>；2. 如果内容URI以id结尾，则后接<code>android.cursor.item/</code>；3. 最后接上<code>vnd.&lt;authority&gt;.&lt;path&gt;</code>。</li><li><code>insert()</code>方法：也是先获取了<code>SQLiteDatabase</code>的实例，然后根据传入的Uri参数判断用户想要往哪张表里添加数据，再调用<code>SQLiteDatabase</code>的<code>insert()</code>方法进行添加就可以了。注意，<strong>insert()方法要求返回一个能够表示这条新增数据的URI</strong>，所以我们还需要调用<code>Uri.parse()</code>方法，将一个内容URI解析成Uri对象，当然这个内容URI是以新增数据的id结尾的。</li><li><code>onCreate()</code>方法：这个方法的代码很短，但是语法可能有点特殊。这里<strong>综合利用了Getter方法语法糖、?.操作符、let函数、?:操作符以及单行代码函数语法糖</strong>。首先调用了<code>getContext()</code>方法并借助<code>?.</code>操作符和<code>let</code>函数判断它的返回值是否为空：<strong>如果为空就使用<code>?:</code>操作符返回false</strong>，表示<code>ContentProvider</code>初始化失败；<strong>如果不为空就执行let函数中的代码</strong>。在<code>let</code>函数中创建了一个<code>MyDatabaseHelper</code>的实例，然后<strong>返回true表示<code>ContentProvider</code>初始化成功。</strong></li><li><code>query()</code>方法：在这个方法中先获取了<code>SQLiteDatabase</code>的实例，然后根据传入的Uri参数判断用户想要访问哪张表，再调用<code>SQLiteDatabase</code>的<code>query()</code>进行查询，<strong>并将Cursor对象返回</strong>就好了。注意，<strong>当访问单条数据的时候</strong>，调用了Uri对象的<code>getPathSegments()</code>方法，<strong>它会将内容URI权限之后的部分以“&#x2F;”符号进行分割</strong>，并把分割后的结果放入一个字符串列表中，那这个列表的<strong>第0个位置存放的就是路径</strong>，<strong>第1个位置存放的就是id</strong>了。得到了id之后，再通过<code>selection</code>和<code>selectionArgs</code>参数进行约束，就实现了查询单条数据的功能。</li><li><code>update()</code>方法：相信这个方法中的代码已经完全难不倒你了，也是先获取<code>SQLiteDatabase</code>的实例，然后根据传入的<code>uri</code>参数判断用户想要更新哪张表里的数据，再调用<code>SQLiteDatabase</code>的<code>update()</code>方法进行更新就好了，受影响的行数将作为返回值返回。</li></ul><p>另外，还有一点需要注意，**<code>ContentProvider</code>一定要在AndroidManifest.xml文件中注册才可以使用**。不过幸运的是，我们是使用Android Studio的快捷方式创建的<code>ContentProvider</code>，因此注册这一步已经自动完成了。打开<code>AndroidManifest.xml</code>文件，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.DatabaseTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.DataBaseProvider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">&quot;work.icu007.databasetest.provider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;application&gt;</code>标签内出现了一个新的标签<provider>，我们使用它来对<code>DatabaseProvider</code>进行注册。<code>android:name</code>属性指定了<code>DatabaseProvider</code>的<strong>类名</strong>，<code>android:authorities</code>属性指定了<code>DatabaseProvider</code>的<strong>authority</strong>，而enabled和exported属性则是根据我们刚才勾选的状态自动生成的，这里表示允许<code>DatabaseProvider</code>被其他应用程序访问。</p><p>现在<code>DatabaseTest</code>这个项目就已经拥有了跨程序共享数据的功能了，将<code>DatabaseTest</code>程序重新安装在模拟器上。接着关闭<code>DatabaseTest</code>这个项目，并创建一个新项目<code>ProviderTest</code>，我们将通过这个程序去访问<code>DatabaseTest</code>中的数据。</p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ubx.providertest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.SuppressLint</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.contentValuesOf</span><br><span class="line"><span class="keyword">import</span> com.ubx.providertest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> bookId: String? = <span class="literal">null</span></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;Range&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        mainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(mainBinding.root)</span><br><span class="line"></span><br><span class="line">        mainBinding.addData.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// add Data</span></span><br><span class="line">            <span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;content://work.icu007.databasetest.provider/book&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> values = contentValuesOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;剑来&quot;</span>, <span class="string">&quot;author&quot;</span> to <span class="string">&quot;烽火戏诸侯&quot;</span>, <span class="string">&quot;pages&quot;</span> to <span class="number">60000</span>,</span><br><span class="line">                <span class="string">&quot;price&quot;</span> to <span class="number">50.99</span>)</span><br><span class="line">            <span class="keyword">val</span> newUri = contentResolver.insert(uri, values)</span><br><span class="line">            bookId = newUri?.pathSegments?.<span class="keyword">get</span>(<span class="number">1</span>)</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;addData: bookId : <span class="variable">$bookId</span> &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.queryData.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// query Data</span></span><br><span class="line">            <span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;content://work.icu007.databasetest.provider/book&quot;</span>)</span><br><span class="line">            contentResolver.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)?.apply &#123;</span><br><span class="line">                <span class="keyword">while</span> (moveToNext())&#123;</span><br><span class="line">                    <span class="keyword">val</span> name = getString(getColumnIndex(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> author = getString(getColumnIndex(<span class="string">&quot;author&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> pages = getInt(getColumnIndex(<span class="string">&quot;pages&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> price = getDouble(getColumnIndex(<span class="string">&quot;price&quot;</span>))</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;onCreate: book name is <span class="variable">$name</span>;\nbook author is <span class="variable">$author</span>;\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;book pages is <span class="variable">$pages</span>;\nbook price is <span class="variable">$price</span>.&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.updateData.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// update Data</span></span><br><span class="line">            bookId?.let &#123;</span><br><span class="line">                <span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;content://work.icu007.databasetest.provider/book/<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> values = contentValuesOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;雪中悍刀行&quot;</span>, <span class="string">&quot;pages&quot;</span> to <span class="number">50000</span>, <span class="string">&quot;price&quot;</span> to <span class="number">49.99</span>)</span><br><span class="line">                contentResolver.update(uri, values, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainBinding.deleteData.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// delete data</span></span><br><span class="line">            Log.d(TAG, <span class="string">&quot;deleteData: bookId : <span class="variable">$bookId</span>&quot;</span>)</span><br><span class="line">            bookId?.let &#123;</span><br><span class="line">                <span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;content://work.icu007.databasetest.provider/book/<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                contentResolver.delete(uri, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;LCR deleteData: delete <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别在这4个按钮的点击事件里面处理了增删改查的逻辑。添加数据的时候，首先调用了<code>Uri.parse()</code>方法将一个内容URI解析成Uri对象，然后把要添加的数据都存放到<code>ContentValues</code>对象中，接着调用<code>ContentResolver</code>的insert()方法执行添加操作就可以了。注意，<code>insert()</code>方法会返回一个Uri对象，这个对象中包含了新增数据的<code>id</code>，我们通过<code>getPathSegments()</code>方法将这个id取出，稍后会用到它。</p><p>查询数据的时候，同样是调用了<code>Uri.parse()</code>方法将一个内容URI解析成Uri对象，然后调用<code>ContentResolver</code>的query()方法查询数据，查询的结果当然还是存放在<code>Cursor</code>对象中。之后对<code>Cursor</code>进行遍历，从中取出查询结果，并一一打印出来。</p><p>更新数据的时候，也是先将内容URI解析成Uri对象，然后把想要更新的数据存放到<code>ContentValues</code>对象中，再调用<code>ContentResolver</code>的<code>update()</code>方法执行更新操作就可以了。注意，这里我们为了不想让<code>Book</code>表中的其他行受到影响，在调用<code>Uri.parse()</code>方法时，给内容URI的尾部增加了一个id，而这个id正是添加数据时所返回的。这就表示我们只希望更新刚刚添加的那条数据，<code>Book</code>表中的其他行都不会受影响。</p><p>删除数据的时候，也是使用同样的方法解析了一个以id结尾的内容URI，然后调用<code>ContentResolver</code>的<code>delete()</code>方法执行删除操作就可以了。由于我们在内容URI里指定了一个id，因此只会删掉拥有相应id的那行数据，Book表中的其他数据都不会受影响。</p><hr><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>本篇文章我们一开始先了解了Android的权限机制，并且学会了如何在<code>Android 6.0</code>以上的系统中使用运行时权限，然后重点学习了<code>ContentProvider</code>的相关内容，以实现跨程序数据共享的功能。现在我们不仅知道了如何访问其他程序中的数据，还学会<br>了怎样创建自己的<code>ContentProvider</code>来共享数据。</p><p>不过，每次在创建<code>ContentProvider</code>的时候，你都需要提醒一下自己，我是不是应该这么做？因为只有在真正需要将数据共享出去的时候才应该创建<code>ContentProvider</code>，如果仅仅是用于程序内部访问的数据，就没有必要这么做，所以千万别对它进行滥用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ContentProvider简介&quot;&gt;&lt;a href=&quot;#一、ContentProvider简介&quot; class=&quot;headerlink&quot; title=&quot;一、ContentProvider简介&quot;&gt;&lt;/a&gt;一、ContentProvider简介&lt;/h2&gt;&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-Broadcast</title>
    <link href="https://icu007work.github.io/archives/f2287651.html"/>
    <id>https://icu007work.github.io/archives/f2287651.html</id>
    <published>2023-11-28T07:11:36.000Z</published>
    <updated>2024-05-11T07:45:32.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、广播机制简介"><a href="#一、广播机制简介" class="headerlink" title="一、广播机制简介"></a>一、广播机制简介</h2><p>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会收到自己所关心的广播内容，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。Android提供了一套完整的API，允许应用程序自由地发送和接收广播。发送广播可以借助之前学习过的Intent，而接收广播的方法则需要引入一个新的概念——BroadcastReceiver。</p><p>这里我们先来了解一下广播的类型，Android中的广播主要可以分为两种类型：标准广播和有序广播。</p><ul><li>标准广播（normal broadcasts）：是一种完全异步执行的广播，在广播发出之后，所有的BroadcastReceiver几乎会在同一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。</li></ul><p><img src="https://pic.ziyuan.wang/2023/11/22/xiheya_6318f129cb33c.png" alt="1700625229306.png"></p><ul><li>有序广播（ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的BroadcastReceiver是有先后顺序的，优先级高的BroadcastReceiver就可以先收到广播消息，并且前面的BroadcastReceiver还可以截断正在传递的广播，这样后面的BroadcastReceiver就无法收到广播消息了。</li></ul><p><img src="https://pic.ziyuan.wang/2023/11/22/xiheya_ffd533f3040a9.png" alt="1700625787026.png"></p><h2 id="二、接收系统广播"><a href="#二、接收系统广播" class="headerlink" title="二、接收系统广播"></a>二、接收系统广播</h2><p>Android内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播，系统时间发生改变也会发出一条广播，等等。如果想要接收这些广播，就需要使用BroadcastReceiver，下面我们就来看一下它的具体用法。</p><h3 id="2-1-动态注册监听时间变化"><a href="#2-1-动态注册监听时间变化" class="headerlink" title="2.1 动态注册监听时间变化"></a>2.1 动态注册监听时间变化</h3><p>我们可以根据自己感兴趣的广播，自由地注册BroadcastReceiver，这样当有相应的广播发出时，相应的BroadcastReceiver就能够收到该广播，并可以在内部进行逻辑处理。注册BroadcastReceiver的方式一般有两种：在代码中注册（<strong>动态注册</strong>）和在AndroidManifest.xml中注册（<strong>静态注册</strong>）。其中前者也被称为动态注册，后者也被称为静态注册。</p><p>该如何创建一个BroadcastReceiver呢？其实只需新建一个类，让它继承自BroadcastReceiver，并重写父类的onReceive()方法就行了。这样当有广播到来时，onReceive()方法就会得到执行，具体的逻辑就可以在这个方法中处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcasttest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> work.icu007.broadcasttest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> activityMainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        activityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(activityMainBinding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        registerReceiver(timeChangeReceiver,intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        unregisterReceiver(timeChangeReceiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">TimeChangeReceiver</span>: <span class="type">BroadcastReceiver</span>()&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;Time has changed&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在MainActivity中定义了一个内部类TimeChangeReceiver，这个类是继承自BroadcastReceiver的，并重写了父类的onReceive()方法。这样每当系统时间发生变化时，onReceive()方法就会得到执行，这里只是简单地使用Toast提示了一段文本信息。然后观察onCreate()方法，首先我们创建了一个IntentFilter的实例，并给它添加了一个值为android.intent.action.TIME_TICK的action，为什么要添加这个值呢？因为当系统时间发生变化时，系统发出的正是一条值为android.intent.action.TIME_TICK的广播，也就是说我们的BroadcastReceiver想要监听什么广播，就在这里添加相应的action。接下来创建了一个TimeChangeReceiver的实例，然后调用registerReceiver()方法进行注册，将TimeChangeReceiver的实例和IntentFilter的实例都传了进去，这样TimeChangeReceiver就会收到所有值为android.intent.action.TIME_TICK的广播，也就实现了监听系统时间变化的功能。</p><p>动态注册的BroadcastReceiver一定要取消注册才行，一般会选择在onDestroy()方法中通过调用unregisterReceiver()方法来实现取消注册。</p><p>系统每隔一分钟就会发出一条android.intent.action.TIME_TICK的广播，因此我们最多只需要等待一分钟就可以收到这条广播了。</p><p>查看完整的系统广播列表，可以到如下的路径中去查看：</p><blockquote><p><code>&lt;Android SDK&gt;/platforms/&lt;任意android api版本&gt;/data/broadcast_actions.txt</code></p></blockquote><h3 id="2-2-静态实现开机启动"><a href="#2-2-静态实现开机启动" class="headerlink" title="2.2 静态实现开机启动"></a>2.2 静态实现开机启动</h3><p>动态注册的BroadcastReceiver可以自由地控制注册与注销，在灵活性方面有很大的优势。但是它存在着一个缺点，即必须在程序启动之后才能接收广播，因为注册的逻辑是写在onCreate()方法中的。如果我们需要实现在程序未启动时也接收广播，我们就需要使用静态注册的方式。</p><p>其实从理论上来说，动态注册能监听到的系统广播，静态注册也应该能监听到，在过去的Android系统中确实是这样的。但是由于大量恶意的应用程序利用这个机制在程序未启动的情况下监听系统广播，从而使任何应用都可以频繁地从后台被唤醒，严重影响了用户手机的电量和性能，因此Android系统几乎每个版本都在削减静态注册BroadcastReceiver的功能。</p><p>在Android 8.0系统之后，所有隐式广播都不允许使用静态注册的方式来接收了。隐式广播指的是那些没有具体指定发送给哪个应用程序的广播，大多数系统广播属于隐式广播，但是少数特殊的系统广播目前仍然允许使用静态注册的方式来接收。这些特殊的系统广播列表详见： <a href="https://developer.android.google.cn/guide/components/broadcastexceptions.">允许使用静态注册的广播</a>。</p><p>在这些特殊的系统广播当中，有一条值为android.intent.action.BOOT_COMPLETED的广播，这是一条开机广播。</p><p>这里我们准备实现一个开机启动的功能。在开机的时候，我们的应用程序肯定是没有启动的，因此这个功能显然不能使用动态注册的方式来实现，而应该使用静态注册的方式来接收开机广播，然后在onReceive()方法里执行相应的逻辑，这样就可以实现开机启动的功能了。</p><p>右击work.icu007.broadcasttest包→New→Other→Broadcast Receiver.将创建的类命名为BootCompleteReceiver. Exported属性表示是否允许这个BroadcastReceiver接收本程序以外的广播，Enabled属性表示是否启用这个BroadcastReceiver。勾选这两个属性，点击“Finish”完成创建。</p><p>修改BootCompleteReceiver中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcasttest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BootCompleteReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// This method is called when the BroadcastReceiver is receiving an Intent broadcast.</span></span><br><span class="line">        TODO(<span class="string">&quot;BootCompleteReceiver.onReceive() is not implemented&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> TAG = <span class="string">&quot;BootCompleteReceiver&quot;</span></span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onReceive: boot complete&quot;</span>)</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;Boot Complete&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，静态的BroadcastReceiver一定要在AndroidManifest.xml文件中注册才可以使用。不过，由于我们是使用Android Studio的快捷方式创建的BroadcastReceiver，因此注册这一步已经自动完成了。</p><p>目前的BootCompleteReceiver是无法收到开机广播的，因为我们还需要对AndroidManifest.xml文件进行修改，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于Android系统启动完成后会发出一条值为android.intent.action.BOOT_COMPLETED的广播，因此我们在<receiver>标签中又添加了一个<intent-filter>标签，并在里面声明了相应的action。</p><p>另外，这里有非常重要的一点需要说明。Android 系统为了保护用户设备的安全和隐私，做了严格的规定：如果程序需要进行一些对用户来说比较敏感的操作，必须在AndroidManifest.xml文件中进行权限声明，否则程序将会直接崩溃。比如这里接收系统的开机广播就是需要进行权限声明的，所以我们在上述代码中使用<uses-permission>标签声明了android.permission.RECEIVE_BOOT_COMPLETED权限。</p><p>到目前为止，我们在BroadcastReceiver的onReceive()方法中只是简单地使用Toast提示了一段文本信息，当你真正在项目中使用它的时候，可以在里面编写自己的逻辑。需要注意的是，不要在onReceive()方法中添加过多的逻辑或者进行任何的耗时操作，因为BroadcastReceiver中是不允许开启线程的，当onReceive()方法运行了较长时间而没有结束时，程序就会出现错误。</p><h3 id="2-3-发送自定义广播"><a href="#2-3-发送自定义广播" class="headerlink" title="2.3 发送自定义广播"></a>2.3 发送自定义广播</h3><p>广播主要分为两种类型：标准广播和有序广播。现在通过实践的方式来看一下这两种广播具体的区别。</p><h4 id="2-3-1-发送标准广播"><a href="#2-3-1-发送标准广播" class="headerlink" title="2.3.1 发送标准广播"></a>2.3.1 发送标准广播</h4><p>在发送广播之前，我们还是需要先定义一个BroadcastReceiver来准备接收此广播，不然发出去也是白发。因此新建一个MyBroadcastReceiver，并在onReceive()方法中加入如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcasttest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;received in MyBroadcastReceiver&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        <span class="comment">// This method is called when the BroadcastReceiver is receiving an Intent broadcast.</span></span><br><span class="line">        TODO(<span class="string">&quot;BroadcastReceiver.onReceive() is not implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当MyBroadcastReceiver收到自定义的广播时，就会弹出“received in MyBroadcastReceiver”的提示。然后在AndroidManifest.xml中对这个BroadcastReceiver进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BroadcastTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里让MyBroadcastReceiver接收一条值为work.icu007.broadcasttest.MY_BROADCAST的广播，因此待会儿在发送广播的时候，我们就需要发出这样的一条广播。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> activityMainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        activityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(activityMainBinding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        registerReceiver(timeChangeReceiver,intentFilter)</span><br><span class="line">        activityMainBinding.btnSendBroadcast.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span>)</span><br><span class="line">            intent.setPackage(packageName)</span><br><span class="line">            sendBroadcast(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在按钮的点击事件里面加入了发送自定义广播的逻辑。首先构建了一个Intent对象，并把要发送的广播的值传入。然后调用Intent的setPackage()方法，并传入当前应用程序的包名。packageName是getPackageName()的语法糖写法，用于获取当前应用程序的包名。最后调用sendBroadcast()方法将广播发送出去，这样所有监听work.icu007.broadcasttest.MY_BROADCAST这条广播的BroadcastReceiver就会收到消息了。此时发出去的广播就是一条标准广播。</p><p>在Android8.0系统之后，静态注册的BroadcastReceiver是无法接收隐式广播的，而默认情况下我们发出的自定义广播恰恰都是隐式广播。因此这里一定要调用setPackage()方法，指定这条广播是发送给哪个应用程序的，从而让它变成一条显式广播，否则静态注册的BroadcastReceiver将无法接收到这条广播。</p><p>由于广播是使用Intent来发送的，因此我们还可以在Intent中携带一些数据传递给相应的BroadcastReceiver，这一点和Activity的用法是比较相似的。</p><h4 id="2-3-2-发送有序广播"><a href="#2-3-2-发送有序广播" class="headerlink" title="2.3.2 发送有序广播"></a>2.3.2 发送有序广播</h4><p>和标准广播不同，有序广播是一种同步执行的广播，并且是可以被截断的。为了验证这一点，我们需要再创建一个新的BroadcastReceiver。新建AnotherBroadcastReceiver，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcasttest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;received broadcast in AnotherBroadcastReceiver&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onReceive: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AnotherBroadcastReceiver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在AndroidManifest.xml中对这个BroadcastReceiver进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BroadcastTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.AnotherBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AnotherBroadcastReceiver同样接收的是work.icu007.broadcasttest.MY_BROADCAST这条广播。</p><p>现在查岗你是发送广播的时候选择发送有序广播，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> activityMainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        activityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(activityMainBinding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        registerReceiver(timeChangeReceiver,intentFilter)</span><br><span class="line">        activityMainBinding.btnSendBroadcast.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span>)</span><br><span class="line">            intent.setPackage(packageName)</span><br><span class="line">            sendOrderedBroadcast(intent,<span class="literal">null</span>)</span><br><span class="line"><span class="comment">//            sendBroadcast(intent)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送有序广播只需要改动一行代码，即将sendBroadcast()方法改成sendOrderedBroadcast()方法。sendOrderedBroadcast()方法接收两个参数：第一个参数仍然是Intent；第二个参数是一个与权限相关的字符串，这里传入null就行了。现在重新运行程序，并点击“Send Broadcast”按钮，你会发现，两个BroadcastReceiver仍然都可以收到这条广播。</p><p>看上去好像和标准广播并没有什么区别嘛。不过别忘了，这个时候的BroadcastReceiver是有先后顺序的，而且前面的BroadcastReceiver还可以将广播截断，以阻止其继续传播。</p><p>该如何设定BroadcastReceiver的先后顺序呢？当然是在注册的时候进行设定了，修改AndroidManifest.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BroadcastTest&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.AnotherBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.broadcasttest.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过android:priority属性给BroadcastReceiver设置了优先级，优先级比较高的BroadcastReceiver就可以先收到广播。这里将MyBroadcastReceiver的优先级设成了100，以保证它一定会在AnotherBroadcastReceiver之前收到广播。</p><p>既然已经获得了接收广播的优先权，那么MyBroadcastReceiver就可以选择是否允许广播继续传递了。修改MyBroadcastReceiver中的代码，如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;received in MyBroadcastReceiver&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onReceive: &quot;</span>)</span><br><span class="line">        abortBroadcast()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyBroadcastReceiver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在onReceive()方法中调用了abortBroadcast()方法，就表示将这条广播截断，后面的BroadcastReceiver将无法再接收到这条广播。</p><h2 id="三、实践-实现强制下线功能"><a href="#三、实践-实现强制下线功能" class="headerlink" title="三、实践-实现强制下线功能"></a>三、实践-实现强制下线功能</h2><p>我们完全可以借刚刚学的广播知识，非常轻松地实现强制下线这一功能。</p><p>强制下线功能需要先关闭所有的Activity，然后回到登录界面。如果你的反应足够快，应该会想到我们在第3章的最佳实践部分已经实现过关闭所有Activity的功能了，因此这里使用同样的方案即可。先创建一个ActivityCollector类用于管理所有的Activity，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcastbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/23-17:35</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> * manage all activity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activites = ArrayList&lt;Activity&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add activities to ArrayList</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        activites.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove activities from ArrayList</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        activites.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finish all activities</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activites)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing)&#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activites.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建BaseActivity类作为所有Activity的父类，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcastbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AlertDialog</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/23-17:40</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> receiver: ForceOfflineReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;work.icu007.broadcastbestpractice.FORCE_OFFLINE&quot;</span>)</span><br><span class="line">        receiver = ForceOfflineReceiver()</span><br><span class="line">        registerReceiver(receiver, intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        unregisterReceiver(receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ForceOfflineReceiver</span> : <span class="type">BroadcastReceiver</span>()&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onReceive: receive broadcast context == null: <span class="subst">$&#123;context == null&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">                AlertDialog.Builder(context).apply &#123;</span><br><span class="line">                    setTitle(<span class="string">&quot;Warning&quot;</span>)</span><br><span class="line">                    setMessage(<span class="string">&quot;U are forced to be offline. please try to login again.&quot;</span>)</span><br><span class="line">                    setCancelable(<span class="literal">false</span>)</span><br><span class="line">                    setPositiveButton(<span class="string">&quot;OK&quot;</span>)&#123;_,_ -&gt;</span><br><span class="line">                        ActivityCollector.finishAll()</span><br><span class="line">                        <span class="keyword">val</span> i = Intent(context,LoginActivity::<span class="keyword">class</span>.java)</span><br><span class="line">                        context.startActivity(i)</span><br><span class="line">                    &#125;</span><br><span class="line">                    show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BaseActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要创建一个LoginActivity来作为登录界面，登录界面需要一个横向的LinearLayout，用于输入账号信息；还需要一个横向的LinearLayout，用于输入密码信息；最后创建一个登录按钮。</p><p>最后监听登录button：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcastbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> work.icu007.broadcastbestpractice.databinding.ActivityLoginBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginActivity</span> : <span class="type">BaseActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> activityLoginBinding: ActivityLoginBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        activityLoginBinding = ActivityLoginBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(activityLoginBinding.root)</span><br><span class="line"></span><br><span class="line">        activityLoginBinding.login.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> account = activityLoginBinding.accountEdit.text.toString()</span><br><span class="line">            <span class="keyword">val</span> password = activityLoginBinding.passwordEdit.text.toString()</span><br><span class="line">            <span class="keyword">if</span> (account == <span class="string">&quot;admin&quot;</span> &amp;&amp; password == <span class="string">&quot;123456&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">                startActivity(intent)</span><br><span class="line">                finish()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;account or password is invalid&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将LoginActivity的继承结构改成继承自BaseActivity，然后在登录按钮的点击事件里对输入的账号和密码进行判断：如果账号是admin并且密码是123456，就认为登录成功并跳转到MainActivity，否则就提示用户账号或密码错误。</p><p>因此MainActivity就是登录成功后进入的程序主界面，我们只需要加入强制下线功能就可以了。修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btnForceOffline&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Send force offline broadcast&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有一个按钮用于触发强制下线功能。然后修改MainActivity中的代码监听下线button</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.broadcastbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> work.icu007.broadcastbestpractice.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">BaseActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> activityMainBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        activityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(activityMainBinding.root)</span><br><span class="line">        activityMainBinding.btnForceOffline.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="string">&quot;work.icu007.broadcastbestpractice.FORCE_OFFLINE&quot;</span>)</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCreate: sendBroadcast&quot;</span>)</span><br><span class="line">            sendBroadcast(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在按钮的点击事件里发送了一条广播，广播的值为work.icu007.broadcastbestpractice.FORCE_OFFLINE，这条广播就是用于通知程序强制用户下线的。也就是说，强制用户下线的逻辑并不是写在MainActivity里的，而是应该写在接收这条广播的BroadcastReceiver里。这样强制下线的功能就不会依附于任何界面了，不管是在程序的任何地方，只要发出这样一条广播，就可以完成强制下线的操作了。那么毫无疑问，接下来我们就需要创建一个BroadcastReceiver来接收这条强制下线广播。唯一的问题就是，应该在哪里创建呢？由于BroadcastReceiver中需要弹出一个对话框来阻塞用户的正常操作，但如果创建的是一个静态注册的BroadcastReceiver，是没有办法在onReceive()方法里弹出对话框这样的UI控件的，而我们显然也不可能在每个Activity中都注册一个动态的BroadcastReceiver。</p><p>那么到底应该怎么办呢？答案其实很明显，只需要在BaseActivity中动态注册一个BroadcastReceiver就可以了</p><p>先来看一下ForceOfflineReceiver中的代码，这次onReceive()方法里可不再是仅仅弹出一个Toast了，而是加入了较多的代码，那我们就来仔细看看吧。首先是使用AlertDialog.Builder构建一个对话框。注意，这里一定要调用setCancelable()方法将对话框设为不可取消，否则用户按一下Back键就可以关闭对话框继续使用程序了。然后使用setPositiveButton()方法给对话框注册确定按钮，当用户点击了“OK”按钮时，就调用ActivityCollector的finishAll()方法销毁所有Activity，并重新启动LoginActivity。</p><p>再来看一下我们是怎么注册ForceOfflineReceiver这个BroadcastReceiver的。可以看到，这里重写了onResume()和onPause()这两个生命周期方法，然后分别在这两个方法里注册和取消注册了ForceOfflineReceiver。</p><p>为什么要这样写呢？之前不都是在onCreate()和onDestroy()方法里注册和取消注册BroadcastReceiver的吗？这是因为我们始终需要保证只有处于栈顶的Activity才能接收到这条强制下线广播，非栈顶的Activity不应该也没必要接收这条广播，所以写在onResume()和onPause()方法里就可以很好地解决这个问题，当一个Activity失去栈顶位置时就会自动取消BroadcastReceiver的注册。</p><p>最后还需要对AndroidManifest.xml文件进行修改，是将主Activity设置为LoginActivity，而不再是MainActivity，因为肯定不能在用户没登录的情况下就直接进入程序主界面。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、广播机制简介&quot;&gt;&lt;a href=&quot;#一、广播机制简介&quot; class=&quot;headerlink&quot; title=&quot;一、广播机制简介&quot;&gt;&lt;/a&gt;一、广播机制简介&lt;/h2&gt;&lt;p&gt;Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会收到自己所关</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-Fragment</title>
    <link href="https://icu007work.github.io/archives/14654f7f.html"/>
    <id>https://icu007work.github.io/archives/14654f7f.html</id>
    <published>2023-11-15T07:06:51.000Z</published>
    <updated>2024-05-11T07:45:29.056Z</updated>
    
    <content type="html"><![CDATA[<p>当今是移动设备发展非常迅速的时代，不仅手机已经成为了生活必需品，而且平板也变得越来越普及。平板和手机最大的区别就在于屏幕的大小：一般手机屏幕的大小在3英寸到6英寸之间，平板屏幕的大小在7英寸到10英寸之间。屏幕大小差距过大有可能会让同样的界面在视觉效果上有较大的差异，比如一些界面在手机上看起来非常美观，但在平板上看起来可能会有控件被过分拉长、元素之间空隙过大等情况。</p><p>对于一名专业的Android开发人员而言，能够兼顾手机和平板的开发是我们尽可能要做到的事情。Android自3.0版本开始引入了Fragment的概念，它可以让界面在平板上更好地展示，下面我们就一起来学习一下。</p><h2 id="一、Fragment是什么"><a href="#一、Fragment是什么" class="headerlink" title="一、Fragment是什么"></a>一、Fragment是什么</h2><p>Fragment是一种可以嵌入在Activity当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛。虽然Fragment对你来说是个全新的概念，但我相信你学习起来应该毫不费力，因为它和Activity实在是太像了，同样都能包含布局，同样都有自己的生命周期。你甚至可以将Fragment理解成一个迷你型的Activity，虽然这个迷你型的Activity有可能和普通的Activity是一样大的。</p><p>那么究竟要如何使用Fragment才能充分地利用平板屏幕的空间呢？想象我们正在开发一个新闻应用，其中一个界面使用RecyclerView展示了一组新闻的标题，当点击其中一个标题时，就打开另一个界面显示新闻的详细内容。如果是在手机中设计，我们可以将新闻标题列表放在一个Activity中，将新闻的详细内容放在另一个Activity中，如图所示。</p><p><img src="https://pic.ziyuan.wang/2023/11/07/xiheya_e90b2199c15a9.png" alt="1699341239870.png"></p><p>可是如果在平板上也这么设计，那么新闻标题列表将会被拉长至填充满整个平板的屏幕，而新闻的标题一般不会太长，这样将会导致界面上有大量的空白区域。</p><p><img src="https://pic.ziyuan.wang/2023/11/07/xiheya_2563c28792cef.png" alt="1699341321005.png"></p><p>因此，更好的设计方案是将新闻标题列表界面和新闻详细内容界面分别放在两个Fragment中，然后在同一个Activity里引入这两个Fragment，这样就可以将屏幕空间充分地利用起来了。</p><p><img src="https://pic.ziyuan.wang/2023/11/07/xiheya_e2a3cc9fdca8c.png" alt="1699341356299.png"></p><h2 id="二、Fragment的使用方式"><a href="#二、Fragment的使用方式" class="headerlink" title="二、Fragment的使用方式"></a>二、Fragment的使用方式</h2><h3 id="2-1-Fragment的简单用法"><a href="#2-1-Fragment的简单用法" class="headerlink" title="2.1 Fragment的简单用法"></a>2.1 Fragment的简单用法</h3><p>这里我们准备先写一个最简单的Fragment示例来练练手。在一个Activity当中添加两个Fragment，并让这两个Fragment平分Activity的空间。</p><p>新建一个左侧Fragment的布局left_fragment.xml，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个布局非常简单，只放置了一个按钮，并让它水平居中显示。</p><p>然后新建右侧Fragment的布局right_fragment.xml，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/design_default_color_secondary_variant&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is right fragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们将这个布局的背景色设置成了绿色，并放置了一个TextView用于显示一段文本。</p><p>接下来介是在Fragment类中加载布局文件了：例如LeftFragment是这样加载的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View? &#123;</span><br><span class="line">    <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">    <span class="keyword">return</span> inflater.inflate(R.layout.left_fragment, container, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里仅仅是重写了Fragment的onCreateView()方法，然后在这个方法中通过LayoutInflater的inflate()方法将刚才定义的left_fragment布局动态加载进来，整个方法简单明了。RightFragment也是使用同样的方法，就不贴代码了。</p><p>接下来修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmenttest.LeftFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/rightFrag&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/rightFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmenttest.RightFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们使用了<fragment>标签在布局中添加Fragment，只不过这里还需要通过android:name属性来显式声明要添加的Fragment类名，注意一定要将类的包名也加上。</p><p><img src="https://pic.ziyuan.wang/2023/11/07/xiheya_69f9e2caaa017.png" alt="1699345080151.png"></p><h3 id="2-2-动态添加Fragment"><a href="#2-2-动态添加Fragment" class="headerlink" title="2.2 动态添加Fragment"></a>2.2 动态添加Fragment</h3><p>现在我们已经学会了在布局文件中添加Fragment的方法，不过Fragment真正的强大之处在于，它可以在程序运行时动态地添加到Activity当中。根据具体情况来动态地添加Fragment，这样就可以将程序界面定制得更加多样化。</p><p>继续新建another_right_fragment.xml，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/material_dynamic_tertiary80&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is another right fragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个布局文件的代码和right_fragment.xml中的代码基本相同，只是将背景色改成了黄色，并将显示的文字改了改。然后新建AnotherRightFragment作为另一个右侧Fragment。</p><p>准备工作已经完成了，接下来就要实现将Fragment动态加载到Activity当中了。</p><p>修改activity_main.xml，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmenttest.LeftFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/rightLayout&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/rightLayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，现在将右侧Fragment替换成了一个FrameLayout。这是Android中最简单的一种布局，所有的控件默认都会摆放在布局的左上角。由于这里仅需要在布局里放入一个Fragment，不需要任何定位，因此非常适合使用FrameLayout。</p><p>下面我们将在代码中向FrameLayout里添加内容，从而实现动态添加Fragment的功能。修改MainActivity中的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.fragmenttest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmenttest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewBinding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        viewBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(viewBinding.root)</span><br><span class="line">        <span class="keyword">val</span> button: Button = findViewById(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            replaceFragment(AnotherRightFragment())</span><br><span class="line">        &#125;</span><br><span class="line">        replaceFragment(RightFragment())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">replaceFragment</span><span class="params">(fragment: <span class="type">Fragment</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> fragmentManager = supportFragmentManager</span><br><span class="line">        <span class="keyword">val</span> transaction = fragmentManager.beginTransaction()</span><br><span class="line">        transaction.replace(R.id.rightLayout, fragment)</span><br><span class="line">        transaction.commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们给左侧Fragment中的按钮注册了一个点击事件，然后调用replaceFragment()方法动态添加了RightFragment。当点击左侧Fragment中的按钮时，又会调用replaceFragment()方法，将右侧Fragment替换成AnotherRightFragment。结合replaceFragment()方法中的代码可以看出，动态添加Fragment主要分为5步。</p><ol><li>创建待添加Fragment的实例。</li><li>获取FragmentManager，在Activity中可以直接调用getSupportFragmentManager()方法获取。</li><li>开启一个事务，通过调用beginTransaction()方法开启。</li><li>向容器内添加或替换Fragment，一般使用replace()方法实现，需要传入容器的id和待添加的Fragment实例。</li><li>提交事务，调用commit()方法来完成。</li></ol><h3 id="2-3-在Fragment中实现返回栈"><a href="#2-3-在Fragment中实现返回栈" class="headerlink" title="2.3 在Fragment中实现返回栈"></a>2.3 在Fragment中实现返回栈</h3><p>在上一小节中，我们成功实现了向Activity中动态添加Fragment的功能。不过你尝试一下就会发现，通过点击按钮添加了一个Fragment之后，这时按下Back键程序就会直接退出。如果我们想实现类似于返回栈的效果，按下Back键可以回到上一个Fragment，该如何实现呢？其实很简单，FragmentTransaction中提供了一个addToBackStack()方法，可以用于将一个事务添加到返回栈中。修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">replaceFragment</span><span class="params">(fragment: <span class="type">Fragment</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> fragmentManager = supportFragmentManager</span><br><span class="line">        <span class="keyword">val</span> transaction = fragmentManager.beginTransaction()</span><br><span class="line">        transaction.replace(R.id.rightLayout, fragment)</span><br><span class="line">        transaction.addToBackStack(<span class="literal">null</span>)</span><br><span class="line">        transaction.commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在事务提交之前调用了FragmentTransaction的addToBackStack()方法，它可以接收一个名字用于描述返回栈的状态，一般传入null即可。现在重新运行程序，并点击按钮将AnotherRightFragment添加到Activity中，然后按下Back键，你会发现程序并没有退出，而是回到了RightFragment界面。继续按下Back键，RightFragment界面也会消失，再次按下Back键，程序才会退出。</p><h3 id="2-4-Fragment和Activity之间的交互"><a href="#2-4-Fragment和Activity之间的交互" class="headerlink" title="2.4 Fragment和Activity之间的交互"></a>2.4 Fragment和Activity之间的交互</h3><p>虽然Fragment是嵌入在Activity中显示的，可是它们的关系并没有那么亲密。实际上，Fragment和Activity是各自存在于一个独立的类当中的，它们之间并没有那么明显的方式来直接进行交互。如果想要在Activity中调用Fragment里的方法，或者在Fragment中调用Activity里的方法，应该如何实现呢？</p><p>为了方便Fragment和Activity之间进行交互，FragmentManager提供了一个类似于findViewById()的方法，专门用于从布局文件中获取Fragment的实例，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fragment = supportFragmentManager.findFragmentById(R.id.leftFrag) <span class="keyword">as</span> LeftFragment</span><br></pre></td></tr></table></figure><p>调用FragmentManager的findFragmentById()方法，可以在Activity中得到相应Fragment的实例，然后就能轻松地调用Fragment里的方法了。</p><p>掌握了如何在Activity中调用Fragment里的方法，那么在Fragment中又该怎样调用Activity里的方法呢？这就更简单了，在每个Fragment中都可以通过调用getActivity()方法来得到和当前Fragment相关联的Activity实例，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(activity != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">val</span> mainActivity = activity <span class="keyword">as</span> MainActivity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里由于getActivity()方法有可能返回null，因此我们需要先进行一个判空处理。有了Activity的实例，在Fragment中调用Activity里的方法就变得轻而易举了。另外当Fragment中需要使用Context对象时，也可以使用getActivity()方法，因为获取到的Activity本身就是一个Context对象。</p><h2 id="三、Fragment的生命周期"><a href="#三、Fragment的生命周期" class="headerlink" title="三、Fragment的生命周期"></a>三、Fragment的生命周期</h2><p>和Activity一样，Fragment也有自己的生命周期，并且它和Activity的生命周期实在是太像了。</p><h3 id="3-1-Fragment的状态和回调"><a href="#3-1-Fragment的状态和回调" class="headerlink" title="3.1 Fragment的状态和回调"></a>3.1 Fragment的状态和回调</h3><p>Activity在其生命周期一共有 <strong>运行状态、暂停状态、停止状态和销毁状态</strong>这4种。类似地，每个Fragment在其生命周期内也可能会经历这几种状态，只不过在一些细小的地方会有部分区别。</p><ol><li><p>运行状态</p><p>当一个Fragment所关联的Activity正处于运行状态时，该Fragment也处于运行状态。</p></li><li><p>暂停状态</p><p>当一个Activity进入暂停状态时（由于另一个未占满屏幕的Activity被添加到了栈顶），与它相关联的Fragment就会进入暂停状态。</p></li><li><p>停止状态</p><p>当一个Activity进入停止状态时，与它相关联的Fragment就会进入停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将Fragment从Activity中移除，但在事务提交之前调用了addToBackStack()方法，这时的Fragment也会进入停止状态。总的来说，进入停止状态的Fragment对用户来说是完全不可见的，有可能会被系统回收。</p></li><li><p>销毁状态</p><p>Fragment总是依附于Activity而存在，因此当Activity被销毁时，与它相关联的Fragment就会进入销毁状态。或者通过调用FragmentTransaction的remove()、replace()方法将Fragment从Activity中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的Fragment也会进入销毁状态。</p><p>同样地，Fragment类中也提供了一系列的回调方法，以覆盖它生命周期的每个环节。其中，Activity中有的回调方法，Fragment中基本上也有，不过Fragment还提供了一些附加的回调方法，下面我们就重点看一下这几个回调。</p><ul><li>onAttach()：当Fragment和Activity建立关联时调用。</li><li>onCreateView()：为Fragment创建视图（加载布局）时调用。</li><li>onActivityCreated()：确保与Fragment相关联的Activity已经创建完毕时调用。</li><li>onDestroyView()：当与Fragment关联的视图被移除时调用。</li><li>onDetach()：当Fragment和Activity解除关联时调用。</li></ul><p><img src="https://pic.ziyuan.wang/2023/11/07/xiheya_553dc0b882a59.png" alt="Fragment完整生命周期"></p></li></ol><h3 id="3-2-体验Fragment的生命周期"><a href="#3-2-体验Fragment的生命周期" class="headerlink" title="3.2 体验Fragment的生命周期"></a>3.2 体验Fragment的生命周期</h3><p>为了能够更直观的体验Fragment生命周期，可以重写 RightFragment中的一系列回调方法来打印一些log。</p><p>接下来，我们在RightFragment中的每一个回调方法里都加入了打印日志的代码，然后重新运行程序。这时观察Logcat中的打印信息如图所示：</p><p><img src="https://pic.ziyuan.wang/2023/11/08/xiheya_b7c78bdee0659.png" alt="1699408161113.png"></p><ul><li><p>当RightFragment第一次被加载到屏幕上时，会依次执行onAttach()、onCreate()、onCreateView()、onActivityCreated()、onStart()和onResume()方法。</p></li><li><p>然后点击LeftFragment中的按钮，由AnotherRightFragment替换了RightFragment，此时的RightFragment进入了停止状态，因此onPause()、onStop()和onDestroyView()方法会得到执行。当然，如果在替换的时候没有调用addToBackStack()方法，此时的RightFragment就会进入销毁状态，onDestroy()和onDetach()方法就会得到执行。</p></li><li><p>接着按下Back键，RightFragment会重新回到屏幕，由于RightFragment重新回到了运行状态，因此onCreateView()、onActivityCreated()、onStart()和onResume()方法会得到执行。注意，此时onCreate()方法并不会执行，因为我们借助了addToBackStack()方法使得RightFragment并没有被销毁。</p></li><li><p>现在再次按下Back键，程序会依次执行onPause()、onStop()、onDestroyView()、onDestroy()和onDetach()方法，最终将Fragment销毁。</p></li></ul><p>在Fragment中你也可以通过onSaveInstanceState()方法来保存数据，因为进入停止状态的Fragment有可能在系统内存不足的时候被回收。保存下来的数据在onCreate()、onCreateView()和onActivityCreated()这3个方法中你都可以重新得到，它们都含有一个Bundle类型的savedInstanceState参数。</p><h2 id="四、动态加载布局的技巧"><a href="#四、动态加载布局的技巧" class="headerlink" title="四、动态加载布局的技巧"></a>四、动态加载布局的技巧</h2><p>虽然动态添加Fragment的功能很强大，可以解决很多实际开发中的问题，但是它毕竟只是在一个布局文件中进行一些添加和替换操作。如果程序能够根据设备的分辨率或屏幕大小，在运行时决定加载哪个布局，那我们可发挥的空间就更多了。因此我们就来探讨一下Android中动态加载布局的技巧。</p><h3 id="4-1-使用限定符"><a href="#4-1-使用限定符" class="headerlink" title="4.1 使用限定符"></a>4.1 使用限定符</h3><p>很多平板应用采用的是双页模式（程序会在左侧的面板上显示一个包含子项的列表，在右侧的面板上显示内容），因为平板的屏幕足够大，完全可以同时显示两页的内容，但手机的屏幕就只能显示一页的内容，因此两个页面需要分开显示。</p><p>那么怎样才能在运行时判断程序应该是使用双页模式还是单页模式呢？这就需要借助限定符（qualifier）来实现了。下面我们通过一个例子来学习一下它的用法，修改FragmentTest项目中的activity_main.xml文件，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;work.icu007.fragmenttest.LeftFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/rightLayout&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里将多余的代码删掉，只留下一个左侧Fragment，并让它充满整个父布局。接着在res目录下新建layout-large文件夹，在这个文件夹下新建一个布局，也叫作activity_main.xml，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;work.icu007.fragmenttest.LeftFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/rightFrag&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/rightFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmenttest.RightFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，layout&#x2F;activity_main布局只包含了一个Fragment，即单页模式，而layoutlarge&#x2F;activity_main布局包含了两个Fragment，即双页模式。其中，large就是一个限定符，那些屏幕被认为是large的设备就会自动加载layout-large文件夹下的布局，小屏幕的设备则还是会加载layout文件夹下的布局。</p><p>这样就实现了在程序运行时动态加载布局的功能，安卓中常见限定符如表所示：</p><table><thead><tr><th align="center">屏幕特征</th><th align="center">限定符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">大小</td><td align="center">small</td><td align="center">提供给小屏幕设备的资源</td></tr><tr><td align="center">大小</td><td align="center">normal</td><td align="center">提供给中等屏幕设备的资源</td></tr><tr><td align="center">大小</td><td align="center">large</td><td align="center">提供给大屏幕设备的资源</td></tr><tr><td align="center">大小</td><td align="center">xlarge</td><td align="center">提供给超大屏幕设备的资源</td></tr><tr><td align="center">分辨率</td><td align="center">ldpi</td><td align="center">提供给低分辨率设备的资源（120dpi以下）</td></tr><tr><td align="center">分辨率</td><td align="center">mdpi</td><td align="center">提供给中等分辨率设备的资源（120dpi-160dpi）</td></tr><tr><td align="center">分辨率</td><td align="center">hdpi</td><td align="center">提供给高分辨率设备的资源（160dpi-240dpi）</td></tr><tr><td align="center">分辨率</td><td align="center">xhdpi</td><td align="center">提供给超高分辨率设备的资源（240dpi-320dpi）</td></tr><tr><td align="center">分辨率</td><td align="center">xxhdpi</td><td align="center">提供给超超高分辨率设备的资源（320dpi-480dpi）</td></tr><tr><td align="center">方向</td><td align="center">land</td><td align="center">提供给横屏设备的资源</td></tr><tr><td align="center">方向</td><td align="center">port</td><td align="center">提供给竖屏设备的资源</td></tr></tbody></table><h3 id="4-2-使用最小宽度限定符"><a href="#4-2-使用最小宽度限定符" class="headerlink" title="4.2 使用最小宽度限定符"></a>4.2 使用最小宽度限定符</h3><p>在上一小节中我们使用large限定符成功解决了单页双页的判断问题，不过很快又有一个新的问题出现了：large到底是指多大呢？有时候我们希望可以更加灵活地为不同设备加载布局，不管它们是不是被系统认定为large，这时就可以使用最小宽度限定符（smallest-width qualifier）。</p><p>最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以dp为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局。</p><p>在res目录下新建layout-sw600dp文件夹，然后在这个文件夹下新建activity_main.xml布局，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;work.icu007.fragmenttest.LeftFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/rightFrag&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/rightFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmenttest.RightFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就意味着，当程序运行在屏幕宽度大于等于600 dp的设备上时，会加载layoutsw600dp&#x2F;activity_main布局，当程序运行在屏幕宽度小于600 dp的设备上时，则仍然加载默认的layout&#x2F;activity_main布局。</p><h2 id="五、Fragment最佳实践：一个简易版的新闻应用"><a href="#五、Fragment最佳实践：一个简易版的新闻应用" class="headerlink" title="五、Fragment最佳实践：一个简易版的新闻应用"></a>五、Fragment最佳实践：一个简易版的新闻应用</h2><p>前面提到过，Fragment很多时候是在平板开发当中使用的，因为它可以解决屏幕空间不能充分利用的问题。那是不是就表明，我们开发的程序都需要提供一个手机版和一个平板版呢？确实有不少公司是这么做的，但是这样会耗费很多的人力物力财力。因为维护两个版本的代码成本很高：每当增加新功能时，需要在两份代码里各写一遍；每当发现一个bug时，需要在两份代码里各修改一次。因此，今天实践内容就是编写兼容手机和平板的应用程序。</p><p>首先我们要准备好一个新闻的实体类，新建类News，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/8-14:07</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">News</span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> content: String)</span><br></pre></td></tr></table></figure><p>News类的代码非常简单，title字段表示新闻标题，content字段表示新闻内容。接着新建NewsContentFragment类并编辑其布局文件fragment_news_content.xml，作为新闻内容的布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.NewsContentFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/contentLayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;invisible&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsTitle&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;1dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/black&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;1dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/black&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新闻内容的布局主要可以分为两个部分：头部部分显示新闻标题，正文部分显示新闻内容，中间使用一条水平方向的细线分隔开。除此之外，这里还使用了一条垂直方向的细线，它的作用是在双页模式时将左侧的新闻列表和右侧的新闻内容分隔开。细线是利用View来实现的，将View的宽或高设置为1 dp，再通过background属性给细线设置一下颜色就可以了，这里我们把细线设置成黑色。</p><p>另外，我们还要将新闻内容的布局设置成不可见。因为在双页模式下，如果还没有选中新闻列表中的任何一条新闻，是不应该显示新闻内容布局的。</p><p>接下来新建一个NewsContentFragment类，继承自Fragment，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.FragmentNewsContentBinding</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Rename parameter arguments, choose names that match</span></span><br><span class="line"><span class="comment">// the fragment initialization parameters, e.g. ARG_ITEM_NUMBER</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_PARAM1 = <span class="string">&quot;title&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_PARAM2 = <span class="string">&quot;content&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A simple [Fragment] subclass.</span></span><br><span class="line"><span class="comment"> * Use the [NewsContentFragment.newInstance] factory method to</span></span><br><span class="line"><span class="comment"> * create an instance of this fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsContentFragment</span>() : Fragment() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Rename and change types of parameters</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> param1: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> param2: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentNewsContentBinding? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        arguments?.let &#123;</span><br><span class="line">            param1 = it.getString(ARG_PARAM1)</span><br><span class="line">            param2 = it.getString(ARG_PARAM2)</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCreate: title: <span class="variable">$param1</span>, content: <span class="variable">$param2</span>&quot;</span>)</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCreate: title: <span class="subst">$&#123;arguments?.getString(<span class="string">&quot;title&quot;</span>)&#125;</span>,content: <span class="subst">$&#123;arguments?.getString(<span class="string">&quot;content&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        _binding = FragmentNewsContentBinding.inflate(inflater,container,<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> bundle = arguments</span><br><span class="line">        <span class="keyword">val</span> title = bundle?.getString(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> content = bundle?.getString(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreateView: title: <span class="variable">$title</span>, content: <span class="variable">$content</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ( title != <span class="literal">null</span> &amp;&amp; content!=<span class="literal">null</span> ) &#123;</span><br><span class="line">            refresh(title,content)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">refresh</span><span class="params">(title: <span class="type">String</span>, content: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;refresh: step in&quot;</span>)</span><br><span class="line">        binding.contentLayout.visibility = View.VISIBLE</span><br><span class="line">        binding.newsTitle.text = title</span><br><span class="line">        binding.newsContent.text = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;NewsContentFragment&quot;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Use this factory method to create a new instance of</span></span><br><span class="line"><span class="comment">         * this fragment using the provided parameters.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> param1 Parameter 1.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> param2 Parameter 2.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> A new instance of fragment NewsContentFragment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Rename and change types and number of parameters</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(param1: <span class="type">String</span>, param2: <span class="type">String</span>)</span></span>: NewsContentFragment&#123;</span><br><span class="line">            <span class="keyword">val</span> fragment = NewsContentFragment()</span><br><span class="line">            <span class="keyword">val</span> bundle = Bundle()</span><br><span class="line">            bundle.putString(<span class="string">&quot;title&quot;</span>,param1)</span><br><span class="line">            bundle.putString(<span class="string">&quot;content&quot;</span>,param2)</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;newInstance: title: <span class="variable">$param1</span>, content: <span class="variable">$param2</span>&quot;</span>)</span><br><span class="line"><span class="comment">//            fragment.arguments = bundle</span></span><br><span class="line">            <span class="keyword">return</span> fragment</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先在onCreateView()方法中加载了我们刚刚创建的news_content_frag布局，接下来又提供了一个refresh()方法，用于将新闻的标题和内容显示在我们刚刚定义的界面上。注意，当调用了refresh()方法时，需要将我们刚才隐藏的新闻内容布局设置成可见。</p><p>这样我们就把新闻内容的Fragment和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个Activity。右击com.example.fragmentbestpractice包→New→Activity→Empty Activity，新建一个NewsContentActivity，布局名就使用默认的activity_news_content即可。然后修改activity_news_content.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.NewsContentActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsContentFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;work.icu007.fragmentbestpractice.NewsContentFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里充分发挥了代码的复用性，直接在布局中引入了NewsContentFragment。这样相当于把news_content_frag布局的内容自动加了进来。</p><p>然后修改NewsContentActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.FragmentManager</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.ActivityNewsContentBinding</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.FragmentNewsContentBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsContentActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityNewsContentBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> contentFragmentBinding: FragmentNewsContentBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;NewsContentActivity&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, title: <span class="type">String</span>, content: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, NewsContentActivity::<span class="keyword">class</span>.java).apply&#123;</span><br><span class="line">                putExtra(<span class="string">&quot;news_title&quot;</span>, title)</span><br><span class="line">                putExtra(<span class="string">&quot;news_content&quot;</span>, content)</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;actionStart: title: <span class="variable">$title</span>, content: <span class="variable">$content</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityNewsContentBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> title = intent.getStringExtra(<span class="string">&quot;news_title&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> content = intent.getStringExtra(<span class="string">&quot;news_content&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;NewsContentActivity&quot;</span>, <span class="string">&quot;onCreate: title: <span class="variable">$title</span>, content: <span class="variable">$content</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (title != <span class="literal">null</span> &amp;&amp; content != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> fragment = supportFragmentManager.findFragmentById(R.id.newsContentFrag) <span class="keyword">as</span> NewsContentFragment</span><br><span class="line">            fragment.refresh(title,content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onCreate()方法中我们通过Intent获取到了传入的新闻标题和新闻内容，然后使用kotlin-android-extensions插件提供的简洁写法得到了NewsContentFragment的实例，接着调用它的refresh()方法，将新闻的标题和内容传入，就可以把这些数据显示出来了。注意，这里我们还提供了一个actionStart()方法用于外部调用启动activity。</p><p>接下来还需要再创建一个用于显示新闻列表的布局，新建news_title_frag.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsTitleRecyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个布局的代码就非常简单了，里面只有一个用于显示新闻列表的RecyclerView。既然要用到RecyclerView，那么就必定少不了子项的布局。新建news_item.xml作为RecyclerView子项的布局，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsTitle&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxLines</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ellipsize</span>=<span class="string">&quot;end&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">&quot;15dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>子项的布局也非常简单，只有一个TextView。仔细观察TextView，你会发现其中有几个属性是我们之前没有学过的：android:padding表示给控件的周围加上补白，这样不至于让文本内容紧靠在边缘上；android:maxLines设置为1表示让这个TextView只能单行显示；android:ellipsize用于设定当文本内容超出控件宽度时文本的缩略方式，这里指定成end表示在尾部进行缩略。</p><p>既然新闻列表和子项的布局都已经创建好了，那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为展示新闻列表的Fragment，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.FragmentNewsContentBinding</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.FragmentNewsTitleBinding</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Rename parameter arguments, choose names that match</span></span><br><span class="line"><span class="comment">// the fragment initialization parameters, e.g. ARG_ITEM_NUMBER</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_PARAM1 = <span class="string">&quot;param1&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_PARAM2 = <span class="string">&quot;param2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A simple [Fragment] subclass.</span></span><br><span class="line"><span class="comment"> * Use the [NewsTitleFragment.newInstance] factory method to</span></span><br><span class="line"><span class="comment"> * create an instance of this fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsTitleFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Rename and change types of parameters</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> param1: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> param2: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isTwoPane = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentNewsTitleBinding? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        arguments?.let &#123;</span><br><span class="line">            param1 = it.getString(ARG_PARAM1)</span><br><span class="line">            param2 = it.getString(ARG_PARAM2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        _binding = FragmentNewsTitleBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">        isTwoPane = activity?.findViewById&lt;View&gt;(R.id.newsContentLayout) != <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewsTitleFragment中并没有多少代码，在onCreateView()方法中加载了news_title_frag布局，这个没什么好说的。我们注意看一下onActivityCreated()方法，这个方法通过在Activity中能否找到一个id为newsContentLayout的View，来判断当前是双页模式还是单页模式，因此我们需要让这个id为newsContentLayout的View只在双页模式中才会出现。注意，由于在Fragment中调用getActivity()方法有可能返回null，所以在上述代码中我们使用了一个?.操作符来保证代码的安全性。</p><p>那么怎样才能实现让id为newsContentLayout的View只在双页模式中才会出现呢？其实并不复杂，只需要借助我们刚刚学过的限定符就可以了。首先修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsTitleFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmentbestpractice.NewsTitleFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码表示在单页模式下只会加载一个新闻标题的Fragment。</p><p>然后新建layout-sw600dp文件夹，在这个文件夹下再新建一个activity_main.xml文件，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsTitleFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmentbestpractice.NewsTitleFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsContentLayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsContentFrag&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.fragmentbestpractice.NewsContentFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，在双页模式下，我们同时引入了两个Fragment，并将新闻内容的Fragment放在了一个FrameLayout布局下，而这个布局的id正是newsContentLayout。因此，能够找到这个id的时候就是双页模式，否则就是单页模式。</p><p>现在我们已经将绝大部分的工作完成了，但还剩下至关重要的一点，就是在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.FragmentNewsContentBinding</span><br><span class="line"><span class="keyword">import</span> work.icu007.fragmentbestpractice.databinding.FragmentNewsTitleBinding</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Rename parameter arguments, choose names that match</span></span><br><span class="line"><span class="comment">// the fragment initialization parameters, e.g. ARG_ITEM_NUMBER</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_PARAM1 = <span class="string">&quot;param1&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_PARAM2 = <span class="string">&quot;param2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A simple [Fragment] subclass.</span></span><br><span class="line"><span class="comment"> * Use the [NewsTitleFragment.newInstance] factory method to</span></span><br><span class="line"><span class="comment"> * create an instance of this fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsTitleFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Rename and change types of parameters</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> param1: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> param2: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isTwoPane = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentNewsTitleBinding? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        arguments?.let &#123;</span><br><span class="line">            param1 = it.getString(ARG_PARAM1)</span><br><span class="line">            param2 = it.getString(ARG_PARAM2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        _binding = FragmentNewsTitleBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">        isTwoPane = activity?.findViewById&lt;View&gt;(R.id.newsContentLayout) != <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> layoutManager = LinearLayoutManager(activity)</span><br><span class="line">        binding.newsTitleRecyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="keyword">val</span> adapter = NewsAdapter(getNews())</span><br><span class="line">        binding.newsTitleRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNews</span><span class="params">()</span></span>: List&lt;News&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> newsList = ArrayList&lt;News&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.50</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> news = News(<span class="string">&quot;This is news title <span class="variable">$i</span>&quot;</span>, getRandomLengthString(<span class="string">&quot;This is news content <span class="variable">$i</span>. &quot;</span>))</span><br><span class="line">                    newsList.add(news)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newsList</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        repeat(n) &#123;</span><br><span class="line">            builder.append(str)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">NewsAdapter</span>(<span class="keyword">val</span> newsList: List&lt;News&gt;): RecyclerView.Adapter&lt;NewsAdapter.ViewHolder&gt;()&#123;</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(view: View): RecyclerView.ViewHolder(view)&#123;</span><br><span class="line">            <span class="keyword">val</span> newsTitle: TextView = view.findViewById(R.id.newsTitle)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.news_item,parent,<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">val</span> holder = ViewHolder(view)</span><br><span class="line">            holder.itemView.setOnClickListener &#123;</span><br><span class="line">                <span class="keyword">val</span> news = newsList[holder.bindingAdapterPosition]</span><br><span class="line">                <span class="keyword">if</span>(isTwoPane) &#123;</span><br><span class="line">                    <span class="keyword">val</span> fragment = parentFragmentManager.findFragmentById(R.id.newsContentFrag) <span class="keyword">as</span> NewsContentFragment</span><br><span class="line">                    fragment.refresh(news.title, news.content)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    NewsContentActivity.actionStart(parent.context,news.title,news.content)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> holder</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newsList.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> news = newsList[position]</span><br><span class="line">            holder.newsTitle.text = news.title</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Use this factory method to create a new instance of</span></span><br><span class="line"><span class="comment">         * this fragment using the provided parameters.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> param1 Parameter 1.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> param2 Parameter 2.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> A new instance of fragment NewsTitleFragment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Rename and change types and number of parameters</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(param1: <span class="type">String</span>, param2: <span class="type">String</span>)</span></span> =</span><br><span class="line">            NewsTitleFragment().apply &#123;</span><br><span class="line">                arguments = Bundle().apply &#123;</span><br><span class="line">                    putString(ARG_PARAM1, param1)</span><br><span class="line">                    putString(ARG_PARAM2, param2)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们都是将适配器写成一个独立的类，其实也可以写成内部类。这里写成内部类的好处就是可以直接访问NewsTitleFragment的变量，比如isTwoPane。onCreateViewHolder()方法中注册的点击事件，首先获取了点击项的News实例，然后通过isTwoPane变量判断当前是单页还是双页模式。如果是单页模式，就启动一个新的Activity去显示新闻内容；如果是双页模式，就更新NewsContentFragment里的数据。</p><p>，onActivityCreated()方法中添加了RecyclerView标准的使用方法。在Fragment中使用RecyclerView和在Activity中使用几乎是一模一样的。这里调用了getNews()方法来初始化50条模拟新闻数据，同样使用了一个getRandomLengthString()方法来随机生成新闻内容的长度，以保证每条新闻的内容差距比较大。</p><h2 id="六、知识小结"><a href="#六、知识小结" class="headerlink" title="六、知识小结"></a>六、知识小结</h2><h3 id="6-1-在Activity中通过ViewBinding获取Fragment的引用"><a href="#6-1-在Activity中通过ViewBinding获取Fragment的引用" class="headerlink" title="6.1 在Activity中通过ViewBinding获取Fragment的引用"></a>6.1 在Activity中通过ViewBinding获取Fragment的引用</h3><p>我们此时有一个activity，且布局文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.NewsContentActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/newsContentFrag&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;work.icu007.fragmentbestpractice.NewsContentFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那如何在Activity中使用 ViewBinding 获取 Fragment 的引用呢？其实很简单：</p><ol><li><p>首先确保你的项目已启用 ViewBinding。你的 build.gradle 文件应该包含以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        <span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 NewsContentActivity 中使用 ViewBinding。确保你的 Activity 已经设置了 ViewBinding：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.commit</span><br><span class="line"><span class="keyword">import</span> com.example.databinding.databinding.ActivityNewsContentBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsContentActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityNewsContentBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 ViewBinding</span></span><br><span class="line">        binding = ActivityNewsContentBinding.inflate(layoutInflater)</span><br><span class="line">        <span class="keyword">val</span> view = binding.root</span><br><span class="line">        setContentView(view)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 fragment 引用</span></span><br><span class="line">        <span class="keyword">val</span> newsContentFragment = supportFragmentManager.findFragmentById(R.id.newsContentFrag) <span class="keyword">as</span> NewsContentFragment</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以使用 newsContentFragment 对象进行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>确保使用正确的 ViewBinding 类型，类名是根据你的布局文件名生成的，以 <code>Activity</code> 类名为前缀，去掉下划线并首字母大写。在这个例子中，假设布局文件名为 <code>activity_news_content.xml</code>，生成的类名为 <code>ActivityNewsContentBinding</code>。这样，你就可以在 <code>NewsContentActivity</code> 中通过 ViewBinding 获取到 <code>newsContentFrag</code> 的引用。</p></li></ol><h3 id="6-2-在另一个-Fragment-中获取到具有-id-为-newsContentFrag-的-Fragment"><a href="#6-2-在另一个-Fragment-中获取到具有-id-为-newsContentFrag-的-Fragment" class="headerlink" title="6.2 在另一个 Fragment 中获取到具有 id 为 newsContentFrag 的 Fragment"></a>6.2 在另一个 Fragment 中获取到具有 id 为 <code>newsContentFrag</code> 的 Fragment</h3><p>如果你想在另一个 Fragment 中获取到具有 id 为 <code>newsContentFrag</code> 的 Fragment，你可以使用 <code>parentFragmentManager</code> 或 <code>childFragmentManager</code>，具体取决于你在哪个 Fragment 中执行这个操作。</p><p>假设你要在另一个 Fragment 的 <code>onCreateView</code> 方法中获取 <code>newsContentFrag</code> 的引用，代码可能如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kotlinCopy codeimport android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> com.example.databinding.databinding.YourFragmentLayoutBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YourOtherFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: YourFragmentLayoutBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// 初始化 ViewBinding</span></span><br><span class="line">        binding = YourFragmentLayoutBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> view = binding.root</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 newsContentFrag 的引用</span></span><br><span class="line">        <span class="keyword">val</span> newsContentFragment = parentFragmentManager.findFragmentById(R.id.newsContentFrag) <span class="keyword">as</span> NewsContentFragment</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以使用 newsContentFragment 对象进行其他操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这里使用的是 <code>parentFragmentManager</code>。如果你的 <code>YourOtherFragment</code> 嵌套在另一个 Fragment 中，你可能需要使用 <code>childFragmentManager</code>。</p><p>确保你的布局文件名和 ViewBinding 类型与你的实际设置一致。在这个例子中，假设你的布局文件名为 <code>your_fragment_layout.xml</code>，生成的类名为 <code>YourFragmentLayoutBinding</code>。</p><h3 id="6-3-使用Random函数来随机生成内容"><a href="#6-3-使用Random函数来随机生成内容" class="headerlink" title="6.3 使用Random函数来随机生成内容"></a>6.3 使用Random函数来随机生成内容</h3><p>如果我们需要生成一些重复内容，且重复内容次数随机。我们就可以这样写：首先通过<code>(1..20).random()</code>来获取一个1-20的随机数。然后再通过实例化一个 <code>StringBuilder()</code>对象，使用其 <code>append</code>方法重复添加n次相同的内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNews</span><span class="params">()</span></span>: List&lt;News&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> newsList = ArrayList&lt;News&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.50</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> news = News(<span class="string">&quot;This is news title <span class="variable">$i</span>&quot;</span>, getRandomLengthString(<span class="string">&quot;This is news content <span class="variable">$i</span>. &quot;</span>))</span><br><span class="line">                    newsList.add(news)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newsList</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        repeat(n) &#123;</span><br><span class="line">            builder.append(str)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当今是移动设备发展非常迅速的时代，不仅手机已经成为了生活必需品，而且平板也变得越来越普及。平板和手机最大的区别就在于屏幕的大小：一般手机屏幕的大小在3英寸到6英寸之间，平板屏幕的大小在7英寸到10英寸之间。屏幕大小差距过大有可能会让同样的界面在视觉效果上有较大的差异，比如一</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发-UI</title>
    <link href="https://icu007work.github.io/archives/f370ac25.html"/>
    <id>https://icu007work.github.io/archives/f370ac25.html</id>
    <published>2023-10-26T07:00:55.000Z</published>
    <updated>2024-05-11T07:45:25.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="〇、导航组件"><a href="#〇、导航组件" class="headerlink" title="〇、导航组件"></a>〇、导航组件</h2><h3 id="0-1-导航简介"><a href="#0-1-导航简介" class="headerlink" title="0.1 导航简介"></a>0.1 导航简介</h3><p>导航组件是 Android Jetpack 的一部分，主要用途是实现用户导航、进入和退出应用中不同内容片段的交互，不论是普通的按钮点击，还是应用栏、抽屉导航栏等复杂的模式，它都能轻松应对，当然，导航组件也有它既定的 导航原则 来确保一致且可预测的用户体验。</p><h4 id="0-1-1-导航组件的组成"><a href="#0-1-1-导航组件的组成" class="headerlink" title="0.1.1 导航组件的组成"></a>0.1.1 导航组件的组成</h4><p> 导航组件的组成<strong>主要有三部分</strong> </p><ul><li>导航图（<font color = "red">navGraph</font>）: 这是包含所有导航相关信息的 <code>XML</code> 资源，这些信息包括应用内所有内容区域个体（称为目标，一般都是 <code>Fragment</code>），以及用户可以通过应用跳转的可能路径。</li><li>导航宿主（ <font color = "red">NavHost</font> ）：这是用来显示导航图中声明的目标的一个空白容器。导航组件包含一个默认的 <code>NavHost</code> 实现 (<code>NavHostFragment</code>)，可用于显示 <code>Fragment</code> 目标。</li><li>导航控制器（<font color = "red"><strong>NavController  </strong></font> ）：在 <code>NavHost</code> 中管理应用导航的目标，当用户在应用中进行操作时，导航控制器会控制目标的切换。</li></ul><p><strong>使用导航组件有各种优势，包括以下方面：</strong></p><ul><li>自动处理 <code>Fragment</code> 事务；</li><li>在默认情况下，能够正确处理往返操作；</li><li>支持动画和转场动画；</li><li>支持导航界面模式（例如：抽屉式导航栏和底部导航栏）</li><li>Safe Args 支持（一种可在导航和目标之间传递数据时提供类型安全的 Gradle 插件）</li><li><code>ViewModel</code> 支持</li><li>可以使用Android Studio的 Navigation Editor 来编辑和查看导航图（必须使用Android Studio 3.3及以上版本）</li></ul><h4 id="0-1-2-导航的原则"><a href="#0-1-2-导航的原则" class="headerlink" title="0.1.2 导航的原则"></a>0.1.2 导航的原则</h4><p> 在使用导航组件时，应当遵循一些原则，以提高用户体验。</p><blockquote><p>注意：即使您未在项目中使用 Navigation 组件，您的应用也应遵循这些设计原则。</p></blockquote><ul><li><h5 id="固定的起始目的地"><a href="#固定的起始目的地" class="headerlink" title="固定的起始目的地"></a>固定的起始目的地</h5></li></ul><p>顾名思义，您构建的应用必须有一个固定的起始目的地，这个起始目的地就是指当应用启动时蛋刀的第一个屏幕。起始目的地也是用户按返回按钮后，在回到启动器前看到的最后一个屏幕。</p><ul><li><h5 id="导航状态表现为目的地堆栈"><a href="#导航状态表现为目的地堆栈" class="headerlink" title="导航状态表现为目的地堆栈"></a>导航状态表现为目的地堆栈</h5></li></ul><p>在用户启动应用时，系统会启动一个新任务，并且显示起始目的地，这个起始目的地是应用导航的而基础。当用户在应用中进行导航时，栈顶的目标就是显示在屏幕上的，而栈内的所有目标都是历史记录。</p><blockquote><p>导航组件会为你管理所有返回栈的顺序，当然你也可以自行管理，已达到某些目的。</p></blockquote><ul><li><h5 id="在应用的任务中向上按钮和返回按钮行为相同"><a href="#在应用的任务中向上按钮和返回按钮行为相同" class="headerlink" title="在应用的任务中向上按钮和返回按钮行为相同"></a>在应用的任务中向上按钮和返回按钮行为相同</h5></li></ul><p>首先，说一下什么是向上按钮，向上按钮是指在应用中的返回上一级的按钮（一般是在用户导航栏中），返回按钮则是系统导航中的返回按钮。在应用的任务重，向上按钮和返回按钮的行为相同，都是将栈顶的目标移除，返回到上一个目标。</p><ul><li><h5 id="向上按钮不会退出应用"><a href="#向上按钮不会退出应用" class="headerlink" title="向上按钮不会退出应用"></a>向上按钮不会退出应用</h5></li></ul><p>在应用的任务重，向上按钮可以返回到上一个目标，但是绝不会退出应用。</p><ul><li><h5 id="深度链接可以模拟手动导航"><a href="#深度链接可以模拟手动导航" class="headerlink" title="深度链接可以模拟手动导航"></a>深度链接可以模拟手动导航</h5></li></ul><p>无论是通过深度链接至特定的目的地，还是手动导航到特定目的地，都可以使用向上按钮通过各个目的地导航回到起始目的地。当深度链接至特定的目的地时，会移除所有返回栈中的任务，并替换为深度链接的返回栈。值得注意的是，深度链接合成的返回栈是一个完整的返回栈，他跟手动导航至特定目的地具有相同的返回栈，这个是非常重要的，因为合成的返回栈必须是真实的。</p><h3 id="0-2-使用入门"><a href="#0-2-使用入门" class="headerlink" title="0.2 使用入门"></a>0.2 使用入门</h3><h4 id="0-2-1-添加依赖"><a href="#0-2-1-添加依赖" class="headerlink" title="0.2.1 添加依赖"></a>0.2.1 添加依赖</h4><p>在应用模块目录下的 <code>build.gradle</code>文件中添加 <code>dependencies</code> 依赖声明。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(platform(&quot;org.jetbrains.kotlin:kotlin-bom:1.8.0&quot;))</span><br><span class="line">    implementation &#x27;androidx.core:core-ktx:1.7.0&#x27;</span><br><span class="line">    implementation &#x27;androidx.appcompat:appcompat:1.6.1&#x27;</span><br><span class="line">    implementation &#x27;com.google.android.material:material:1.9.0&#x27;</span><br><span class="line">    implementation &#x27;androidx.constraintlayout:constraintlayout:2.1.4&#x27;</span><br><span class="line">    implementation &#x27;androidx.navigation:navigation-fragment-ktx:2.7.4&#x27;</span><br><span class="line">    implementation &#x27;androidx.navigation:navigation-ui-ktx:2.7.4&#x27;</span><br><span class="line">    testImplementation &#x27;junit:junit:4.13.2&#x27;</span><br><span class="line">    androidTestImplementation &#x27;androidx.test.ext:junit:1.1.5&#x27;</span><br><span class="line">    androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.5.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0-2-2-创建导航图资源文件"><a href="#0-2-2-创建导航图资源文件" class="headerlink" title="0.2.2 创建导航图资源文件"></a>0.2.2 创建导航图资源文件</h4><p>导航是发生在各个目的地之间的，而这些目的地通过操作连接在一起。导航图是一种资源文件，它包含了所有的目的地和操作的声明。</p><p>创建导航图资源文件，可以按以下步骤进行：</p><p>右键res-&gt; new -&gt; android resource file -&gt; resource type 选择Navigation，然后取个名字。</p><p><img src="https://pic.ziyuan.wang/2023/10/17/guest_a2c970b7a003e_IP210.22.23.7_UPTIME1697508605.png" alt="1697508603575.png"></p><p>新建的导航图资源文件是一个 XML 资源文件，以 <code>navigation</code> 为根节点，大致内容如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_graph&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="0-2-3-向-Activity-添加导航宿主（NavHost）"><a href="#0-2-3-向-Activity-添加导航宿主（NavHost）" class="headerlink" title="0.2.3 向 Activity 添加导航宿主（NavHost）"></a>0.2.3 向 Activity 添加导航宿主（NavHost）</h4><p>导航宿主是导航组件的核心部分之一，导航宿主是一个空容器，用来存放和处理目的地。导航宿主必须派生于 NavHost、 NavHostFragment 是导航组件的默认导航宿主实现，负责处理 <code>Fragment</code> 目的地的交换。</p><blockquote><p>注意：导航组件的设计理念是用于具有一个主 Activity 和多个 Fragment 目的地的应用，主 Activity 与导航图相关联，并且包含一个负责根据需要交换目的地的 NavHostFragment。如果您的应用需要在多个 Activity 上实现导航，就需要为每个 Activity 添加导航宿主，并在每个 Activity 关联其自己的导航图。</p></blockquote><ul><li><h5 id="通过-XML-添加-NavHostFragment"><a href="#通过-XML-添加-NavHostFragment" class="headerlink" title="通过 XML 添加 NavHostFragment"></a>通过 XML 添加 NavHostFragment</h5></li></ul><p> 在主 <code>Activity</code> 的布局文件中，添加 <code>&lt;fragment&gt;</code> 标签，并在内部指定导航图，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_host_fragment_content_main&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">&quot;@navigation/nav_graph&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>android:name</code> 属性包含 <code>NavHost</code> 实现类的名称（示例中使用的是默认实现 <code>NavHostFragment</code>，如果有需要，可以使用自定义的<code>Fragment</code>类，但是必须实现 <code>NavHost</code> 或者继承 <code>NavHostFragment</code>）</li><li><code>app:navGraph</code> 属性将导航宿主（<code>NavHostFragment</code>）与导航图关联，指向包含所有导航目的地的导航图资源文件</li><li><code>app:defaultNavHost=&quot;true&quot;</code> 属性确保导航宿主会拦截系统返回按钮。请注意，只能有一个默认导航宿主，如果同一布局（例如，双窗格布局）中有多个导航宿主，请务必仅指定一个默认导航宿主。</li></ul><blockquote><p>说明：导航组件是 Android Jetpack 部分，不属于 Android 系统组件，所以需要在布局中添加属性引入，如：<code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code></p></blockquote><ul><li><h5 id="向导航图中添加目的地"><a href="#向导航图中添加目的地" class="headerlink" title="向导航图中添加目的地"></a>向导航图中添加目的地</h5></li></ul><p>对于懒于编码的小伙伴可以使用 Navigation Editor 向导航中添加目的地，因为这些都是用户引导模式的，没什么可说，我这里主要讲一下手动添加目的地的步骤：</p><ol><li>新建 <code>Fragment</code> 类和布局文件，并实现相关逻辑代码；</li><li>在导航图 XML 中新增 <code>&lt;fragment&gt;</code> 标签；</li><li>配置 <code>&lt;fragment&gt;</code> 标签的相关属性，如：<code>android:id</code> 、<code>android:name</code> 、<code>android:lable</code> 等；</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_graph&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.uiwidgettest.FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/first_fragment_label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_first&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_FirstFragment_to_SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/SecondFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;work.icu007.uiwidgettest.SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/second_fragment_label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_second&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_SecondFragment_to_FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目的地属性详解</p><ul><li><p>Type：即标签名称，指示在源代码中，该目的地是作为 Fragment、Activity还是其他自定义类实现的</p></li><li><p>anroid:label：这个属性指定目的地的名称</p></li><li><p>android:id： 这个属性指定改目的地的ID，用于在代码中引用该目的地</p></li><li><p>android:name：这个属性用来指定目的地所关联的类 </p><p>除此之外，还可以通过tools:layout属性指定预览布局文件，这样就可以在导航图编辑器中看到对应的布局预览。</p></li><li><h5 id="指定起始目的地"><a href="#指定起始目的地" class="headerlink" title="指定起始目的地"></a>指定起始目的地</h5></li></ul><p>导航的原则之一就是固定的起始目的地，指定起始目的地的方法有两种，一种是使用 Navigation Editor，在 “Design”窗口中，选中需要指定为起始目的地的目标，点击 “房子”图标（如下图）即可。另一种方法就是在 XML 源代码中，在 <navigation> 标签中添加 app:startDestination 属性进行指定，属性值为需要指定的目的地的ID（如下示例）。</p><p><img src="https://pic.ziyuan.wang/2023/10/17/guest_917c91f48d9c3_IP210.22.23.7_UPTIME1697510923.png" alt="1697510921503.png"></p><p>或者在 xml 直接指定：<code>app:startDestination=&quot;@id/FirstFragment&quot;</code></p><ul><li><h5 id="连接目的地"><a href="#连接目的地" class="headerlink" title="连接目的地"></a>连接目的地</h5></li></ul><p>目的地之间的逻辑连接也叫做操作，操作一般是将一个目的地连接到另一个目的地，当然，你也可以定义 全局操作 ，这类操作可以在任意位置跳转到指定的目的地，这个我们在后面会详细讲到。<br>您可以使用 Navigation Editor 连接两个目的地，直接拖动箭头即可，在这里就不多介绍这种方式，直接介绍通过修改 XML 源码的方式（其实使用 Navigation Editor 也会自动修改 XML 源码），具体步骤如下：</p><ol><li>在 <code>&lt;fragment&gt;</code> 标签内部新增 <code>&lt;action&gt;</code> 标签;</li><li>配置<code>anroid:id</code>和<code>app:destnation</code> 属性；</li><li>如果需要，可配置<code>app:enterAnim</code>、<code>app:exitAnim</code>、<code>app:popEnterAnim</code>、<code>app:popExitAnim</code>属性定义动画。</li></ol><p>详细解说：</p><ul><li>**<code>Type</code>**：即 <code>&lt;action&gt;</code> 标签；</li><li>**<code>anroid:id</code>**：这个字段是操作ID，代码中通过这个ID执行操作；</li><li>**<code>app:destnation</code>**：这个字段是操作的目的地，用来指定操作跳转的目的地。</li></ul><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_FirstFragment_to_SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:destination</span>=<span class="string">&quot;@id/SecondFragment&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h5 id="导航到目的地"><a href="#导航到目的地" class="headerlink" title="导航到目的地"></a>导航到目的地</h5></li></ul><p>完成了导航图的各种配置，那么就需要在代码中实现导航到目的地了。导航到目的地是使用 NavController 完成的，这是在导航宿主中管理导航的对象的，每个导航宿主都有自己的相应导航控制器（<code>NavController</code>）。导航到目的地的步骤如下：</p><ol><li>检索导航控制器；</li><li>导航到目的地。</li></ol><ul><li><h6 id="检索导航控制器"><a href="#检索导航控制器" class="headerlink" title="检索导航控制器"></a>检索导航控制器</h6></li></ul><p>Kotlin：</p><ul><li>Fragment.findNavController()</li><li>View.findNavController()</li><li>Activity.findNavController(viewId: Int)</li></ul><p>Java：</p><ul><li>NavHostFragment.findNavController(Fragment)</li><li>Navigation.findNavController(Activity, @IdRes int viewId)</li><li>Navigation.findNavController(View)</li></ul><blockquote><p>说明：Kotlin可以直接在<code>Fragment</code>、<code>View</code>以及<code>Activity</code>使用<code>findNavController</code>是因为使用了扩展方法，当然，也可以直接跟Java那样调用对应的接口。</p></blockquote><ul><li><h6 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h6></li></ul><p>检索到导航控制器之后，使用导航控制器类的 <code>NavController.navigate()</code>API 导航到指定的目的地，<code>NavController.navigate()</code>有多个变体，这里就以使用目的地ID进行导航为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentFirstBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This property is only valid between onCreateView and</span></span><br><span class="line">    <span class="comment">// onDestroyView.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line"></span><br><span class="line">        _binding = FragmentFirstBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">        binding.buttonFirst.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// Kotlin 扩展方法检索当前导航宿主的导航控制器并导航到目的地</span></span><br><span class="line">            findNavController().navigate(R.id.action_FirstFragment_to_SecondFragment)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h6 id="返回到指定目的地"><a href="#返回到指定目的地" class="headerlink" title="返回到指定目的地"></a>返回到指定目的地</h6></li></ul><p>返回到指定的目的地，是指返回到之前导航过的目的地，这些目的地必须是在任务栈内的，可以通过 NavController.popBackStack() 接口返回上一级，或者通过 NavController.popBackStack (int destinationId, boolean inclusive) 返回到指定的某个目的地。</p><hr><h2 id="一、常用的控件使用方法"><a href="#一、常用的控件使用方法" class="headerlink" title="一、常用的控件使用方法"></a>一、常用的控件使用方法</h2><p>Android给我们提供了大量的UI控件，合理地使用这些控件就可以非常轻松地编写出相当不错的界面，下面我们就挑选几种常用的控件，详细介绍一下它们的使用方法。</p><h3 id="1-1-TextView"><a href="#1-1-TextView" class="headerlink" title="1.1 TextView"></a>1.1 TextView</h3><p>TextView可以说是Android中最简单的一个控件了，你在前面其实已经和它打过一些交道了。<br>它主要用于在界面上显示一段文本信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview_first&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/hello_first_fragment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在TextView中我们使用<code>android:id</code>给当前控件定义了一个唯一标识符，这个属性在上一章中已经讲解过了。然后使用<code>android:layout_width</code>和<code>android:layout_height</code>指定了控件的宽度和高度。Android中所有的控件都具有这两个属<br>性，可选值有3种：match_parent、wrap_content和固定值。<strong>match_parent表示让当前控件的大小和父布局的大小一样</strong>，也就是<strong>由父布局来决定当前控件的大小</strong>。<strong>wrap_content表示让当前控件的大小能够刚好包含住里面的内容</strong>，也就是<strong>由控件内容决定当前控件的大小</strong>。固定值表示表示给控件指定一个固定的尺寸，单位一般用dp，这是一种屏幕密度无关的尺寸单位，可以保证在不同分辨率的手机上显示效果尽可能地一致，如50 dp就是一个有效的固定值。</p><p>我们使用android:gravity来指定文字的对齐方式，可选值有top、bottom、start、end、center等，可以用“|”来同时指定多个值，这里我们指定的是”center”，效果等同于”center_vertical|center_horizontal”，表示文字在垂直和水平方向都居中对齐。</p><p>通过android:textColor属性可以指定文字的颜色，通过android:textSize属性可以指定文字的大小。文字大小要使用sp作为单位，这样当用户在系统中修改了文字显示尺寸时，应用程序中的文字大小也会跟着变化。</p><h3 id="1-2-Button"><a href="#1-2-Button" class="headerlink" title="1.2 Button"></a>1.2 Button</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/next&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/textview_first&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Android系统默认会将按钮上的英文字母全部转换成大写，可能是认为按钮上的内容都比较重要吧。如果这不是你想要的效果，可以在XML中添加android:textAllCaps&#x3D;”false”这个属性，这样系统就会保留你指定的原始文字内容了。</p><h3 id="1-3-EditText"><a href="#1-3-EditText" class="headerlink" title="1.3 EditText"></a>1.3 EditText</h3><p>EditText是程序用于和用户进行交互的另一个重要控件，它允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/edittext_test&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/textview_first&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-ImageView"><a href="#1-4-ImageView" class="headerlink" title="1.4 ImageView"></a>1.4 ImageView</h3><p>ImageView是用于在界面上展示图片的一个控件，它可以让我们的程序界面变得更加丰富多彩。图片通常是放在以drawable开头的目录下的，并且要带上具体的分辨率。现在最主流的手机屏幕分辨率大多是xxhdpi的，所以我们在res目录下再新建一个drawable-xxhdpi目录，然后将事先准备好的两张图片img_1.png和img_2.png复制到该目录当中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/img01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/textview_first&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>还可以通过调用ImageView的setImageResource()方法来改变ImageView中的图片</p><h3 id="1-5-ProgressBar"><a href="#1-5-ProgressBar" class="headerlink" title="1.5 ProgressBar"></a>1.5 ProgressBar</h3><p>ProgressBar用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。它的用法也<br>非常简单，修改布局文件中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/progressBar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/textview_first&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>Android控件的可见属性。所有的Android控件都具有这个属性，可以通过android:visibility进行指定，可选值有3种：visible、invisible和gone。visible表示控件是可见的，这个值是默认值，不指定android:visibility时，控件都是可见的。invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。gone则表示控件不仅不可见，而且不再占用任何屏幕空间。我们可以通过代码来设置控件的可见性，使用的是setVisibility()方法，允许传入View.VISIBLE、View.INVISIBLE和View.GONE这3种值。</p><p>我们还可以把进度条样式设置成水平进度条：<code>style=&quot;?android:attr/progressBarStyleHorizontal&quot;</code> 再加一个最大值 <code>android:max=&quot;100&quot;</code></p><p>还可以通过代码手动更新进度： <code>binding.progressBar.progress += 10</code></p><h3 id="1-6-AlertDialog"><a href="#1-6-AlertDialog" class="headerlink" title="1.6 AlertDialog"></a>1.6 AlertDialog</h3><p>AlertDialog可以在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽其他控件的交互能力，因此AlertDialog一般用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一下它的用法，修改代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder(<span class="keyword">this</span>.context).apply &#123;</span><br><span class="line">    setTitle(<span class="string">&quot;this is Dialog&quot;</span>)</span><br><span class="line">    setMessage(<span class="string">&quot;something important&quot;</span>)</span><br><span class="line">    setCancelable(<span class="literal">false</span>)</span><br><span class="line">    setPositiveButton(<span class="string">&quot;OK&quot;</span>)&#123;</span><br><span class="line">        dialog,which -&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*setNegativeButton(&quot;Cancel&quot;)&#123;</span></span><br><span class="line"><span class="comment">        dialog,which -&gt;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过AlertDialog.Builder构建一个对话框，这里我们使用了Kotlin标准函数中的apply函数。在apply函数中为这个对话框设置标题、内容、可否使用Back键关闭对话框等属性，接下来调用setPositiveButton()方法为对话框设置确定按钮的点击事件，调用setNegativeButton()方法设置取消按钮的点击事件，最后调用show()方法将对话框显示出来就可以了。</p><hr><h2 id="二、详解7种基本布局"><a href="#二、详解7种基本布局" class="headerlink" title="二、详解7种基本布局"></a>二、详解7种基本布局</h2><p>一个丰富的界面是由很多个控件组成的，那么我们如何才能让各个控件都有条不紊地摆放在界面上，而不是乱糟糟的呢？这就需要借助布局来实现了。布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面。当然，布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，我们就能够完成一些比较复杂的界面实现。</p><p><img src="https://pic.ziyuan.wang/2023/10/18/guest_974d4c96f8f85_IP210.22.23.7_UPTIME1697601554.png" alt="1697601553846.png"></p><p>下面我们就来详细学习一下Android中3种最基本的布局。</p><h3 id="2-1-LinearLayout线性布局"><a href="#2-1-LinearLayout线性布局" class="headerlink" title="2.1 LinearLayout线性布局"></a>2.1 LinearLayout线性布局</h3><blockquote><p>android:gravity：内部控件对齐方式，常用属性值有center、center_vertical、center_horizontal、top、bottom、left、right等。<br>这个属性在布局组件RelativeLayout、TableLayout中也有使用，FrameLayout、AbsoluteLayout则没有这个属性。<br>center：居中显示，这里并不是表示显示在LinearLayout的中心，当LinearLayout线性方向为垂直方向时，center表示水平居中，但是并不能垂直居中，此时等同于center_horizontal的作用；同样当线性方向为水平方向时，center表示垂直居中，等同于center_vertical。<br>top、bottom、left、right顾名思义为内部控件居顶、低、左、右布局。<br>这里要与android:layout_gravity区分开，layout_gravity是用来设置自身相对于父元素的布局。<br>android:layout_weight：权重，用来分配当前控件在剩余空间的大小。<br>使用权重一般要把分配该权重方向的长度设置为零，比如在水平方向分配权重，就把width设置为零</p></blockquote><p>LinearLayout又称作线性布局，是一种非常常用的布局。正如它的名字所描述的一样，这个布局会将它所包含的控件在线性方向上依次排列。相信你之前也已经注意到了，我们在上一节中学习控件用法时，所有的控件就都是放在LinearLayout布局里的，因此上一节中的控件也确实是在垂直方向上线性排列的。</p><p>既然是线性排列，肯定就不只有一个方向，那为什么上一节中的控件都是在垂直方向排列的呢？这是由于我们通过android:orientation属性指定了排列方向是vertical，如果指定的是horizontal，控件就会在水平方向上排列了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意，如果LinearLayout的排列方向是horizontal，内部的控件就绝对不能将宽度指定为match_parent，否则，单独一个控件就会将整个水平方向占满，其他的控件就没有可放置的位置了。同样的道理，如果LinearLayout的排列方向是vertical，内部的控件就不能将高度指定为match_parent。</p><p>android:layout_gravity属性，它和我们上一节中学到的android:gravity属性看起来有些相似，这两个属性有什么区别呢？其实从名字就可以看出，android:gravity用于指定文字在控件中的对齐方式，而android:layout_gravity用于指定控件在布局中的对齐方式。android:layout_gravity的可选值和android:gravity差不多，但是需要注意，当LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效。因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;top&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>android:layout_weight。这个属性允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要的作用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/editText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;top&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面将EditText设置成 <code>android:layout_weight=&quot;2&quot;</code> Button设置成 <code>android:layout_weight=&quot;1&quot;</code>这样在水平方向EditText就占2&#x2F;3，Button占1&#x2F;3.</p><h3 id="2-2-RelativeLayout相对布局"><a href="#2-2-RelativeLayout相对布局" class="headerlink" title="2.2 RelativeLayout相对布局"></a>2.2 RelativeLayout相对布局</h3><blockquote><p>相对布局可以让子控件相对于兄弟控件或父控件进行布局，可以设置子控件相对于兄弟控件或父控件进行上下左右对齐。<br>RelativeLayout能替换一些嵌套视图，当我们用LinearLayout来实现一个简单的布局但又使用了过多的嵌套时，就可以考虑使用RelativeLayout重新布局。<br>相对布局就是一定要加Id才能管理。</p><p>RelativeLayout中子控件常用属性：<br>1、相对于父控件，例如：android:layout_alignParentTop&#x3D;“true”<br>android:layout_alignParentTop      控件的顶部与父控件的顶部对齐;<br>android:layout_alignParentBottom  控件的底部与父控件的底部对齐;<br>android:layout_alignParentLeft      控件的左部与父控件的左部对齐;<br>android:layout_alignParentRight     控件的右部与父控件的右部对齐;</p><p>2、相对给定Id控件，例如：android:layout_above&#x3D;“@id&#x2F;**”<br>android:layout_above 控件的底部置于给定ID的控件之上;<br>android:layout_below     控件的底部置于给定ID的控件之下;<br>android:layout_toLeftOf    控件的右边缘与给定ID的控件左边缘对齐;<br>android:layout_toRightOf  控件的左边缘与给定ID的控件右边缘对齐;<br>android:layout_alignBaseline  控件的baseline与给定ID的baseline对齐;<br>android:layout_alignTop        控件的顶部边缘与给定ID的顶部边缘对齐;<br>android:layout_alignBottom   控件的底部边缘与给定ID的底部边缘对齐;<br>android:layout_alignLeft       控件的左边缘与给定ID的左边缘对齐;<br>android:layout_alignRight      控件的右边缘与给定ID的右边缘对齐;</p><p>3、居中，例如：android:layout_centerInParent&#x3D;“true”<br>android:layout_centerHorizontal 水平居中;<br>android:layout_centerVertical    垂直居中;<br>android:layout_centerInParent  父控件的中央;</p></blockquote><p>RelativeLayout又称作相对布局，也是一种非常常用的布局。和LinearLayout的排列规则不同，RelativeLayout显得更加随意，它可以通过相对定位的方式让控件出现在布局的任何位置。也正因为如此，RelativeLayout中的属性非常多，不过这些属性都是有规律可循的，其实并不难理解和记忆。我们还是通过实践来体会一下，修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button5&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们让Button 1和父布局的左上角对齐，Button 2和父布局的右上角对齐，Button 3居中显示，Button 4和父布局的左下角对齐，Button 5和父布局的右下角对齐。虽然android:layout_alignParentLeft、android:layout_alignParentTop、android:layout_alignParentRight、android:layout_alignParentBottom、android:layout_centerInParent这几个属性我们之前都没接触过，可是它们的名字已经完全说明了它们的作用。</p><p>上面例子中的每个控件都是相对于父布局进行定位的，那控件可不可以相对于控件进行定位呢？当然是可以的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toLeftOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 3&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toLeftOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 4&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button5&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 5&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这次的代码稍微复杂一点，不过仍然是有规律可循的。android:layout_above属性可以让一个控件位于另一个控件的上方，需要为这个属性指定相对控件id的引用，这里我们填入了@id&#x2F;button3，表示让该控件位于Button 3的上方。其他的属性也是相似的，android:layout_below表示让一个控件位于另一个控件的下方，android:layout_toLeftOf表示让一个控件位于另一个控件的左侧，android:layout_toRightOf表示让一个控件位于另一个控件的右侧。注意，当一个控件去引用另一个控件的id时，该控件一定要定义在引用控件的后面，不然会出现找不到id的情况。</p><p>RelativeLayout中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight表示让一个控件的右边缘和另一个控件的右边缘对齐。此外，还有android:layout_alignTop和android:layout_alignBottom，道理都是一样的。</p><h3 id="2-3-FrameLayout帧布局"><a href="#2-3-FrameLayout帧布局" class="headerlink" title="2.3 FrameLayout帧布局"></a>2.3 FrameLayout帧布局</h3><blockquote><p>帧布局或叫层布局，从屏幕左上角按照层次堆叠方式布局，后面的控件覆盖前面的控件。<br>该布局在开发中设计地图经常用到，因为是按层次方式布局，我们需要实现层面显示的样式时就可以<br>采用这种布局方式，比如我们要实现一个类似百度地图的布局，我们移动的标志是在一个图层的上面。<br>在普通功能的软件设计中用得也不多。层布局主要应用就是地图方面。</p></blockquote><p>FrameLayout又称作帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景少了很多。这种布局没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角。让我们通过例子来看一看吧.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is TextView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有添加gravity属性，文字和按钮都位于布局的左上角。由于Button是在TextView之后添加的，因此按钮压在了文字的上面。当然，除了这种默认效果之外，我们还可以使用layout_gravity属性来指定控件在布局中的对齐方式，这和LinearLayout中的用法是相似的。</p><h3 id="2-4-AbsoluteLayout绝对布局"><a href="#2-4-AbsoluteLayout绝对布局" class="headerlink" title="2.4 AbsoluteLayout绝对布局"></a>2.4 AbsoluteLayout绝对布局</h3><p>绝对布局是前端布局中最为简单的布局，但灵活性极差，不具有自动适应设备分辨率的能力，就好比在手机上设置的布局，在平板上布局就会全部混乱，所以在日常开发中很少使用绝对布局。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>layout_width</td><td>设置组件的宽度</td></tr><tr><td>layout_height</td><td>设置组件的高度</td></tr><tr><td>layout_x</td><td>设置组件的X坐标</td></tr><tr><td>layout_y</td><td>设置组件的Y坐标</td></tr></tbody></table><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AbsoluteLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;账号: &quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;350dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;250dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;110dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;350dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;密码: &quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;420dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;250dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;110dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;420dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;500dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;登录&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;210dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;500dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;注册&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">AbsoluteLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-TableLayout表格布局"><a href="#2-5-TableLayout表格布局" class="headerlink" title="2.5 TableLayout表格布局"></a>2.5 TableLayout表格布局</h3><p>表格布局就是类似于excel中的表格，每个“单元格”的位置都是由行与列共同决定，最后组件元素放入某个“单元格”进行布局定位，以达到最终的布局效果。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>collapseColumns</td><td>设置需要被隐藏的列的列序号</td></tr><tr><td>shrinkColumns</td><td>设置允许被收缩的列的列序号</td></tr><tr><td>stretchColumns</td><td>设置允许被拉伸的列的列序号</td></tr><tr><td>layout_column</td><td>设置跳过指定的列，组件元素从下一列开始显示</td></tr><tr><td>layout_span</td><td>合并指定列数的单元格</td></tr></tbody></table><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TableLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    //第一行</span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;用户名：&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;40px&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:minWidth</span>=<span class="string">&quot;200px&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;40px&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //第二行</span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;密  码：&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;40px&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:minWidth</span>=<span class="string">&quot;200px&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;40px&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //第三行</span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;登 录&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;40px&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;#00BCD4&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;注 册&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;40px&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;#FFC107&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">TableLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6-GridLayout网格布局"><a href="#2-6-GridLayout网格布局" class="headerlink" title="2.6 GridLayout网格布局"></a>2.6 GridLayout网格布局</h3><p>网格布局容器属性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>orientation</td><td>设置布局中组件的排列方式，<code>vertical</code>与<code>horizontal</code></td></tr><tr><td>layout_gravity</td><td>设置布局容器的对齐方式，<code>center</code>、<code>bottom</code>等等</td></tr><tr><td>rowCount</td><td>设置网格布局有多少行</td></tr><tr><td>columnCount</td><td>设置网格布局有多少列</td></tr></tbody></table><p>网格布局组件属性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>layout_row</td><td>设置组件位于布局中的某一行</td></tr><tr><td>layout_column</td><td>设置组件位于布局中的某一列</td></tr><tr><td>layout_rowSpan</td><td>设置组件横跨几行</td></tr><tr><td>layout_columnSpan</td><td>设置组件横跨几列</td></tr></tbody></table><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GridLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/GridLayout1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:columnCount</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center|top&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:rowCount</span>=<span class="string">&quot;6&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_row</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_columnSpan</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/setbar_bg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;50sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_columnWeight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;1/X&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_columnWeight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;X^2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_columnWeight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;根号x&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;%&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;CE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;C&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_columnSpan</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;X&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;1/X&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;X^2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;根号x&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;7&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;9&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;X&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;-&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;+&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;+/-&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;.&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;fill&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;=&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#92c2e8&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">GridLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-7-ConstraintLayout约束布局"><a href="#2-7-ConstraintLayout约束布局" class="headerlink" title="2.7 ConstraintLayout约束布局"></a>2.7 <strong>ConstraintLayout</strong>约束布局</h3><blockquote><p>ConstraintLayout 是一个使用“相对定位”灵活地确定微件的位置和大小的一个布局，在 2016 年 Google I&#x2F;O 中面世，它的出现是为了解决开发中过于复杂的页面层级嵌套过多的问题——层级过深会增加绘制界面需要的时间，影响用户体验，以灵活的方式定位和调整小部件。从 Android Studio 2.3起，创建layout文件就已经是默认ConstraintLayout了</p></blockquote><h4 id="2-7-1-布局的使用"><a href="#2-7-1-布局的使用" class="headerlink" title="2.7.1 布局的使用"></a>2.7.1 布局的使用</h4><h5 id="2-7-1-1-位置约束"><a href="#2-7-1-1-位置约束" class="headerlink" title="2.7.1.1 位置约束"></a>2.7.1.1 位置约束</h5><blockquote><p><code>ConstraintLayout</code>采用方向约束的方式对控件进行定位，至少要保证水平和垂直方向都至少有一个约束才能确定控件的位置</p></blockquote><h6 id="1-基本方向布局"><a href="#1-基本方向布局" class="headerlink" title="1 基本方向布局"></a>1 基本方向布局</h6><p>比如我们想实现这个位置，顶部和界面顶部对齐，左部和界面左部对齐：</p><p><img src="https://pic.ziyuan.wang/2023/10/19/guest_1f9b53a9ca9f7_IP210.22.23.7_UPTIME1697697653.png" alt="1697697651050.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.UILayoutTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;220dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/img01&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is TextView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#ffffff&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">&quot;HardcodedText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_finish&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Finish&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br></pre></td></tr></table></figure><blockquote><p>这两行代码的意思就是,控件的开始方向与父容器的开始方向对齐，控件的顶部方向与父容器的顶部方向对齐，其实layout_constraintStart_toStartOf也可以使用layout_constraintLeft_toLeftOf，但是使用start和end来表示左和右是为了考虑别的国家的习惯，有的国家开始方向是右，所以使用start和end可以兼容这种情况。到这里就可以看到该控件使用layout_constraintStart_toStartOf和layout_constraintTop_toTopOf两条约束确定了自己的位置，这里有一个使用技巧，就是，该控件的？？方向在哪个控件的？？方向，记住这一点就可以了。那么下面就介绍下全部的约束属性：</p></blockquote><table><thead><tr><th align="center">基本方向约束</th><th align="center">我的什么位置在谁的什么位置</th></tr></thead><tbody><tr><td align="center">app:layout_constraintTop_toTopOf&#x3D;””</td><td align="center">我的顶部和谁的顶部对齐</td></tr><tr><td align="center">app:layout_constraintBottom_toBottomOf&#x3D;””</td><td align="center">我的底部和谁的底部对齐</td></tr><tr><td align="center">app:layout_constraintLeft_toLeftOf&#x3D;””</td><td align="center">我的左边和谁的左边对齐</td></tr><tr><td align="center">app:layout_constraintRight_toRightOf&#x3D;””</td><td align="center">我的右边和谁的右边对齐</td></tr><tr><td align="center">app:layout_constraintStart_toStartOf&#x3D;””</td><td align="center">我的开始位置和谁的开始位置对齐</td></tr><tr><td align="center">app:layout_constraintEnd_toEndOf&#x3D;””</td><td align="center">我的结束位置和谁的结束位置对齐</td></tr><tr><td align="center">app:layout_constraintTop_toBottomOf&#x3D;””</td><td align="center">我的顶部位置在谁的底部位置</td></tr><tr><td align="center">app:layout_constraintStart_toEndOf&#x3D;””</td><td align="center">我的开始位置在谁的结束为止</td></tr></tbody></table><p>那么<code>ConstraintLayout</code>就是使用这些属性来确定控件的位置，虽然比较多，但是有规律可循，没有任何记忆压力</p><h6 id="2-基线对齐"><a href="#2-基线对齐" class="headerlink" title="2 基线对齐"></a>2 基线对齐</h6><p>比如我们需要实现这样的需求</p><p><img src="https://pic.ziyuan.wang/2023/10/19/guest_f952016181c6f_IP210.22.23.7_UPTIME1697698699.png" alt="1697698697496.png"></p><p>两个文本是基线对齐的，那就可以用到我们的一个属性<code>layout_constraintBaseline_toBaselineOf</code>来实现，它的意思就是这个控件的基线与谁的基线对齐，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewPrice&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#673AB7&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;50sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/button_finish&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewCurrency&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBaseline_toBaselineOf</span>=<span class="string">&quot;@+id/textViewPrice&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/textViewPrice&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;￥&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#673AB7&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h6 id="3-角度约束"><a href="#3-角度约束" class="headerlink" title="3 角度约束"></a>3 角度约束</h6><p>有些时候我们需要一个控件在某个控件的某个角度的位置，那么通过其他的布局其实是不太好实现的，但是<code>ConstraintLayout</code>为我们提供了角度位置相关的属性</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">app:layout_constraintCircle&#x3D;””</td><td align="center">设置目标控件id</td></tr><tr><td align="center">app:layout_constraintCircleAngle&#x3D;””</td><td align="center">设置对于目标的角度(0-360)</td></tr><tr><td align="center">app:layout_constraintCircleRadius&#x3D;””</td><td align="center">设置到目标中心的距离</td></tr></tbody></table><p><img src="https://pic.ziyuan.wang/2023/10/19/guest_3cbe062341685_IP210.22.23.7_UPTIME1697700881.png" alt="1697700880378.png"></p><p>比如我们要实现这个效果就可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/img01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/img01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/textViewCurrency&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textViewCurrency&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/img02&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/img02&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintCircle</span>=<span class="string">&quot;@+id/img01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintCircleAngle</span>=<span class="string">&quot;45&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintCircleRadius</span>=<span class="string">&quot;70dp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h6 id="4-百分比偏移"><a href="#4-百分比偏移" class="headerlink" title="4 百分比偏移"></a>4 百分比偏移</h6><p>有的时候我们需要让控件在父布局的水平方向或垂直方向的百分之多少的位置，可以使用如下属性：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">app:layout_constraintHorizontal_bias&#x3D;””</td><td align="center">设置水平偏移（取值范围是0-1的小数）</td></tr><tr><td align="center">app:layout_constraintVertical_bias&#x3D;””</td><td align="center">设置垂直偏移（取值范围是0-1的小数）</td></tr></tbody></table><p>如果想实现这个效果，可以这样写：</p><p><img src="https://pic.ziyuan.wang/2023/10/19/guest_f9c488e8bbfd8_IP210.22.23.7_UPTIME1697702283.png" alt="1697702282502.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;220dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/img01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;This is TextView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#ffffff&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;HardcodedText&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-7-1-2-控件内边距、外边距、GONE-Margin"><a href="#2-7-1-2-控件内边距、外边距、GONE-Margin" class="headerlink" title="2.7.1.2 控件内边距、外边距、GONE Margin"></a>2.7.1.2 控件内边距、外边距、GONE Margin</h5><blockquote><p><code>ConstraintLayout</code>的内边距和外边距的使用方式其实是和其他布局一致的</p></blockquote><table><thead><tr><th align="center">外边距</th><th align="center">内边距</th></tr></thead><tbody><tr><td align="center">android:layout_margin&#x3D;”0dp”</td><td align="center">android:padding&#x3D;”0dp”</td></tr><tr><td align="center">android:layout_marginStart&#x3D;”0dp”</td><td align="center">android:padding&#x3D;”0dp”</td></tr><tr><td align="center">android:layout_marginLeft&#x3D;”0dp”</td><td align="center">android:paddingLeft&#x3D;”0dp”</td></tr><tr><td align="center">android:layout_marginTop&#x3D;”0dp”</td><td align="center">android:paddingTop&#x3D;”0dp”</td></tr><tr><td align="center">android:layout_marginEnd&#x3D;”0dp”</td><td align="center">android:paddingEnd&#x3D;”0dp”</td></tr><tr><td align="center">android:layout_marginRight&#x3D;”0dp”</td><td align="center">android:paddingRight&#x3D;”0dp”</td></tr><tr><td align="center">android:layout_marginBottom&#x3D;”0dp”</td><td align="center">android:paddingBottom&#x3D;”0dp”</td></tr></tbody></table><blockquote><p><code>ConstraintLayout</code>除此之外还有<code>GONE Margin</code>，当依赖的目标<code>view</code>隐藏时会生效的属性，例如B被A依赖约束，当B隐藏时B会缩成一个点，自身的<code>margin</code>效果失效，A设置的<code>GONE Margin</code>就会生效，属性如下：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  GONE Margin  --&gt;</span></span><br><span class="line">app:layout_goneMarginBottom=&quot;0dp&quot;</span><br><span class="line">app:layout_goneMarginEnd=&quot;0dp&quot;</span><br><span class="line">app:layout_goneMarginLeft=&quot;0dp&quot;</span><br><span class="line">app:layout_goneMarginRight=&quot;0dp&quot;</span><br><span class="line">app:layout_goneMarginStart=&quot;0dp&quot;</span><br><span class="line">app:layout_goneMarginTop=&quot;0dp&quot;</span><br></pre></td></tr></table></figure><p>比如下述代码：textView不可见时，button_finish的Top间距会变为100dp。也就是说textView不可见时，button_finish的<code>app:layout_goneMarginTop</code>属性就会生效</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;220dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/img01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;This is TextView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#ffffff&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;HardcodedText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_finish&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Finish&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_goneMarginTop</span>=<span class="string">&quot;100dp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-7-1-3-控件尺寸"><a href="#2-7-1-3-控件尺寸" class="headerlink" title="2.7.1.3 控件尺寸"></a>2.7.1.3 控件尺寸</h5><h6 id="1-尺寸限制"><a href="#1-尺寸限制" class="headerlink" title="1 尺寸限制"></a>1 尺寸限制</h6><blockquote><p>在<code>ConstraintLayout</code>中提供了一些尺寸限制的属性，可以用来限制最大、最小宽高度，这些属性只有在给出的宽度或高度为<code>wrap_content</code>时才会生效，比如想给宽度设置最小或最大值，那宽度就必须设置为<code>wrap_content</code>，这个比较简单就不放示例代码了，具体的属性如下：</p></blockquote><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">android:minWidth&#x3D;””</td><td align="center">设置view的最小宽度</td></tr><tr><td align="center">android:minHeight&#x3D;””</td><td align="center">设置view的最小高度</td></tr><tr><td align="center">android:maxWidth&#x3D;””</td><td align="center">设置view的最大宽度</td></tr><tr><td align="center">android:maxHeight&#x3D;””</td><td align="center">设置view的最大高度</td></tr></tbody></table><h6 id="2-0dp-MATCH-CONSTRAINT"><a href="#2-0dp-MATCH-CONSTRAINT" class="headerlink" title="2 0dp(MATCH_CONSTRAINT)"></a>2 0dp(MATCH_CONSTRAINT)</h6><blockquote><p>设置view的大小除了传统的wrap_content、指定尺寸、match_parent外，ConstraintLayout还可以设置为0dp（MATCH_CONSTRAINT），并且0dp的作用会根据设置的类型而产生不同的作用，进行设置类型的属性是layout_constraintWidth_default和layout_constraintHeight_default，取值可为spread、percent、wrap。具体的属性及示例如下：</p></blockquote><p><code>app:layout_constraintWidth_default=&quot;spread|percent|wrap&quot;</code> <code>app:layout_constraintHeight_default=&quot;spread|percent|wrap&quot;</code></p><ul><li><strong>spread（默认）</strong>：占用所有的符合约束的空间</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewTest&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;AAA水果批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_default</span>=<span class="string">&quot;spread&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到，view的宽度适应了所有有效的约束空间，左右留出了margin的设置值50dp，这种效果就就是：自身view的大小充满可以配置的剩余空间，因为左右约束的都是父布局，所以view可配置的空间是整个父布局的宽度，又因为设置了margin，所以会留出margin的大小，因为spread是默认值，所以可以不写 app:layout_constraintWidth_default&#x3D;”spread”。</p></blockquote><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_5ce2a91c00179_IP210.22.23.7_UPTIME1697773202.png" alt="1697773200939.png"></p><ul><li><strong>percent</strong>: 按照父布局的百分比设置</li></ul><blockquote><p>percent模式的意思是自身view的尺寸是父布局尺寸的一定比例，上图所展示的是宽度是父布局宽度的0.5（50%，取值是0-1的小数），该模式需要配合layout_constraintWidth_percent使用，但是写了layout_constraintWidth_percent后，layout_constraintWidth_default&#x3D;”percent”其实就可以省略掉了。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewTest&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;AAA水果批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_default</span>=<span class="string">&quot;percent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_percent</span>=<span class="string">&quot;0.3&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_4d3c5295d3427_IP210.22.23.7_UPTIME1697773523.png" alt="1697773522381.png"></p><ul><li><strong>wrap</strong>：匹配内容大小但不超过约束限制</li></ul><blockquote><p>这里写了两个控件作为对比，控件A宽度设置为wrap_content，宽度适应内容大小，并且设置了margin，但是显然宽度已经超过margin的设置值了，而控件B宽度设置为0dp wrap模式，宽度适应内容大小，并且不会超过margin的设置值，也就是不会超过约束限制，这就是这两者的区别。Google还提供了两个属性用于强制约束：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewFruit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;AAAAAAA水果批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_default</span>=<span class="string">&quot;spread&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewVegetable&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;AAAAAAA蔬菜批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_default</span>=<span class="string">&quot;wrap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_944871a114b2d_IP210.22.23.7_UPTIME1697781483.png" alt="1697781482210.png"></p><blockquote><!--  当一个view的宽或高,设置成wrap_content时  --><p>app:layout_constrainedWidth&#x3D;”true|false”<br>app:layout_constrainedHeight&#x3D;”true|false”</p></blockquote><p>如果上述代码将控件A设置了强制约束，展示出的效果和控件B是一样的了。</p><p>除此之外，<code>0dp</code>还有一些其他的独特属性用于设置尺寸的大小限制：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">app:layout_constraintWidth_min&#x3D;””</td><td align="center">0dp下，<strong>宽度</strong>的最<strong>小</strong>值</td></tr><tr><td align="center">app:layout_constraintHeight_min&#x3D;””</td><td align="center">0dp下，<strong>高度</strong>的最小值</td></tr><tr><td align="center">app:layout_constraintWidth_max&#x3D;””</td><td align="center">0dp下，<strong>宽度</strong>的最<strong>大</strong>值</td></tr><tr><td align="center">app:layout_constraintHeight_max&#x3D;””</td><td align="center">0dp下，<strong>高度</strong>的最<strong>大</strong>值</td></tr></tbody></table><h6 id="3-比例宽高"><a href="#3-比例宽高" class="headerlink" title="3 比例宽高"></a>3 比例宽高</h6><blockquote><p><code>ConstraintLayout</code>中可以对宽高设置比例，前提是至少有一个约束维度设置为<code>0dp</code>，这样比例才会生效，该属性可使用两种设置：<br>1.浮点值，表示宽度和高度之间的比率<br>2.宽度:高度，表示宽度和高度之间形式的比率</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewVegetable&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;AAAAAAA蔬菜批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">&quot;10:3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_default</span>=<span class="string">&quot;wrap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>比如上述代码：<code>android:layout_height=&quot;60dp&quot;</code>但是width确实0dp，这个时候设置 <code>app:layout_constraintDimensionRatio=&quot;10:3&quot;</code>就表明宽高比为 10:3 那么width就会变成200dp</p><h5 id="2-7-1-4-Chains"><a href="#2-7-1-4-Chains" class="headerlink" title="2.7.1.4 Chains"></a>2.7.1.4 Chains</h5><blockquote><p>Chains(链)也是一个非常好用的特性，它是将许多个控件在水平或者垂直方向，形成一条链，用于平衡这些控件的位置，那么如何形成一条链呢？形成一条链要求链中的控件在水平或者垂直方向，首尾互相约束，这样就可以形成一条链，水平方向互相约束形成的就是一条水平链，反之则是垂直链，下面看示例：</p></blockquote><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_8e874243c695f_IP210.22.23.7_UPTIME1697783699.png" alt="1697783697533.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewFruit&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;A水果批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/textViewVegetable&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_chainStyle</span>=<span class="string">&quot;spread&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewVegetable&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;A蔬菜批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/textViewFruit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>textViewFruit和textViewVegetable控件在水平方向上首尾互相约束，这样就形成了一条水平链，他们默认的模式是spread，均分剩余空间，我们可以使用layout_constraintHorizontal_chainStyle和layout_constraintVertical_chainStyle分别对水平和垂直链设置模式，模式可选的值有：spread、packed、spread_inside。</p><ul><li><strong>spread（默认）</strong>：均分剩余空间</li></ul><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_8e874243c695f_IP210.22.23.7_UPTIME1697783699.png" alt="1697783697533.png"></p><ul><li><strong>spread_inside</strong>：两侧的控件贴近两边，剩余的控件均分剩余空间</li></ul><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_0046bfa66c4d1_IP210.22.23.7_UPTIME1697783952.png" alt="1697783950544.png"></p><ul><li><strong>packed</strong>：所有控件贴紧居中</li></ul><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20231020143955874.png" alt="image-20231020143955874"></p><p><code>Chains(链)</code>还支持<code>weight（权重）</code>的配置，使用<code>layout_constraintHorizontal_weight</code>和<code>layout_constraintVertical_weight</code>进行设置链元素的权重</p><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_f9a5843454f59_IP210.22.23.7_UPTIME1697784463.png" alt="1697784461286.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewFruit&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;A水果批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/textViewVegetable&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_chainStyle</span>=<span class="string">&quot;spread&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewVegetable&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;A蔬菜批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/textViewFruit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_weight</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>比如说这里权重比就是 2:1 那么Fruit就占2&#x2F;3，Vegetable占 1&#x2F;3。并且使用权重时对应的宽度或者高度要改为0dp</p><h4 id="2-7-2-辅助类"><a href="#2-7-2-辅助类" class="headerlink" title="2.7.2 辅助类"></a>2.7.2 辅助类</h4><blockquote><p><code>ConstraintLayout</code>为了解决嵌套问题还提供了一系列的辅助控件帮助开发者布局，这些工具十分的方便，我在日常开发工作中也是使用的非常频繁</p></blockquote><h5 id="2-7-2-1-Guideline（参考线）"><a href="#2-7-2-1-Guideline（参考线）" class="headerlink" title="2.7.2.1 Guideline（参考线）"></a>2.7.2.1 Guideline（参考线）</h5><blockquote><p>Guideline是一条参考线，可以帮助开发者进行辅助定位，并且实际上它并不会真正显示在布局中，像是数学几何中的辅助线一样，使用起来十分方便，出场率很高，Guideline也可以用来做一些百分比分割之类的需求，有着很好的屏幕适配效果，Guideline有水平和垂直方向之分，位置可以使用针对父级的百分比或者针对父级位置的距离。</p></blockquote><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">android:orientation&#x3D;”horizontal|vertical”</td><td align="center">辅助线的对齐方式</td></tr><tr><td align="center">app:layout_constraintGuide_percent&#x3D;”0-1”</td><td align="center">距离父级宽度或高度的百分比(小数形式)</td></tr><tr><td align="center">app:layout_constraintGuide_begin&#x3D;””</td><td align="center">距离父级起始位置的距离(左侧或顶部)</td></tr><tr><td align="center">app:layout_constraintGuide_end&#x3D;””</td><td align="center">距离父级结束位置的距离(右侧或底部)</td></tr></tbody></table><p><img src="https://pic.ziyuan.wang/2023/10/20/guest_8c346b6c79397_IP210.22.23.7_UPTIME1697785851.png" alt="1697785850352.png"></p><p>比如要实现这样的效果就可以这么写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideLine&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;.3&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textViewFruit&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;A水果批发&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#abfa00&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideLine&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-7-2-2-Barrier（屏障）"><a href="#2-7-2-2-Barrier（屏障）" class="headerlink" title="2.7.2.2 Barrier（屏障）"></a>2.7.2.2 Barrier（屏障）</h5><p>这个<code>Barrier</code>和<code>Guideline</code>一样，也不会实际出现在布局中，它的作用如同其名，形成一个屏障、障碍，使用也非常多。</p><p>比如我们下面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;warehouse&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;warehouse house&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/textView1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/text3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>效果是这样的</p><p><img src="https://pic.ziyuan.wang/2023/10/23/guest_5bb3d887d5194_IP210.22.23.7_UPTIME1698027243.png" alt="1698027242366.png"></p><p>可以发现因为 textView2 字符过长，导致有一部分text被遮挡了。</p><p>其实这里我们是可以优化的，那要怎么优化呢?也很简单，只需要加一个 Barrier就可以了。让textView3 Start_toEndOf于Barrier。优化后效果如图</p><p><img src="https://pic.ziyuan.wang/2023/10/23/guest_3f61840a217e6_IP210.22.23.7_UPTIME1698027109.png" alt="1698027107734.png"></p><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;warehouse&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;warehouse house&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/textView1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Barrier</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/barrier&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:barrierDirection</span>=<span class="string">&quot;end&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:constraint_referenced_ids</span>=<span class="string">&quot;textView2,textView1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/text3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/barrier&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-7-2-3-Group（组）"><a href="#2-7-2-3-Group（组）" class="headerlink" title="2.7.2.3 Group（组）"></a>2.7.2.3 Group（组）</h5><blockquote><p>工作当中常常会有很多个控件同时隐藏或者显示的场景，传统做法要么是进行嵌套，对父布局进行隐藏或显示，要么就是一个一个设置，这显然都不是很好的办法，ConstraintLayout中的Group就是来解决这个问题的。Group的作用就是可以对一组控件同时隐藏或显示，没有其他的作用，它的属性如下：</p></blockquote><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">app:constraint_referenced_ids&#x3D;”id,id”</td><td align="center">加入组的控件id</td></tr></tbody></table><p>拿上面的代码举个栗子🌰</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Group</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">&quot;visible&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:constraint_referenced_ids</span>=<span class="string">&quot;textView1,textView2,textView3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们将 textView1-3 都加入到组中，当我们设置visibility的值时，这三个textView会一起改变。</p><h5 id="2-7-2-4-Placeholder（占位符）"><a href="#2-7-2-4-Placeholder（占位符）" class="headerlink" title="2.7.2.4 Placeholder（占位符）"></a>2.7.2.4 Placeholder（占位符）</h5><blockquote><p><code>Placeholder</code>的作用就是占位，它可以在布局中占好位置，通过<code>app:content=&quot;&quot;</code>属性，或者动态调用<code>setContent()</code>设置内容，来让某个控件移动到此占位符中</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Placeholder</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:content</span>=<span class="string">&quot;@id/textView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当我们设置<code>app:content=&quot;@+id/A&quot;</code>或者调用<code>setContent()</code>时，控件A就会被移动到<code>Placeholder</code>中，当然在布局中使用<code>app:content=&quot;&quot;</code>显然就失去了它的作用。</p><h5 id="2-7-2-5-Flow（流式虚拟布局）"><a href="#2-7-2-5-Flow（流式虚拟布局）" class="headerlink" title="2.7.2.5 Flow（流式虚拟布局）"></a>2.7.2.5 Flow（流式虚拟布局）</h5><blockquote><p>Flow是用于构建链的新虚拟布局，当链用完时可以缠绕到下一行甚至屏幕的另一部分。当您在一个链中布置多个项目时，这很有用，但是您不确定容器在运行时的大小。您可以使用它来根据应用程序中的动态尺寸（例如旋转时的屏幕宽度）构建布局。Flow是一种虚拟布局。在ConstraintLayout中，虚拟布局(Virtual layouts)作为virtual view group的角色参与约束和布局中，但是它们并不会作为视图添加到视图层级结构中，而是仅仅引用其它视图来辅助它们在布局系统中完成各自的布局功能。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.helper.widget.Flow</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:constraint_referenced_ids</span>=<span class="string">&quot;A,B,C,D,E&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>链约束</p><blockquote><p>Flow的constraint_referenced_ids关联的控件是没有设置约束的，这一点和普通的链是不一样的，这种排列方式是Flow的默认方式none，我们可以使用app:flow_wrapMode&#x3D;””属性来设置排列方式，并且我们还可以使用flow_horizontalGap和flow_verticalGap分别设置两个view在水平和垂直方向的间隔，下面我们再添加几个控件来展示三种排列方式：</p></blockquote><ul><li>none（默认值）： 所有引用的<code>view</code>形成一条链，水平居中，超出屏幕两侧的<code>view</code>不可见</li><li>chain： 所引用的<code>view</code>形成一条链，超出部分会自动换行，同行的<code>view</code>会平分宽度。</li><li>aligned： 所引用的<code>view</code>形成一条链，但<code>view</code>会在同行同列。</li></ul><p>当<code>flow_wrapMode</code>的值是<code>chian</code>或<code>aligned</code>时，我们还可以针对不同的链进行配置，这里就不一一展示效果了，具体的属性如下：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">app:flow_horizontalStyle&#x3D;”packed｜spread｜spread_inside”</td><td align="center">所有水平链的配置</td></tr><tr><td align="center">app:flow_verticalStyle&#x3D;”packed｜spread｜spread_inside”</td><td align="center">所有垂直链的配置</td></tr><tr><td align="center">app:flow_firstHorizontalStyle&#x3D;”packed｜spread｜spread_inside”</td><td align="center">第一条水平链的配置，其他条不生效</td></tr><tr><td align="center">app:flow_firstVerticalStyle&#x3D;”packed｜spread｜spread_inside”</td><td align="center">第一条垂直链的配置，其他条不生效</td></tr><tr><td align="center">app:flow_lastHorizontalStyle&#x3D;”packed｜spread｜spread_inside”</td><td align="center">最后一条水平链的配置，其他条不生效</td></tr><tr><td align="center">app:flow_lastVerticalStyle&#x3D;”packed｜spread｜spread_inside”</td><td align="center">最后一条垂直链的配置，其他条不生效</td></tr></tbody></table></li><li><p>对齐约束</p><blockquote><p>上面展示的都是相同大小的<code>view</code>，那么不同大小<code>view</code>的对齐方式，<code>Flow</code>也提供了相应的属性进行配置(<code>flow_wrapMode=&quot;aligned&quot;</code>时，我试着没有效果)</p></blockquote><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">app:flow_verticalAlign&#x3D;”top｜bottom｜center｜baseline”</td><td align="center">top:顶对齐、bottom:底对齐、center:中心对齐、baseline:基线对齐</td></tr><tr><td align="center">app:flow_horizontalAlign&#x3D;start|end”</td><td align="center">start:开始对齐、end:结尾对齐、center:中心对齐</td></tr></tbody></table><blockquote><p>使用<code>flow_verticalAlign</code>时，要求<code>orientation</code>的方向是<code>horizontal</code>，而使用<code>flow_horizontalAlign</code>时，要求<code>orientation</code>的方向是<code>vertical</code></p></blockquote></li><li><p>数量约束</p><blockquote><p>当<code>flow_wrapMode</code>属性为<code>aligned</code>和<code>chian</code>时，通过<code>flow_maxElementsWrap</code>属性控制每行最大的子<code>View</code>数量，例如我们设置为<code>flow_maxElementsWrap=4</code>，那么每行最大子 <code>View</code>数量就是4.</p></blockquote></li></ol><h5 id="2-7-2-6-Layer（层布局）"><a href="#2-7-2-6-Layer（层布局）" class="headerlink" title="2.7.2.6 Layer（层布局）"></a>2.7.2.6 Layer（层布局）</h5><blockquote><p>Layer继承自ConstraintHelper，是一个约束助手，相对于Flow来说，Layer的使用较为简单，常用来增加背景，或者共同动画，图层 (Layer) 在布局期间会调整大小，其大小会根据其引用的所有视图进行调整，代码的先后顺序也会决定着它的位置，如果代码在所有引用view的最后面，那么它就会在所有view的最上面，反之则是最下面，在最上面的时候如果添加背景，就会把引用的view覆盖掉，下面展示下添加背景的例子，做动画的例子这里不再展示了</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#DAF3FE&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;HardcodedText&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.helper.widget.Layer</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/common_rect_white_100_10&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraint_referenced_ids</span>=<span class="string">&quot;AndroidImg,NameTv&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/AndroidImg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/android&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/NameTv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Android&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;bold&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;@id/AndroidImg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@id/AndroidImg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/AndroidImg&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当<code>Layer</code>的代码在所有引用<code>view</code>的上面时，效果是正常的，因为此时所有的<code>view</code>都在<code>Layer</code>的上面。但当<code>Layer</code>代码在最后面时,<code>Layer</code>就会把所有的<code>view</code>覆盖住，效果就不正常了。</p><h5 id="2-7-2-7-ImageFilterButton-ImageFilterView"><a href="#2-7-2-7-ImageFilterButton-ImageFilterView" class="headerlink" title="2.7.2.7 ImageFilterButton &amp; ImageFilterView"></a>2.7.2.7 ImageFilterButton &amp; ImageFilterView</h5><blockquote><p>ImageFilterButton和ImageFilterView是两个控件，他们之间的关系就和ImageButton与ImageView是一样的，所以这里就只拿ImageFilterView来做讲解。从名字上来看，它们的定位是和过滤有关系的，它们的大致作用有两部分，一是可以用来做圆角图片，二是可以叠加图片资源进行混合过滤，下面一一展示：</p></blockquote><ol><li><p>圆角图片</p><blockquote><p>ImageFilterButton和ImageFilterView可以使用两个属性来设置图片资源的圆角，分别是roundPercent和round，roundPercent接受的值类型是0-1的小数，根据数值的大小会使图片在方形和圆形之间按比例过度，round&#x3D;可以设置具体圆角的大小，我在使用的过程中发现我的AndroidStudio，没有这两个属性的代码提示，也没有预览效果，但是运行起来是有效果的，可能是没有做好优化吧。最近很热门的一个话题，小米花费200万设计的新logo，我们拿来做做例子：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.utils.widget.ImageFilterView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/mi&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:roundPercent</span>=<span class="string">&quot;0.7&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然和小米新logo的圆弧不太一样，不过这也不是我们考虑的地方，可以看到我们使用<code>roundPercent</code>设置了圆角为0.7（70%），实现一个圆角图片就是如此简单。</p></blockquote></li><li><p>图片过滤</p><blockquote><p>ImageFilterButton和ImageFilterView不但可以使用src来设置图片资源，还可以使用altSrc来设置第二个图片资源，altSrc提供的资源将会和src提供的资源通过crossfade属性形成交叉淡化效果,默认情况下，crossfade&#x3D;0，altSrc所引用的资源不可见，取值在0-1。下面看例子：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.utils.widget.ImageFilterView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/mi&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:altSrc</span>=<span class="string">&quot;@drawable/ic_launcher_background&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:crossfade</span>=<span class="string">&quot;.5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:roundPercent</span>=<span class="string">&quot;0.7&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>除此之外，<code>warmth</code>属性可以用来调节色温，<code>brightness</code>属性用来调节亮度，<code>saturation</code>属性用来调节饱和度，<code>contrast</code>属性用来调节对比度</p></blockquote></li></ol><h5 id="2-7-2-8-MockView"><a href="#2-7-2-8-MockView" class="headerlink" title="2.7.2.8 MockView"></a>2.7.2.8 MockView</h5><blockquote><p>你家产品经理经常会给你画原型图，但这绝对不是他们的专属，我们也有自己的原型图，一个成熟的程序员要学会给自己的产品经理画大饼，我们可以使用<code>MockView</code>来充当原型图，下面看例子：</p></blockquote><hr><h2 id="三、自定义控件"><a href="#三、自定义控件" class="headerlink" title="三、自定义控件"></a>三、自定义控件</h2><p>在前两节我们学习了Android中的一些常用控件和基本布局的用法，不过当时我们并没有关注这些控件和布局的继承结构，现在是时候来看一下了，如图所示。</p><p><img src="https://pic.ziyuan.wang/2023/10/24/xiheya_a377f4dd3ff37.png" alt="1698114246144.png"></p><p>可以看到，我们所用的所有控件都是直接或间接继承自View的，所用的所有布局都是直接或间接继承自ViewGroup的。View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上又添加了各自特有的功能。而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个用于放置控件和布局的容器。</p><p>这个时候我们就可以思考一下，当系统自带的控件并不能满足我们的需求时，可不可以利用上面的继承结构来创建自定义控件呢？答案是肯定的.</p><h3 id="3-1-引入布局"><a href="#3-1-引入布局" class="headerlink" title="3.1 引入布局"></a>3.1 引入布局</h3><p>一般我们的程序中可能有很多个Activity需要这样的标题栏，如果在每个Activity的布局中都编写一遍同样的标题栏代码，明显就会导致代码的大量重复。这时我们就可以使用引入布局的方式来解决这个问题，在layout目录下新建一个title.xml布局，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/title_bg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/titleBack&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/back_bg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Back&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/titleText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Title Text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/titleEdit&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/edit_bg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Edit&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可能会出现修改button背景失败的情况，这个时候只需要修改 <code>themes.xml</code>中的<code>&lt;style name=&quot;Theme.UICustomViews&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt;</code>，把他修改成： <code>&lt;style name=&quot;Theme.UICustomViews&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar.Bridge&quot;&gt;</code>这样就可以修改背景颜色啦。</p><p>可以看到，我们在LinearLayout中分别加入了两个Button和一个TextView，左边的Button可用于返回，右边的Button可用于编辑，中间的TextView则可以显示一段标题文本。上面代码中的大多数属性是你已经见过的，下面我来说明一下几个之前没有讲过的属性。android:background用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充。这里我提前准备好了3张图片——title_bg.png、back_bg.png和edit_bg.png（资源下载地址见前言），分别用于作为标题栏、返回按钮和编辑按钮的背景。另外，在两个Button中我们都使用了android:layout_margin这个属性，它可以指定控件在上下左右方向上的间距。当然也可以使用android:layout_marginLeft或android:layout_marginTop等属性来单独指定控件在某个方向上的间距。</p><p>现在标题栏布局已经编写完成了，剩下的就是如何在程序中使用这个标题栏了，修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/title&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没错！我们只需要通过一行include语句引入标题栏布局就可以了。 <code>&lt;include layout=&quot;@layout/title&quot;/&gt;</code></p><p>最后我们需要在MainActivity中将自带的标题栏隐藏掉，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uicustomviews</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> work.icu007.uicustomviews.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        supportActionBar?.hide()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们调用了getSupportActionBar()方法来获得ActionBar的实例，然后再调用它的hide()方法将标题栏隐藏起来。由于ActionBar有可能为空，所以这里还使用了?.操作符。</p><blockquote><p>如果使用 viewbinding 出现Unresolved reference: databinding的报错，可能是对应module的build.gradle没有添加databinding配置</p></blockquote><p>这个时候只需要在对应module的 bulid.gradle中加入：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 如下</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdk 34</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;work.icu007.uicustomviews&quot;</span><br><span class="line">        minSdk 21</span><br><span class="line">        targetSdk 33</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION<span class="built_in">_</span>1<span class="built_in">_</span>8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION<span class="built_in">_</span>1<span class="built_in">_</span>8</span><br><span class="line">    &#125;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = &#x27;1.8&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可</p><h3 id="3-2-创建自定义控件"><a href="#3-2-创建自定义控件" class="headerlink" title="3.2 创建自定义控件"></a>3.2 创建自定义控件</h3><p>引入布局的技巧确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个Activity中为这些控件单独编写一次事件注册的代码。比如标题栏中的返回按钮，其实不管是在哪一个Activity中，这个按钮的功能都是相同的，即销毁当前Activity。而如果在每一个Activity中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。</p><p>新建TitleLayout继承自LinearLayout，让它成为我们自定义的标题栏控件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uicustomviews</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/27-11:50</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TitleLayout</span>(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在TitleLayout的主构造函数中声明了Context和AttributeSet这两个参数，在布局中引入TitleLayout控件时就会调用这个构造函数。然后在init结构体中需要对标题栏布局进行动态加载，这就要借助LayoutInflater来实现了。通过LayoutInflater的from()方法可以构建出一个LayoutInflater对象，然后调用inflate()方法就可以动态加载一个布局文件。inflate()方法接收两个参数：第一个参数是要加载的布局文件的id，这里我们传入R.layout.title；第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为TitleLayout，于是直接传入this。</p><p>现在自定义控件已经创建好了，接下来我们需要在布局文件中添加这个自定义控件，修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">work.icu007.uicustomviews.TitleLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">&quot;MissingConstraints&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我们需要指明控件的完整类名，包名在这里是不可以省略的。重新运行程序，你会发现此时的效果和使用引入布局方式的效果是一样的。</p><p>下面我们尝试为标题栏中的按钮注册点击事件，修改TitleLayout中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uicustomviews</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> work.icu007.uicustomviews.databinding.TitleBinding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/27-11:50</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TitleLayout</span>(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> btnBack = findViewById&lt;Button&gt;(R.id.titleBack)</span><br><span class="line">        btnBack.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> activity = context <span class="keyword">as</span> Activity</span><br><span class="line">            activity.finish()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> btnEdit = findViewById&lt;Button&gt;(R.id.titleEdit)</span><br><span class="line">        btnEdit.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;u click btnEdit&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们分别给返回和编辑这两个按钮注册了点击事件，当点击返回按钮时销毁当前Activity，当点击编辑按钮时弹出一段文本。</p><p>注意，TitleLayout中接收的context参数实际上是一个Activity的实例，在返回按钮的点击事件里，我们要先将它转换成Activity类型，然后再调用finish()方法销毁当前的Activity。Kotlin中的类型强制转换使用的关键字是as，由于是第一次用到，所以这里单独讲解一下。</p><p>重新运行程序，点击一下编辑按钮，效果如图所示。点击返回按钮，当前界面就会立即关闭。由此说明，我们的自定义控件确实已经可以正常工作了。</p><p><img src="https://pic.ziyuan.wang/2023/10/28/xiheya_d682163f33870.png" alt="1698488183331.png"></p><p>这样的话，每当我们在一个布局中引入TitleLayout时，返回按钮和编辑按钮的点击事件就已经自动实现好了，这就省去了很多编写重复代码的工作。</p><h3 id="3-3-最常用和最难用的控件：ListView"><a href="#3-3-最常用和最难用的控件：ListView" class="headerlink" title="3.3 最常用和最难用的控件：ListView"></a>3.3 最常用和最难用的控件：ListView</h3><p>ListView在过去绝对可以称得上是Android中最常用的控件之一，几乎所有的应用程序都会用到它。由于手机屏幕空间比较有限，能够一次性在屏幕上显示的内容并不多，当我们的程序中有大量的数据需要展示的时候，就可以借助ListView来实现。ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据会滚动出屏幕。你其实每天都在使用这个控件，比如查看QQ聊天记录，翻阅微博最新消息，等等。</p><h4 id="3-3-1-ListView的简单用法"><a href="#3-3-1-ListView的简单用法" class="headerlink" title="3.3.1 ListView的简单用法"></a>3.3.1 ListView的简单用法</h4><p>新建一个ListViewTest项目，修改 activity_main.xml文件如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/listView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布局中加入ListView控件还算非常简单，先为ListView指定一个id，然后将宽度和高度都设置为match_parent，这样ListView就占满了整个布局的空间。</p><p>接下来修改MainActivity中的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.listviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter</span><br><span class="line"><span class="keyword">import</span> work.icu007.listviewtest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span> = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Mango&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Mango&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="keyword">val</span> adapter = ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_1,<span class="keyword">data</span>)</span><br><span class="line">        binding.listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然ListView是用于展示大量数据的，那我们就应该先将数据提供好。这些数据可以从网上下载，也可以从数据库中读取，应该视具体的应用程序场景而定。这里我们就简单使用一个data集合来进行测试，里面包含了很多水果的名称，初始化集合的方式使用的是之前在第2章学过的listOf()函数。</p><p>不过，集合中的数据是无法直接传递给ListView的，我们还需要借助适配器来完成。Android中提供了很多适配器的实现类，其中我认为最好用的就是ArrayAdapter。它可以通过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入。ArrayAdapter有多个构造函数的重载，你应该根据实际情况选择最合适的一种。由于我们这里提供的数据都是字符串，因此将ArrayAdapter的泛型指定为String，然后在ArrayAdapter的构造函数中依次传入Activity的实例、ListView子项布局的id，以及数据源。注意，我们使用了android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。这样适配器对象就构建好了。</p><p>最后，还需要调用ListView的setAdapter()方法，将构建好的适配器对象传递进去，这样ListView和数据之间的关联就建立完成了。效果如下</p><p><img src="https://pic.ziyuan.wang/2023/10/31/xiheya_d0ff1190c945b.png" alt="效果"></p><h4 id="3-3-2-定制ListView的界面"><a href="#3-3-2-定制ListView的界面" class="headerlink" title="3.3.2 定制ListView的界面"></a>3.3.2 定制ListView的界面</h4><p>只能显示一段文本的ListView实在是太单调了，现在就来对ListView的界面进行定制，让它可以显示更加丰富的内容。</p><p>定义一个实体类，作为ListView适配器的适配类型。新建Fruit类。Fruit类中只有两个字段：name表示水果的名字，imageId表示水果对应图片的资源id。代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.listviewtest</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/31-14:28</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> imageID: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>然后需要为ListView的子项指定一个我们自定义的布局，在layout目录下新建fruit_item.xml，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;20dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个布局中，我们定义了一个ImageView用于显示水果的图片，又定义了一个TextView用于显示水果的名称，并让ImageView和TextView都在垂直方向上居中显示。</p><p>接下来需要创建一个自定义的适配器，这个适配器继承自ArrayAdapter，并将泛型指定为Fruit类。新建类FruitAdapter，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.listviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/31-14:36</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(activity: Activity, <span class="keyword">private</span> <span class="keyword">val</span> resourceId: <span class="built_in">Int</span>, <span class="keyword">data</span>: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, <span class="keyword">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="comment">// 将 resourceId 指向的视图 一一填充到父布局当中，并存为view变量</span></span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">        <span class="comment">// 根据position 获取当前的Fruit实例</span></span><br><span class="line">        <span class="keyword">val</span> fruitItem = getItem(position)</span><br><span class="line">        <span class="keyword">if</span>(fruitItem != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 若实例不为空，则为fruitImage 和fruitName 设置成该实例中的ImageID及name</span></span><br><span class="line">            fruitImage.setImageResource(fruitItem.imageID)</span><br><span class="line">            fruitName.text = fruitItem.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FruitAdapter定义了一个主构造函数，用于将Activity的实例、ListView子项布局的id和数据源传递进来。另外又重写了getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。</p><p>在getView()方法中，首先使用LayoutInflater来为这个子项加载我们传入的布局。LayoutInflater的inflate()方法接收3个参数，前两个参数我们已经知道是什么意思了，第三个参数指定成false，表示只让我们在父布局中声明的layout属性生效，但不会为这个View添加父布局。因为一旦View有了父布局之后，它就不能再添加到ListView中了。如果你现在还不能理解这段话的含义，也没关系，只需要知道这是ListView中的标准写法就可以了，当你以后对View理解得更加深刻的时候，再来读这段话就没有问题了。</p><p>我们继续往下看，接下来调用View的findViewById()方法分别获取到ImageView和TextView的实例，然后通过getItem()方法得到当前项的Fruit实例，并分别调用它们的setImageResource()和setText()方法设置显示的图片和文字，最后将布局返回，这样我们自定义的适配器就完成了。</p><p>最后修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.listviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter</span><br><span class="line"><span class="keyword">import</span> work.icu007.listviewtest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="comment">/*private val data = listOf&lt;String&gt;(&quot;Apple&quot;,&quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;,</span></span><br><span class="line"><span class="comment">        &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot;,</span></span><br><span class="line"><span class="comment">        &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;,</span></span><br><span class="line"><span class="comment">        &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot;)*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="comment">/*val adapter = ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,data)</span></span><br><span class="line"><span class="comment">        binding.listView.adapter = adapter*/</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        initFruits()</span><br><span class="line">        <span class="comment">// 创建一个adapter</span></span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(<span class="keyword">this</span>, R.layout.fruit_item, fruitList)</span><br><span class="line">        <span class="comment">// 将新建的adapter 设置为 listView的adapter</span></span><br><span class="line">        binding.listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat(<span class="number">2</span>)&#123;</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Apple&quot;</span>, R.drawable.apple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Banana&quot;</span>, R.drawable.banana_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Orange&quot;</span>, R.drawable.orange_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Watermelon&quot;</span>, R.drawable.watermelon_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pear&quot;</span>, R.drawable.pear_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Grape&quot;</span>, R.drawable.grape_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pineapple&quot;</span>, R.drawable.pineapple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Strawberry&quot;</span>, R.drawable.strawberry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Cherry&quot;</span>, R.drawable.cherry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Mango&quot;</span>, R.drawable.mango_pic))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://pic.ziyuan.wang/2023/10/31/xiheya_1a87af42ff442.png" alt="1698737713152.png"></p><h4 id="3-3-3-提升ListView的运行效率"><a href="#3-3-3-提升ListView的运行效率" class="headerlink" title="3.3.3 提升ListView的运行效率"></a>3.3.3 提升ListView的运行效率</h4><p>之所以说ListView这个控件很难用，是因为它有很多细节可以优化，其中运行效率就是很重要的一点。目前我们ListView的运行效率是很低的，因为在FruitAdapter的getView()方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，这就会成为性能的瓶颈。</p><p>仔细观察你会发现，getView()方法中还有一个convertView参数，这个参数用于将之前加载好的布局进行缓存，以便之后进行重用，我们可以借助这个参数来进行性能优化。修改FruitAdapter中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.listviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/31-14:36</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(activity: Activity, <span class="keyword">private</span> <span class="keyword">val</span> resourceId: <span class="built_in">Int</span>, <span class="keyword">data</span>: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, <span class="keyword">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="comment">// 将 resourceId 指向的视图 一一填充到父布局当中，并存为view变量</span></span><br><span class="line">        <span class="keyword">var</span> view = LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">        view = convertView ?: LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">        <span class="comment">// 根据position 获取当前的Fruit实例</span></span><br><span class="line">        <span class="keyword">val</span> fruitItem = getItem(position)</span><br><span class="line">        <span class="keyword">if</span>(fruitItem != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 若实例不为空，则为fruitImage 和fruitName 设置成该实例中的ImageID及name</span></span><br><span class="line">            fruitImage.setImageResource(fruitItem.imageID)</span><br><span class="line">            fruitName.text = fruitItem.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，现在我们在getView()方法中进行了判断：如果convertView为null，则使用LayoutInflater去加载布局；如果不为null，则直接对convertView进行重用。这样就大大提高了ListView的运行效率，在快速滚动的时候可以表现出更好的性能。</p><p>不过，目前我们的这份代码还是可以继续优化的，虽然现在已经不会再重复去加载布局，但是每次在getView()方法中仍然会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个ViewHolder来对这部分性能进行优化，修改FruitAdapter中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.listviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/31-14:36</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(activity: Activity, <span class="keyword">private</span> <span class="keyword">val</span> resourceId: <span class="built_in">Int</span>, <span class="keyword">data</span>: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, <span class="keyword">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类用于缓存 ImageView和TextView的控件实例</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(<span class="keyword">val</span> fruitImage: ImageView, <span class="keyword">val</span> fruitName: TextView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="comment">// 将 resourceId 指向的视图 一一填充到父布局当中，并存为view变量</span></span><br><span class="line">        <span class="keyword">var</span> view: View</span><br><span class="line">        <span class="keyword">var</span> viewHolder: ViewHolder</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>)&#123;</span><br><span class="line">            view = LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">            <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">            viewHolder = ViewHolder(fruitImage, fruitName)</span><br><span class="line">            view.tag = viewHolder</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView</span><br><span class="line">            viewHolder = view.tag <span class="keyword">as</span> ViewHolder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据position 获取当前的Fruit实例</span></span><br><span class="line">        <span class="keyword">val</span> fruitItem = getItem(position)</span><br><span class="line">        <span class="keyword">if</span>(fruitItem != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 若实例不为空，则为fruitImage 和fruitName 设置成该实例中的ImageID及name</span></span><br><span class="line">            viewHolder.fruitImage.setImageResource(fruitItem.imageID)</span><br><span class="line">            viewHolder.fruitName.text = fruitItem.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新增了一个内部类ViewHolder，用于对ImageView和TextView的控件实例进行缓存，Kotlin中使用inner class关键字来定义内部类。当convertView为null的时候，创建一个ViewHolder对象，并将控件的实例存放在ViewHolder里，然后调用View的setTag()方法，将ViewHolder对象存储在View中。当convertView不为null的时候，则调用View的getTag()方法，把ViewHolder重新取出。这样所有控件的实例都缓存在了ViewHolder里，就没有必要每次都通过findViewById()方法来获取控件实例了。</p><h4 id="3-3-4-ListView的点击事件"><a href="#3-3-4-ListView的点击事件" class="headerlink" title="3.3.4 ListView的点击事件"></a>3.3.4 ListView的点击事件</h4><p>话说回来，ListView 的滚动毕竟只是满足了我们视觉上的效果，可是如果ListView中的子项不能点击的话，这个控件就没有什么实际的用途了。因此，接下来就来学习一下ListView如何才能响应用户的点击事件。</p><p>修改 MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    <span class="comment">/*val adapter = ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,data)</span></span><br><span class="line"><span class="comment">    binding.listView.adapter = adapter*/</span></span><br><span class="line">    initFruits()</span><br><span class="line">    <span class="keyword">val</span> adapter = FruitAdapter(<span class="keyword">this</span>, R.layout.fruit_item, fruitList)</span><br><span class="line">    binding.listView.adapter = adapter</span><br><span class="line">    binding.listView.setOnItemClickListener &#123; parent, view, position, id -&gt;</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, fruit.name, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们使用setOnItemClickListener()方法为ListView注册了一个监听器，当用户点击了ListView中的任何一个子项时，就会回调到Lambda表达式中。这里我们可以通过position参数判断用户点击的是哪一个子项，然后获取到相应的水果，并通过Toast将水果的名字显示出来。</p><p>上述代码的Lambda表达式在参数列表中声明了4个参数，那么我们如何知道需要声明哪几个参数呢？，按住Ctrl键（Mac系统是command键）点击setOnItemClickListener()方法查看它的源码，你会发现setOnItemClickListener()方法接收一个OnItemClickListener参数，这当然就是一个Java单抽象方法接口了，要不然这里我们也无法使用函数式API的写法。OnItemClickListener接口的定义如图：</p><p><img src="https://pic.ziyuan.wang/2023/10/31/xiheya_217b830e91550.png" alt="1698740235331.png"></p><p>可以看到，它的唯一待实现方法onItemClick()中接收4个参数，这些就是我们要在Lambda表达式的参数列表中声明的参数了。</p><p>另外你会发现，虽然这里我们必须在Lambda表达式中声明4个参数，但实际上却只用到了position这一个参数而已。针对这种情况，Kotlin允许我们将没有用到的参数使用下划线来替代，因此下面这种写法也是合法且更加推荐的：</p><p><img src="https://pic.ziyuan.wang/2023/10/31/xiheya_3926c95898e78.png" alt="1698739922027.png"></p><p>注意，即使将没有用到的参数使用下划线来代替，它们之间的位置是不能改变的，position参数仍然得在第三个参数的位置。</p><h3 id="3-4-更强大的滚动控件：RecyclerView"><a href="#3-4-更强大的滚动控件：RecyclerView" class="headerlink" title="3.4 更强大的滚动控件：RecyclerView"></a>3.4 更强大的滚动控件：RecyclerView</h3><p>ListView由于强大的功能，在过去的Android开发当中可以说是贡献卓越，直到今天仍然还有不计其数的程序在使用ListView。不过ListView并不是完美无缺的，比如如果不使用一些技巧来提升它的运行效率，那么ListView的性能就会非常差。还有，ListView的扩展性也不够好，它只能实现数据纵向滚动的效果，如果我们想实现横向滚动的话，ListView是做不到的。</p><p>为此，Android提供了一个更强大的滚动控件——RecyclerView。它可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView存在的各种不足之处。目前Android官方更加推荐使用RecyclerView，未来也会有更多的程序逐渐从ListView转向RecyclerView，那么本节我们就来详细讲解一下RecyclerView的用法。</p><h4 id="3-4-1-RecyclerView的基本用法"><a href="#3-4-1-RecyclerView的基本用法" class="headerlink" title="3.4.1 RecyclerView的基本用法"></a>3.4.1 RecyclerView的基本用法</h4><p>和之前我们所学的所有控件不同，RecyclerView属于新增控件，那么怎样才能让新增的控件在所有Android系统版本上都能使用呢？为此，Google将RecyclerView控件定义在了AndroidX当中，我们只需要在项目的build.gradle中添加RecyclerView库的依赖，就能保证在所有Android系统版本上都可以使用RecyclerView控件了。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation fileTree(dir: &#x27;libs&#x27;, include: <span class="section">[&#x27;*.jar&#x27;]</span>)</span><br><span class="line">implementation&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br><span class="line">implementation &#x27;androidx.appcompat:appcompat:1.0.2&#x27;</span><br><span class="line">implementation &#x27;androidx.core:core-ktx:1.0.2&#x27;</span><br><span class="line">implementation &#x27;androidx.constraintlayout:constraintlayout:1.1.3&#x27;</span><br><span class="line">implementation &#x27;androidx.recyclerview:recyclerview:1.0.0&#x27;</span><br><span class="line">testImplementation &#x27;junit:junit:4.12&#x27;</span><br><span class="line">androidTestImplementation &#x27;androidx.test:runner:1.1.1&#x27;</span><br><span class="line">androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.1.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就表示将RecyclerView库引入我们的项目当中，其中除了版本号部分可能会变化，其他部分是固定不变的。那么可能你会好奇，我怎么知道每个库现在最新的版本号是多少呢？这里告诉你一个小窍门，当你不能确定最新的版本号是多少的时候，可以不输入完整库，然后按下tab，Android Studio会主动提醒你，并告诉你最新的版本号是多少然后填充。</p><p><img src="https://pic.ziyuan.wang/2023/11/01/xiheya_af1ec520afa3d.png" alt="1698805151517.png"></p><p>接下来修改activity_main.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布局中加入RecyclerView控件也是非常简单的，先为RecyclerView指定一个id，然后将宽度和高度都设置为match_parent，这样RecyclerView就占满了整个布局的空间。需要注意的是，由于RecyclerView并不是内置在系统SDK当中的，所以需要把完整的包路径写出来。</p><p>这里我们想要使用RecyclerView来实现和ListView相同的效果，因此就需要准备一份同样的水果图片。简单起见，我们就直接从ListViewTest项目中把图片复制过来，另外顺便将Fruit类和fruit_item.xml也复制过来，省得将同样的代码再写一遍。</p><p>接下来需要为RecyclerView准备一个适配器，新建FruitAdapter类，让这个适配器继承自RecyclerView.Adapter，并将泛型指定为FruitAdapter.ViewHolder。其中，ViewHolder是我们在FruitAdapter中定义的一个内部类，代码如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.recyclerviewtest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/1-15:58</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(<span class="keyword">val</span> fruitList: List&lt;Fruit&gt;) :</span><br><span class="line">    RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  fruitList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        holder.fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">        holder.fruitName.text = fruit.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是RecyclerView适配器标准的写法，虽然看上去好像多了好几个方法，但其实它比ListView的适配器要更容易理解。这里我们首先定义了一个内部类ViewHolder，它要继承自RecyclerView.ViewHolder。然后ViewHolder的主构造函数中要传入一个View参数，这个参数通常就是RecyclerView子项的最外层布局，那么我们就可以通过findViewById()方法来获取布局中ImageView和TextView的实例了。FruitAdapter中也有一个主构造函数，它用于把要展示的数据源传进来，我们后续的操作都将在这个数据源的基础上进行。</p><p>继续往下看，由于FruitAdapter是继承自RecyclerView.Adapter的，那么就必须重写onCreateViewHolder()、onBindViewHolder()和getItemCount()这3个方法。onCreateViewHolder()方法是用于创建ViewHolder实例的，我们在这个方法中将fruit_item布局加载进来，然后创建一个ViewHolder实例，并把加载出来的布局传入构造函数当中，最后将ViewHolder的实例返回。onBindViewHolder()方法用于对RecyclerView子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行，这里我们通过position参数得到当前项的Fruit实例，然后再将数据设置到ViewHolder的ImageView和TextView当中即可。getItemCount()方法就非常简单了，它用于告诉RecyclerView一共有多少子项，直接返回数据源的长度就可以了。</p><p>适配器准备好了之后，我们就可以开始使用RecyclerView了，修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.recyclerviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> work.icu007.recyclerviewtest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        initFruits()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">        binding.recyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(fruitList)</span><br><span class="line">        binding.recyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat(<span class="number">2</span>)&#123;</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Apple&quot;</span>, R.drawable.apple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Banana&quot;</span>, R.drawable.banana_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Orange&quot;</span>, R.drawable.orange_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Watermelon&quot;</span>, R.drawable.watermelon_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pear&quot;</span>, R.drawable.pear_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Grape&quot;</span>, R.drawable.grape_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pineapple&quot;</span>, R.drawable.pineapple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Strawberry&quot;</span>, R.drawable.strawberry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Cherry&quot;</span>, R.drawable.cherry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Mango&quot;</span>, R.drawable.mango_pic))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里使用了一个同样的initFruits()方法，用于初始化所有的水果数据。接着在onCreate()方法中先创建了一个LinearLayoutManager对象，并将它设置到RecyclerView当中。LayoutManager用于指定RecyclerView的布局方式，这里使用的LinearLayoutManager是线性布局的意思，可以实现和ListView类似的效果。接下来我们创建了FruitAdapter的实例，并将水果数据传入FruitAdapter的构造函数中，最后调用RecyclerView的setAdapter()方法来完成适配器设置，这样RecyclerView和数据之间的关联就建立完成了。</p><p>使用RecyclerView可以实现和ListView几乎一模一样的效果，虽说在代码量方面并没有明显的减少，但是逻辑变得更加清晰了。当然这只是RecyclerView的基本用法而已，接下来再来学习如何使用RecyclerView实现那些ListView实现不了的效果。</p><h4 id="3-4-2-实现横向滚动和瀑布流布局"><a href="#3-4-2-实现横向滚动和瀑布流布局" class="headerlink" title="3.4.2 实现横向滚动和瀑布流布局"></a>3.4.2 实现横向滚动和瀑布流布局</h4><p>ListView的扩展性并不好，它只能实现纵向滚动的效果，如果想进行横向滚动的话，ListView就做不到了。但是RecyclerView却能很简单的做到横向滚动。</p><p>首先要对fruit_item布局进行修改，因为目前这个布局里面的元素是水平排列的，适用于纵向滚动的场景，而如果我们要实现横向滚动的话，应该把fruit_item里的元素改成垂直排列才比较合理。修改fruit_item.xml中的代码，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先把LinearLayout改成垂直方向排列，并把宽度设为80 dp。再将ImageView和TextView都设置成了在布局中水平居中，并且使用layout_marginTop属性让文字和图片之间保持一定距离。</p><p>MainActivity中只需要加入一行代码，调用LinearLayoutManager的setOrientation()方法设置布局的排列方向。默认是纵向排列的，我们传入LinearLayoutManager.HORIZONTAL表示让布局横行排列，这样RecyclerView就可以横向滚动了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.recyclerviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> work.icu007.recyclerviewtest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="comment">// 初始化水果数据</span></span><br><span class="line">        initFruits()</span><br><span class="line">        <span class="comment">// 将 recyclerView的布局方式设置成线性布局</span></span><br><span class="line">        <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">        layoutManager.orientation = LinearLayoutManager.HORIZONTAL</span><br><span class="line">        binding.recyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="comment">// 创建FruitAdapter实例，将fruitList传入</span></span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(fruitList)</span><br><span class="line">        binding.recyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat(<span class="number">2</span>)&#123;</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Apple&quot;</span>, R.drawable.apple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Banana&quot;</span>, R.drawable.banana_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Orange&quot;</span>, R.drawable.orange_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Watermelon&quot;</span>, R.drawable.watermelon_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pear&quot;</span>, R.drawable.pear_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Grape&quot;</span>, R.drawable.grape_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pineapple&quot;</span>, R.drawable.pineapple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Strawberry&quot;</span>, R.drawable.strawberry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Cherry&quot;</span>, R.drawable.cherry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Mango&quot;</span>, R.drawable.mango_pic))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="https://pic.ziyuan.wang/2023/11/02/xiheya_1c6a666edac00.png" alt="1698891531731.png"></p><p>为什么ListView很难或者根本无法实现的效果在RecyclerView上这么轻松就实现了呢？这主要得益于RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager。LayoutManager制定了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。</p><p>除了LinearLayoutManager之外，RecyclerView还给我们提供了GridLayoutManager和StaggeredGridLayoutManager这两种内置的布局排列方式。GridLayoutManager可以用于实现网格布局，StaggeredGridLayoutManager可以用于实现瀑布流布局。</p><p>瀑布流该怎么实现呢？现在我们尝试使用瀑布流布局来展示我们的数据</p><p>首先修改fruit_item.xml代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将LinearLayout的宽度由80 dp改成了match_parent，因为瀑布流布局的宽度应该是根据布局的列数来自动适配的，而不是一个固定值。其次我们使用了layout_margin属性来让子项之间互留一点间距，这样就不至于所有子项都紧贴在一些。最后还将TextView的对齐属性改成了居左对齐，因为待会我们会将文字的长度变长，如果还是居中显示就会感觉怪怪的。</p><p>接着修改MainActivity中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.recyclerviewtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.StaggeredGridLayoutManager</span><br><span class="line"><span class="keyword">import</span> work.icu007.recyclerviewtest.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="comment">// 初始化水果数据</span></span><br><span class="line">        initFruits()</span><br><span class="line">        <span class="comment">// 将 recyclerView的布局方式设置成想要的布局</span></span><br><span class="line">        <span class="keyword">val</span> layoutManager = StaggeredGridLayoutManager(<span class="number">3</span>,StaggeredGridLayoutManager.VERTICAL)</span><br><span class="line">        binding.recyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="comment">// 创建FruitAdapter实例，将fruitList传入</span></span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(fruitList)</span><br><span class="line">        binding.recyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat(<span class="number">2</span>)&#123;</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Apple&quot;</span>), R.drawable.apple_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Banana&quot;</span>), R.drawable.banana_pic))</span><br><span class="line">            fruitList.add(Fruit( getRandomLengthString(<span class="string">&quot;Orange&quot;</span>), R.drawable.orange_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Watermelon&quot;</span>), R.drawable.watermelon_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Pear&quot;</span>), R.drawable.pear_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Grape&quot;</span>), R.drawable.grape_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Pineapple&quot;</span>), R.drawable.pineapple_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Strawberry&quot;</span>), R.drawable.strawberry_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Cherry&quot;</span>), R.drawable.cherry_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Mango&quot;</span>), R.drawable.mango_pic))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(string: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">        <span class="keyword">val</span> length = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">        <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">        repeat(length)&#123;</span><br><span class="line">            stringBuilder.append(string)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onCreate()方法中，我们创建了一个StaggeredGridLayoutManager的实例。StaggeredGridLayoutManager的构造函数接收两个参数：第一个参数用于指定布局的列数，传入3表示会把布局分为3列；第二个参数用于指定布局的排列方向，传入StaggeredGridLayoutManager.VERTICAL表示会让布局纵向排列。最后把创建好的实例设置到RecyclerView当中就可以了，就是这么简单！</p><h4 id="3-4-3-RecyclerView的点击事件"><a href="#3-4-3-RecyclerView的点击事件" class="headerlink" title="3.4.3 RecyclerView的点击事件"></a>3.4.3 RecyclerView的点击事件</h4><p>和ListView一样，RecyclerView也必须能响应点击事件才可以，不然的话就没什么实际用途了。不过不同于ListView的是，RecyclerView并没有提供类似于setOnItemClickListener()这样的注册监听器方法，而是需要我们自己给子项具体的View去注册点击事件。这相比于ListView来说，实现起来要复杂一些。</p><p>那么你可能就有疑问了，为什么RecyclerView在各方面的设计都要优于ListView，偏偏在点击事件上却没有处理得非常好呢？其实不是这样的，ListView在点击事件上的处理并不人性化，setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里具体的某一个按钮呢？虽然ListView也能做到，但是实现起来就相对比较麻烦了。为此，RecyclerView干脆直接摒弃了子项点击事件的监听器，让所有的点击事件都由具体的View去注册，就再没有这个困扰了。</p><p>下面我们来具体学习一下如何在RecyclerView中注册点击事件，修改FruitAdapter中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.recyclerviewtest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/1-15:58</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> fruitList: List&lt;Fruit&gt;) :</span><br><span class="line">    RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> viewHolder = ViewHolder(view)</span><br><span class="line">        viewHolder.itemView.setOnClickListener &#123; </span><br><span class="line">            <span class="keyword">val</span> position = viewHolder.bindingAdapterPosition</span><br><span class="line">            <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">            Toast.makeText(parent.context, <span class="string">&quot;u clicked view <span class="subst">$&#123;fruit.name&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.fruitImage.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> position = viewHolder.bindingAdapterPosition</span><br><span class="line">            <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">            Toast.makeText(parent.context, <span class="string">&quot;u clicked image <span class="subst">$&#123;fruit.name&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> viewHolder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  fruitList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        holder.fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">        holder.fruitName.text = fruit.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们是在onCreateViewHolder()方法中注册点击事件。上述代码分别为最外层布局和ImageView都注册了点击事件，itemView表示的就是最外层布局。RecyclerView的强大之处也在于此，它可以轻松实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的position，然后通过position拿到相应的Fruit实例，再使用Toast分别弹出两种不同的内容以示区别。</p><h3 id="3-5-编写界面的最佳实践"><a href="#3-5-编写界面的最佳实践" class="headerlink" title="3.5 编写界面的最佳实践"></a>3.5 编写界面的最佳实践</h3><h4 id="3-5-1-制作9-Patch图片"><a href="#3-5-1-制作9-Patch图片" class="headerlink" title="3.5.1 制作9-Patch图片"></a>3.5.1 制作9-Patch图片</h4><p>在实战正式开始之前，我们需要先学习一下如何制作9-Patch图片。你之前可能没有听说过这个名词，它是一种被特殊处理过的png图片，能够指定哪些区域可以被拉伸、哪些区域不可以。</p><p>在Android Studio中，我们可以将任何png类型的图片制作成9-Patch图片。首先对着message_left.png图片右击→Create 9-Patch file.在这之后，我们可以适当拉伸 9-Patch 图片以达到我们想要的效果。</p><p>我们可以在图片的4个边框绘制一个个的小黑点，在上边框和左边框绘制的部分表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分表示内容允许被放置的区域。使用鼠标在图片的边缘拖动就可以进行绘制了，按住Shift键拖动可以进行擦除。</p><p><img src="https://pic.ziyuan.wang/2023/11/02/xiheya_24db80f5c4b4a.png" alt="1698896587676.png"></p><h4 id="3-5-2-编写精美的聊天界面"><a href="#3-5-2-编写精美的聊天界面" class="headerlink" title="3.5.2 编写精美的聊天界面"></a>3.5.2 编写精美的聊天界面</h4><p>既然是要编写一个聊天界面，那肯定要有收到的消息和发出的消息。上一小节中我们制作的message_left.9.png可以作为收到消息的背景图，那么毫无疑问我们还需要再制作一张message_right.9.png作为发出消息的背景图。制作过程是完全一样的。</p><p>图片都准备好了之后，就可以开始编码了。由于待会我们会用到RecyclerView，因此首先需要在app&#x2F;build.gradle当中添加依赖库，如下所示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;androidx.core:core-ktx:1.9.0&quot;)</span><br><span class="line">    implementation(&quot;androidx.appcompat:appcompat:1.6.1&quot;)</span><br><span class="line">    implementation(&quot;com.google.android.material:material:1.10.0&quot;)</span><br><span class="line">    implementation(&quot;androidx.constraintlayout:constraintlayout:2.1.4&quot;)</span><br><span class="line">    implementation(&quot;androidx.recyclerview:recyclerview:1.3.2&quot;)</span><br><span class="line">    testImplementation(&quot;junit:junit:4.13.2&quot;)</span><br><span class="line">    androidTestImplementation(&quot;androidx.test.ext:junit:1.1.5&quot;)</span><br><span class="line">    androidTestImplementation(&quot;androidx.test.espresso:espresso-core:3.5.1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写主界面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/send&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/inputText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;Type something here&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:maxLines</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@id/send&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/send&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Send&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在主界面中放置了一个RecyclerView用于显示聊天的消息内容，又放置了一个EditText用于输入消息，还放置了一个Button用于发送消息。</p><p>接下来定义消息的实体类，新建Msg，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/2-14:13</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Msg</span>(<span class="keyword">val</span> content: String, <span class="keyword">val</span> type: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TYPE_RECEIVED = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TYPE_SENT = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Msg类中只有两个字段：content表示消息的内容，type表示消息的类型。其中消息类型有两个值可选：TYPE_RECEIVED表示这是一条收到的消息，TYPE_SENT表示这是一条发出的消息。这里我们将TYPE_RECEIVED和TYPE_SENT定义成了常量，定义常量的关键字是const，注意只有在单例类、companion object或顶层方法中才可以使用const关键字。</p><p>接下来开始编写RecyclerView的子项布局，新建msg_left_item.xml，代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/message_left_originall&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftMsg&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;@color/white&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是接收消息的子项布局。这里我们让收到的消息居左对齐，并使用message_left.9.png作为背景图。<br>类似地，我们还需要再编写一个发送消息的子项布局，新建msg_right_item.xml，我们让发出的消息居右对齐，并使message_right.9.png作为背景图，基本上和刚才的msg_left_item.xml是差不多的。代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/message_right_originall&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rightMsg&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;@color/white&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来需要创建RecyclerView的适配器类，新建类MsgAdapter，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/11/2-14:34</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">LeftViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftMsg: TextView = view.findViewById(R.id.leftMsg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">RightViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> rightMsg: TextView = view.findViewById(R.id.rightMsg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据消息来返回对应的type</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">return</span>  msg.type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的viewType 来加载不同的布局并创建不同的ViewHolder；</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (viewType == Msg.TYPE_RECEIVED)&#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_left_item,parent,<span class="literal">false</span>)</span><br><span class="line">            LeftViewHolder(view)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_right_item,parent,<span class="literal">false</span>)</span><br><span class="line">            RightViewHolder(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Item数量</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msgList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是LeftViewHolder，就将内容显示到左边的消息布局；如果是RightViewHolder，就将内容显示到右边的消息布局。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">when</span>(holder)&#123;</span><br><span class="line">            <span class="keyword">is</span> LeftViewHolder -&gt; holder.leftMsg.text = msg.content</span><br><span class="line">            <span class="keyword">is</span> RightViewHolder -&gt; holder.rightMsg.text = msg.content</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中根据不同的viewType创建不同的界面。首先定义了LeftViewHolder和RightViewHolder这两个ViewHolder，分别用于缓存msg_left_item.xml和msg_right_item.xml布局中的控件。然后要重写getItemViewType()方法，并在这个方法中返回当前position对应的消息类型。</p><p>最后修改MainActivity中的代码，为RecyclerView初始化一些数据，并给发送按钮加入事件响应，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.uibestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> work.icu007.uibestpractice.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> msgList = ArrayList&lt;Msg&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter:MsgAdapter? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="comment">// 初始化Msg</span></span><br><span class="line">        initMsg()</span><br><span class="line">        <span class="comment">// 将recyclerView的布局设置成线性布局</span></span><br><span class="line">        <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">        binding.recyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        adapter = MsgAdapter(msgList)</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        binding.recyclerView.adapter = adapter</span><br><span class="line">        binding.send.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg1 = Msg(<span class="string">&quot;Hello guy.&quot;</span>, Msg.TYPE_RECEIVED)</span><br><span class="line">        msgList.add(msg1)</span><br><span class="line">        <span class="keyword">val</span> msg2 = Msg(<span class="string">&quot;Hello. Who is that?&quot;</span>, Msg.TYPE_SENT)</span><br><span class="line">        msgList.add(msg2)</span><br><span class="line">        <span class="keyword">val</span> msg3 = Msg(<span class="string">&quot;This is Tom. Nice talking to you. &quot;</span>, Msg.TYPE_RECEIVED)</span><br><span class="line">        msgList.add(msg3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (v) &#123;</span><br><span class="line">            binding.send -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> content = binding.inputText.text.toString()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (content.isNotEmpty())&#123;</span><br><span class="line">                    <span class="keyword">val</span> msg = Msg(content, Msg.TYPE_SENT)</span><br><span class="line">                    <span class="comment">// 将 msg 添加到msgList中</span></span><br><span class="line">                    msgList.add(msg)</span><br><span class="line">                    <span class="comment">// 通知列表有新的数据插入</span></span><br><span class="line">                    adapter?.notifyItemInserted(msgList.size - <span class="number">1</span>)</span><br><span class="line">                    <span class="comment">// 将显示的数据定位到最后一行</span></span><br><span class="line">                    binding.recyclerView.scrollToPosition(msgList.size - <span class="number">1</span>)</span><br><span class="line">                    <span class="comment">// 清空输入框内容</span></span><br><span class="line">                    binding.inputText.setText(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先在initMsg()方法中初始化了几条数据用于在RecyclerView中显示，接下来按照标准的方式构建RecyclerView，给它指定一个LayoutManager和一个适配器。</p><p>然后在发送按钮的点击事件里获取了EditText中的内容，如果内容不为空字符串，则创建一个新的Msg对象并添加到msgList列表中去。之后又调用了适配器的notifyItemInserted()方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在RecyclerView中显示出来。或者你也可以调用适配器的notifyDataSetChanged()方法，它会将RecyclerView中所有可见的元素全部刷新，这样不管是新增、删除、还是修改元素，界面上都会显示最新的数据，但缺点是效率会相对差一些。接着调用RecyclerView的scrollToPosition()方法将显示的数据定位到最后一行，以保证一定可以看得到最后发出的一条消息。最后调用EditText的setText()方法将输入的内容清空。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;〇、导航组件&quot;&gt;&lt;a href=&quot;#〇、导航组件&quot; class=&quot;headerlink&quot; title=&quot;〇、导航组件&quot;&gt;&lt;/a&gt;〇、导航组件&lt;/h2&gt;&lt;h3 id=&quot;0-1-导航简介&quot;&gt;&lt;a href=&quot;#0-1-导航简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin安卓开发入门</title>
    <link href="https://icu007work.github.io/archives/3ba91e1b.html"/>
    <id>https://icu007work.github.io/archives/3ba91e1b.html</id>
    <published>2023-10-11T03:37:21.000Z</published>
    <updated>2024-05-11T07:45:19.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ViewBinding"><a href="#一、ViewBinding" class="headerlink" title="一、ViewBinding"></a>一、ViewBinding</h2><h3 id="1-1-什么是ViewBinding"><a href="#1-1-什么是ViewBinding" class="headerlink" title="1.1 什么是ViewBinding"></a>1.1 什么是ViewBinding</h3><p><strong>ViewBinding</strong>总体来说其实非常简单，它的目的只有一个，就是为了避免编写<code>findViewById</code>，这和它另外一个非常复杂的兄弟<strong>DataBinding</strong>相比有明显的区别。</p><p>要想使用<strong>ViewBinding</strong>需要注意两件事。第一，确保你的<strong>Android Studio是3.6或更高</strong>的版本。第二，在你项目工程模块的<code>build.gradle</code>中加入以下配置：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-在Activity中使用ViewBinding"><a href="#1-2-在Activity中使用ViewBinding" class="headerlink" title="1.2 在Activity中使用ViewBinding"></a>1.2 在Activity中使用ViewBinding</h3><p>一旦启动了<strong>ViewBinding</strong>功能之后，Android Studio会自动为我们所编写的每一个布局文件都生成一个对应的<code>Binding</code>类.<code>Binding</code>类的命名规则是将布局文件按驼峰方式重命名后，再加上<code>Binding</code>作为结尾。比如说，前面我们定义了一个<code>activity_main.xml</code>布局，那么与它对应的<code>Binding</code>类就是<code>ActivityMainBinding</code>。当然，如果有些布局文件你不希望为它生成对应的<code>Binding</code>类，可以在该布局文件的根元素位置加入如下声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:viewBindingIgnore</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们看一下如何使用ViewBinding来实现在MainActivity中去设置TextView内容的功能，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ViewBinding</strong>的用法可以说就是这么简单。首先我们要调用<code>activity_main.xml</code>布局文件对应的<code>Binding</code>类，也就是<code>ActivityMainBinding</code>的<code>inflate()</code>函数去加载该布局，<code>inflate()</code>函数接收一个<code>LayoutInflater</code>参数，在<code>Activity</code>中是可以直接获取到的。</p><p>接下来就更加简单了，调用<code>Binding</code>类的<code>getRoot()</code>函数可以得到<code>activity_main.xml</code>中根元素的实例，调用<code>getTextView()</code>函数可以获得<code>id</code>为<code>textView</code>的元素实例。</p><p>那么很明显，我们应该把根元素的实例传入到<code>setContentView()</code>函数当中，这样<code>Activity</code>就可以成功显示<code>activity_main.xml</code>这个布局的内容了。然后获取<code>TextView</code>控件的实例，并给它设置要显示的文字即可。</p><p>当然，如果你需要在<code>onCreate()</code>函数之外的地方对控件进行操作，那么就得将<code>binding</code>变量声明成全局变量，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Kotlin声明的变量都必须在声明的同时对其进行初始化。而这里我们显然无法在声明全局binding变量的同时对它进行初始化，所以这里又使用了lateinit关键字对binding变量进行了延迟初始化。</p><h2 id="二、Intent"><a href="#二、Intent" class="headerlink" title="二、Intent"></a>二、Intent</h2><p><strong>Intent</strong>大致可以分为两种：<strong>显式Intent</strong>和隐式Intent。我们先来看一下<strong>显式Intent</strong>如何使用。<strong>Intent</strong>有多个构造函数的重载，其中一个是<code>Intent(Context packageContext, Class&lt;?&gt;cls)</code>。这个构造函数接收两个参数：第一个参数<code>Context</code>要求提供一个启动<code>Activity</code>的<strong>上下文</strong>；第二个参数<code>Class</code>用于<strong>指定想要启动的目标<code>Activity</code><strong>，通过</strong>这个构造函数就可以构建出<code>Intent</code>的“意图</strong>”。那么接下来我们应该怎么使用这个<code>Intent</code>呢？<code>Activity</code>类中提供了一个<code>startActivity()</code>方法，专门用于启动<code>Activity</code>，它接收一个<code>Intent</code>参数，<strong>这里我们将构建好的Intent传入startActivity()方法就可以启动目标Activity了。</strong></p><h3 id="2-1-显式Intent"><a href="#2-1-显式Intent" class="headerlink" title="2.1 显式Intent"></a>2.1 显式Intent</h3><p>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可用于启动Activity、启动Service以及发送广播等场景。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line"><span class="comment">//        val button1: Button = findViewById(R.id.button1)</span></span><br><span class="line">        binding.button1.text = <span class="string">&quot;显式INTENT&quot;</span></span><br><span class="line">        binding.button1.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;hello , u clicked button1: <span class="subst">$&#123;binding.button1.text&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们首先构建了一个<strong>Intent</strong>对象，第一个参数传入<code>this</code>也就是<code>FirstActivity</code>作为上下文，第二个参数传入<code>SecondActivity::class.java</code>作为目标<code>Activity</code>，这样我们的“意图”就非常明显了，即在<code>FirstActivity</code>的基础上打开<code>SecondActivity</code>。注意，<strong>Kotlin</strong>中<code>SecondActivity::class.java</code>的写法就相当于<strong>Java</strong>中<code>SecondActivity.class</code>的写法。接下来再通过<code>startActivity()</code>方法执行这个<strong>Intent</strong>就可以了。</p><h3 id="2-2-隐式Intent"><a href="#2-2-隐式Intent" class="headerlink" title="2.2 隐式Intent"></a>2.2 隐式Intent</h3><p>相比于显式<strong>Intent</strong>，隐式<strong>Intent</strong>则含蓄了许多，它并不明确指出想要启动哪一个<code>Activity</code>，而是指定了一系列更为抽象的<code>action</code>和<code>category</code>等信息，然后交由系统去分析这个<strong>Intent</strong>，并帮我们找出合适的<code>Activity</code>去启动。</p><p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前<code>Activity</code>能够响应的<code>action</code>和<code>category</code>，打开<code>AndroidManifest.xml</code>，添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.icu007.activitytest.ACTION_START&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;com.icu007.activitytest.MY_CATEGORY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;action&gt;</code>标签中我们指明了当前<code>Activity</code>可以响应<code>com.example.activitytest.ACTION_START</code>这个<code>action</code>，而<code>&lt;category&gt;</code>标签则包含了一些附加信息，更精确地指明了当前<code>Activity</code>能够响应的<code>Intent</code>中还可能带有的<code>category</code>。只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>中的内容同时匹配<code>Intent</code>中指定的<code>action</code>和<code>category</code>时，这个<code>Activity</code>才能响应该<code>Intent</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.button2.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.icu007.activitytest.ACTION_START&quot;</span>)</span><br><span class="line">    intent.addCategory(<span class="string">&quot;com.icu007.activitytest.MY_CATEGORY&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-更多隐式Intent的用法"><a href="#2-2-1-更多隐式Intent的用法" class="headerlink" title="2.2.1 更多隐式Intent的用法"></a>2.2.1 更多隐式Intent的用法</h4><p>使用隐式<strong>Intent</strong>，不仅可以启动自己程序内的<code>Activity</code>，还可以启动其他程序的<code>Activity</code>，这就使多个应用程序之间的功能共享成为了可能。比如你的应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），只需要调用系统的浏览器来打开这个网页就行了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.button2.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_VIEW)</span><br><span class="line">    intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;http://icu007.work&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先指定了<strong>Intent</strong>的<code>action</code>是<code>Intent.ACTION_VIEW</code>，这是一个<code>Android</code>系统内置的动作，其常量值为<code>android.intent.action.VIEW</code>。然后通过<code>Uri.parse()</code>方法将一个网址字符串解析成一个<code>Uri</code>对象，再调用<strong>Intent</strong>的<code>setData()</code>方法将这个Uri对象传递进去。当然，这里再次使用了前面学习的语法糖，看上去像是给<strong>Intent</strong>的<code>data</code>属性赋值一样。</p><p>我们还可以在<code>&lt;intent-filter&gt;</code>标签中再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前<code>Activity</code>能够响应的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容。</p><ul><li><code>android:scheme</code>：用于指定数据的协议部分，如上例中的https部分；</li><li><code>android:host</code>：用于指定数据的主机名部分，如上例中的<a href="http://www.baidu.com部分;/">www.baidu.com部分；</a></li><li><code>android:port</code>：用于指定数据的端口部分，一般紧随在主机名之后；</li><li><code>android:path</code>：用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容；</li><li><code>android:mimeType</code>：用于指定可以处理的数据类型，允许使用通配符的方式进行指定。</li></ul><p>只有当<code>&lt;data&gt;</code>标签中指定的内容和<strong>Intent</strong>中携带的<code>Data</code>完全一致时，当前<code>Activity</code>才能够响应该<strong>Intent</strong>。不过，在<code>&lt;data&gt;</code>标签中一般不会指定过多的内容。例如在上面的浏览器示例中，其实只需要指定<code>android:scheme</code>为<strong>https</strong>，就可以响应所有<strong>https</strong>协议的<strong>Intent</strong>了。</p><p>除了<strong>https</strong>协议外，我们还可以指定很多其他协议，比如<strong>geo</strong>表示显示地理位置、<strong>tel</strong>表示拨打电话。下面的代码展示了如何在我们的程序中调用系统拨号界面。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.button2.setOnClickListener &#123;</span><br><span class="line">     <span class="keyword">val</span> intent1 = Intent(Intent.ACTION_DIAL)</span><br><span class="line">     intent1.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;tel:10086&quot;</span>)</span><br><span class="line">     startActivity(intent1)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-向下一个Activity传递数据"><a href="#2-3-向下一个Activity传递数据" class="headerlink" title="2.3 向下一个Activity传递数据"></a>2.3 向下一个Activity传递数据</h3><p>到目前为止，我们只是简单地使用<strong>Intent</strong>来启动一个<code>Activity</code>，其实<strong>Intent</strong>在启动<code>Activity</code>的时候还可以传递数据。</p><p>在启动<code>Activity</code>时传递数据的思路很简单，<strong>Intent</strong>中提供了一系列<code>putExtra()</code>方法的重载，可以把我们想要传递的数据暂存在<strong>Intent</strong>中，在启动另一个<code>Activity</code>后，只需要把这些数据从<strong>Intent</strong>中取出就可以了。比如说<code>FirstActivity</code>中有一个字符串，现在想把这个字符串传递到<code>SecondActivity</code>中，你就可以这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">binding.button1.setOnClickListener&#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">&quot;hello SecondActivity&quot;</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;extra_data&quot;</span>,<span class="keyword">data</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还是使用显式<strong>Intent</strong>的方式来启动<code>SecondActivity</code>，并通过<code>putExtra()</code>方法传递了一个字符串。注意，这里<code>putExtra()</code>方法接收两个参数，第一个参数是键，用于之后从<strong>Intent</strong>中取值，第二个参数才是真正要传递的数据。然后在<code>SecondActivity</code>中将传递的数据取出，并打印出来，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> bindings = ActivitySecondBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(bindings.root)</span><br><span class="line">        <span class="keyword">val</span> extraData = intent.getStringExtra(<span class="string">&quot;extra_data&quot;</span>)</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, extraData, Toast.LENGTH_SHORT).show()</span><br><span class="line">        bindings.button2.text = <span class="string">&quot;前往FirstActivity&quot;</span></span><br><span class="line">        bindings.button2.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, FirstActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的<strong>intent</strong>实际上调用的是父类的<code>getIntent()</code>方法，该方法会获取用于启动<code>SecondActivity</code>的<strong>Intent</strong>，然后调用<code>getStringExtra()</code>方法并传入相应的键值，就可以得到传递的数据了。这里由于我们传递的是字符串，所以使用<code>getStringExtra()</code>方法来获取传递的数据。如果传递的是整型数据，则使用<code>getIntExtra()</code>方法；如果传递的是布尔型数据，则使用<code>getBooleanExtra()</code>方法，以此类推。</p><h3 id="2-4-返回数据给上一个Activity"><a href="#2-4-返回数据给上一个Activity" class="headerlink" title="2.4 返回数据给上一个Activity"></a>2.4 返回数据给上一个Activity</h3><p>既然可以传递数据给下一个<code>Activity</code>，那么能不能够返回数据给上一个<code>Activity</code>呢？答案是肯定的。不过不同的是，返回上一个<code>Activity</code>只需要按一下<strong>Back</strong>键就可以了，并没有一个用于启动<code>Activity</code>的<strong>Intent</strong>来传递数据，这该怎么办呢？其实<code>Activity</code>类中还有一个用于启动<code>Activity</code>的<code>startActivityForResult()</code>方法，但它期望在<code>Activity</code>销毁的时候能够返回一个结果给上一个<code>Activity</code>。毫无疑问，这就是我们所需要的。</p><p><code>startActivityForResult()</code>方法接收两个参数：第一个参数还是<strong>Intent</strong>；第二个参数是<strong>请求码</strong>，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改<code>FirstActivity</code>中按钮的点击事件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE = <span class="number">1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    binding.button3.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">when</span> (requestCode)&#123;</span><br><span class="line">        REQUEST_CODE -&gt;&#123;</span><br><span class="line">            <span class="keyword">val</span> code = requestCode</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = <span class="keyword">data</span>?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;code: <span class="variable">$code</span>, data: <span class="variable">$data</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onActivityResult: code: <span class="variable">$code</span>, data: <span class="variable">$data</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了<code>startActivityForResult()</code>方法来启动<code>SecondActivity</code>，请求码只要是一个唯一值即可，这里传入了<code>1024</code>。接下来我们在<code>SecondActivity</code>中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bindings.button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent()</span><br><span class="line">    intent.putExtra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>)</span><br><span class="line">    setResult(<span class="number">1024</span>, intent)</span><br><span class="line">    finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方式在在&#96;&#96;androidx.activity-1.2.0-alpha04<code>时开始就已经被弃用了.Android中这位被调用过无数次的</code>startActivityForResult<code>和</code>onActivityResult<code>，已经被官方标记为弃用了，继而推出了名为</code>Activity Result API&#96;的组件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG: String? = <span class="string">&quot;FirstActivity&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> resultLauncher: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> launcherCallback = ActivityResultCallback&lt;ActivityResult&gt; &#123; result -&gt;</span><br><span class="line">        <span class="keyword">val</span> code = result.resultCode</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = result.<span class="keyword">data</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;code: <span class="variable">$code</span>, data: <span class="subst">$&#123;data?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE = <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        resultLauncher = registerForActivityResult(</span><br><span class="line">            ActivityResultContracts.StartActivityForResult(),</span><br><span class="line">            launcherCallback</span><br><span class="line">        )</span><br><span class="line">        binding.button3.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="comment">//            startActivityForResult(intent, REQUEST_CODE)</span></span><br><span class="line">            resultLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实分为三个部分：对载体、定义协定、回调3个类分别定义写出来。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> resultLauncher: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> launcherCallback = ActivityResultCallback&lt;ActivityResult&gt; &#123; result -&gt;</span><br><span class="line">    <span class="keyword">val</span> code = result.resultCode</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = result.<span class="keyword">data</span></span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;code: <span class="variable">$code</span>, data: <span class="subst">$&#123;data?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    resultLauncher = registerForActivityResult(</span><br><span class="line">        ActivityResultContracts.StartActivityForResult(),</span><br><span class="line">        launcherCallback</span><br><span class="line">    )</span><br><span class="line">    resultLauncher.launch(Intent(<span class="keyword">this</span>,SecondActivity::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实大部分情况下，我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> launcherActivity = registerForActivityResult(</span><br><span class="line">    ActivityResultContracts.StartActivityForResult()) &#123;</span><br><span class="line">    <span class="keyword">val</span> code = it.resultCode</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = it.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    launcherActivity.launch(Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是瞬间清爽了许多，但是…你还是觉得比使用<code>startActivityForResult</code>更复杂？其实不然，因为上面代码的需求是一个单一的回调，所以看着似乎<code>startActivityForResult</code>更便于维护和使用。但倘若编写一个稍复杂的页面，需要同时请求相册、需要在其它<strong>Activity</strong>选择数据并回调、需要判断权限等等时，继续使用<code>startActivityForResult</code>，会导致<code>onActivityResult</code>里掺杂各种嵌套及判断，导致代码难以维护。而使用<code>registerForActivityResult()</code>可以多次调用以注册多个 <code>ActivityResultLauncher</code> 实例，用来处理不同的<strong>Activity</strong>结果，让代码更便于维护。</p><p>优势了解到了，但既然需要使用新的功能，那么我们就必须要先了解以下，刚说到的<code>ActivityResultLauncher</code>、<code>ActivityResultContract</code>、<code>ActivityResultCallback</code>到底是些什么东西</p><ul><li><strong>ActivityResultLauncher</strong> 从字面意思其实就能很好理解，可以理解它就是一个Activity的启动器，它的作用就是承载启动对象与返回对象，通过<code>registerForActivityResult</code>返回该对象，这时并不会立即启动另一个Activity。</li><li><strong>ActivityResultContract</strong> 是用来协定所需的输入类型以及结果的输出类型，Android默认提供了一些常用的定义，例如上面所使用到到<code>ActivityResultContracts.StartActivityForResult()</code>。当然这里你也可以通过继承<code>ActivityResultContract</code>实现自己的定义。</li><li><strong>ActivityResultCallback</strong> 通过名字就可以了解到这是启动Activity并返回到当前Activity时的结果回调。</li></ul><p>对于这3个类，其实只需重点了解<code>ActivityResultContract</code>，就能很轻松的理解并使用好<code>Activity Result API</code>了。</p><blockquote><p>官方文档的警告</p><p><strong>注意</strong>：虽然在 fragment 或 activity 创建完毕之前可安全地调用 <code>registerForActivityResult()</code>，但在 fragment 或 activity 的 <code>Lifecycle</code> 变为 <code>CREATED</code> 状态之前，您无法启动 <code>ActivityResultLauncher</code>。</p></blockquote><h2 id="三、Activity的生命周期"><a href="#三、Activity的生命周期" class="headerlink" title="三、Activity的生命周期"></a>三、Activity的生命周期</h2><p>掌握<strong>Activity</strong>的生命周期对任何<strong>Android</strong>开发者来说都非常重要，当你深入理解<strong>Activity</strong>的生命周期之后，就可以写出更加连贯流畅的程序，并在如何合理管理应用资源方面发挥得游刃有余。你的应用程序也将会拥有更好的用户体验。</p><h3 id="3-1-返回栈"><a href="#3-1-返回栈" class="headerlink" title="3.1 返回栈"></a>3.1 返回栈</h3><p>经过前面几节的学习，相信你已经发现了<strong>Android</strong>中的<strong>Activity</strong>是可以层叠的。我们每启动一个新的<strong>Activity</strong>，就会覆盖在原<strong>Activity</strong>之上，然后点击<strong>Back</strong>键会销毁最上面的<strong>Activity</strong>，下面的一个<strong>Activity</strong>就会重新显示出来。</p><p>其实<strong>Android</strong>是使用任务（<strong>task</strong>）来管理<strong>Activity</strong>的，一个任务就是一组存放在栈里的<strong>Activity</strong>的集合，这个栈也被称作返回栈（<strong>back stack</strong>）。栈是一种<strong>后进先出</strong>的数据结构，<strong>在默认情况下，每当我们启动了一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置</strong>。而每当我们按下<strong>Back</strong>键或调用<code>finish()</code>方法去销毁一个<strong>Activity</strong>时，处于栈顶的<strong>Activity</strong>就会出栈，前一个入栈的<strong>Activity</strong>就会重新处于栈顶的位置。系统总是会显示处于栈顶的<strong>Activity</strong>给用户。</p><p><img src="https://pic.ziyuan.wang/2023/09/22/guest_8e608b6d30eef_IP210.22.23.7_UPTIME1695350133.png" alt="返回栈管理Activity入栈出栈操作"></p><h3 id="3-2-Activity状态"><a href="#3-2-Activity状态" class="headerlink" title="3.2 Activity状态"></a>3.2 Activity状态</h3><p>每个<strong>Activity</strong>在其生命周期中最多可能会有4种状态。</p><h4 id="3-2-1-运行状态"><a href="#3-2-1-运行状态" class="headerlink" title="3.2.1 运行状态"></a>3.2.1 运行状态</h4><p>当一个<strong>Activity</strong>位于返回栈的栈顶时，<strong>Activity</strong>就处于运行状态。系统最不愿意回收的就是处于运行状态的<strong>Activity</strong>，因为这会带来非常差的用户体验。</p><h4 id="3-2-2-暂停状态"><a href="#3-2-2-暂停状态" class="headerlink" title="3.2.2 暂停状态"></a>3.2.2 暂停状态</h4><p>当一个<strong>Activity不再处于栈顶位置，但仍然可见时</strong>，<strong>Activity</strong>就进入了<strong>暂停</strong>状态。你可能会觉得，既然Activity已经不在栈顶了，怎么会可见呢？这是因为并不是每一个Activity都会占满整个屏幕，比如对话框形式的Activity只会占用屏幕中间的部分区域。处于暂停状态的Activity仍然是完全存活着的，系统也不愿意回收这种Activity（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种Activity。</p><h4 id="3-2-3-停止状态"><a href="#3-2-3-停止状态" class="headerlink" title="3.2.3 停止状态"></a>3.2.3 停止状态</h4><p><strong>当一个Activity不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。</strong>系统仍然会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的Activity有可能会被系统回收。</p><h4 id="3-2-4-销毁状态"><a href="#3-2-4-销毁状态" class="headerlink" title="3.2.4 销毁状态"></a>3.2.4 销毁状态</h4><p><strong>一个Activity从返回栈中移除后就变成了销毁状态</strong>。<strong>系统最倾向于回收处于这种状态的Activity</strong>，以保证手机的内存充足。</p><h3 id="3-3-Activity的生存期"><a href="#3-3-Activity的生存期" class="headerlink" title="3.3 Activity的生存期"></a>3.3 Activity的生存期</h3><p>Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节，下面就来一一介绍这7个方法。</p><ul><li><code>onCreate()</code>:这个方法你已经看到过很多次了，我们在每个Activity中都重写了这个方法，它会在Activity第一次被创建的时候调用。你应该在这个方法中完成Activity的初始化操作，比如加载布局、绑定事件等。</li><li><code>onStart()</code>:这个方法在Activity由不可见变为可见的时候调用。</li><li><code>onResume()</code>:这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一定位于返回栈的栈顶，并且处于运行状态。</li><li><code>onPause()</code>:这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶Activity的使用。</li><li><code>onStop()</code>:这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。</li><li><code>onDestroy()</code>:这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</li><li><code>onRestart()</code>:这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</li></ul><p>以上7个方法中除了<code>onRestart()</code>方法，其他都是两两相对的，从而又可以将<strong>Activity</strong>分为以下3种生存期。</p><ul><li><strong>完整生存期</strong>：Activity在<code>onCreate()</code>方法和<code>onDestroy()</code>方法之间所经历的就是完整生存期。一般情况下，一个Activity会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。</li><li><strong>可见生存期</strong>：Activity在<code>onStart()</code>方法和<code>onStop()</code>方法之间所经历的就是可见生存期。在可见生存期内，Activity对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法合理地管理那些对用户可见的资源。比如在<code>onStart()</code>方法中对资源进行加载，而在<code>onStop()</code>方法中对资源进行释放，从而保证处于停止状态的Activity不会占用过多内存。</li><li><strong>前台生存期</strong>：Activity在<code>onResume()</code>方法和<code>onPause()</code>方法之间所经历的就是前台生存期。在前台生存期内，Activity总是处于运行状态，此时的Activity是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的Activity。</li></ul><p>为了帮助我们理解，Android官方提供了一张Activity生命周期的示意图，如图所示：</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_4aec46f2fe334_IP210.22.23.7_UPTIME1695438124.png" alt="1695438122586.png"></p><h3 id="3-4-体验Activity的生命周期"><a href="#3-4-体验Activity的生命周期" class="headerlink" title="3.4 体验Activity的生命周期"></a>3.4 体验Activity的生命周期</h3><p>如果我们重写Activity中的：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>、<code>onDestroy()</code>和<code>onRestart()</code>方法并打印log，我们就可以发现：Activity在第一次被创建时会依次执行<code>onCreate()</code>、<code>onStart()</code>和onResume()方法。如下所示：</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_7a524a4f102bd_IP210.22.23.7_UPTIME1695459211.png" alt="1695459210334.png"></p><p>Activity启动后 我们按下Home键：由于MainAtivity已经不再可见，因此<code>onPause()</code>和<code>onStop()</code>方法都会得到执行。</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_950a90c3af688_IP210.22.23.7_UPTIME1695459060.png" alt="1695459058606.png"></p><p>接下来我们再次进入应用，由于之前MainActivity已经进入了停止状态，所以<code>onRestart()</code>方法会得到执行，之后会依次执行<code>onStart()</code>和<code>onResume()</code>方法。注意，<strong>此时<code>onCreate()</code>方法不会执行，因为MainActivity并没有重新创建。</strong></p><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20230923165303676.png" alt="image-20230923165303676"></p><p>假如我们在MainActivity当中启动了一个Dialog，此时我们再去观察打印信息就会发现：</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_908b26616516a_IP210.22.23.7_UPTIME1695459420.png" alt="1695459418512.png"></p><p>只有<code>onPause()</code>方法得到了执行，<code>onStop()</code>方法并没有执行，这是因为DialogActivity并没有完全遮挡住MainActivity，<strong>此时MainActivity只是进入了暂停状态，并没有进入停止状态</strong>。相应地，按下Back键返回MainActivity也应该只有<code>onResume()</code>方法会得到执行</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_1752fd92f9fa7_IP210.22.23.7_UPTIME1695459808.png" alt="1695459806957.png"></p><p>当调用了 <code>finish()</code>方法结束Activity时，依次会执行<code>onPause()</code>、<code>onStop()</code>和<code>onDestroy()</code>方法，最终销毁MainActivity。</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_46ea5f1413bda_IP210.22.23.7_UPTIME1695459615.png" alt="1695459613638.png"></p><h3 id="3-5-Activity被回收了怎么办"><a href="#3-5-Activity被回收了怎么办" class="headerlink" title="3.5 Activity被回收了怎么办"></a>3.5 Activity被回收了怎么办</h3><p>前面我们说过，当一个Activity进入了停止状态，是有可能被系统回收的。那么想象以下场景：应用中有一个Activity A，用户在Activity A的基础上启动了Activity B，Activity A就进入了停止状态，这个时候由于系统内存不足，将Activity A回收掉了，然后用户按下Back键返回Activity A，会出现什么情况呢？其实还是会正常显示Activity A的，只不过这时并不会执行onRestart()方法，而是会执行Activity A的onCreate()方法，因为Activity A在这种情况下会被重新创建一次。</p><p>这样看上去好像一切正常，可是别忽略了一个重要问题：Activity A中是可能存在临时数据和状态的。打个比方，MainActivity中如果有一个文本输入框，现在你输入了一段文字，然后启动NormalActivity，这时MainActivity由于系统内存不足被回收掉，过了一会你又点击了Back键回到MainActivity，你会发现刚刚输入的文字都没了，因为MainActivity被重新创建了。</p><p>如果我们的应用出现了这种情况，是会比较影响用户体验的，所以得想想办法解决这个问题。其实，Activity中还提供了一个<code>onSaveInstanceState()</code>回调方法，这个方法可以保证在Activity被回收之前一定会被调用，因此我们可以通过这个方法来解决问题。</p><p><code>onSaveInstanceState()</code>方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle中取值，第二个参数是真正要保存的内容。</p><p>在MainActivity当中添加如下代码就可以将临时数据进行保存了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line">       <span class="keyword">val</span> tempData = <span class="string">&quot;Something u just typed&quot;</span></span><br><span class="line">       outState.putString(<span class="string">&quot;data_key&quot;</span>, tempData)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一直使用的onCreate()方法其实也有一个Bundle类型的参数。这个参数在一般情况下都是null，但是如果在Activity被系统回收之前，你通过onSaveInstanceState()方法保存数据，这个参数就会带有之前保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。</p><p>修改MainActivity方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    Log.d(tag, <span class="string">&quot;onCreate: Activity第一次被创建的时候调用&quot;</span>)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    <span class="keyword">if</span>(savedInstanceState != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> tempData = savedInstanceState.getString(<span class="string">&quot;data_key&quot;</span>,<span class="literal">null</span>)</span><br><span class="line">        Log.d(tag, <span class="string">&quot;onCreate: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出值之后再做相应的恢复操作就可以了，比如将文本内容重新赋值到文本输入框上.</p><p>不知道你有没有察觉，使用Bundle保存和取出数据是不是有些似曾相识呢？没错！我们在使用Intent传递数据时也用的类似的方法。这里提醒一点，Intent还可以结合Bundle一起用于传递数据。首先我们可以把需要传递的数据都保存在Bundle对象中，然后再将Bundle对象存放在Intent里。到了目标Activity之后，先从Intent中取出Bundle，再从Bundle中一一取出数据。</p><hr><h2 id="四、Activity的启动模式"><a href="#四、Activity的启动模式" class="headerlink" title="四、Activity的启动模式"></a>四、Activity的启动模式</h2><p>在实际项目中我们应该根据特定的需求为每个<strong>Activity</strong>指定恰当的启动模式。启动模式一共有4种，分别是<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>和<code>singleInstance</code>，可以在<strong>AndroidManifest.xml</strong>中通过给**<code>&lt;activity&gt;</code>**标签指定<code>android:launchMode</code>属性来选择启动模式。</p><h3 id="4-1-standard"><a href="#4-1-standard" class="headerlink" title="4.1 standard"></a>4.1 standard</h3><p>standard是Activity默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用这种启动模式。Android是使用返回栈来管理Activity的，<strong>在standard模式下，每当启动一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置。</strong>对于使用standard模式的Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建一个该Activity的新实例。</p><p>standard模式的原理：</p><p><img src="https://pic.ziyuan.wang/2023/09/25/guest_6d3de3b7b8990_IP210.22.23.7_UPTIME1695630789.png" alt="1695630787163.png"></p><h3 id="4-2-singleTop"><a href="#4-2-singleTop" class="headerlink" title="4.2 singleTop"></a>4.2 singleTop</h3><p>可能在有些情况下，<strong>standard</strong>模式不太合理。Activity明明已经在栈顶了，为什么再次启动的时候还要创建一个新的Activity实例呢？</p><p>别着急，这只是系统默认的一种启动模式而已，你完全可以根据自己的需要进行修改，比如使用<strong>singleTop模式</strong>。当Activity的启动模式指定为singleTop，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。</p><p>在 <strong>AndroidManifest.xml</strong>中可以如下设置：<code>android:launchMode=&quot;singleTop&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.ziyuan.wang/2023/09/26/guest_1dc0c06bc5b27_IP210.22.23.7_UPTIME1695716282.png" alt="1695716279930.png"></p><p>有这么一种情况：从 <strong>FirstActivity</strong>启动 <strong>SecondActivity</strong> 再从 <strong>SecondActivity</strong>启动 <strong>FirstActivity</strong>。</p><p>此时系统就创建了两个不同的FirstActivity实例，这是由于在SecondActivity中再次启动FirstActivity时，栈顶Activity已经变成了SecondActivity，因此会创建一个新的FirstActivity实例。</p><h3 id="4-3-singleTask"><a href="#4-3-singleTask" class="headerlink" title="4.3 singleTask"></a>4.3 singleTask</h3><p><strong>使用singleTop模式可以很好地解决重复创建栈顶Activity的问题</strong>，如果该Activity并没有处于栈顶的位置，还是可能会创建多个Activity实例的。那么有没有什么办法可以让某个Activity在整个应用程序的上下文中只存在一个实例呢？这就要借助singleTask模式来实现了。<strong>当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。</strong></p><p>通过代码更直观的感受一下</p><p>首先从 <strong>FirstActivity</strong>启动 <strong>SecondActivity</strong> 再从 <strong>SecondActivity</strong>启动 <strong>FirstActivity</strong>。在相应的生存周期加上日志打印：</p><p><img src="https://pic.ziyuan.wang/2023/10/07/guest_a37c3b91912f5_IP38.207.142.167_UPTIME1696648431.png" alt="1696648430077.png"></p><p>其实从打印信息中就可以明显看出，在<strong>SecondActivity</strong>中启动<strong>FirstActivity</strong>时，会发现返回栈中已经存在一个<strong>FirstActivity</strong>的实例，并且是在<strong>SecondActivity</strong>的下面，于是<strong>SecondActivity</strong>会从返回栈中出栈，而<strong>FirstActivity重新成为了栈顶Activity，因此FirstActivity的<code>onRestart()</code>方法和SecondActivity的<code>onDestroy()</code>方法会得到执行</strong>。现在返回栈中只剩下一个FirstActivity的实例了，按一下Back键就可以退出程序。</p><p>SingleTask 模式原理</p><p><img src="https://pic.ziyuan.wang/2023/10/07/guest_430ee7fa2a0dc_IP38.207.142.167_UPTIME1696649401.png" alt="1696649398154.png"></p><h3 id="4-3-singleInstance"><a href="#4-3-singleInstance" class="headerlink" title="4.3 singleInstance"></a>4.3 singleInstance</h3><p><strong>singleInstance</strong>模式应该算是4种启动模式中最特殊也最复杂的一个了。不同于以上3种启动模式，<strong>指定为singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</strong>那么这样做有什么意义呢？想象以下场景，假设我们的程序中有一个<strong>Activity</strong>是允许其他程序调用的，如果想实现其他程序和我们的程序可以共享这个<strong>Activity</strong>的实例，应该如何实现呢？使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个<strong>Activity</strong>在不同的返回栈中入栈时必然创建了新的实例。而使用<strong>singleInstance</strong>模式就可以解决这个问题，在这种模式下，会有一个单独的返回栈来管理这个<strong>Activity</strong>，不管是哪个应用程序来访问这个<strong>Activity</strong>，都共用同一个返回栈，也就解决了共享<strong>Activity</strong>实例的问题。</p><p>为了更好理解这种启动模式，接下来实践一下：在<code>AndroidManifest.xml</code>中修改启动模式为 <strong>singleInstance</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后从 <strong>MainActivity</strong>启动 <strong>NormalActivity</strong>,再从<strong>NormalActivity</strong>启动<strong>ThirdActivity</strong>。并在这几个<strong>Activity</strong>中分别打印出<strong>TaskID</strong>。</p><p><strong>通过打印我们可以发现 MainActivity是单独在一个返回栈的，NormalActivity和ThirdActivity在另外一个返回栈。</strong></p><p><img src="https://pic.ziyuan.wang/2023/10/08/guest_5704819fa6887_IP210.22.23.7_UPTIME1696732588.png" alt="1696732586522.png"></p><p><strong>singleInstance</strong>模式的原理如图所示</p><p><img src="https://pic.ziyuan.wang/2023/10/08/guest_aaeb91b4fdf1e_IP210.22.23.7_UPTIME1696734778.png" alt="1696734776879.png"></p><hr><h2 id="五、Activity的最佳实践"><a href="#五、Activity的最佳实践" class="headerlink" title="五、Activity的最佳实践"></a>五、Activity的最佳实践</h2><h3 id="5-1-知晓当前是在哪一个Activity"><a href="#5-1-知晓当前是在哪一个Activity" class="headerlink" title="5.1 知晓当前是在哪一个Activity"></a>5.1 知晓当前是在哪一个Activity</h3><p>我们还是在ActivityTest项目的基础上修改，首先需要新建一个BaseActivity类。右击com.example.activitytest包→New→Kotlin File&#x2F;Class，在弹出的窗口中输入BaseActivity，创建类型选择Class。让BaseActivity继承自AppCompatActivity，并重写onCreate()方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR BaseActivity&quot;</span>, javaClass.simpleName)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在onCreate()方法中加了一行日志，用于打印当前实例的类名。这里我要额外说明一下，Kotlin中的javaClass表示获取当前实例的Class对象，相当于在Java中调用getClass()方法；而Kotlin中的BaseActivity::class.java表示获取BaseActivity类的Class对象，相当于在Java中调用BaseActivity.class。在上述代码中，我们先是获取了当前实例的Class对象，然后再调用simpleName获取当前实例的类名。</p><p>下来我们需要让BaseActivity成为ActivityTest项目中所有Activity的父类，为了使BaseActivity可以被继承，我已经提前在类名的前面加上了open关键字。然后修改FirstActivity、SecondActivity和ThirdActivity的继承结构，让它们不再继承自AppCompatActivity，而是继承自BaseActivity。而由于BaseActivity又是继承自AppCompatActivity的，所以项目中所有Activity的现有功能并不受影响，它们仍然继承了Activity中的所有特性。</p><p>通过日志可以看到，启动的Activity都被打印出来了。现在每当我们进入一个Activity的界面，该Activity的类名就会被打印出来，这样我们就可以时刻知晓当前界面对应的是哪一个Activity了。</p><p><img src="https://pic.ziyuan.wang/2023/10/08/guest_35b81189e5066_IP210.22.23.7_UPTIME1696756272.png" alt="1696756270348.png"></p><h3 id="5-2-随时随地退出程序"><a href="#5-2-随时随地退出程序" class="headerlink" title="5.2 随时随地退出程序"></a>5.2 随时随地退出程序</h3><p>如果手机的界面停留在ThirdActivity，我们会发现当前想退出程序是非常不方便的，需要连按3次Back键才行。按Home键只是把程序挂起，并没有退出程序。如果我们的程序需要注销或者退出的功能该怎么办呢？看来要有一个随时随地都能退出程序的方案才行。</p><p>其实解决思路也很简单，只需要用一个专门的集合对所有的Activity进行管理就可以了。下面我们就来实现一下。</p><p>新建一个单例类ActivityCollector作为Activity的集合，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.activitylifecycletest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/11-11:09</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activites = ArrayList&lt;Activity&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR ActivityCollector&quot;</span>, <span class="string">&quot;addActivity: <span class="subst">$&#123;activity.componentName&#125;</span> add&quot;</span>)</span><br><span class="line">        activites.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR ActivityCollector&quot;</span>, <span class="string">&quot;removeActivity: <span class="subst">$&#123;activity.componentName&#125;</span> remove&quot;</span>)</span><br><span class="line">        activites.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activites)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing)&#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activites.clear()</span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid())</span><br><span class="line">        Log.d(<span class="string">&quot;LCR ActivityCollector&quot;</span>, <span class="string">&quot;finishAll: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了单例类，是因为全局只需要一个Activity集合。在集合中，我们通过一个ArrayList来暂存Activity，然后提供了一个addActivity()方法，用于向ArrayList中添加Activity；提供了一个removeActivity()方法，用于从ArrayList中移除Activity；最后提供了一个finishAll()方法，用于将ArrayList中存储的Activity全部销毁。注意在销毁Activity之前，我们需要先调用activity.isFinishing来判断Activity是否正在销毁中，因为Activity还可能通过按下Back键等方式被销毁，如果该Activity没有正在销毁中，我们再去调用它的finish()方法来销毁它。</p><p>接下来修改 BaseActivity中的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR BaseActivity&quot;</span>, javaClass.simpleName)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">//        Log.d(&quot;LCR BaseActivity&quot;, &quot;onCreate: $&#123;javaClass.simpleName&#125; added&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">//        Log.d(&quot;LCR BaseActivity&quot;, &quot;onDestroy: $&#123;javaClass.simpleName&#125; removed&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BaseActivity的onCreate()方法中调用了ActivityCollector的addActivity()方法，表明将当前正在创建的Activity添加到集合里。然后在BaseActivity中重写onDestroy()方法，并调用了ActivityCollector的removeActivity()方法，表明从集合里移除一个马上要销毁的Activity。</p><p>从此以后，不管你想在什么地方退出程序，只需要调用ActivityCollector.finishAll()方法就可以了。例如在ThirdActivity界面想通过点击按钮直接退出程序，只需将代码改成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdActivity</span> : <span class="type">BaseActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityThirdBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;LCR&quot;</span>, <span class="string">&quot;onCreate: TaskId is <span class="variable">$taskId</span>&quot;</span>)</span><br><span class="line">        binding = ActivityThirdBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        binding.btnFinish.setOnClickListener &#123;</span><br><span class="line">            ActivityCollector.finishAll()</span><br><span class="line"><span class="comment">//            android.os.Process.killProcess(android.os.Process.myPid())</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-启动Activity的最佳写法"><a href="#5-3-启动Activity的最佳写法" class="headerlink" title="5.3 启动Activity的最佳写法"></a>5.3 启动Activity的最佳写法</h3><p>启动Activity的方法相信我们已经非常熟悉了，首先通过Intent构建出当前的“意图”，然后调用startActivity()或startActivityForResult()方法将Activity启动起来，如果有数据需要在Activity之间传递，也可以借助Intent来完成。</p><p>假设SecondActivity中需要用到两个非常重要的字符串参数，在启动SecondActivity的时候必须传递过来，那么我们很容易会写出如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>虽然这样写是完全正确的，但是在真正的项目开发中经常会出现对接的问题。比如SecondActivity并不是由你开发的，但现在你负责开发的部分需要启动SecondActivity，而你却不清楚启动SecondActivity需要传递哪些数据。这时无非就有两个办法：一个是你自己去阅读SecondActivity中的代码，另一个是询问负责编写SecondActivity的同事。你会不会觉得很麻烦呢？其实只需要换一种写法，就可以轻松解决上面的窘境。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> : BaseActivity() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, data1: <span class="type">String</span>, data2: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(context, ThirdActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param1&quot;</span>, data1)</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param2&quot;</span>, data2)</span><br><span class="line">        context.startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用了一个新的语法结构companion object，并在companion object中定义了一个actionStart()方法。之所以要这样写，是因为Kotlin规定，所有定义在companionobject中的方法都可以使用类似于Java静态方法的形式调用。</p><p>接下来我们重点看actionStart()方法，在这个方法中完成了Intent的构建，另外所有SecondActivity中需要的数据都是通过actionStart()方法的参数传递过来的，然后把它们存储到Intent中，最后调用startActivity()方法启动SecondActivity。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ViewBinding&quot;&gt;&lt;a href=&quot;#一、ViewBinding&quot; class=&quot;headerlink&quot; title=&quot;一、ViewBinding&quot;&gt;&lt;/a&gt;一、ViewBinding&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是ViewBinding&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin入门</title>
    <link href="https://icu007work.github.io/archives/add4ecd9.html"/>
    <id>https://icu007work.github.io/archives/add4ecd9.html</id>
    <published>2023-09-11T07:56:35.000Z</published>
    <updated>2023-09-12T01:34:50.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin入门"><a href="#Kotlin入门" class="headerlink" title="Kotlin入门"></a>Kotlin入门</h1><h2 id="一、变量和函数"><a href="#一、变量和函数" class="headerlink" title="一、变量和函数"></a>一、变量和函数</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><ul><li>在<strong>Kotlin</strong>中定义变量的方式和<strong>Java</strong>区别很大，在<strong>Java</strong>中如果想要定义一个变量，需要在变量前面声明这个变量的类型，比如说<code>int a</code>表示<code>a</code>是一个整型变量，<code>String b</code>表示<code>b</code>是一个字符串变量。而<strong>Kotlin</strong>中定义一个变量，只允许在变量前声明两种关键字：<code>val</code>和 <code>var</code>。<ul><li><code>val</code>（<strong>value</strong>的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应<strong>Java</strong>中的<code>final</code>变量。</li><li><code>var</code>（<strong>variable</strong>的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应<strong>Java</strong>中的<strong>非</strong><code>final</code>变量。</li></ul></li><li>仅仅使用<code>val</code>或者<code>var</code>来声明一个变量，那么编译器怎么能知道这个变量是什么类型呢？这也是Kotlin比较有特色的一点，它拥有出色的类型推导机制。</li><li>🌰举个栗子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;a = &quot;</span> + a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上述代码中，我们使用<code>val</code>关键字定义了一个变量<code>a</code>，并将它赋值为<strong>10</strong>，这里<code>a</code>就会被自动推导成整型变量。因为既然你要把一个整数赋值给<code>a</code>，那么<code>a</code>就只能是整型变量，而如果你要把一个<strong>字符串</strong>赋值给<code>a</code>的话，那么<code>a</code>就会被自动推导成<strong>字符串变量</strong>，这就是<strong>Kotlin</strong>的<strong>类型推导机制</strong>。</li><li>但是<strong>Kotlin</strong>的类型推导机制并不总是可以正常工作的，比如说如果我们对一个变量延迟赋值的话，<strong>Kotlin</strong>就无法自动推导它的类型了。这时候就需要显式地声明变量类型才行，<strong>Kotlin</strong>提供了对这一功能的支持，语法如下所示:</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>在上述代码中我们显式的声明了变量 <code>a</code> 为 <code>Int</code> 类型，这个时候 <strong>Kotlin</strong>就不会再进行类型推导了。如果此时我们再尝试将一个 <strong>字符串</strong>复制给 <code>a</code>，那么编译器会抛出一个类型不匹配的异常。</li><li><strong>Kotlin</strong>中<code>Int</code>的首字母是大写的，而<strong>Java</strong>中<code>int</code>的首字母是小写的。不要小看这一个字母大小写的差距，这表示<strong>Kotlin</strong>完全抛弃了<strong>Java</strong>中的基本数据类型，全部使用了对象数据类型。在<strong>Java</strong>中<code>int</code>是关键字，而在<strong>Kotlin</strong>中<code>Int</code>变成了一个类，它拥有自己的方法和继承结构。下表列出了<strong>Java</strong>中的每一个基本数据类型在<strong>Kotlin</strong>中对应的对象数据类型。</li></ul><table><thead><tr><th align="center">Java基本数据类型</th><th align="center">Kotlin对象数据类型</th><th align="center">数据类型说明</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Int</td><td align="center">整型</td></tr><tr><td align="center">long</td><td align="center">Long</td><td align="center">长整型</td></tr><tr><td align="center">short</td><td align="center">Short</td><td align="center">短整型</td></tr><tr><td align="center">float</td><td align="center">Float</td><td align="center">单精度浮点型</td></tr><tr><td align="center">double</td><td align="center">Double</td><td align="center">双精度浮点型</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td><td align="center">布尔型</td></tr><tr><td align="center">char</td><td align="center">Char</td><td align="center">字符型</td></tr><tr><td align="center">byte</td><td align="center">Byte</td><td align="center">字节型</td></tr></tbody></table><ul><li>在<strong>Java</strong>中，除非你主动在变量前声明了<code>final</code>关键字，否则这个变量就是可变的。然而这并不是一件好事，当项目变得越来越复杂，参与开发的人越来越多时，你永远不知道一个可变的变量会在什么时候被谁给修改了，即使它原本不应该被修改，这就经常会导致出现一些很难排查的问题。因此，一个好的编程习惯是，除非一个变量明确允许被修改，否则都应该给它加上<code>final</code>关键字。</li><li>但是，不是每个人都能养成这种良好的编程习惯。我相信至少有<strong>90%<strong>的</strong>Java</strong>程序员没有主动在变量前加上<code>final</code>关键字的意识，仅仅因为<strong>Java</strong>对此是不强制的。因此，<strong>Kotlin</strong>在设计的时候就采用了和<strong>Java</strong>完全不同的方式，提供了<code>val</code>和<code>var</code>这两个关键字，必须由开发者主动声明该变量是可变的还是不可变的。</li><li><strong>小诀窍</strong>：就是永远优先使用<code>val</code>来声明一个变量，而当<code>val</code>没有办法满足你的需求时再使用<code>var</code>。这样设计出来的程序会更加健壮，也更加符合高质量的编码规范。</li></ul><h3 id="1-2-函数"><a href="#1-2-函数" class="headerlink" title="1.2 函数"></a>1.2 函数</h3><ul><li><strong>函数是用来运行代码的载体</strong>，我们可以在一个函数里编写很多行代码，当运行这个函数时，函数中的所有代码会全部运行。就像<code>main()</code>函数就是一个函数，只不过它比较特殊，是程序的入口函数，即程序一旦运行，就是从<code>main()</code>函数开始执行的。</li><li>但是只有一个main()函数的程序显然是很初级的，和其他编程语言一样，<code>Kotlin</code>也允许我们自由地定义函数，语法规则如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span> <span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先<code>fun</code>（<strong>function</strong>的简写）是定义函数的关键字，无论你在 <code>Kotlin</code> 中定义什么函数，都一定要使用<code>fun</code>来声明。</li><li>其次这里的<code>methodName</code>是函数名，我们可以给它取任何名字，但是最好能够做到<strong>见文知意</strong>。良好的编程习惯是函数名最好要有一定的意义，能表达这个函数的作用是什么。</li><li>函数名后面紧跟着一对括号，里面可以声明该函数接收什么参数，<strong>参数的数量可以是任意多个</strong>，例如上述示例就表示该函数接收两个<code>Int</code>类型的参数。<strong>参数的声明格式是“参数名: 参数类型”</strong>，其中<strong>参数名也是可以随便定义</strong>的，这一点和函数名类似。如果不想接收任何参数，那么写一对空括号就可以了。</li><li><strong>参数括号后面的那部分是可选的，用于声明该函数会返回什么类型的数据</strong>，上述示例就表示该函数会返回一个<code>Int</code>类型的数据。<strong>如果你的函数不需要返回任何数据，这部分可以直接不写。</strong></li><li>最后<strong>两个大括号之间的内容就是函数体</strong>了，我们可以在这里编写一个函数的具体逻辑。由于上述示例中声明了该函数会返回一个<code>Int</code>类型的数据，因此在函数体中我们简单地返回了一个0。</li></ul><p>最后我们再来学习一个<strong>Kotlin</strong>函数的语法糖：当一个函数中只有一行代码时，<strong>Kotlin</strong>允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。</p><ul><li>🌰举个栗子：我们现在编写一个返回两数之间最大数的函数，我们可以这样写</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个函数中，函数体内只有一行代码，此时我们可以不写函数体，简化如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(a, b)</span><br></pre></td></tr></table></figure><ul><li>使用这种语法，<code>return</code>关键字也可以省略了，等号足以表达返回值的意思。另外，之前还讲过<strong>Kotlin</strong>出色的类型推导机制，在这里它也可以发挥重要的作用。由于<code>max()</code>函数返回的是一个<code>Int</code>值，而我们在<code>largerNumber()</code>函数的尾部又使用等号连接了<code>max()</code>函数，因此<strong>Kotlin</strong>可以推导出<code>largerNumber()</code>函数返回的必然也是一个<code>Int</code>值，这样就不用再显式地声明返回值类型了，代码可以进一步简化成如下形式：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = max(a, b)</span><br></pre></td></tr></table></figure><hr><h2 id="二、程序的逻辑控制"><a href="#二、程序的逻辑控制" class="headerlink" title="二、程序的逻辑控制"></a>二、程序的逻辑控制</h2><p>程序的执行语句主要分为3种：顺序语句、条件语句和循环语句。顺序语句很好理解，就是代码一行一行地往下执行就可以了，但是这种“愣头青”的执行方式在很多情况下并不能满足我们的编程需求，这时就需要引入条件语句和循环语句了</p><p><strong>Kotlin</strong>的条件语句主要有两种实现方式：<code>if</code> 和 <code>when</code></p><h3 id="2-1-条件语句"><a href="#2-1-条件语句" class="headerlink" title="2.1 条件语句"></a>2.1 条件语句</h3><h4 id="2-1-1-if条件语句"><a href="#2-1-1-if条件语句" class="headerlink" title="2.1.1 if条件语句"></a>2.1.1 if条件语句</h4><ul><li>首先学习<code>if</code>，<strong>Kotlin</strong>中的<code>if</code>语句和<strong>Java</strong>中的<code>if</code>语句几乎没有任何区别</li><li>🌰举个栗子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以这样写：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> value: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么可以写成上述代码呢？这是因为<strong>Kotlin</strong>中的<code>if</code>语句相比于<strong>Java</strong>有一个额外的功能，它是可以有返回值的，返回值就是<code>if</code>语句每一个条件中最后一行代码的返回值。</li><li>结合之前讲的语法糖，我们可以再简化一下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是上述代码还不是最精简的，我们甚至可以这样写：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><h4 id="2-1-2-when条件语句"><a href="#2-1-2-when条件语句" class="headerlink" title="2.1.2 when条件语句"></a>2.1.2 when条件语句</h4><ul><li>接下来我们开始学习<code>when</code>。<strong>Kotlin</strong>中的<code>when</code>语句有点类似于<strong>Java</strong>中的<code>switch</code>语句，但它又远比<code>switch</code>语句强大得多；</li><li>首先，在<strong>Java</strong>中<code>switch</code>只能传入整型或短于整型的变量作为条件，JDK 1.7之后增加了对字符串变量的支持，但如果你的判断逻辑使用的并非是上述几种类型的变量,<code>switch</code>就不再适用了；其次，<code>switch</code>中的每个<code>case</code>条件都要在最后主动加上一个<code>break</code>，否则执行完当前<code>case</code>之后会依次执行下面的<code>case</code>，这一特性曾经导致过无数奇怪的bug，就是因为有人忘记添加<code>break</code>；</li><li>而 <strong>Kotlin</strong>中的 <code>when</code>语句不仅解决了上述痛点，还增加了许多更为强大的新特性，有时它比if语句还要简单好用。</li><li>🌰 举个栗子</li><li>现在我们编写一个demo,输入一个单词，返回其数字。我们先用if语句来实现:</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNumber</span><span class="params">(words: <span class="type">String</span>)</span></span> = <span class="keyword">if</span>( words = <span class="string">&quot;one&quot;</span>)&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;two&quot;</span>)&#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;three&quot;</span>)&#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;four&quot;</span>)&#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;five&quot;</span>)&#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虽然上述代码确实可以实现我们想要的功能，但是写了这么多的if和else，我们会发现代码很冗余。没错，当你的判断条件非常多的时候，就是应该考虑使用when语句的时候，现在我们将代码改成如下写法：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNumber</span><span class="params">(words: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (words) &#123;</span><br><span class="line">    <span class="string">&quot;one&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">    <span class="string">&quot;two&quot;</span> -&gt; <span class="number">2</span></span><br><span class="line">    <span class="string">&quot;three&quot;</span> -&gt; <span class="number">3</span></span><br><span class="line">    <span class="string">&quot;four&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    <span class="string">&quot;five&quot;</span> -&gt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 **Kotlin **中 <code>when</code>语句和 <code>if</code> 语句一样都有返回值，所以我们仍然可以使用单行代码函数的语法糖；</li><li>在 <strong>Kotlin</strong>中 <code>when</code>语句允许传入一个任意类型的参数，然后可以在<code>when</code>的结构体中定义一系列的条件，格式是：</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配值 -&gt; &#123;执行逻辑&#125;</span><br></pre></td></tr></table></figure><ul><li>当你的执行逻辑只有一行代码时，{ }可以省略。除了精确匹配之外，<code>when</code>语句还允许进行类型匹配。那么什么是类型匹配呢？</li><li>🌰 举个栗子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(num)&#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;number is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;number is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码中，<code>is</code>关键字就是类型匹配的核心，它相当于<strong>Java</strong>中的<code>instanceof</code>关键字。由于<code>checkNumber()</code>函数接收一个<code>Number</code>类型的参数，这是<strong>Kotlin</strong>内置的一个抽象类，像<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>等与数字相关的类都是它的子类，所以这里就可以使用类型匹配来判断传入的参数到底属于什么类型，如果是<code>Int</code>型或<code>Double</code>型，就将该类型打印出来，否则就打印不支持该参数的类型。</li><li>哦对了，在 <strong>Kotlin</strong> 中 <code>when</code>语句还可以不传参数，🌰 举个栗子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNumber</span><span class="params">(words: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    words == <span class="string">&quot;one&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">    words == <span class="string">&quot;two&quot;</span> -&gt; <span class="number">2</span></span><br><span class="line">    words == <span class="string">&quot;three&quot;</span> -&gt; <span class="number">3</span></span><br><span class="line">    words == <span class="string">&quot;four&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    words == <span class="string">&quot;five&quot;</span> -&gt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-循环语句"><a href="#2-2-循环语句" class="headerlink" title="2.2 循环语句"></a>2.2 循环语句</h3><p>学完条件语句后，接下来我们学习 <strong>Kotlin</strong> 中的循环语句。</p><ul><li>熟悉Java的人应该都知道，<strong>Java</strong>中主要有两种循环语句：<code>while</code>循环和<code>for</code>循环。而<strong>Kotlin</strong>也提供了<code>while</code>循环和<code>for</code>循环，其中<code>while</code>循环不管是在语法还是使用技巧上都和<strong>Java</strong>中的<code>while</code>循环没有任何区别。所以我们直接学习 <code>for</code>循环。</li><li><strong>Kotlin</strong>在<strong>for</strong>循环方面做了很大幅度的修改，<strong>Java</strong>中最常用的<strong>for-i</strong>循环在<strong>Kotlin</strong>中直接被舍弃了，而<strong>Java</strong>中另一种<strong>for-each</strong>循环则被<strong>Kotlin</strong>进行了大幅度的加强，变成了<strong>for-in</strong>循环，所以我们只需要学习<strong>for-in</strong>循环的用法就可以了。</li><li>在开始学习for-in循环之前，先来学习一个区间的概念，因为这也是Java中没有的东西。我们可以使用如下Kotlin代码来表示一个区间：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0.</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>这种语法结构虽然看上去挺奇怪的,但在<strong>Kotlin</strong>中，它是完全合法的。上述代码表示创建了一个0到10的区间，并且<strong>两端都是闭区间</strong>，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是**[0, 10]**。</p><ul><li>其中，<code>..</code>是创建两端闭区间的关键字，在<code>..</code>的两边指定区间的左右端点就可以创建一个区间了。</li><li>有了区间之后，我们就可以通过<code>for-in</code>循环来遍历这个区间.</li><li>🌰 举个栗子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是<code>for-in</code>循环最简单的用法了，我们遍历了区间中的每一个元素，并将它打印出来。</p><p>但是在很多情况下，双端闭区间却不如单端闭区间好用。为什么这么说呢？相信你一定知道数组的下标都是从0开始的，一个长度为10的数组，它的下标区间范围是0到9，因此左闭右开的区间在程序设计当中更加常用。<strong>Kotlin</strong>中可以使用<code>until</code>关键字来创建一个左闭右开的区间，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0</span> until <span class="number">10</span></span><br></pre></td></tr></table></figure><p>上述代码表示创建了一个0到10的<strong>左闭右开区间</strong>，它的数学表达方式是**[0, 10)**。</p><p>当然，我们在 <strong>Kotlin</strong> 中也可以创建一个降序区间，使用 <code>downTo</code>关键字，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">10</span> downTo <span class="number">1</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>for-in</code>循环每次执行循环时会在区间范围内递增1，相当于<strong>Java</strong> <code>for-i</code>循环中<code>i++</code>的效果，而如果你想跳过其中的一些元素，可以使用<code>step</code>关键字：🌰 举个栗子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>)&#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码表示在遍历**[1, 10]**这个区间的时候，每次执行循环都会在区间范围内递增2，相当于<code>for-i</code>循环中<code>i = i + 2</code>的效果。当然 <code>downTo</code>关键字创建的降序区间也是可以使用 <code>step</code>关键字的。</p><p>总的来说，<code>for-in</code>循环并没有传统的<code>for-i</code>循环那样灵活，但是却比<code>for-i</code>循环要简单好用得多，而且足够覆盖大部分的使用场景。如果有一些特殊场景使用<code>for-in</code>循环无法实现的话，我们还可以改用<code>while</code>循环的方式来进行实现。</p><hr><h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><p>和很多现代高级语言一样，<code>Kotlin</code>也是面向对象的，因此理解什么是<strong>面向对象编程</strong>对我们来说就非常重要了。不同于<strong>面向过程</strong>的语言（比如C语言），<strong>面向对象的语言是可以创建类的</strong>。<strong>类就是对事物的一种封装</strong>，比如说人、汽车、房屋、书等任何事物，我们都可以将它封装一个类，<strong>类名通常是名词</strong>。而类中又可以拥有自己的<strong>字段和函数</strong>，字段表示该类所拥有的属性，比如说人可以有姓名和年龄，汽车可以有品牌和价格，这些就属于类中的字段，<strong>字段名通常也是名词</strong>。而函数则表示该类可以有哪些行为，比如<br>说人可以吃饭和睡觉，汽车可以驾驶和保养等，<strong>函数名通常是动词</strong>。</p><p>通过这种类的封装，我们就可以在适当的时候创建该类的对象，然后调用对象中的字段和函数来满足实际编程的需求，这就是面向对象编程最基本的思想。当然，面向对象编程还有很多其他特性，如继承、多态等，但是这些特性都是建立在基本的思想之上的。</p><h3 id="3-1-类与对象"><a href="#3-1-类与对象" class="headerlink" title="3.1 类与对象"></a>3.1 类与对象</h3><p>在 <strong>Kotlin</strong>中 也是使用 <code>class</code>关键字来声明一个类的，这一点和<strong>Java</strong>一致；这里创建一个 <code>Person</code> 类，并且加入 字段（属性）和 函数（方法）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating. He is <span class="variable">$age</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们创建了 <code>name</code>和 <code>age</code> 字段（属性） 然后还定义了一个 <code>eat()</code> 函数（方法）并在其中打印了一句话。</p><p>接下来我们实例化一个 <code>Person</code>对象，<strong>Kotlin</strong>中实例化一个类的方式和<strong>Java</strong>是基本类似的，只是去掉了<code>new</code>关键字而已。之所以这么设计，是因为当你调用了某个类的构造函数时，你的意图只可能是对这个类进行实例化，因此即使没有<code>new</code>关键字，也能清晰表达出你的意图。<strong>Kotlin</strong>本着最简化的设计原则，将诸如<code>new</code>、行尾分号这种不必要的语法结构都取消了。</p><p>实例化对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Person()</span><br></pre></td></tr></table></figure><p>我们可以在 <code>main()</code>函数中对p对象进行一些操作，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    p.name = <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">    p.age = <span class="number">24</span></span><br><span class="line">    p.eat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是面向对象编程最基本的用法了，简单概括一下，就是要<strong>先将事物封装成具体的类</strong>，然后将<strong>事物所拥有的属性和能力</strong>分别<strong>定义成类中的字段和函数</strong>，接下来对类进行实例化，再<strong>根据具体的编程需求调用类中的字段和方法</strong>即可。</p><h3 id="3-2-继承与构造函数"><a href="#3-2-继承与构造函数" class="headerlink" title="3.2 继承与构造函数"></a>3.2 继承与构造函数</h3><h4 id="3-2-1-继承"><a href="#3-2-1-继承" class="headerlink" title="3.2.1 继承"></a>3.2.1 继承</h4><p>继承—面向对象编程中另一个极其重要的特性。继承也是基于现实场景总结出来的一个概念，其实非常好理解。比如现在我们要定义一个<code>Student</code>类，每个学生都有自己的学号和年级，因此我们可以在<code>Student</code>类中加入<code>sno</code>和<code>grade</code>字段。但同时学生也是人呀，学生也会有姓名和年龄，也需要吃饭，如果我们在<code>Student</code>类中重复定义<code>name</code>、<code>age</code>字段和<code>eat()</code>函数的话就显得太过冗余了。这个时候就可以让<code>Student</code>类去继承<code>Person</code>类，这样<code>Student</code>就自动拥有了<code>Person</code>中的字段和函数，另外还可以定义自己独有的字段和函数。这就是面向对象编程中的继承思想。</p><p>接下来实现让 <code>Student</code>类继承 <code>Person</code> 类，我们要先做两件事：</p><p>第一件事：使 <code>Person</code>类可以被继承，对你没看错，就是先让父类可被继承。可能很多人会觉得奇怪，尤其是有<strong>Java</strong>编程经验的人。一个类本身不就是可以被继承的吗？为什么还要使<code>Person</code>类可以被继承呢？这就是<strong>Kotlin</strong>不同的地方，在<strong>Kotlin</strong>中任何一个非抽象类默认都是不可以被继承的，相当于<strong>Java</strong>中给类声明了<code>final</code>关键字。之所以这么设计，其实和<code>val</code>关键字的原因是差不多的，因为类和变量一样，最好都是不可变的，而一个类允许被继承的话，它无法预知子类会如何实现，因此可能就会存在一些未知的风险。<strong>Effective Java</strong>这本书中明确提到，如果一个类不是专门为继承而设计的，那么就应该主动将它加上<code>final</code>声明，禁止它可以被继承。</p><p>很明显，<strong>Kotlin</strong>在设计的时候遵循了这条编程规范，<strong>默认所有非抽象类都是不可以被继承的</strong>。之所以这里一直在说非抽象类，是因为抽象类本身是无法创建实例的，一定要由子类去继承它才能创建实例，因此抽象类必须可以被继承才行，要不然就没有意义了。</p><p>那我们应该如何让 <code>Person</code>类可被继承呢？其实很简单！只需要在类前面加上 <code>open</code>关键字就可以啦！如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上<code>open</code>关键字之后，我们就是在主动告诉<strong>Kotlin</strong>编译器，<code>Person</code>这个类是专门为继承而设计的，这样<code>Person</code>类就允许被继承了。</p><p>第二件事： 让 <code>Student</code>类继承 <code>Person</code>类，在Java中继承的关键字是<code>extends</code>，而在<strong>Kotlin</strong>中变成了一个冒号。写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的写法如果只是替换一下关键字倒也挺简单的，但是为什么<code>Person</code>类的后面要加上一对括号呢？<strong>Java</strong>中继承的时候好像并不需要括号。这对括号还涉及 <code>Kotlin</code>中 主构造函数、次构造函数等方面的知识.</p><h4 id="3-2-2-构造函数"><a href="#3-2-2-构造函数" class="headerlink" title="3.2.2 构造函数"></a>3.2.2 构造函数</h4><p>任何一个面向对象的编程语言都会有构造函数的概念，<strong>Kotlin</strong>中也有，但是<strong>Kotlin</strong>将构造函数分成了两种：<strong>主构造函数</strong>和<strong>次构造函数</strong>。</p><h5 id="3-2-2-1-主构造函数"><a href="#3-2-2-1-主构造函数" class="headerlink" title="3.2.2.1 主构造函数"></a>3.2.2.1 主构造函数</h5><p><strong>主构造函数将会是我们最常用的构造函数</strong>，每个类默认都会有一个不带参数的主构造函数，当然也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即可。比如下面这种写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将学号和年级这两个字段都放到了主构造函数当中，这就表明在对<code>Student</code>类进行实例化的时候，<strong>必须</strong>传入构造函数中要求的所有参数。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这样我们就创建了一个<code>Student</code>的对象，同时指定该学生的学号是<code>123</code>，年级是<code>5</code>。另外，由于构造函数中的参数是在创建实例的时候传入的，不像之前的写法那样还得重新赋值，因此我们可以将参数全部声明成<code>val</code>。</p><p>当然啦，我们也可以在主构造函数当中写一些逻辑，<strong>Kotlin</strong>给我们提供了一个 <code>init</code>结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;sno is &quot;</span> + sno)</span><br><span class="line">        println(<span class="string">&quot;grade is &quot;</span> + grade)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们打印了学号以及年级。到这里为止都还挺好理解的，但是这和那对括号又有什么关系呢？这就涉及了<strong>Java</strong>继承特性中的一个规定，<strong>子类中的构造函数必须调用父类中的构造函数</strong>，这个规定在<strong>Kotlin</strong>中也要遵守。</p><p>看一下<strong>Student</strong>类，现在我们声明了一个主构造函数，根据继承特性的规定，子类的构造函数必须调用父类的构造函数，可是主构造函数并没有函数体，我们怎样去调用父类的构造函数呢？你可能会说，在<code>init</code>结构体中去调用不就好了。这或许是一种办法，但绝对不是一种好办法，因为在绝大多数的场景下，我们是不需要编写<code>init</code>结构体的。<br><strong>Kotlin</strong>当然没有采用这种设计，而是用了另外一种简单但是可能不太好理解的设计方式：括号。<strong>子类的主构造函数调用父类中的哪个构造函数，在继承的时候通过括号来指定。</strong>因此再来看一遍这段代码，你应该就能理解了吧。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>Person</code>类后面的一对空括号表示<code>Student</code>类的主构造函数在初始化的时候会调用<code>Person</code>类的无参数构造函数，即使在无参数的情况下，这对括号也不能省略。</p><p>此时如果我们更改一下 <code>Person</code>类，将姓名和年龄放到主构造函数中，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> (<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>此时我们在<code>Student</code>再去使用空括号调用<code>Person</code>类的无参构造函数肯定会报错，因为此时<code>Person</code>类的主构造函数需要 <code>name</code>和 <code>age</code>两个参数。</p><p>要解决这个问题也很简单，给<code>Person</code>类的构造函数传入<code>name</code>和<code>age</code>字段就好了。可是问题又来了<code>Student</code>类中也没有这两个字段啊，其实我们可以在 <code>Student</code> 类的主构造函数中 加上 <code>name</code> 和 <code>age</code> 这两个参数，然后再将这两个参数传给<code>Person</code>类的构造函数就行了。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name, age)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭐<strong>注意</strong>，我们在<code>Student</code>类的主构造函数中增加<code>name</code>和<code>age</code>这两个字段时，不能再将它们声明成<code>val</code>，因为在主构造函数中声明成<code>val</code>或者<code>var</code>的参数将自动成为该类的字段，这就会导致和父类中同名的<code>name</code>和<code>age</code>字段造成冲突。因此，这里的<code>name</code>和<code>age</code>参数前面我们不用加任何关键字，让它的作用域仅限定在主构造函数当中即可。</p><p>现在可以通过如下代码来创建一个<code>Student</code>类的实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure><h5 id="3-2-2-2-次构造函数"><a href="#3-2-2-2-次构造函数" class="headerlink" title="3.2.2.2 次构造函数"></a>3.2.2.2 次构造函数</h5><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。其实我们几乎是用不到次构造函数的，Kotlin提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。<br><strong>Kotlin</strong>规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用）。</p><p>🌰举个栗子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次构造函数是通过<code>constructor</code>关键字来定义的，这里我们定义了两个次构造函数：第一个次构造函数接收<code>name</code>和<code>age</code>参数，然后它又通过<code>this</code>关键字调用了主构造函数，并将<code>sno</code>和<code>grade</code>这两个参数赋值成初始值；第二个次构造函数不接收任何参数，它通过<code>this</code>关键字调用了我们刚才定义的第一个次构造函数，并将<code>name</code>和<code>age</code>参数也赋值成初始值，由于第二个次构造函数间接调用了主构造函数，因此这仍然是合法的。</p><p>那么现在我们就拥有了3种方式来对<code>Student</code>类进行实体化，分别是通过<strong>不带参数</strong>的构造函数、通过带<strong>两个参数</strong>的构造函数和通过带<strong>4个参数</strong>的构造函数，对应代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student1 = Student()</span><br><span class="line"><span class="keyword">val</span> student2 = Student(<span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="keyword">val</span> student3 = Student(<span class="string">&quot;123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。这种情况真的十分少见，但在<strong>Kotlin</strong>中是允许的。当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，首先<code>Student</code>类的后面<strong>没有显式地定义主构造函数</strong>，同时又因为定义了次构造函数，所以现在<code>Student</code>类是没有主构造函数的。那么既然没有主构造函数，继承<code>Person</code>类的时候就<strong>不用继承其主构造函数</strong>，也就不需要再加上括号了。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将<code>this</code>关键字换成了<code>super</code>关键字。</p><h3 id="3-3-接口"><a href="#3-3-接口" class="headerlink" title="3.3 接口"></a>3.3 接口</h3><p>接口是用于实现多态编程的重要组成部分。我们都知道，<strong>Java</strong>是单继承结构的语言，任何一个类最多只能继承一个父类，但是却可以实现任意多个接口，<strong>Kotlin</strong>也是如此。</p><p>我们可以在接口中定义一系列的抽象行为，然后由具体的类去实现。下面还是通过具体的代码来学习一下，首先创建一个<code>Study</code>接口，并在其中定义几个学习行为。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBook</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以让<code>Student</code>类去实现<code>Study</code>接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name, age), Study &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span>&#x27;s sno is <span class="variable">$sno</span> he&#x27;s grade is <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBook</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is reading&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is doing homework&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉<strong>Java</strong>的人一定知道，<strong>Java</strong>中继承使用的关键字是<code>extends</code>，实现接口使用的关键字是<code>implements</code>，而<strong>Kotlin</strong>中统一使用冒号，中间用<code>,</code>进行分隔。上述代码就表示<code>Student</code>类继承了<code>Person</code>类，同时还实现了<code>Study</code>接口。另外接口的后面不用加上括号，因为它没有构造函数可以去调用。Study接口中定义了<code>readBooks()</code>和<code>doHomework()</code>这两个待实现函数，因此<code>Student</code>类必须实现这两个函数。<strong>Kotlin</strong>中使用<code>override</code>关键字来重写父类或者实现接口中的函数，这里我们只是简单地在实现的函数中打印了一行信息。</p><p>接下来在 <code>main()</code>函数中调用如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;1232&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br><span class="line">    student.eat()</span><br><span class="line">    student.info()</span><br><span class="line">    student.readBook()</span><br><span class="line">    student.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person</code>类如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating. He is <span class="variable">$age</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让接口的功能更加灵活，<strong>Kotlin</strong>还增加了一个额外的功能：允许对接口中定义的函数进行默认实现。其实<strong>Java</strong>在<strong>JDK1.8</strong>之后也开始支持这个功能了，因此总体来说，<strong>Kotlin</strong>和<strong>Java</strong>在接口方面的功能仍然是一模一样的。</p><p>对接口中的函数进行默认实现的具体实现如下（修改<code>Study</code>接口）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBook</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;zZZZ sleeping... default implementation&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Study</code>接口中，我们新增了一个 <code>sleep()</code>函数，并且默认实现了。如果接口中的一个函数拥有了函数体，这个函数体中的内容就是它的默认实现。现在当一个类去实现<code>Study</code>接口时，只会强制要求实现<code>readBooks()</code>和<code>doHomework()</code>函数，而<code>sleep</code>函数则可以自由选择实现或者不实现，不实现时就会自动使用默认的实现逻辑。</p><p>现在回到<code>Student</code>类当中，你会发现如果我们删除了<code>doHomework()</code>和<code>readBooks()</code>函数，代码是会提示错误的，而删除<code>sleep()</code>函数则不会。</p><p>以上就是<strong>Kotlin</strong>面向对象编程中最主要的一些内容，接下来我们再学习一个和<strong>Java</strong>相比变化比较大的部分——<code>函数的可见性修饰</code>符。</p><p>熟悉<strong>Java</strong>的人一定知道，<strong>Java</strong>中有<code>public</code>、<code>private</code>、<code>protected</code>和<code>default</code>（什么都不写）这4种函数可见性修饰符。<strong>Kotlin</strong>中也有4种，分别是<code>public</code>、<code>private</code>、<code>protected</code>和<code>internal</code>，需要使用哪种修饰符时，直接定义在<code>fun</code>关键字的前面即可。接下来详细介绍一下<strong>Java</strong>和<strong>Kotlin</strong>中这些函数可见性修饰符的异同。</p><p>首先<code>private</code>修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。<code>public</code>修饰符的作用虽然也是一致的，表示对所有类都可见，但是在<strong>Kotlin</strong>中<code>public</code>修饰符是默认项，而在<code>Java</code>中<code>default</code>才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是<code>public</code>的。<code>protected</code>关键字在<strong>Java</strong>中表示对当前类、子类和同一包路径下的类可见，在<code>Kotlin</code>中则表示只对当前类和子类可见。<code>Kotlin</code>抛弃了<strong>Java</strong>中的<code>default</code>可见性（同一包路径下的类可见），引入了一种新的可见性概念，只对同一模块中的类可见，使用的是<code>internal</code>修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成<code>internal</code>。</p><table><thead><tr><th align="center">修饰符</th><th align="center">Java</th><th align="center">kotlin</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">所有类可见</td><td align="center">所有类可见（默认）</td></tr><tr><td align="center">private</td><td align="center">当前类可见</td><td align="center">当前类可见</td></tr><tr><td align="center">protected</td><td align="center">当前类、子类、同一包路径下的类可见</td><td align="center">当前类、子类可见</td></tr><tr><td align="center">default</td><td align="center">同一包路径下的类可见（默认）</td><td align="center">无</td></tr><tr><td align="center">internal</td><td align="center">无</td><td align="center">同一模块中的类可见</td></tr></tbody></table><h3 id="3-4-数据类与单例类"><a href="#3-4-数据类与单例类" class="headerlink" title="3.4 数据类与单例类"></a>3.4 数据类与单例类</h3><h4 id="3-4-1-数据类"><a href="#3-4-1-数据类" class="headerlink" title="3.4.1 数据类"></a>3.4.1 数据类</h4><p>在一个规范的系统架构中，数据类通常占据着非常重要的角色，它们用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。或许你听说过<strong>MVC</strong>、<strong>MVP</strong>、<strong>MVVM</strong>之类的架构模式，不管是哪一种架构模式，其中的<strong>M</strong>指的就是<strong>数据类</strong>。</p><p>数据类通常需要<strong>重写</strong><code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>这几个方法。其中，<code>equals()</code>方法用于判断两个数据类是否相等。<code>hashCode()</code>方法作为<code>equals()</code>的配套方法，也需要一起重写，否则会导致<code>HashMap</code>、<code>HashSet</code>等hash相关的系统类无法正常工作。<code>toString()</code>方法用于提供更清晰的输入日志，否则一个数据类默认打印出来的就是一行内存地址。</p><p>比如在 <strong>Java</strong>中 我们要实现一个手机数据类，我们要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>&#123;</span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cellphone</span><span class="params">(String brand, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Cellphone)&#123;</span><br><span class="line">            <span class="type">Cellphone</span> <span class="variable">other</span> <span class="operator">=</span> (Cellphone) obj;</span><br><span class="line">            <span class="keyword">return</span> other.brand.equals(brand) &amp;&amp; other.price == price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand.hashCode() + (<span class="type">int</span>) price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cellphone(brand=&quot;</span> + band + <span class="string">&quot;, price=&quot;</span> + price + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去挺复杂的吧？关键是这些代码还是一些没有实际逻辑意义的代码，只是为了让它拥有数据类的功能而已。而同样的功能使用<strong>Kotlin</strong>来实现就会变得极其简单:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对！你没有看错，在 <strong>Kotlin</strong>当中，当我们需要一个数据类的时候只需要在这个类前声明了data关键字。当在一个类前面声明了<code>data</code>关键字时，就表明你希望这个类是一个<strong>数据类</strong>，<strong>Kotlin</strong>会根据主构造函数中的参数帮你将<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>等固定且无实际逻辑意义的方法自动生成，从而大大减少了开发的工作量。</p><h4 id="3-4-2-单例类"><a href="#3-4-2-单例类" class="headerlink" title="3.4.2 单例类"></a>3.4.2 单例类</h4><p>掌握了数据类的使用技巧之后，接下来我们再来看另外一个Kotlin中特有的功能——<strong>单例类</strong>。</p><p>想必你一定听说过<strong>单例模式</strong>吧，这是<strong>最常用、最基础的设计模式之一</strong>，它可以用于<strong>避免创建重复的对象</strong>。比如我们希望某个类在全局最多只能拥有一个实例，这时就可以使用单例模式。当然单例模式也有很多种写法，这里演示一种最常见的Java写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            intance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;singleTon is called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看下这段代码，为了禁止外部创建<code>Singleton</code>的实例，我们使用<code>private</code>关键字将 <code>Singleton</code>的构造函数私有化，然后给外部提供了一个<code>getInstance()</code>静态方法用于获取<code>Singleton</code>的实例。在<code>getInstance()</code>方法中，我们判断如果当前缓存的<code>Singleton</code>实例为<code>null</code>，就创建一个新的实例，否则直接返回缓存的实例即可，这就是单例模式的工作机制。</p><p>如果我们想调用单例类中的方法，也很简单，比如想调用上述的<code>singletonTest()</code>方法，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton singleton = Singleton.getInstance();</span><br><span class="line">singleton.singletonTest();</span><br></pre></td></tr></table></figure><p>虽然<strong>Java</strong>中的单例实现并不复杂，但是<strong>Kotlin</strong>明显做得更好，它同样是将一些固定的、重复的逻辑实现隐藏了起来，只暴露给我们最简单方便的用法。</p><p>在<code>Kotlin</code>中创建一个单例类的方式极其简单，只需要将<code>class</code>关键字改成<code>object</code>关键字即可。初始化代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;singletonTest is called. --kotlin&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<strong>Kotlin</strong>中我们不需要私有化构造函数，也不需要提供<code>getInstance()</code>这样的静态方法，只需要把<code>class</code>关键字改成<code>object</code>关键字，一个单例类就创建完成了。而调用单例类中的函数也很简单，比较类似于<strong>Java</strong>中静态方法的调用方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.singletonTest()</span><br></pre></td></tr></table></figure><p>这种写法虽然看上去像是静态方法的调用，但其实Kotlin在背后自动帮我们创建了一个Singleton类的实例，并且保证全局只会存在一个Singleton实例。</p><hr><h2 id="四、Lambda编程"><a href="#四、Lambda编程" class="headerlink" title="四、Lambda编程"></a>四、Lambda编程</h2><p>可能很多<strong>Java</strong>程序员对于Lambda编程还比较陌生，但其实这并不是什么新鲜的技术。许多现代高级编程语言在很早之前就开始支持<code>Lambda</code>编程了，但是<strong>Java</strong>却直到<strong>JDK 1.8</strong>之后才加入了<code>Lambda</code>编程的语法支持。因此，大量早期开发的<strong>Java</strong>和<strong>Android</strong>程序其实并未使用<code>Lambda</code>编程的特性。</p><p><strong>Kotlin</strong>从第一个版本开始就支持了<code>Lambda</code>编程，并且<strong>Kotlin</strong>中的<code>Lambda</code>功能极为强大，我甚至认为<code>Lambda</code>才是<strong>Kotlin</strong>的灵魂所在。</p><h3 id="4-1-集合的创建和遍历"><a href="#4-1-集合的创建和遍历" class="headerlink" title="4.1 集合的创建和遍历"></a>4.1 集合的创建和遍历</h3><p><strong>集合的函数式API</strong>是用来入门<code>Lambda</code>编程的绝佳示例，不过在此之前，我们得先学习创建集合的方式才行。</p><p>传统意义上的集合主要就是<code>List</code>和<code>Set</code>，再广泛一点的话，像<code>Map</code>这样的键值对数据结构也可以包含进来。<code>List</code>、<code>Set</code>和<code>Map</code>在<strong>Java</strong>中都是接口，<code>List</code>的主要实现类是<code>ArrayList</code>和<code>LinkedList</code>，<code>Set</code>的主要实现类是<code>HashSet</code>，<code>Map</code>的主要实现类是<code>HashMap</code>，熟悉<strong>Java</strong>的人对这些集合的实现类一定不会陌生。</p><p>现在我们提出一个需求，创建一个包含许多水果名称的集合。如果是在<strong>Java</strong>中你会怎么实现？我们首先想到的是创建一个 <code>ArrayList</code>实例，然后再将水果的名称一个个添加到集合中。当然啦，在 <code>kotlin</code>中我们也可以这么做。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;pear&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;grape&quot;</span>)</span><br></pre></td></tr></table></figure><p>但是这种初始化集合的方式比较烦琐，为此<strong>Kotlin</strong>专门提供了一个内置的<code>listOf()</code>函数来简化初始化集合的写法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listof(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这里仅用一行代码就完成了集合的初始化操作。之前在学习循环语句时提到过：<code>for-in</code>循环不仅可以用来遍历区间，还可以用来遍历集合。现在我们就尝试一下使用<code>for-in</code>循环来遍历这个水果集合：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list)&#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过需要注意的是，<code>listOf()</code>函数创建的是一个不可变的集合。你也许不太能理解什么叫作不可变的集合，因为在<strong>Java</strong>中这个概念不太常见。不可变的集合指的就是该集合只能用于读取，我们无法对集合进行添加、修改或删除操作。</p><p>至于这么设计的理由，和<code>val</code>关键字、类默认不可继承的设计初衷是类似的，可见<strong>Kotlin</strong>在不可变性方面控制得极其严格。那如果我们确实需要创建一个可变的集合呢？也很简单，使用<code>mutableListOf()</code>函数就可以了，示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> listVar = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    showlist(list)</span><br><span class="line">    showList(listVar)</span><br><span class="line">    listVar.add(<span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    showList(listVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========List===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (l <span class="keyword">in</span> list)&#123;</span><br><span class="line">        println(l)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========List===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们介绍的都是List集合的用法，实际上<code>Set</code>集合的用法几乎与此一模一样，只是将创建集合的方式换成了<code>setOf()</code>和<code>mutableSetOf()</code>函数而已。大致代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = setOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> setVar = mutableSetOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    showSet(<span class="keyword">set</span>)</span><br><span class="line">    showSet(setVar)</span><br><span class="line">    setVar.add(<span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    showSet(setVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showSet</span><span class="params">(list: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========Set===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (l <span class="keyword">in</span> list)&#123;</span><br><span class="line">        println(l)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========Set===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭐<strong>需要注意</strong>，<code>Set</code>集合中是<strong>不可以存放重复元素</strong>的，<strong>如果存放了多个相同的元素，只会保留其中一份</strong>，这是和<code>List</code>集合最大的不同之处。</p><p>最后再来看一下<code>Map</code>集合的用法。Map是一种键值对形式的数据结构，因此在用法上和<code>List</code>、<code>Set</code>集合有较大的不同。传统的<code>Map</code>用法是先创建一个<code>HashMap</code>的实例，然后将一个个键值对数据添加到<code>Map</code>中。比如这里我们给每种水果设置一个对应的编号，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Apple&quot;</span>,<span class="number">1</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Banana&quot;</span>,<span class="number">2</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Orange&quot;</span>,<span class="number">3</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Pear&quot;</span>,<span class="number">4</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Grape&quot;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    hashMap[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    hashMap[<span class="string">&quot;Banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    hashMap[<span class="string">&quot;Orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">    hashMap[<span class="string">&quot;Pear&quot;</span>] = <span class="number">4</span></span><br><span class="line">    hashMap[<span class="string">&quot;Grape&quot;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map1 = mapOf&lt;String, <span class="built_in">Int</span>&gt;(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>, <span class="string">&quot;Orange&quot;</span> to <span class="number">3</span>, <span class="string">&quot;Pear&quot;</span> to <span class="number">4</span>, <span class="string">&quot;Grape&quot;</span> to <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    showMap(map)</span><br><span class="line">    showMap(hashMap)</span><br><span class="line">    showMap(map1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMap</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map)&#123;</span><br><span class="line">        println(<span class="string">&quot;fruit is <span class="variable">$fruit</span>, number is <span class="variable">$number</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用第一种写法，是因为这种写法和<strong>Java</strong>语法是最相似的，因此可能最好理解。但其实在<strong>Kotlin</strong>中并不建议使用<code>put()</code>和<code>get()</code>方法来对<code>Map</code>进行添加和读取数据操作，而是更加推荐使用一种类似于数组下标的语法结构，比如向<code>Map</code>中添加一条数据就可以像第二种方法这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hashMap = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    hashMap[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    hashMap[<span class="string">&quot;Banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    hashMap[<span class="string">&quot;Orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">    hashMap[<span class="string">&quot;Pear&quot;</span>] = <span class="number">4</span></span><br><span class="line">    hashMap[<span class="string">&quot;Grape&quot;</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>而从Map中读取一条数据就可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = map[<span class="string">&quot;Apple&quot;</span>]</span><br></pre></td></tr></table></figure><p>当然，这仍然不是最简便的写法，因为<strong>Kotlin</strong>毫无疑问地提供了一对<code>mapOf()</code>和<code>mutableMapOf()</code>函数来继续简化<code>Map</code>的用法。在<code>mapOf()</code>函数中，我们可以直接传入初始化的键值对组合来完成对Map集合的创建,如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map1 = mapOf&lt;String, <span class="built_in">Int</span>&gt;(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>, <span class="string">&quot;Orange&quot;</span> to <span class="number">3</span>, <span class="string">&quot;Pear&quot;</span> to <span class="number">4</span>, <span class="string">&quot;Grape&quot;</span> to <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这里的键值对组合看上去好像是使用<code>to</code>这个关键字来进行关联的，但其实<code>to</code>并不是关键字，而是一个<code>infix</code>函数.</p><p>最后，遍历<code>Map</code>集合中的数据也是使用 <code>for-in</code>循环，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMap</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map)&#123;</span><br><span class="line">        println(<span class="string">&quot;fruit is <span class="variable">$fruit</span>, number is <span class="variable">$number</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要的区别在于，在<code>for-in</code>循环中，我们将Map的键值对变量一起声明到了一对括号里面，这样当进行循环遍历时，每次遍历的结果就会赋值给这两个键值对变量，最后将它们的值打印出来。</p><h3 id="4-2-集合的函数式API"><a href="#4-2-集合的函数式API" class="headerlink" title="4.2 集合的函数式API"></a>4.2 集合的函数式API</h3><p>集合的函数式<code>API</code>有很多个，这里重点学习函数式<code>API</code>的语法结构，也就是<code>Lambda</code>表达式的语法结构。</p><p>首先实现一个需求：在一个水果集合里面找到单词最长的那个水果，我们可以这样写:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> maxLengthFruit = <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> (fruit <span class="keyword">in</span> listLength)&#123;</span><br><span class="line">       <span class="keyword">if</span> (fruit.length &gt; maxLengthFruit.length)&#123;</span><br><span class="line">           maxLengthFruit = fruit</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;maxLengthFruit is <span class="variable">$maxLengthFruit</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码使用的是打擂台的方法找出单词最长的那个水果，我们还可以使用集合的函数式<strong>API</strong>，这可以让我们的功能变的更加容易:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123; it.length &#125;</span><br><span class="line">println(<span class="string">&quot;maxLength is <span class="variable">$maxLength</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码只用了一行就找出了单词最长的那个水果，是怎么做到的呢?一起来学习下！</p><p>首先来看一下<code>Lambda</code>的定义，如果用最直白的语言来阐述的话，<code>Lambda</code>就是一小段可以作为参数传递的代码。从定义上看，这个功能就很厉害了，因为正常情况下，我们向某个函数传参时只能传入变量，而借助<code>Lambda</code>却允许传入一小段代码。这里两次使用了“一小段代码”这种描述，那么到底多少代码才算一小段代码呢？<strong>Kotlin</strong>对此并没有进行限制，但是通常不建议在<code>Lambda</code>表达式中编写太长的代码，否则可能会影响代码的可读性。</p><p><code>Lambda</code>表达式的语法结构如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是<code>Lambda</code>表达式最完整的语法结构定义。首先最外层是一对大括号，如果有参数传入到<code>Lambda</code>表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个<code>-&gt;</code>符号，<strong>表示参数列表的结束以及函数体的开始</strong>，函数体中可以编写任意行代码（虽然不建议编写太长的代码），并且最后一行代码会自动作为<code>Lambda</code>表达式的返回值。</p><p>当然，在很多情况下，我们并不需要使用<code>Lambda</code>表达式完整的语法结构，而是有很多种简化的写法。还是回到刚才找出最长单词水果的需求，前面使用的函数式<strong>API</strong>的语法结构看上去好像很特殊，但其实<code>maxBy</code>就是一个普通的函数而已，只不过它接收的是一个<code>Lambda</code>类型的参数，并且会在遍历集合时将每次遍历的值作为参数传递给<code>Lambda</code>表达式。<code>maxBy</code>函数的工作原理是根据我们传入的条件来遍历集合，从而找到该条件下的最大值，比如说想要找到单词最长的水果，那么条件自然就应该是单词的长度了。</p><p>理解了maxBy函数的工作原理之后，我们就可以开始套用刚才学习的Lambda表达式的语法结构，并将它传入到maxBy函数中了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lambda = &#123;fruit: String -&gt; fruit.length&#125;</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy(lambda)</span><br></pre></td></tr></table></figure><p>可以看到，<code>maxBy</code>函数实质上就是接收了一个<code>Lambda</code>参数而已，并且这个<code>Lambda</code>参数是完全按照刚才学习的表达式的语法结构来定义的，因此这段代码应该算是比较好懂的。<br>这种写法虽然可以正常工作，但是比较啰嗦，可简化的点也非常多，下面我们就开始对这段代码一步步进行简化。<br>首先，我们不需要专门定义一个<code>lambda</code>变量，而是可以直接将<code>lambda</code>表达式传入<code>maxBy</code>函数当中，因此第一步简化如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy(&#123;fruit: String -&gt; fruit.length&#125;)</span><br></pre></td></tr></table></figure><p>然后<strong>Kotlin</strong>规定，<strong>当<code>Lambda</code>参数是函数的最后一个参数时，可以将<code>Lambda</code>表达式移到函数括号的外面</strong>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy() &#123;fruit: String -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure><p>接下来，<strong>如果<code>Lambda</code>参数是函数的唯一一个参数的话，还可以将函数的括号省略</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123;fruit: String -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>Kotlin</strong>拥有出色的类型推导机制，<code>Lambda</code>表达式中的参数列表其实在大多数情况下不必声明参数类型，因此代码可以进一步简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123;fruit -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure><p>最后，当<code>Lambda</code>表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用<code>it</code>关键字来代替，那么代码就变成了:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123;it.length&#125;</span><br></pre></td></tr></table></figure><p>怎么样？通过一步步推导的方式，我们就得到了和一开始那段函数式<strong>API</strong>一模一样的写法，是不是现在理解起来就非常轻松了呢？</p><p>接下来我们就再来学习几个集合中比较常用的函数式<strong>API</strong>,集合中的<code>map</code>函数是最常用的一种函数式API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在<code>Lambda</code>表达式中指定，最终生成一个新的集合。比如，这里我们希望让所有的水果名都变成大写模式，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">val</span> list = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> newList = list.map &#123; it.toUpperCase() &#125;</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> newList)&#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>函数的功能非常强大，它可以按照我们的需求对集合中的元素进行任意的映射转换，上面只是一个简单的示例而已。除此之外，你还可以将水果名全部转换成小写，或者是只取单词的首字母，甚至是转换成单词长度这样一个数字集合，只要在<code>Lambda</code>表示式中编写你需要的逻辑即可。</p><p>我们再来学习另外一个比较常用的函数式<strong>API</strong>——<code>filter</code>函数。顾名思义，<code>filter</code>函数是用来过滤集合中的数据的，它可以单独使用，也可以配合刚才的<code>map</code>函数一起使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> newList = list.filter &#123; it.length &lt; <span class="number">5</span> &#125; .map &#123; it.toUpperCase()) &#125;</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> newList)&#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续学习两个比较常用的函数式<strong>API</strong>——<code>any</code>和<code>all</code>函数。其中<code>any</code>函数用于判断集合中是否至少存在一个元素满足指定条件，<code>all</code>函数用于判断集合中是否所有元素都满足指定条件。由于这两个函数都很好理解，我们就直接通过代码示例学习了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> anyResult = list.any&#123;it.length &lt;= <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> allResult = list.all&#123;it.length &lt;= <span class="number">5</span>&#125;</span><br><span class="line">    println(<span class="string">&quot;anyResult is <span class="variable">$anyResult</span>, allResult is <span class="variable">$allResult</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是在<code>Lambda</code>表达式中将条件设置为5个字母以内的单词，那么<code>any</code>函数就表示集合中<strong>是否存在5个字母以内的单词</strong>，而<code>all</code>函数就表示集合中<strong>是否所有单词都在5个字母以内</strong>。</p><p>这样我们就将<code>Lambda</code>表达式的语法结构和几个常用的函数式<strong>API</strong>的用法都学习完了，虽然集合中还有许多其他函数式<strong>API</strong>，但是只要掌握了基本的语法规则，其他函数式API的用法只要看一看文档就能掌握了.</p><h3 id="4-3-Java函数式API的使用"><a href="#4-3-Java函数式API的使用" class="headerlink" title="4.3 Java函数式API的使用"></a>4.3 Java函数式API的使用</h3><p>现在我们已经学习了<strong>Kotlin</strong>中函数式<strong>API</strong>的用法，但实际上在<strong>Kotlin</strong>中调用<strong>Java</strong>方法时也可以使用函数式<strong>API</strong>，只不过这是有一定条件限制的。具体来讲，如果我们在<strong>Kotlin</strong>代码中调用了一个<strong>Java</strong>方法，并且该方法接收一个<strong>Java</strong>单抽象方法接口参数，就可以使用函数式<strong>API</strong>。<strong>Java</strong>单抽象方法接口指的是接口中只有一个待实现方法，如果接口中有多个待实现方法，则无法使用函数式<strong>API</strong>。</p><p>🌰 举个栗子：</p><p><strong>Java</strong>原生<strong>API</strong>中有一个最为常见的单抽象方法接口——<code>Runnable</code>接口。这个接口中只有一个待实现的<code>run()</code>方法，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的讲解，对于任何一个<strong>Java</strong>方法，只要它接收<code>Runnable</code>参数，就可以使用函数式<strong>API</strong>。那么什么<strong>Java</strong>方法接收了<code>Runnable</code>参数呢？这就有很多了，不过<code>Runnable</code>接口主要还是结合线程来一起使用的，因此这里我们就通过<strong>Java</strong>的线程类<code>Thread</code>来学习一下。</p><p><code>Thread</code>类的构造方法中接收了一个<code>Runnable</code>参数，我们可以使用如下<strong>Java</strong>代码创建并执行一个子线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>⭐注意：这里使用了匿名类的写法，我们创建了一个<code>Runnable</code>接口的匿名类实例，并将它传给了<code>Thread</code>类的构造方法，最后调用<code>Thread</code>类的<code>start()</code>方法执行这个线程。</p><p>而如果将这段代码翻译成 <code>Kotlin</code> 版本，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(<span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p><strong>Kotlin</strong>中匿名类的写法和<strong>Java</strong>有一点区别，由于<strong>Kotlin</strong>完全舍弃了<code>new</code>关键字，因此创建匿名类实例的时候就不能再使用<code>new</code>了，而是改用了<code>object</code>关键字。这种写法虽然算不上复杂，但是相比于<strong>Java</strong>的匿名类写法，并没有什么简化之处。<br>但是别忘了，目前<code>Thread</code>类的构造方法是符合<strong>Java</strong>函数式<strong>API</strong>的使用条件的，下面我们就看看如何对代码进行精简，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable &#123;</span><br><span class="line">println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为<code>Runnable</code>类中只有一个待实现方法，即使这里没有显式地重写<code>run()</code>方法，<strong>Kotlin</strong>也能自动明白<code>Runnable</code>后面的<code>Lambda</code>表达式就是要在<code>run()</code>方法中实现的内容。</p><p>另外，如果一个<strong>Java</strong>方法的参数列表中有且仅有一个<strong>Java</strong>单抽象方法接口参数，我们还可以将接口名进行省略，这样代码就变得更加精简了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(&#123;</span><br><span class="line">    println(<span class="string">&quot;thread is running&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p>不过到这里还没有结束，和之前<strong>Kotlin</strong>中函数式<strong>API</strong>的用法类似，当<code>Lambda</code>表达式是方法的最后一个参数时，可以将<code>Lambda</code>表达式移到方法括号的外面。同时，如果<code>Lambda</code>表达式还是方法的唯一一个参数，还可以将方法的括号省略，最终简化结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread&#123;</span><br><span class="line">    println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><hr><h2 id="五、空指针检查"><a href="#五、空指针检查" class="headerlink" title="五、空指针检查"></a>五、空指针检查</h2><p>某国外机构做了一个统计，<strong>Android</strong>系统上崩溃率最高的异常类型就是<strong>空指针异常（NullPointerException）</strong>。相信不只是<strong>Android</strong>，其他系统上也面临着相同的问题。若要分析其根本原因的话，我觉得主要<strong>是因为空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免</strong>，但即使是最出色的程序员，也不可能将所有潜在的空指针异常全部考虑到。</p><p>先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStudy</span><span class="params">(Study study)</span>&#123;</span><br><span class="line">    study.readBook();</span><br><span class="line">    study.doHomework();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码安全吗？不一定，因为这要取决于调用方传入的参数是什么，如果我们向<code>doStudy()</code>方法传入了一个<code>null</code>参数，那么毫无疑问这里就会发生空指针异常。因此，更加稳妥的做法是<strong>在调用参数的方法之前先进行一个判空处理</strong>，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStudy</span><span class="params">(Study study)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBook();</span><br><span class="line">        study.doHomework();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能保证不管传入的参数是什么，这段代码始终都是安全的。</p><p>由此可以看出，即使是如此简单的一小段代码，都有产生空指针异常的潜在风险，那么在一个大型项目中，想要完全规避空指针异常几乎是不可能的事情，这也是它高居各类崩溃排行榜首位的原因。</p><h3 id="5-1-可空类型系统"><a href="#5-1-可空类型系统" class="headerlink" title="5.1 可空类型系统"></a>5.1 可空类型系统</h3><p>然而，<strong>Kotlin</strong>却非常科学地解决了这个问题，它利用编译时判空检查的机制几乎杜绝了空指针异常。虽然编译时判空检查的机制有时候会导致代码变得比较难写，但是不用担心，<strong>Kotlin</strong>提供了一系列的辅助工具，让我们能轻松地处理各种判空情况。</p><p>是回到刚才的<code>doStudy()</code>函数，现在将这个函数再翻译回<strong>Kotlin</strong>版本，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span>&#123;</span><br><span class="line">    study.readBook()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去和刚才的<strong>Java</strong>版本并没有什么区别，但实际上它是没有空指针风险的，因为Kotlin默认所有的参数和变量都不可为空，所以这里传入的<code>Study</code>参数也一定不会为空，我们可以放心地调用它的任何函数。如果你尝试向<code>doStudy()</code>函数传入一个<strong>null</strong>参数,则它会报错： <code>Null can not be a value of a non-null type Study</code></p><p>也就是说，Kotlin将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那如果我们的业务逻辑就是需要某个参数或者变量为空该怎么办呢？不用担心，<strong>Kotlin</strong>提供了另外一套可为空的类型系统，<strong>只不过在使用可为空的类型系统时，我们需要在编译时期就将所有潜在的空指针异常都处理掉</strong>，否则代码将无法编译通过。</p><p>那么<strong>可为空的类型系统是什么样的呢</strong>？很简单，就是在类名的后面加上一个问号。比如，<strong>Int</strong>表示<strong>不可为空的整型</strong>，而<strong>Int?<strong>就表示</strong>可为空的整型</strong>；<strong>String</strong>表示<strong>不可为空的字符串</strong>，而<strong>String?<strong>就表示</strong>可为空的字符串</strong>。</p><p>回到刚才的<code>doStudy()</code>函数，如果我们希望传入的参数可以为空，那么就应该<strong>将参数的类型由<code>Study</code>改成<code>Study?</code></strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study.readBook()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，现在在调用<code>doStudy()</code>函数时传入<code>null</code>参数，就不会再提示错误了。但是，在<code>doStudy()</code>函数中调用参数的<code>readBooks()</code>和<code>doHomework()</code>方法时，却出现了一个红色下滑线的错误提示，这又是为什么呢？</p><p>由于我们将参数改成了可为空的<code>Study?</code>类型，此时调用参数的<code>readBooks()</code>和<code>doHomework()</code>方法都可能造成空指针异常，因此<strong>Kotlin</strong>在这种情况下不允许编译通过。我们只需要把空指针异常都处理掉就可以了，比如做个判断处理，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBook()</span><br><span class="line">        study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码就可以正常编译通过了，并且还能保证完全不会出现空指针异常。</p><p>为了在编译时期就处理掉所有的空指针异常，通常需要编写很多额外的检查代码才行。如果每处检查代码都使用<code>if</code>判断语句，则会让代码变得比较啰嗦，而且<code>if</code>判断语句还处理不了全局变量的判空问题。为此，<strong>Kotlin</strong>专门提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理.接下来一一学习！</p><h3 id="5-2-判空辅助工具"><a href="#5-2-判空辅助工具" class="headerlink" title="5.2 判空辅助工具"></a>5.2 判空辅助工具</h3><ul><li>首先学习最常用的<code>?.</code>操作符。这个操作符的作用非常好理解，就是<strong>当对象不为空时正常调用相应的方法，当对象为空时则什么都不做</strong>。比如以下的判空处理代码：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>)&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用 <code>?.</code>操作符就可以简化为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>了解了 <code>?.</code>操作符后 <code>doStudy()</code>函数就可以优化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> doStudy(study: Study?)&#123;</span><br><span class="line">    study?.readBook()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这样我们就借助<code>?.</code>操作符将<code>if</code>判断语句去掉了。可能你会觉得使用<code>if</code>语句来进行判空处理也没什么复杂的，那是因为目前的代码还非常简单，当以后我们开发的功能越来越复杂，需要判空的对象也越来越多的时候，你就会觉得<code>?.</code>操作符特别好用了。</p><ul><li>接下来再来学习另外一个非常常用的<code>?:</code>操作符。<strong>这个操作符的左右两边都接收一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</strong>这个操作符和<strong>三目运算符</strong> <code>a ? b : c</code> 类似但又有差异.观察如下代码：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span>(a != <span class="literal">null</span>)&#123;</span><br><span class="line">    a</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用了 <code>?:</code>操作符就可以简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><p>接下来通过一个具体的例子来结合使用 <code>?.</code> 和 <code>?:</code>这两个操作符，从而加深理解。</p><p>比如我们现在编写一个函数用来获得一段文本的长度，传统写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(text != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> text.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于文本是可能为空的，因此我们需要先进行一次判空操作，如果文本不为空就返回它的长度，如果文本为空就返回0。<br>这段代码看上去也并不复杂，但是我们却可以借助操作符让它变得更加简单，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span> = text?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里我们将<code>?.</code>和<code>?:</code>操作符结合到了一起使用，首先由于<code>text</code>是可能为空的，因此我们在调用它的<code>length</code>字段时需要使用<code>?.</code>操作符，而当<code>text</code>为空时，<code>text?.length</code>会返回一个<code>null</code>值，这个时候我们再借助<code>?:</code>操作符让它返回<code>0</code>。</p><p>不过<strong>Kotlin</strong>的空指针检查机制也并非总是那么智能，有的时候我们可能从逻辑上已经将空指针异常处理了，但是<strong>Kotlin</strong>的编译器并不知道，这个时候它还是会编译失败.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content: String? = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(content != <span class="literal">null</span>)&#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = content.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个可为空的全局变量<code>content</code>，然后在<code>main()</code>函数里先进行一次判空操作，当<code>content</code>不为空的时候才会调用<code>printUpperCase()</code>函数，在<code>printUpperCase()</code>函数里，我们将<code>content</code>转换为大写模式，最后打印出来。</p><p>看上去好像逻辑没什么问题，但是很遗憾，这段代码一定是无法运行的。因为<code>printUpperCase()</code>函数并不知道外部已经对<code>content</code>变量进行了非空检查，在调用<code>toUpperCase()</code>方法时，还认为这里存在空指针风险，从而无法编译通过。</p><p>在这种情况下，如果我们想要强行通过编译，可以使用非空断言工具，写法是在对象的后面加上<code>!!</code>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = content!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法就是在告知 <strong>Kotlin</strong>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</p><ul><li>最后我们再来学习一个比较与众不同的辅助工具 — <code>let</code>。 <code>let</code>既不是操作符，也不是什么关键字，而是一个<strong>函数</strong>。这个函数提供了函数式的 <strong>API</strong>的编程接口，并将原始调用对象作为参数传递到 <code>Lambda</code>表达式中。示例代码如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.let &#123; obj2 -&gt;</span><br><span class="line">         <span class="comment">// 具体代码实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里调用了<code>obj</code>对象的<code>let</code>函数，然后<code>Lambda</code>表达式中的代码就会立即执行，并且这个<code>obj</code>对象本身还会作为参数传递到<code>Lambda</code>表达式中。不过，为了防止变量重名，这里我将参数名改成了<code>obj2</code>，但<strong>实际上它们是同一个对象</strong>，这就是<code>let</code>函数的作用。</p><p><code>let</code>函数属于<strong>Kotlin</strong>中的标准函数，那这个<code>let</code>函数和空指针检查有什么关系呢？其实<code>let</code>函数的特性配合<code>?.</code>操作符可以在空指针检查的时候起到很大的作用。</p><p>就回到上面的 <code>doStudy()</code>函数当中，目前代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> doStudy(study: Study?)&#123;</span><br><span class="line">    study?.readBook()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这段代码我们通过<code>?.</code>操作符优化之后可以正常编译通过，但其实这种表达方式是有点啰嗦的，如果将这段代码准确翻译成使用<code>if</code>判断语句的写法，对应的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> doStudy(study: Study?)&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBook()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，本来我们进行一次<code>if</code>判断就能随意调用<code>study</code>对象的任何方法，但受制于<code>?.</code>操作符的限制，现在变成了每次调用<code>study</code>对象的方法时都要进行一次<code>if</code>判断。<br>这个时候就可以结合使用<code>?.</code>操作符和<code>let</code>函数来对代码进行优化了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.let &#123; stu -&gt;</span><br><span class="line">        stu.readBook()</span><br><span class="line">        stu.doHomeworl()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的意思是，<code>?.</code>操作符表示对象为空时什么都不做，对象不为空时就调用<code>let</code>函数，而<code>let</code>函数会将<code>study</code>对象本身作为参数传递到<code>Lambda</code>表达式中，此时的<code>study</code>对象肯定不为空了，我们就能放心地调用它的任意方法了。</p><p>外还记得<code>Lambda</code>表达式的语法特性吗？<strong>当<code>Lambda</code>表达式的参数列表中只有一个参数时</strong>，可以不用声明参数名，直接使用<code>it</code>关键字来代替即可，那么代码就可以进一步简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.let &#123;</span><br><span class="line">        it.readBook()</span><br><span class="line">        it.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code>函数是可以处理全局变量的判空问题的，而<code>if</code>判断语句则无法做到这一点。比如我们将<code>doStudy()</code>函数中的参数变成一个全局变量，使用<code>let</code>函数仍然可以正常工作，但使用 <code>if</code>判断句则会提示错误。</p><hr><h2 id="六、Kotlin中的小魔术"><a href="#六、Kotlin中的小魔术" class="headerlink" title="六、Kotlin中的小魔术"></a>六、Kotlin中的小魔术</h2><p>其实就是一些<strong>Kotlin</strong>小技巧啦~</p><h3 id="6-1-字符串内嵌表达式"><a href="#6-1-字符串内嵌表达式" class="headerlink" title="6.1 字符串内嵌表达式"></a>6.1 字符串内嵌表达式</h3><p><code>Kotlin</code>从一开始就支持了字符串内嵌表达式的功能，可以直接将表达式写在字符串里面，即使是构建非常复杂的字符串，也会变得轻而易举。</p><p>首先来看一下<code>Kotlin</code>中字符串内嵌表达式的语法规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello, <span class="subst">$&#123;obj.name&#125;</span>. nice to meet u&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，<strong>Kotlin</strong>允许我们在字符串里嵌入<code>$&#123;&#125;</code>这种语法结构的表达式，并在运行时使用表达式执行的结果替代这一部分内容。另外，当表达式中仅有一个变量的时候，还可以将两边的大括号省略，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello <span class="variable">$name</span> . nice to meet u&quot;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-函数的参数默认值"><a href="#6-2-函数的参数默认值" class="headerlink" title="6.2 函数的参数默认值"></a>6.2 函数的参数默认值</h3><p>其实之前在学习次构造函数用法的时候我就提到过，次构造函数在<strong>Kotlin</strong>中很少用，因为<strong>Kotlin</strong>提供了给函数设定参数默认值的功能，它在很大程度上能够替代次构造函数的作用。<br>具体来讲，我们可以在定义函数的时候给任意参数设定一个默认值，这样当调用此函数时就不会强制要求调用方为此参数传值，在没有传值的情况下会自动使用参数的默认值。<br>给参数设定默认值的方式也很简单，观察如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span>, str: <span class="type">String</span> = <span class="string">&quot;hello&quot;</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;num is <span class="variable">$num</span>, str is <span class="variable">$str</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printParams(<span class="number">123</span>)</span><br><span class="line">    printParams(<span class="number">123</span>,<span class="string">&quot;Charlie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们给<code>printParams()</code>函数的第二个参数设定了一个默认值，这样当调用<code>printParams()</code>函数时，可以选择给第二个参数传值，也可以选择不传，在不传的情况下就会自动使用默认值。</p><p>而如果我们想要 <code>printParams()</code>中的 <code>num</code>参数使用默认值应该怎么写呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span> = <span class="number">100</span>, str: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;num is <span class="variable">$num</span>, str is <span class="variable">$str</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数像上面这样写是没有问题的，那么我们该如何调用呢？模仿刚才的写法肯定是行不通的，因为编译器会认为我们想把字符串赋值给第一个<code>num</code>参数，从而报类型不匹配的错误。</p><p>不过不用担心，<strong>Kotlin</strong>提供了另外一种神奇的机制，就是可以通过键值对的方式来传参，从而不必像传统写法那样按照参数定义的顺序来传参。比如调用<code>printParams()</code>函数，我们还可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printParams(str = <span class="string">&quot;world&quot;</span>, num = <span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>此时哪个参数在前哪个参数在后都无所谓，<strong>Kotlin</strong>可以准确地将参数匹配上。而使用这种键值对的传参方式之后，我们就可以省略<code>num</code>参数了.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span> = <span class="number">100</span>, str: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;num is <span class="variable">$num</span>, str is <span class="variable">$str</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printParams(str = <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经掌握了如何给函数设定参数默认值，那么为什么说这个功能可以在很大程度上替代次构造函数的作用呢？</p><p>回忆一下当初我们学习次构造函数时所编写的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中有一个主构造函数和两个次构造函数，次构造函数在这里的作用是提供了使用更少参数来对Student类进行实例化的方式。无参的次构造函数会调用两个参数的次构造函数，并将这两个参数赋值成初始值。两个参数的次构造函数会调用4个参数的主构造函数，并将缺失的两个参数也赋值成初始值。<br>这种写法在Kotlin中其实是不必要的，因为我们完全可以通过只编写一个主构造函数，然后给参数设定默认值的方式来实现，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String = <span class="string">&quot;&quot;</span>, <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span>, name: String = <span class="string">&quot;&quot;</span>, age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kotlin入门&quot;&gt;&lt;a href=&quot;#Kotlin入门&quot; class=&quot;headerlink&quot; title=&quot;Kotlin入门&quot;&gt;&lt;/a&gt;Kotlin入门&lt;/h1&gt;&lt;h2 id=&quot;一、变量和函数&quot;&gt;&lt;a href=&quot;#一、变量和函数&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>语雀同款链接卡片—butterfly主题标签外挂</title>
    <link href="https://icu007work.github.io/archives/9765c01a.html"/>
    <id>https://icu007work.github.io/archives/9765c01a.html</id>
    <published>2023-08-03T07:02:03.000Z</published>
    <updated>2023-08-23T03:20:38.019Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考自：</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://blog.leonus.cn/favicon.ico">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(进一寸有进一寸的欢喜。)">          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>        </div>        <div class="tag-link-right">            <div class="tag-link-title">https://blog.leonus.cn/2022/link-card.html</div>            <div class="tag-link-sitename">Leonus</div>        </div>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>    </div>    </a></div><p>样式如下：</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://icu007.work/wp-content/uploads/2022/08/icno.png">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(与君共赴，万里征程)">          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>        </div>        <div class="tag-link-right">            <div class="tag-link-title">https://icu007.work</div>            <div class="tag-link-sitename">Charlie_l</div>        </div>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>    </div>    </a></div><h3 id="link-js"><a href="#link-js" class="headerlink" title="link.js"></a>link.js</h3><p>在 <code>\themes\butterfly\scripts\tag</code> 文件夹下面新建 <code>link.js</code> 并粘贴如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">JS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * link</span></span><br><span class="line"><span class="comment"> * &#123;% link url,title,favicon,desc %&#125;</span></span><br><span class="line"><span class="comment"> * &#123;% link 链接,标题,图标,介绍 %&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">link</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    args = args.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> url = (args[<span class="number">0</span>] || <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>(),</span><br><span class="line">        title = (args[<span class="number">1</span>] || <span class="string">&#x27;点击直达链接&#x27;</span>).<span class="title function_">trim</span>(),</span><br><span class="line">        favicon = (args[<span class="number">2</span>] ? <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;args[<span class="number">2</span>]&#125;</span>&quot; class=&quot;no-lightbox&quot;&gt;`</span> : defaultIcon).<span class="title function_">trim</span>(),</span><br><span class="line">        desc = (args[<span class="number">3</span>] || <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;url&#125;</span>&quot; <span class="subst">$&#123;url.includes(<span class="string">&#x27;http&#x27;</span>)?<span class="string">&#x27;target=&quot;_blank&quot;&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span> title=&quot;<span class="subst">$&#123;title&#125;</span>&quot; referrerPolicy=&quot;no-referrer&quot; class=&quot;link_card&quot;&gt;&lt;div class=&quot;link_icon&quot;&gt;<span class="subst">$&#123;favicon&#125;</span>&lt;/div&gt;&lt;div class=&quot;link_content&quot;&gt;&lt;div class=&quot;link_title&quot;&gt;<span class="subst">$&#123;title&#125;</span>&lt;/div&gt;<span class="subst">$&#123;desc?<span class="string">`&lt;div class=&quot;link_desc&quot;&gt;<span class="subst">$&#123;desc&#125;</span>&lt;/div&gt;`</span>:<span class="string">&#x27;&#x27;</span>&#125;</span>&lt;/div&gt;&lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(<span class="string">&#x27;link&#x27;</span>, link, &#123; <span class="attr">ends</span>: <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="link-styl"><a href="#link-styl" class="headerlink" title="link.styl"></a>link.styl</h3><p>在 <code>\themes\butterfly\source\css\_tags</code> 文件夹下面新建 <code>link.styl</code> 并粘贴如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.link_card</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  margin: <span class="number">10px</span> <span class="number">0</span></span><br><span class="line">  color: <span class="built_in">var</span>(--font-color) <span class="meta">!important</span></span><br><span class="line">  text-decoration: none <span class="meta">!important</span></span><br><span class="line">  background: <span class="built_in">var</span>(--reward-pop)</span><br><span class="line">  border-radius: <span class="number">10px</span></span><br><span class="line">  padding: <span class="number">12px</span></span><br><span class="line">  &amp;:hover</span><br><span class="line">    background: <span class="number">#4976f5</span></span><br><span class="line">    color: white <span class="meta">!important</span></span><br><span class="line">  .link_icon,.link_content</span><br><span class="line">    height: <span class="number">4rem</span></span><br><span class="line">  .link_icon</span><br><span class="line">    img,svg</span><br><span class="line">      height: <span class="number">4rem</span></span><br><span class="line">      width: <span class="number">4rem</span></span><br><span class="line">  .link_content</span><br><span class="line">    margin-left: <span class="number">1rem</span></span><br><span class="line">    width: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">6rem</span>)</span><br><span class="line">    overflow: hidden</span><br><span class="line">    line-height: <span class="number">1.5</span></span><br><span class="line">    display: flex</span><br><span class="line">    flex-direction: column</span><br><span class="line">    justify-content: center</span><br><span class="line">    .link_title</span><br><span class="line">      font-weight: bold</span><br><span class="line">      font-size: <span class="number">1.2rem</span></span><br><span class="line">    .link_title,.link_desc</span><br><span class="line">      word-break: break-all</span><br><span class="line">      overflow:hidden</span><br><span class="line">      text-overflow: ellipsis</span><br><span class="line">    &amp;:<span class="built_in">not</span>(:<span class="built_in">has</span>(.link_desc)) .link_title</span><br><span class="line">      display:-webkit-box</span><br><span class="line">      -webkit-box-orient:vertical</span><br><span class="line">      -webkit-line-clamp:<span class="number">2</span></span><br><span class="line">    .link_desc</span><br><span class="line">      opacity: .<span class="number">6</span></span><br><span class="line">    .link_desc,&amp;:<span class="built_in">has</span>(.link_desc) .link_title</span><br><span class="line">      white-space: nowrap</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>注意：<code>内容不能有英文逗号</code>，不然会出bug</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用html是为了高亮代码，不必在意 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参数如下： --&gt;</span></span><br><span class="line">&#123;% link 链接,标题,图标,介绍 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 示例如下： --&gt;</span></span><br><span class="line">&#123;% link https://blog.leonus.cn/,Leonus,https://blog.leonus.cn/favicon.ico,进一寸有进一寸的欢喜。 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 你也可以什么都不填，将会全部使用默认值，如下： --&gt;</span></span><br><span class="line">&#123;% card %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 你也可以省略部分内容，如下： --&gt;</span></span><br><span class="line">&#123;% link https://blog.leonus.cn/ %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 位置在后面的参数不填的话可以直接省略，但是如果中间的不想填必须留空，如下： --&gt;</span></span><br><span class="line">&#123;% link https://blog.leonus.cn/,,,进一寸有进一寸的欢喜。 %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>链接</td><td>如果连接中包含http则新标签打开，否则本标签页打开</td><td>无</td></tr><tr><td>标题</td><td>网站的标题</td><td>点击直达链接</td></tr><tr><td>图标</td><td>网站favicon<code>链接</code></td><td></td></tr><tr><td>介绍</td><td>网站的description</td><td>无</td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有什么问题可以留言，也可以根据自身需求进行修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考自：&lt;/p&gt;
&lt;div calss=&#39;anzhiyu-tag-link&#39;&gt;&lt;a class=&quot;tag-Link&quot; target=&quot;_blank&quot; href=&quot;https://blog.leonus.cn/favicon.ico&quot;&gt;
    &lt;div class=&quot;t</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA使用技巧</title>
    <link href="https://icu007work.github.io/archives/419d96b2.html"/>
    <id>https://icu007work.github.io/archives/419d96b2.html</id>
    <published>2023-07-29T07:30:11.000Z</published>
    <updated>2023-08-23T07:57:43.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA使用技巧"><a href="#IDEA使用技巧" class="headerlink" title="IDEA使用技巧"></a>IDEA使用技巧</h1><h2 id="一、入门导览"><a href="#一、入门导览" class="headerlink" title="一、入门导览"></a>一、入门导览</h2><ul><li>按住 <code>Alt + 1</code>即可打开项目视图，双击源码即可打开文件。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/4fa81c51a8b5b.png" alt="1690527585832.png"></p><ul><li>按下<code>Shift + F10</code> 即可运行项目，旁边的小虫子即为调试模式-</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/5b7369330558a.png" alt="1690527632047.png"></p><ul><li>在<code>for循环</code>处，按下 <code>Alt + Enter</code>即可将<code>for循环</code>优化为<code>增强for循环</code>，在打印语句中按下 <code>Alt + Enter</code>即可 <code>+</code> 号替换成 <code>String.format</code></li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/5d8a51a96c98e.png" alt="1690528026893.png"><img src="https://pic.ziyuan.wang/2023/07/28/da96868e287cd.png" alt="1690528134066.png"></p><ul><li>双击 <code>Shift</code>即可触发全局搜索。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/0096bcd4dc133.png" alt="1690528240450.png"></p><hr><h2 id="二、基本"><a href="#二、基本" class="headerlink" title="二、基本"></a>二、基本</h2><h3 id="2-1-上下文操作"><a href="#2-1-上下文操作" class="headerlink" title="2.1 上下文操作"></a>2.1 上下文操作</h3><ul><li>同样的在需要操作的代码处，按下 <code>Alt + Enter</code>即可显示上下文操作。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/9e4ae19c8e262.png" alt="1690528356924.png"></p><p><img src="https://pic.ziyuan.wang/2023/07/28/536470d6d8bdb.png" alt="1690528461547.png"></p><hr><h3 id="2-2-搜索操作"><a href="#2-2-搜索操作" class="headerlink" title="2.2 搜索操作"></a>2.2 搜索操作</h3><ul><li>可以按下 <code>Ctrl + Shift + A</code> 或连按两次 <code>Shift</code>触发搜索。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a34515b5d40dc.png" alt="1690528644744.png"></p><ul><li><code>Ctrl + N</code>搜索类， <code>Ctrl + Q</code> 预览所选类的文档</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a2928125e6403.png" alt="1690528829830.png"></p><ul><li>总结<ul><li><code>Ctrl + N</code>：搜索类</li><li><code>Ctrl + Shift + N</code>：搜索文件</li><li><code>Ctrl + Shift + Alt + N</code>：搜索符号</li><li><code>Ctrl + Shift + A</code>：搜索操作</li><li>双击 <code>Shift</code>：全局搜索</li></ul></li></ul><hr><h3 id="2-3-基本补全"><a href="#2-3-基本补全" class="headerlink" title="2.3 基本补全"></a>2.3 基本补全</h3><ul><li><code>Ctrl + 空格</code>：触发基本补全，<code>Ctrl + Shift + Enter</code>：补全当前语句。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/07a5fa14fea3b.png" alt="1690529434725.png"></p><ul><li><code>Ctrl + 两次空格</code>：查看有关静态变量或方法的建议</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/4f7170be5a781.png" alt="1690529682757.png"></p><hr><h2 id="三、编辑器基础知识"><a href="#三、编辑器基础知识" class="headerlink" title="三、编辑器基础知识"></a>三、编辑器基础知识</h2><h3 id="3-1-扩展和收缩代码选取"><a href="#3-1-扩展和收缩代码选取" class="headerlink" title="3.1 扩展和收缩代码选取"></a>3.1 扩展和收缩代码选取</h3><ul><li><p>按 <code>Ctrl + W</code>可选择文本光标处的单词。</p></li><li><p>再次按<code>Ctrl + W</code>可选择整个字符串。</p></li><li><p>第三次按<code>Ctrl + W</code>以在选择中添加引号。</p></li><li><p>再按<code>Ctrl + W</code>两次可选择整个调用。</p></li><li><p>如果要选择它的实参，而不是选择整个调用。可按 <code>Ctrl + Shift + W</code> 将选区收缩到实参。</p></li><li><p>在if语句的开头。可按两次 <code>Ctrl + W</code> 将其选中。只需按几下，即可很好地将关键字作为选择对应语句的一个起点。</p></li><li><p>总结：<code>Ctrl + W</code>：扩选 ； <code>Ctrl + Shift + W</code>：缩选。</p></li></ul><hr><h3 id="3-2-注释行和代码块"><a href="#3-2-注释行和代码块" class="headerlink" title="3.2 注释行和代码块"></a>3.2 注释行和代码块</h3><ul><li><code>Ctrl + /</code>： 单行注释&#x2F;取消单行注释</li><li><code>Ctrl + Shift + /</code>：多行注释&#x2F;取消多行注释</li></ul><hr><h3 id="3-3-复制和删除行"><a href="#3-3-复制和删除行" class="headerlink" title="3.3 复制和删除行"></a>3.3 复制和删除行</h3><ul><li><code>Ctrl + D</code>： 复制光标所在行</li><li><code>Ctrl + Y</code>： 删除光标所在行</li><li><code>Ctrl + ↑</code>： 向上选择</li></ul><hr><h3 id="3-4-移动代码段"><a href="#3-4-移动代码段" class="headerlink" title="3.4 移动代码段"></a>3.4 移动代码段</h3><ul><li><code>Alt + Shift + ↑</code>： 当前行向上移动</li><li><code>Alt + Shift + ↓</code>： 当前行向下移动</li><li><code>Ctrl + Shift + ↑</code>： 当前整个方法向上移动</li><li><code>Ctrl + Shift + ↓</code>： 当前整个方法向下移动</li></ul><hr><h3 id="3-5-收起代码块"><a href="#3-5-收起代码块" class="headerlink" title="3.5 收起代码块"></a>3.5 收起代码块</h3><ul><li><code>Ctrl + -</code>：收起当前代码块</li><li><code>Ctrl + =</code>：展开当前代码块</li><li><code>Ctrl + Shift + -</code>：收起文件中的所有区域</li><li><code>Ctrl + Shift + =</code>：展开文件中的所有区域</li></ul><hr><h3 id="3-6-包围和解包"><a href="#3-6-包围和解包" class="headerlink" title="3.6 包围和解包"></a>3.6 包围和解包</h3><ul><li><code>Ctrl + Alt + T</code>：使用一些模板代码包围代码段</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/ed25d369395be.png" alt="1690532033070.png"></p><ul><li><code>Ctrl + Alt + Delete</code>：解除模板代码包围</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/b6e236a6d4e9b.png" alt="1690532082762.png"></p><hr><h3 id="3-7-多选"><a href="#3-7-多选" class="headerlink" title="3.7 多选"></a>3.7 多选</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Multiple selections<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Firstname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Lastname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Points<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Eve<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Jackson<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>94<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>按 <code>Alt + J</code>可选择文本光标处的符号</li><li>再次按<code>Alt + J</code>可选择此符号的下一个匹配项</li><li>按 <code>AIt + Shift + J</code>可取消选择上一个匹配项</li><li>按 <code>Ctrl + Alt + Shift + L</code>可选择文件中的所有匹配项。</li><li>键入 <code>td</code>，将 <code>th</code>的所有匹配项替换为<code>td</code></li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/02a63a138c362.png" alt="1690532511051.png"></p><hr><h2 id="四、代码补全"><a href="#四、代码补全" class="headerlink" title="四、代码补全"></a>四、代码补全</h2><h3 id="4-1-基本补全"><a href="#4-1-基本补全" class="headerlink" title="4.1 基本补全"></a>4.1 基本补全</h3><ul><li><code>Ctrl + 空格</code>：触发基本补全，<code>Ctrl + Shift + Enter</code>：补全当前语句。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/07a5fa14fea3b.png" alt="1690529434725.png"></p><ul><li><code>Ctrl + 两次空格</code>：查看有关静态变量或方法的建议</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/4f7170be5a781.png" alt="1690529682757.png"></p><hr><h3 id="4-2-类型匹配补全"><a href="#4-2-类型匹配补全" class="headerlink" title="4.2 类型匹配补全"></a>4.2 类型匹配补全</h3><ul><li><code>Ctrl + Shift + 空格</code>：查看匹配当前类型的建议列表</li><li><code>Ctrl + Shift + 空格</code>还可以为 <code>return</code>提供代码建议</li></ul><hr><h3 id="4-3-后缀补全"><a href="#4-3-后缀补全" class="headerlink" title="4.3 后缀补全"></a>4.3 后缀补全</h3><ul><li>后缀补全有助于在编写代码时减少向后跳转文本光标。使用它可以根据添加的后缀、表达式的类型及其上下文，将已键入的表达式转换另一种表达式。 在圆括号后面键入<code>.</code>，以查看后缀补全建议列表。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/ed61e269d482d.png" alt="1690534971158.png"></p><hr><h3 id="4-4-语句补全"><a href="#4-4-语句补全" class="headerlink" title="4.4 语句补全"></a>4.4 语句补全</h3><ul><li><code>Ctrl + Shift + Enter</code>：可以补全类似 <code>for</code> 、 <code>if</code> 、 <code>switch</code>等语句</li></ul><hr><h3 id="4-5-Tab补全"><a href="#4-5-Tab补全" class="headerlink" title="4.5 Tab补全"></a>4.5 Tab补全</h3><ul><li>所有补全都可以搭配<code>Tab</code>使用</li></ul><hr><h2 id="五、重构"><a href="#五、重构" class="headerlink" title="五、重构"></a>五、重构</h2><h3 id="5-1-重命名"><a href="#5-1-重命名" class="headerlink" title="5.1 重命名"></a>5.1 重命名</h3><ul><li><code>Shift + F6</code>：重命名<strong>所有与选中内容一致</strong>的代码。</li></ul><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20230728173111078.png" alt="image-20230728173111078"></p><ul><li>IDEA还会检测相应的 getter&#x2F;setter，并提出相应的重命名建议。</li></ul><hr><h3 id="5-2-提取变量"><a href="#5-2-提取变量" class="headerlink" title="5.2 提取变量"></a>5.2 提取变量</h3><ul><li><code>Ctrl + Alt + V</code>：可以提取局部变量，并且会自动匹配代码中所有与选中变量一致的变量。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a845344f7a8ef.png" alt="1690536888565.png"></p><hr><h3 id="5-3-提取方法"><a href="#5-3-提取方法" class="headerlink" title="5.3 提取方法"></a>5.3 提取方法</h3><ul><li><code>Ctrl + Alt + M</code>：将所选代码块提取为方法</li></ul><hr><h3 id="5-4-重构菜单"><a href="#5-4-重构菜单" class="headerlink" title="5.4 重构菜单"></a>5.4 重构菜单</h3><ul><li><code>Ctrl + Shift + Alt + T</code>：列出当前上下文中可用的所有重构</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a0c80aecc4800.png" alt="1690537208428.png"></p><hr><h2 id="六、代码辅助"><a href="#六、代码辅助" class="headerlink" title="六、代码辅助"></a>六、代码辅助</h2><h3 id="6-1-还原移除的代码"><a href="#6-1-还原移除的代码" class="headerlink" title="6.1 还原移除的代码"></a>6.1 还原移除的代码</h3><ul><li>假设开发过程中需要还原先前删除的代码。因为此后发生了多项更改，撤消不起作用，而此时又不希望丢失这些更改。可点击几次 <strong>本地历史记录</strong> 来还原已删除的代码。在编辑器中的任意位置点击鼠标右键即可打开上下文菜单。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/496d7ecb83c99.png" alt="1690537789293.png"></p><hr><h3 id="6-2-格式化代码"><a href="#6-2-格式化代码" class="headerlink" title="6.2 格式化代码"></a>6.2 格式化代码</h3><ul><li><code>Ctrl + Alt + L</code>：更正代码格式，若有选中的代码则更正当前选中的代码；若未选中代码，则重新格式化整个文件。</li><li><code>Ctrl + Alt + Shift + L</code>：显示重新格式化设置</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/c2d55dddcfde6.png" alt="1690538025154.png"></p><hr><h3 id="6-3-形参信息"><a href="#6-3-形参信息" class="headerlink" title="6.3 形参信息"></a>6.3 形参信息</h3><ul><li><code>Ctrl + P</code>：查看方法签名</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/d8f002a921c1f.png" alt="1690538025154.png"></p><hr><h3 id="6-4-快速弹出窗口"><a href="#6-4-快速弹出窗口" class="headerlink" title="6.4 快速弹出窗口"></a>6.4 快速弹出窗口</h3><ul><li>按 <code>Ctrl + Q</code>可查看文本光标处符号的文档。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/8fde9ce454399.png" alt="1690538637711.png"></p><ul><li>按<code>Ctrl + Shift + l</code> 可查看文本光标处符号的定义。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/6551090e183d2.png" alt="1690538613744.png"></p><hr><h3 id="6-5-编辑器编码辅助"><a href="#6-5-编辑器编码辅助" class="headerlink" title="6.5 编辑器编码辅助"></a>6.5 编辑器编码辅助</h3><ul><li><code>F2</code>： 转到文件中下一个高亮显示的错误。</li><li><code>Ctrl F1</code>：展开警告说明。</li><li>另一种有用的工具是高亮显示用法。按 <code>Ctrl + Shift + F7</code> 可高亮显示文件中文本光标处符号的所有用法。</li></ul><hr><h2 id="七、导航"><a href="#七、导航" class="headerlink" title="七、导航"></a>七、导航</h2><h3 id="7-1-随处搜索"><a href="#7-1-随处搜索" class="headerlink" title="7.1 随处搜索"></a>7.1 随处搜索</h3><ul><li><code>Ctrl + N</code>：搜索类</li><li><code>Ctrl + Shift + N</code>：搜索文件</li><li><code>Ctrl + Shift + Alt + N</code>：搜索符号</li><li><code>Ctrl + Shift + A</code>：搜索操作</li><li>双击 <code>Shift</code>：全局搜索</li></ul><hr><h3 id="7-2-查找与替换"><a href="#7-2-查找与替换" class="headerlink" title="7.2 查找与替换"></a>7.2 查找与替换</h3><ul><li><code>Ctrl + Shift + F</code>：全局搜索</li><li><code>Ctrl + Shift + R</code>：打开 在文件中替换窗口</li></ul><hr><h3 id="7-3-文件重构"><a href="#7-3-文件重构" class="headerlink" title="7.3 文件重构"></a>7.3 文件重构</h3><ul><li><code>Ctrl + F12</code>：打开文件结构，打开后可键入单词以查找相关方法。</li><li><code>Alt + 7</code>：将文件结构显示为工具窗口</li></ul><hr><h3 id="7-4-声明和用法"><a href="#7-4-声明和用法" class="headerlink" title="7.4 声明和用法"></a>7.4 声明和用法</h3><ul><li><code>Ctrl + B</code>：在方法调用处，按下可跳转到方法声明</li><li><code>Ctrl + B</code>：在方法声明处，按下可查看其所有用法。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/3929cedb1b7c9.png" alt="1690599111074.png"></p><ul><li><code>Alt + F7</code>：查看更详细的用法视图，浏览完后按<code>Shift + Esc</code>：隐藏视图，按 <code>Alt + 3</code>：再次打开查找视图</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/5d41571606bd4.png" alt="1690599187782.png"></p><hr><h3 id="7-5-继承层次结构"><a href="#7-5-继承层次结构" class="headerlink" title="7.5 继承层次结构"></a>7.5 继承层次结构</h3><ul><li><code>Ctrl + Alt + B</code>：查找某个接口的实现</li><li><code>Ctrl + U</code>：从派生导航到 <code>super</code>方法</li><li><code>Ctrl + H</code>：查看某个类的层次结构</li><li><code>Ctrl + Shift + H</code>：查看某个方法的层次结构</li><li>注意：也可以对类执行 <code>Ctrl + Alt + B</code>和<code>Ctrl + U</code>操作</li></ul><hr><h3 id="7-6-最近的文件和位置"><a href="#7-6-最近的文件和位置" class="headerlink" title="7.6 最近的文件和位置"></a>7.6 最近的文件和位置</h3><ul><li><code>Ctrl + E</code>：显示最近打开的文件</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/5ce656e84c878.png" alt="1690600123613.png"></p><ul><li><code>Ctrl + Shift + E</code>：显示最近打开文件内的代码视图</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/4455b3f3dbcd9.png" alt="1690600156977.png"></p><hr><h3 id="7-7-下一个-上一个匹配项"><a href="#7-7-下一个-上一个匹配项" class="headerlink" title="7.7 下一个&#x2F;上一个匹配项"></a>7.7 下一个&#x2F;上一个匹配项</h3><ul><li><code>Ctrl + F</code>：在当前文件中执行全文搜索。</li><li><code>F3 / Enter</code>：查找下一个匹配项</li><li><code>Shift + F3</code>：跳转到上一个匹配项</li><li>注意，在查找面板关闭的情况下仍可使用上述快捷键跳转匹配项</li></ul><hr><h2 id="八、运行并调试"><a href="#八、运行并调试" class="headerlink" title="八、运行并调试"></a>八、运行并调试</h2><h3 id="8-1-运行配置"><a href="#8-1-运行配置" class="headerlink" title="8.1 运行配置"></a>8.1 运行配置</h3><ul><li>点击代码左上角的<img src="https://pic.ziyuan.wang/2023/07/29/eb27041a07a1a.png" alt="1690600625871.png">是创建一个临时运行配置</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/759a51529fa14.png" alt="1690600566371.png"></p><ul><li>我们可以选择保存配置，这样配置就保存为 <code>Sample with parameters</code>了</li></ul><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20230729111841097.png" alt="image-20230729111841097"></p><p><img src="https://pic.ziyuan.wang/2023/07/29/436ab8e60a59c.png" alt="1690600750761.png"></p><ul><li>要使同事可以访问运行配置，可将其存储为单独的文件并通过版本控制系统共享此文件。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/e48b5ab33a1cd.png" alt="1690600509040.png"></p><h3 id="8-2-调试工作流"><a href="#8-2-调试工作流" class="headerlink" title="8.2 调试工作流"></a>8.2 调试工作流</h3><ul><li><code>Ctrl + F8</code>：在当前行打断点</li><li><code>Shift + F9</code>：使用当前所选运行配置开始调试</li><li>调试时可以在搜索框调用函数表达式来检查某个函数是否抛出异常。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/9687714379594.png" alt="1690604094195.png"></p><ul><li>当表达式导致异常时 可点击<img src="https://pic.ziyuan.wang/2023/07/29/f00e7417cfe29.png" alt="1690611152951.png">或者按下 <code>Ctrl + Shift + A</code>将该表达式添加到监听。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/fc6b03ae7bbbc.png" alt="1690611103971.png"></p><ul><li><code>F7</code>： 步入</li><li><code>F8</code>： 步过</li><li><code>F9</code>： 恢复程序</li><li><code>Shift + F8</code>: 步出</li><li><code>Ctrl + Alt + F8</code>： 为所选实参调用“对表达式快速求值”</li><li>我们可以在修复后重新运行我们的小程序，但是对于大程序，重新运行可能需要很长时间。如果修复只影响纯方法，我们可以重新构建项目并应用热交换，而不是重新运行。按 <code>Ctrl + F9</code> 构建项目。</li><li><code>Alt + F9</code>： 执行程序直到文本光标所在的行。</li></ul><hr><h2 id="九、Git"><a href="#九、Git" class="headerlink" title="九、Git"></a>九、Git</h2><h3 id="9-1-快速入门"><a href="#9-1-快速入门" class="headerlink" title="9.1 快速入门"></a>9.1 快速入门</h3><ul><li>双击 <code>Shift</code>并搜索克隆 打开克隆视图，输入URL即可克隆任意public git仓库的代码</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/6341ad8d942c7.png" alt="1690614101281.png"></p><ul><li><code>Ctrl + Alt + N</code>：新建分支</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/caf261acd55be.png" alt="1690614259677.png"></p><ul><li>提交界面</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/d702ab66db582.png" alt="1690614333074.png"></p><ul><li><code>Ctrl + Shift + K</code>： 推送代码</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/7c3a22be6d469.png" alt="1690614382744.png"></p><hr><h3 id="9-2-项目历史记录"><a href="#9-2-项目历史记录" class="headerlink" title="9.2 项目历史记录"></a>9.2 项目历史记录</h3><ul><li><code>Alt + 9</code>：打开Git工具窗口</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/8d86935cfafae.png" alt="1690614558981.png"></p><hr><h3 id="9-3-提交"><a href="#9-3-提交" class="headerlink" title="9.3 提交"></a>9.3 提交</h3><ul><li><code>Ctrl + K</code>: 打开提交工具窗口</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/5717b7cf44ec8.png" alt="1690614724472.png"></p><ul><li><code>Alt + 9</code> 打开Git工具窗口即可看到提交</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/ae562005aa6ff.png" alt="1690614842835.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDEA使用技巧&quot;&gt;&lt;a href=&quot;#IDEA使用技巧&quot; class=&quot;headerlink&quot; title=&quot;IDEA使用技巧&quot;&gt;&lt;/a&gt;IDEA使用技巧&lt;/h1&gt;&lt;h2 id=&quot;一、入门导览&quot;&gt;&lt;a href=&quot;#一、入门导览&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="IDEA" scheme="https://icu007work.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 4(4143)注册方法</title>
    <link href="https://icu007work.github.io/archives/9491d997.html"/>
    <id>https://icu007work.github.io/archives/9491d997.html</id>
    <published>2023-07-26T03:54:24.000Z</published>
    <updated>2023-08-23T07:57:28.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sublime-Text-4-4143-注册方法"><a href="#Sublime-Text-4-4143-注册方法" class="headerlink" title="Sublime Text 4(4143)注册方法"></a>Sublime Text 4(4143)注册方法</h2><p>截止2023年7月26日，最新版本是Sublime Text 4 (Build 4143)。注册方法如下：</p><ul><li>安装软件：去官方站点下载并安装 Sublime Text - <a href="https://www.sublimetext.com/">Text Editing, Done Right</a></li><li>使用浏览器打开网站：<a href="https://hexed.it/">https://hexed.it/</a> ，点击打开文件，打开Sublime Text安装目录选择文件 sublime_text.exe</li><li>在 <strong>搜索</strong> 中输入：807805000f94c1 按回车键Enter</li><li>选中 <strong>启用替换</strong> ，在 <strong>替换为</strong> 输入c64005014885c9 点击Replace即可</li><li>点击 <strong>另存为</strong> ，保存文件到本地，文件名设定为sublime_text<br><img src="https://pic.ziyuan.wang/2023/07/26/385db4c3a936f.png" alt="1690344313607.png"></li><li>备份原sublime_text.exe文件（修改为如sublime_text_bk.exe）</li><li>将修改过的sublime_text.exe复制到原sublime text 4安装目录中即可<br>这样就激活成功了，打开Sublime Text之后，可以看到 “ Registered ” 的提示。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/26/778d98efbc375.png" alt="1690344350428.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sublime-Text-4-4143-注册方法&quot;&gt;&lt;a href=&quot;#Sublime-Text-4-4143-注册方法&quot; class=&quot;headerlink&quot; title=&quot;Sublime Text 4(4143)注册方法&quot;&gt;&lt;/a&gt;Sublime Text 4</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Win FR:一款数据恢复工具</title>
    <link href="https://icu007work.github.io/archives/2940757f.html"/>
    <id>https://icu007work.github.io/archives/2940757f.html</id>
    <published>2023-05-23T07:31:47.000Z</published>
    <updated>2023-08-23T07:57:14.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、官方工具"><a href="#一、官方工具" class="headerlink" title="一、官方工具"></a>一、官方工具</h2><blockquote><p>商店页面：<a href="https://www.microsoft.com/store/productId/9N26S50LN705">https://www.microsoft.com/store/productId/9N26S50LN705</a></p></blockquote><ul><li>通常文件被删除后，数据还会残留在硬盘中一段时间，用数据恢复工具就有概率能够恢复文件。而微软就出品了一款数据恢复相关的工具 Windows File Recovery，相当不错！</li></ul><p><img src="http://p1.meituan.net/csc/2118a5e67b680fee26cee58963cf7f3a127433.png" alt="微软数据恢复"></p><ul><li><p>微软的这款 Windows File Recovery 已经上架了 Window 商店了，它支持多种文件系统（比如NTFS、exFAT、FAT、ReFS），可对多种文件格式（比如照片、视频、文档等等）进行恢复。无论想要恢复 SSD、HDD还是U盘、SD卡的各种文件，Windows File Recovery 都可以发挥作用。</p></li><li><p>Windows File Recovery 提供三种恢复模式，分别是 Windows File Recovery 普通、分段（segment mode）、签名（signature mode），各模式使用场景如下：</p><ul><li><p>1） 普通模式：用于最近删除过的文件恢复，支持文件格式为NTFS；</p></li><li><p>2） 分段模式（segment mode）：用于恢复已删除一段时间的文件，或者对已经格式化过的磁盘执行恢复操作；</p></li><li><p>3） 签名模式（signature mode）：针对FAT、exFAT、ReFS等文件系统恢复，此外如果其他恢复模式不顺利，也可用这个模式试一试。</p></li></ul></li><li><p>需要注意的是，Windows File Recovery 没有图形界面，需要通过命令行使用，但并不难。它的命令语法是：</p></li></ul><blockquote><p>winfr [被删文件所在盘符] [恢复文件对应盘符] [&#x2F;开关] 文件详细路径</p></blockquote><ul><li><p>例如，我们要将E:\test\下一个名为“XX.txt”的文件找回来，具体命令就是：<code>winfr e: d: /n \test\XX.txt</code>。</p></li><li><p>而通过各种命令，Windows File Recovery 还可以实现其他功能，例如支持通配符、恢复整个文件夹等等。关于各种命令，微软专门提供了一个命令说明网页，以便新手熟悉。网址如下：</p></li></ul><blockquote><p><a href="https://support.microsoft.com/zh-cn/help/4538642/windows-10-restore-lost-files">https://support.microsoft.com/zh-cn/help/4538642/windows-10-restore-lost-files</a></p></blockquote><ul><li>感兴趣的可以看看，非常全面，可以翻译为中文。</li></ul><h2 id="二、图形化工具"><a href="#二、图形化工具" class="headerlink" title="二、图形化工具"></a>二、图形化工具</h2><ul><li>简单来说，Windows File Recovery 的功能和效果都相当不错。如果你实在不想用命令行，那么也可以使用基于 Windows File Recovery 打造的软件，例如傲梅出品的 WinFR 界面版，恢复数据更加简单！</li></ul><p><img src="http://p0.meituan.net/csc/e3d7aef8a3dc47ce6fbd039bf339f281161908.png" alt="WinFR界面版"></p><blockquote><p>官网：<a href="https://www.winfr.com.cn/">WinFR官网 – 免费的数据恢复软件</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、官方工具&quot;&gt;&lt;a href=&quot;#一、官方工具&quot; class=&quot;headerlink&quot; title=&quot;一、官方工具&quot;&gt;&lt;/a&gt;一、官方工具&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;商店页面：&lt;a href=&quot;https://www.microsoft.com/s</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="软件分享" scheme="https://icu007work.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo发布文章指北</title>
    <link href="https://icu007work.github.io/archives/5d597b5d.html"/>
    <id>https://icu007work.github.io/archives/5d597b5d.html</id>
    <published>2023-05-13T08:26:26.000Z</published>
    <updated>2023-08-23T07:56:26.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、快速开始"><a href="#一、快速开始" class="headerlink" title="一、快速开始"></a>一、快速开始</h2><h3 id="1-1-新建一篇文章"><a href="#1-1-新建一篇文章" class="headerlink" title="1.1 新建一篇文章"></a>1.1 新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="1-2-运行服务"><a href="#1-2-运行服务" class="headerlink" title="1.2 运行服务"></a>1.2 运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="1-3-生成静态文件"><a href="#1-3-生成静态文件" class="headerlink" title="1.3 生成静态文件"></a>1.3 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="1-4-部署到远程站点"><a href="#1-4-部署到远程站点" class="headerlink" title="1.4 部署到远程站点"></a>1.4 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、快速开始&quot;&gt;&lt;a href=&quot;#一、快速开始&quot; class=&quot;headerlink&quot; title=&quot;一、快速开始&quot;&gt;&lt;/a&gt;一、快速开始&lt;/h2&gt;&lt;h3 id=&quot;1-1-新建一篇文章&quot;&gt;&lt;a href=&quot;#1-1-新建一篇文章&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Github Action实现Android自动打包并发布apk</title>
    <link href="https://icu007work.github.io/archives/40fd71e7.html"/>
    <id>https://icu007work.github.io/archives/40fd71e7.html</id>
    <published>2023-05-12T09:35:25.000Z</published>
    <updated>2023-08-23T07:56:26.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Github-Action介绍"><a href="#Github-Action介绍" class="headerlink" title="Github Action介绍"></a>Github Action介绍</h2><h3 id="一、Github-Action-是什么？"><a href="#一、Github-Action-是什么？" class="headerlink" title="一、Github Action 是什么？"></a>一、Github Action 是什么？</h3><p>是 Github 推出的持续集成工具</p><h3 id="二、持续集成是什么？"><a href="#二、持续集成是什么？" class="headerlink" title="二、持续集成是什么？"></a>二、持续集成是什么？</h3><p>简单说就是自动化的打包程序——如果是前端程序员，这样解释比较顺畅：</p><p>每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac &#x2F; Windows &#x2F; Linux 任我们选），来执行一段或多段指令（由我们定），例如：</p><ol><li>npm install</li><li>npm run build</li></ol><h3 id="三、Yaml-是什么？"><a href="#三、Yaml-是什么？" class="headerlink" title="三、Yaml 是什么？"></a>三、Yaml 是什么？</h3><p>我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个 .github 文件夹，里面放一个 *.yaml 文件——这个 Yaml 文件就是我们配置 Github Action 所用的文件。</p><h3 id="四、Github-Action-的使用限制"><a href="#四、Github-Action-的使用限制" class="headerlink" title="四、Github Action 的使用限制"></a>四、Github Action 的使用限制</h3><ul><li>每个 Workflow 中的 job 最多可以执行 6 个小时</li><li>每个 Workflow 最多可以执行 72 小时</li><li>每个 Workflow 中的 job 最多可以排队 24 小时</li><li>在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求</li><li>并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 &#x2F; 50）</li></ul><h3 id="五、什么是-Workflow？"><a href="#五、什么是-Workflow？" class="headerlink" title="五、什么是 Workflow？"></a>五、什么是 Workflow？</h3><p>Workflow 是由一个或多个 job 组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow 配置。</p><hr><h4 id="5-1-如何定义-Workflow-的名字？"><a href="#5-1-如何定义-Workflow-的名字？" class="headerlink" title="5.1 如何定义 Workflow 的名字？"></a>5.1 如何定义 Workflow 的名字？</h4><blockquote><p>name</p></blockquote><p>Workflow 的名称，Github 在存储库的 Action 页面上显示 Workflow 的名称。</p><p>如果我们省略 name，则 Github 会将其设置为相对于存储库根目录的工作流文件路径。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Greeting from Mona</span><br><span class="line">on: push</span><br></pre></td></tr></table></figure><hr><h4 id="5-2-如何定义-Workflow-的触发器？"><a href="#5-2-如何定义-Workflow-的触发器？" class="headerlink" title="5.2 如何定义 Workflow 的触发器？"></a>5.2 如何定义 Workflow 的触发器？</h4><blockquote><p>on</p></blockquote><p>触发 Workflow 执行的 event 名称，比如：<strong>每当我提交代码到 Github 上的时候，或者是每当我打 TAG 的时候。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单个事件</span><br><span class="line">on: push</span><br><span class="line"></span><br><span class="line">// 多个事件</span><br><span class="line">on: [push,pull_request]</span><br></pre></td></tr></table></figure><h3 id="六、Workflow-的-job-是什么？"><a href="#六、Workflow-的-job-是什么？" class="headerlink" title="六、Workflow 的 job 是什么？"></a>六、Workflow 的 job 是什么？</h3><p>答：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p><h4 id="6-1-如何定义一个-job？"><a href="#6-1-如何定义一个-job？" class="headerlink" title="6.1 如何定义一个 job？"></a>6.1 如何定义一个 job？</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  my_first_job:</span><br><span class="line">    name: My first job</span><br><span class="line">  my_second_job:</span><br><span class="line">    name: My second job</span><br></pre></td></tr></table></figure><p>答：通过 job 的 id 定义。</p><p>每个 job 必须具有一个 id 与之关联。</p><p>上面的 my_first_job 和 my_second_job 就是 job_id。</p><h4 id="6-2-如何定义-job-的名称？"><a href="#6-2-如何定义-job-的名称？" class="headerlink" title="6.2 如何定义 job 的名称？"></a>6.2 如何定义 job 的名称？</h4><blockquote><p>jobs.<job_id>.name</p></blockquote><p>name 会显示在 Github 上</p><h4 id="6-3-如何定义-job-的依赖？job-是否可以依赖于别的-job-的输出结果？"><a href="#6-3-如何定义-job-的依赖？job-是否可以依赖于别的-job-的输出结果？" class="headerlink" title="6.3 如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？"></a>6.3 如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？</h4><blockquote><p>jobs.<job_id>.needs</p></blockquote><p>答：needs 可以标识 job 是否依赖于别的 job——如果 job 失败，则会跳过所有需要该 job 的 job。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">  job2:</span><br><span class="line">    needs: job1</span><br><span class="line">  job3:</span><br><span class="line">    needs: [job1, job2]</span><br></pre></td></tr></table></figure><blockquote><p>jobs.<jobs_id>.outputs：用于和 need 打配合，outputs 输出&#x3D;》need 输入</p></blockquote><p>jobs 的输出，用于和 needs 打配合：可以看到 ouput</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    # Map a step output to a job output</span><br><span class="line">    outputs:</span><br><span class="line">      output1: $&#123;&#123; steps.step1.outputs.test &#125;&#125;</span><br><span class="line">      output2: $&#123;&#123; steps.step2.outputs.test &#125;&#125;</span><br><span class="line">    steps:</span><br><span class="line">    - id: step1</span><br><span class="line">      run: echo &quot;::set-output name=test::hello&quot;</span><br><span class="line">    - id: step2</span><br><span class="line">      run: echo &quot;::set-output name=test::world&quot;</span><br><span class="line">  job2:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    needs: job1</span><br><span class="line">    steps:</span><br><span class="line">    - run: echo $&#123;&#123;needs.job1.outputs.output1&#125;&#125; $&#123;&#123;needs.job1.outputs.output2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-如何定义-job-的运行环境？"><a href="#6-4-如何定义-job-的运行环境？" class="headerlink" title="6.4 如何定义 job 的运行环境？"></a>6.4 如何定义 job 的运行环境？</h4><blockquote><p>jobs.<job_id>.runs-on</p></blockquote><p>指定运行 job 的运行环境，Github 上可用的运行器为：</p><ul><li>windows-2019</li><li>ubuntu-20.04</li><li>ubuntu-18.04</li><li>ubuntu-16.04</li><li>macos-10.15</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    runs-on: macos-10.15</span><br><span class="line">  job2:</span><br><span class="line">    runs-on: windows-2019</span><br></pre></td></tr></table></figure><h4 id="6-5-如何给-job-定义环境变量？"><a href="#6-5-如何给-job-定义环境变量？" class="headerlink" title="6.5 如何给 job 定义环境变量？"></a>6.5 如何给 job 定义环境变量？</h4><blockquote><p>jobs.<jobs_id>.env</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    env:</span><br><span class="line">      FIRST_NAME: Mona</span><br></pre></td></tr></table></figure><h4 id="6-6-如何使用-job-的条件控制语句？"><a href="#6-6-如何使用-job-的条件控制语句？" class="headerlink" title="6.6 如何使用 job 的条件控制语句？"></a>6.6 如何使用 job 的条件控制语句？</h4><blockquote><p>jobs.<job_id>.if</p></blockquote><p>我们可以使用 if 条件语句来组织 job 运行</p><hr><h3 id="七、Step-属性是什么？"><a href="#七、Step-属性是什么？" class="headerlink" title="七、Step 属性是什么？"></a>七、Step 属性是什么？</h3><p>答：每个 job 由多个 step 构成，它会从上至下依次执行。</p><h4 id="7-1-step-运行的是什么？"><a href="#7-1-step-运行的是什么？" class="headerlink" title="7.1 step 运行的是什么？"></a>7.1 step 运行的是什么？</h4><p><strong>step 可以运行：</strong></p><ol><li><strong>command</strong>s：命令行命令</li><li><strong>setup tasks</strong>：环境配置命令（比如安装个 Node 环境、安装个 Python 环境）</li><li><strong>action</strong>（in your repository, in public repository, in Docker registry）：一段 action（Action 是什么我们后面再说）</li></ol><p><strong>每个 step 都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。</strong></p><p>因为每个 step 都在运行器环境中独立运行，所以 <strong>step 之间不会保留对环境变量的更改</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 定义 Workflow 的名字</span><br><span class="line">name: Greeting from Mona</span><br><span class="line"></span><br><span class="line"># 定义 Workflow 的触发器</span><br><span class="line">on: push</span><br><span class="line"></span><br><span class="line"># 定义 Workflow 的 job</span><br><span class="line">jobs:</span><br><span class="line">  # 定义 job 的 id</span><br><span class="line">  my-job:</span><br><span class="line">    # 定义 job 的 name</span><br><span class="line">    name: My Job</span><br><span class="line">    # 定义 job 的运行环境</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    # 定义 job 的运行步骤</span><br><span class="line">    steps:</span><br><span class="line">    # 定义 step 的名称</span><br><span class="line">    - name: Print a greeting</span><br><span class="line">      # 定义 step 的环境变量</span><br><span class="line">      env:</span><br><span class="line">        MY_VAR: Hi there! My name is</span><br><span class="line">        FIRST_NAME: Mona</span><br><span class="line">        MIDDLE_NAME: The</span><br><span class="line">        LAST_NAME: Octocat</span><br><span class="line">      # 运行指令：输出环境变量</span><br><span class="line">      run: |</span><br><span class="line">        echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.</span><br></pre></td></tr></table></figure><hr><h3 id="八、Action-是什么？"><a href="#八、Action-是什么？" class="headerlink" title="八、Action 是什么？"></a>八、Action 是什么？</h3><p>我们可以直接打开下面的 Action 市场来看看：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace?type=actions">https://github.com/marketplace?type=actionsgithub.com/marketplace?type=actions</a></p><p>Action 其实就是命令，比如 Github 官方给了我们一些默认的命令：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace?type=actions&query=actions">GitHub Marketplace: actions to improve your workflowgithub.com&#x2F;marketplace?type&#x3D;actions&amp;query&#x3D;actions<img src="https://pic4.zhimg.com/v2-d06dfc50fef28a5c76fa9034fe797faf_180x120.jpg" alt="img"></a></p><p><img src="https://pic2.zhimg.com/80/v2-5208c22215435edfa36040d6b217c325_720w.webp" alt="img"></p><p>比如最常用的，check-out 代码到 Workflow 工作区：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace/actions/checkout">https://github.com/marketplace/actions/checkoutgithub.com/marketplace/actions/checkout</a></p><h4 id="8-1-我们应该如何使用-Action？"><a href="#8-1-我们应该如何使用-Action？" class="headerlink" title="8.1 我们应该如何使用 Action？"></a>8.1 我们应该如何使用 Action？</h4><blockquote><p>jobs.<job_id>.steps.uses</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-e6855fd2e091401590baf4febf356cce_720w.webp" alt="img"></p><p>Action 库：Checkout</p><p>比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - uses: actions/checkout@v2</span><br></pre></td></tr></table></figure><p>当然，我们还可以给它添加个名字：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: Check out Git repository</span><br><span class="line">    uses: actions/checkout@v2</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-8ea878b5f2917be32ba9aa18b3a1cef9_720w.webp" alt="img"></p><p>Action 库：Setup Node</p><p>再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">- uses: actions/checkout@v2</span><br><span class="line">- uses: actions/setup-node@v2-beta</span><br><span class="line">  with:</span><br><span class="line">    node-version: &#x27;12&#x27;</span><br></pre></td></tr></table></figure><h4 id="8-2-上面我们为什么要用：-v2-和-v2-beta-呢？"><a href="#8-2-上面我们为什么要用：-v2-和-v2-beta-呢？" class="headerlink" title="8.2 上面我们为什么要用：@v2 和 @v2-beta 呢？"></a>8.2 上面我们为什么要用：@v2 和 @v2-beta 呢？</h4><p>答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。</p><p>我们如果不带版本号的话，其实就是默认使用最新版本的了。</p><p>但是 <strong>Github 官方强烈要求我们带上版本号</strong>——这样子的话，我们就不会出现：<strong>写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。</strong></p><h4 id="8-3-上面的-with-参数是什么意思？"><a href="#8-3-上面的-with-参数是什么意思？" class="headerlink" title="8.3 上面的 with 参数是什么意思？"></a><strong>8.3 上面的 with 参数是什么意思？</strong></h4><p>答：<strong>有的 Action 可能会需要我们传入一些特定的值</strong>：比如上面的 node 版本啊之类的，这些<strong>需要我们传入的参数由 with 关键字来引入</strong>。</p><p><strong>具体的 Action 需要传入哪些参数，还请去 Github Action Market 中 Action 的页面中查看。</strong></p><p>具体库的使用和参数，我们可以去官方的 Action 市场查看：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace/actions/">Github Action 市场github.com&#x2F;marketplace&#x2F;actions&#x2F;</a></p><hr><h3 id="九、我们如何运行命令行命令？"><a href="#九、我们如何运行命令行命令？" class="headerlink" title="九、我们如何运行命令行命令？"></a>九、我们如何运行命令行命令？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs.&lt;job_id&gt;.steps.run</span><br></pre></td></tr></table></figure><p>上文说到，<strong>steps 可以运行：action 和 command-line programs</strong>。</p><p>我们现在已经知道<strong>可以使用 uses 来运行 action 了</strong>，那么我们该如何运行 command-line programs 呢？</p><p><strong>答案是：run</strong></p><p><strong>run 命令在默认状态下会启动一个没有登录的 shell 来作为命令输入器。</strong></p><h4 id="9-1-如何运行多行命令？"><a href="#9-1-如何运行多行命令？" class="headerlink" title="9.1 如何运行多行命令？"></a><strong>9.1 如何运行多行命令？</strong></h4><p><strong>每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：</strong></p><ul><li><strong>单行命令</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- name: Install Dependencies</span><br><span class="line">  run: npm install</span><br></pre></td></tr></table></figure><ul><li><strong>多行命令</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: Clean install dependencies and build</span><br><span class="line">  run： |</span><br><span class="line">    npm ci</span><br><span class="line">    npm run build</span><br></pre></td></tr></table></figure><h4 id="9-2-如何指定-command-运行的位置？"><a href="#9-2-如何指定-command-运行的位置？" class="headerlink" title="9.2 如何指定 command 运行的位置？"></a>9.2 如何指定 command 运行的位置？</h4><p>使用 working-directory 关键字，我们可以指定 command 的运行位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: Clean temp directory</span><br><span class="line">  run: rm -rf *</span><br><span class="line">  working-directory: ./temp</span><br></pre></td></tr></table></figure><h4 id="9-3-如何指定-shell-的类型？（使用-cmd-or-powershell-or-python？？）"><a href="#9-3-如何指定-shell-的类型？（使用-cmd-or-powershell-or-python？？）" class="headerlink" title="9.3 如何指定 shell 的类型？（使用 cmd or powershell or python？？）"></a>9.3 如何指定 shell 的类型？（使用 cmd or powershell or python？？）</h4><p>使用 shell 关键字，来指定特定的 shell：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: Display the path</span><br><span class="line">    run: echo $PATH</span><br><span class="line">    shell: bash</span><br></pre></td></tr></table></figure><p>下面是各个系统支持的 shell 类型：</p><p><img src="https://pic2.zhimg.com/80/v2-9283bfe170157cf550cbc86c36fa28c5_720w.webp" alt="img"></p><hr><h3 id="十、什么是矩阵？"><a href="#十、什么是矩阵？" class="headerlink" title="十、什么是矩阵？"></a>十、什么是矩阵？</h3><p>答：就是有时候，我们的代码可能编译环境有多个。比如 electron 的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe 可执行文件。</p><p><strong>这种时候，我们使用矩阵就可以啦~</strong></p><p>比如下面的代码，我们使用了矩阵指定了：<strong>2 个操作系统，3 个 node 版本</strong>。</p><p>这时候<strong>下面这段代码就会执行 6 次</strong>—— 2 x 3 &#x3D; 6！！！</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runs-on: $&#123;&#123; matrix.os &#125;&#125;</span><br><span class="line">strategy:</span><br><span class="line">  matrix:</span><br><span class="line">    os: [ubuntu-16.04, ubuntu-18.04]</span><br><span class="line">    node: [6, 8, 10]</span><br><span class="line">steps:</span><br><span class="line">  - uses: actions/setup-node@v1</span><br><span class="line">    with:</span><br><span class="line">      node-version: $&#123;&#123; matrix.node &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="如何用GitHub-Action自动编译并且发布软件到-Release"><a href="#如何用GitHub-Action自动编译并且发布软件到-Release" class="headerlink" title="如何用GitHub Action自动编译并且发布软件到 Release"></a>如何用GitHub Action自动编译并且发布软件到 Release</h2><h3 id="一、配置连接私有秘钥仓库的token"><a href="#一、配置连接私有秘钥仓库的token" class="headerlink" title="一、配置连接私有秘钥仓库的token"></a>一、配置连接私有秘钥仓库的token</h3><ol><li>首先点击 <code>Settings</code></li></ol><p><img src="http://p1.meituan.net/csc/fe431f6c5e071351005b8f960891b1a539243.png" alt="image.png"></p><ol start="2"><li>然后选择<code>Developer settings</code></li></ol><p><img src="http://p0.meituan.net/csc/43fff60e59380a738053cdd60ed0e1f7279525.png" alt="image.png"></p><ol start="3"><li>依次选择<code>Tokens</code> -&gt; <code>generate new token</code>生成新的token后复制并保存下来。</li></ol><p><img src="http://p1.meituan.net/csc/af9948599cade116963039b4f6897988176494.png" alt="image.png"></p><ol start="4"><li>在仓库的设置中依次选择 <code>Settings</code> -&gt; <code>Secrets and variables</code> -&gt; <code>Action</code> -&gt; <code>new repository secret</code>新建一个名为TOKEN的密钥，并将第三步复制的token粘贴进去。</li></ol><p><img src="http://p0.meituan.net/csc/f381faeac8abed51ad36adee738ef4d7336383.png" alt="image.png"></p><h3 id="二、配置-GitHub-Action"><a href="#二、配置-GitHub-Action" class="headerlink" title="二、配置 GitHub Action"></a>二、配置 GitHub Action</h3><ol><li>依次点击 <code>Action</code> -&gt; <code>Android CI</code> -&gt; <code>Configure</code></li></ol><p><img src="http://p0.meituan.net/csc/f2d6e561835f7aa369fde4574259892f374070.png" alt="image.png"></p><ol start="2"><li>配置 <code>android.yml</code></li></ol><p><img src="http://p0.meituan.net/csc/c210d15c2d5069928b0cd2072e8366d3274932.png" alt="image.png"></p><ul><li><code>android.yml</code>配置如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"> <span class="attr">push:</span></span><br><span class="line">   <span class="attr">branches:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;feature/*&quot;</span></span><br><span class="line">   <span class="attr">tags:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;v*.*.*&quot;</span></span><br><span class="line"> <span class="attr">pull_request:</span></span><br><span class="line">   <span class="attr">branches:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;feature/*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"> <span class="attr">apk:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">APK</span></span><br><span class="line">   <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">   <span class="attr">steps:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/checkout@v2.4.0</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Branch</span> <span class="string">name</span></span><br><span class="line">       <span class="attr">run:</span> <span class="string">echo</span> <span class="string">running</span> <span class="string">on</span> <span class="string">branch</span> <span class="string">$&#123;GITHUB_REF##*/&#125;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">JDK</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/setup-java@v2.5.0</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">distribution:</span> <span class="string">temurin</span></span><br><span class="line">         <span class="attr">java-version:</span> <span class="string">&quot;11&quot;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">execution</span> <span class="string">flag</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">       <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">APK</span></span><br><span class="line">       <span class="attr">run:</span> <span class="string">bash</span> <span class="string">./gradlew</span> <span class="string">assembleDebug</span> <span class="string">--stacktrace</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">APK</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v1</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">name:</span> <span class="string">apk</span></span><br><span class="line">         <span class="attr">path:</span> <span class="string">app/build/outputs/apk/debug/app-debug.apk</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">release:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">Release</span> <span class="string">APK</span></span><br><span class="line">   <span class="attr">needs:</span> <span class="string">apk</span></span><br><span class="line">   <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">   <span class="attr">steps:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">branch</span> <span class="string">name</span></span><br><span class="line">       <span class="attr">id:</span> <span class="string">branch-name</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">tj-actions/branch-names@v5.1</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">branch</span>    </span><br><span class="line">       <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">         echo &quot;Running on default: $&#123;&#123; steps.branch-name.outputs.current_branch &#125;&#125;&quot;</span></span><br><span class="line"><span class="string"></span>       </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Download</span> <span class="string">APK</span> <span class="string">from</span> <span class="string">build</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/download-artifact@v1</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">name:</span> <span class="string">apk</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line">       <span class="attr">id:</span> <span class="string">create_release</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/create-release@v1</span></span><br><span class="line">       <span class="attr">env:</span></span><br><span class="line">         <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">tag_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.run_number</span> <span class="string">&#125;&#125;</span></span><br><span class="line">         <span class="attr">release_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.repository.name</span> <span class="string">&#125;&#125;</span>  <span class="string">$&#123;&#123;</span> <span class="string">steps.branch-name.outputs.current_branch</span> <span class="string">&#125;&#125;</span> <span class="string">v$&#123;&#123;</span> <span class="string">github.run_number</span> <span class="string">&#125;&#125;.$&#123;&#123;</span> <span class="string">github.run_attempt</span> <span class="string">&#125;&#125;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Release</span> <span class="string">APK</span></span><br><span class="line">       <span class="attr">id:</span> <span class="string">upload_release_asset</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/upload-release-asset@v1.0.1</span></span><br><span class="line">       <span class="attr">env:</span></span><br><span class="line">         <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">upload_url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">&#125;&#125;</span></span><br><span class="line">         <span class="attr">asset_path:</span> <span class="string">apk/app-debug.apk</span></span><br><span class="line">         <span class="attr">asset_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.repository.name</span> <span class="string">&#125;&#125;</span>  <span class="string">$&#123;&#123;</span> <span class="string">steps.branch-name.outputs.current_branch</span> <span class="string">&#125;&#125;</span> <span class="string">v$&#123;&#123;</span> <span class="string">github.run_number</span> <span class="string">&#125;&#125;.$&#123;&#123;</span> <span class="string">github.run_attempt</span> <span class="string">&#125;&#125;.apk</span></span><br><span class="line">         <span class="attr">asset_content_type:</span> <span class="string">application/zip</span></span><br></pre></td></tr></table></figure><ol start="3"><li>手动执行一次<code>Action</code> 依次点击 <code>Action</code> -&gt; <code>Build and Release</code> -&gt; <code>Update android.yml</code></li></ol><p><img src="http://p0.meituan.net/csc/e1dbb65ea6a7f7de21d6c9d0730d19d3205339.png" alt="image.png"></p><ol start="4"><li>如下图所示后，表明Action 已经帮我们完成了编译-发布这两个操作。</li></ol><p><img src="http://p1.meituan.net/csc/3fe33a7c8b4f494fbab499b98545674f324900.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Github-Action介绍&quot;&gt;&lt;a href=&quot;#Github-Action介绍&quot; class=&quot;headerlink&quot; title=&quot;Github Action介绍&quot;&gt;&lt;/a&gt;Github Action介绍&lt;/h2&gt;&lt;h3 id=&quot;一、Github-Acti</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora快捷键</title>
    <link href="https://icu007work.github.io/archives/5e339248.html"/>
    <id>https://icu007work.github.io/archives/5e339248.html</id>
    <published>2023-04-19T09:42:30.000Z</published>
    <updated>2023-08-23T07:56:26.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Typora-快捷键"><a href="#Typora-快捷键" class="headerlink" title="Typora 快捷键"></a>Typora 快捷键</h2><h3 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">新窗口（当前路径下）</td><td align="left">Ctrl + N</td><td>Command + N</td></tr><tr><td align="center">新窗口（默认路径下）</td><td align="left">Ctrl + Shift + N</td><td>Command +Shift + N</td></tr><tr><td align="center">新标签页</td><td align="left"><em>(不支持)</em></td><td>Command + T</td></tr><tr><td align="center">打开一个markdown文件</td><td align="left">Ctrl + O</td><td>Command + O</td></tr><tr><td align="center">快速打开markdown文件</td><td align="left">Ctrl + P</td><td>Command + Shift + O</td></tr><tr><td align="center">重新打开已关闭的文件</td><td align="left">Ctrl + Shift + T</td><td>Command + Shift + T</td></tr><tr><td align="center">保存</td><td align="left">Ctrl + S</td><td>Command + S</td></tr><tr><td align="center">另存为 &#x2F; 复制</td><td align="left">Ctrl + Shift + S</td><td>Command + Shift + S</td></tr><tr><td align="center">偏好设置</td><td align="left">Ctrl + ,</td><td>Command + ,</td></tr><tr><td align="center">关闭</td><td align="left">Ctrl + W</td><td>Command + W</td></tr></tbody></table><h3 id="2-编辑"><a href="#2-编辑" class="headerlink" title="2. 编辑"></a>2. 编辑</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">另起一段</td><td align="left">Enter</td><td>Enter</td></tr><tr><td align="center">另起一行</td><td align="left">Shift + Enter</td><td>Shift + Enter</td></tr><tr><td align="center">剪切</td><td align="left">Ctrl + X</td><td>Command + X</td></tr><tr><td align="center">复制</td><td align="left">Ctrl + C</td><td>Command + C</td></tr><tr><td align="center">粘贴</td><td align="left">Ctrl + V</td><td>Command + V</td></tr><tr><td align="center">赋值为Markdown格式</td><td align="left">Ctrl + Shift + C</td><td>Command + Shift + C</td></tr><tr><td align="center">粘贴为纯文本格式</td><td align="left">Ctrl + Shift + V</td><td>Command + Shift + V</td></tr><tr><td align="center">全选</td><td align="left">Ctrl + A</td><td>Command + A</td></tr><tr><td align="center">选择一行</td><td align="left">Ctrl + L</td><td>Command + L</td></tr><tr><td align="center">删除行 (在表格中)</td><td align="left">Ctrl + Shift + Backspace</td><td>Command + Shift + Backspace</td></tr><tr><td align="center">选中当前区域(在表格内)</td><td align="left">Ctrl + E</td><td>Command + E</td></tr><tr><td align="center">选中一个字符</td><td align="left">Ctrl + D</td><td>Command + D</td></tr><tr><td align="center">删除一个字符</td><td align="left">Ctrl + Shift + D</td><td>Command + Shift + D</td></tr><tr><td align="center">跳转到顶部</td><td align="left">Ctrl + Home</td><td>Command + ↑</td></tr><tr><td align="center">跳转到光标处</td><td align="left">Ctrl + J</td><td>Command + J</td></tr><tr><td align="center">跳转到底部</td><td align="left">Ctrl + End</td><td>Command + ↓</td></tr><tr><td align="center">查找</td><td align="left">Ctrl + F</td><td>Command + F</td></tr><tr><td align="center">查找下一个</td><td align="left">F3 &#x2F; Enter</td><td>Command + G &#x2F; Enter</td></tr><tr><td align="center">查找上一个</td><td align="left">Shift + F3 &#x2F; Shift + Enter</td><td>Command + Shift + G &#x2F; Shift + Enter</td></tr><tr><td align="center">替换</td><td align="left">Ctrl + H</td><td>Command + H</td></tr></tbody></table><h3 id="3-程序"><a href="#3-程序" class="headerlink" title="3. 程序"></a>3. 程序</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">1-6级标题</td><td align="left">Ctrl + 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td><td>Command + 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td></tr><tr><td align="center">正文</td><td align="left">Ctrl + 0</td><td>Command + 0</td></tr><tr><td align="center">增加标题等级</td><td align="left">Ctrl + &#x3D;</td><td>Command + &#x3D;</td></tr><tr><td align="center">降低标题等级</td><td align="left">Ctrl + -</td><td>Command + -</td></tr><tr><td align="center">新建表格</td><td align="left">Ctrl + T</td><td>Command + Option + T</td></tr><tr><td align="center">代码块</td><td align="left">Ctrl + Shift + K</td><td>Command + Option + C</td></tr><tr><td align="center">数学公式</td><td align="left">Ctrl + Shift + M</td><td>Command + Option + B</td></tr><tr><td align="center">引用</td><td align="left">Ctrl + Shift + Q</td><td>Command + Option + Q</td></tr><tr><td align="center">有序列表</td><td align="left">Ctrl + Shift + [</td><td>Command + Option + O</td></tr><tr><td align="center">无序列表</td><td align="left">Ctrl + Shift + ]</td><td>Command + Option + U</td></tr><tr><td align="center">向后缩进</td><td align="left">Ctrl + [ &#x2F; Tab</td><td>Command + [ &#x2F; Tab</td></tr><tr><td align="center">向前缩进</td><td align="left">Ctrl + ] &#x2F; Shift + Tab</td><td>Command + ] &#x2F; Shift + Tab</td></tr></tbody></table><h3 id="4-格式"><a href="#4-格式" class="headerlink" title="4. 格式"></a>4. 格式</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center"><strong>加粗</strong></td><td align="left">Ctrl + B</td><td>Command + B</td></tr><tr><td align="center"><em>斜体</em></td><td align="left">Command + I</td><td></td></tr><tr><td align="center"><u>下划线</u></td><td align="left">Ctrl + U</td><td>Command + U</td></tr><tr><td align="center"><code>代码</code></td><td align="left">Ctrl + Shift + &#96;</td><td>Command + Shift + &#96;</td></tr><tr><td align="center"><del>删除线</del></td><td align="left">Alt + Shift + 5</td><td>Control + Shift + &#96;</td></tr><tr><td align="center">超链接</td><td align="left">Ctrl + K</td><td>Command + K</td></tr><tr><td align="center">图像链接</td><td align="left">Ctrl + Shift + I</td><td>Command + Control + I</td></tr><tr><td align="center">清除格式</td><td align="left">Ctrl + \</td><td>Command + \</td></tr></tbody></table><h3 id="5-视图"><a href="#5-视图" class="headerlink" title="5. 视图"></a>5. 视图</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">开关侧边栏</td><td align="left">Ctrl + Shift + L</td><td>Command + Shift + L</td></tr><tr><td align="center">大纲视图</td><td align="left">Ctrl + Shift + 1</td><td>Command + Control + 1</td></tr><tr><td align="center">文章视图</td><td align="left">Ctrl + Shift + 2</td><td>Command + Control + 2</td></tr><tr><td align="center">文件树</td><td align="left">Ctrl + Shift + 3</td><td>Command + Control + 3</td></tr><tr><td align="center">源码模式</td><td align="left">Ctrl + &#x2F;</td><td>Command + &#x2F;</td></tr><tr><td align="center">专注模式</td><td align="left">F8</td><td>F8</td></tr><tr><td align="center">打字机模式</td><td align="left">F9</td><td>F9</td></tr><tr><td align="center">切换全屏</td><td align="left">F11</td><td>Command + Option + F</td></tr><tr><td align="center">实际大小</td><td align="left">Ctrl + Shift + 0</td><td><em>(Not Supported)</em></td></tr><tr><td align="center">放大</td><td align="left">Ctrl + Shift + &#x3D;</td><td><em>(Not Supported)</em></td></tr><tr><td align="center">缩小</td><td align="left">Ctrl + Shift + -</td><td><em>(Not Supported)</em></td></tr><tr><td align="center">在打开的文档间切换</td><td align="left">Ctrl + Tab</td><td>Command + &#96;</td></tr><tr><td align="center">切换开发工具</td><td align="left">Ctrl + Shift + I</td><td>-</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Typora-快捷键&quot;&gt;&lt;a href=&quot;#Typora-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Typora 快捷键&quot;&gt;&lt;/a&gt;Typora 快捷键&lt;/h2&gt;&lt;h3 id=&quot;1-文件&quot;&gt;&lt;a href=&quot;#1-文件&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>

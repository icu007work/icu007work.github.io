<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米奇妙妙屋</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="https://icu007work.github.io/atom.xml" rel="self"/>
  
  <link href="https://icu007work.github.io/"/>
  <updated>2024-05-11T06:42:30.606Z</updated>
  <id>https://icu007work.github.io/</id>
  
  <author>
    <name>Rookie_l</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin安卓开发入门</title>
    <link href="https://icu007work.github.io/archives/3ba91e1b.html"/>
    <id>https://icu007work.github.io/archives/3ba91e1b.html</id>
    <published>2024-10-11T03:37:21.000Z</published>
    <updated>2024-05-11T06:42:30.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ViewBinding"><a href="#一、ViewBinding" class="headerlink" title="一、ViewBinding"></a>一、ViewBinding</h2><h3 id="1-1-什么是ViewBinding"><a href="#1-1-什么是ViewBinding" class="headerlink" title="1.1 什么是ViewBinding"></a>1.1 什么是ViewBinding</h3><p><strong>ViewBinding</strong>总体来说其实非常简单，它的目的只有一个，就是为了避免编写<code>findViewById</code>，这和它另外一个非常复杂的兄弟<strong>DataBinding</strong>相比有明显的区别。</p><p>要想使用<strong>ViewBinding</strong>需要注意两件事。第一，确保你的<strong>Android Studio是3.6或更高</strong>的版本。第二，在你项目工程模块的<code>build.gradle</code>中加入以下配置：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-在Activity中使用ViewBinding"><a href="#1-2-在Activity中使用ViewBinding" class="headerlink" title="1.2 在Activity中使用ViewBinding"></a>1.2 在Activity中使用ViewBinding</h3><p>一旦启动了<strong>ViewBinding</strong>功能之后，Android Studio会自动为我们所编写的每一个布局文件都生成一个对应的<code>Binding</code>类.<code>Binding</code>类的命名规则是将布局文件按驼峰方式重命名后，再加上<code>Binding</code>作为结尾。比如说，前面我们定义了一个<code>activity_main.xml</code>布局，那么与它对应的<code>Binding</code>类就是<code>ActivityMainBinding</code>。当然，如果有些布局文件你不希望为它生成对应的<code>Binding</code>类，可以在该布局文件的根元素位置加入如下声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:viewBindingIgnore</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们看一下如何使用ViewBinding来实现在MainActivity中去设置TextView内容的功能，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ViewBinding</strong>的用法可以说就是这么简单。首先我们要调用<code>activity_main.xml</code>布局文件对应的<code>Binding</code>类，也就是<code>ActivityMainBinding</code>的<code>inflate()</code>函数去加载该布局，<code>inflate()</code>函数接收一个<code>LayoutInflater</code>参数，在<code>Activity</code>中是可以直接获取到的。</p><p>接下来就更加简单了，调用<code>Binding</code>类的<code>getRoot()</code>函数可以得到<code>activity_main.xml</code>中根元素的实例，调用<code>getTextView()</code>函数可以获得<code>id</code>为<code>textView</code>的元素实例。</p><p>那么很明显，我们应该把根元素的实例传入到<code>setContentView()</code>函数当中，这样<code>Activity</code>就可以成功显示<code>activity_main.xml</code>这个布局的内容了。然后获取<code>TextView</code>控件的实例，并给它设置要显示的文字即可。</p><p>当然，如果你需要在<code>onCreate()</code>函数之外的地方对控件进行操作，那么就得将<code>binding</code>变量声明成全局变量，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Kotlin声明的变量都必须在声明的同时对其进行初始化。而这里我们显然无法在声明全局binding变量的同时对它进行初始化，所以这里又使用了lateinit关键字对binding变量进行了延迟初始化。</p><h2 id="二、Intent"><a href="#二、Intent" class="headerlink" title="二、Intent"></a>二、Intent</h2><p><strong>Intent</strong>大致可以分为两种：<strong>显式Intent</strong>和隐式Intent。我们先来看一下<strong>显式Intent</strong>如何使用。<strong>Intent</strong>有多个构造函数的重载，其中一个是<code>Intent(Context packageContext, Class&lt;?&gt;cls)</code>。这个构造函数接收两个参数：第一个参数<code>Context</code>要求提供一个启动<code>Activity</code>的<strong>上下文</strong>；第二个参数<code>Class</code>用于<strong>指定想要启动的目标<code>Activity</code><strong>，通过</strong>这个构造函数就可以构建出<code>Intent</code>的“意图</strong>”。那么接下来我们应该怎么使用这个<code>Intent</code>呢？<code>Activity</code>类中提供了一个<code>startActivity()</code>方法，专门用于启动<code>Activity</code>，它接收一个<code>Intent</code>参数，<strong>这里我们将构建好的Intent传入startActivity()方法就可以启动目标Activity了。</strong></p><h3 id="2-1-显式Intent"><a href="#2-1-显式Intent" class="headerlink" title="2.1 显式Intent"></a>2.1 显式Intent</h3><p>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可用于启动Activity、启动Service以及发送广播等场景。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line"><span class="comment">//        val button1: Button = findViewById(R.id.button1)</span></span><br><span class="line">        binding.button1.text = <span class="string">&quot;显式INTENT&quot;</span></span><br><span class="line">        binding.button1.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;hello , u clicked button1: <span class="subst">$&#123;binding.button1.text&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们首先构建了一个<strong>Intent</strong>对象，第一个参数传入<code>this</code>也就是<code>FirstActivity</code>作为上下文，第二个参数传入<code>SecondActivity::class.java</code>作为目标<code>Activity</code>，这样我们的“意图”就非常明显了，即在<code>FirstActivity</code>的基础上打开<code>SecondActivity</code>。注意，<strong>Kotlin</strong>中<code>SecondActivity::class.java</code>的写法就相当于<strong>Java</strong>中<code>SecondActivity.class</code>的写法。接下来再通过<code>startActivity()</code>方法执行这个<strong>Intent</strong>就可以了。</p><h3 id="2-2-隐式Intent"><a href="#2-2-隐式Intent" class="headerlink" title="2.2 隐式Intent"></a>2.2 隐式Intent</h3><p>相比于显式<strong>Intent</strong>，隐式<strong>Intent</strong>则含蓄了许多，它并不明确指出想要启动哪一个<code>Activity</code>，而是指定了一系列更为抽象的<code>action</code>和<code>category</code>等信息，然后交由系统去分析这个<strong>Intent</strong>，并帮我们找出合适的<code>Activity</code>去启动。</p><p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前<code>Activity</code>能够响应的<code>action</code>和<code>category</code>，打开<code>AndroidManifest.xml</code>，添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.icu007.activitytest.ACTION_START&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;com.icu007.activitytest.MY_CATEGORY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;action&gt;</code>标签中我们指明了当前<code>Activity</code>可以响应<code>com.example.activitytest.ACTION_START</code>这个<code>action</code>，而<code>&lt;category&gt;</code>标签则包含了一些附加信息，更精确地指明了当前<code>Activity</code>能够响应的<code>Intent</code>中还可能带有的<code>category</code>。只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>中的内容同时匹配<code>Intent</code>中指定的<code>action</code>和<code>category</code>时，这个<code>Activity</code>才能响应该<code>Intent</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.button2.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.icu007.activitytest.ACTION_START&quot;</span>)</span><br><span class="line">    intent.addCategory(<span class="string">&quot;com.icu007.activitytest.MY_CATEGORY&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-更多隐式Intent的用法"><a href="#2-2-1-更多隐式Intent的用法" class="headerlink" title="2.2.1 更多隐式Intent的用法"></a>2.2.1 更多隐式Intent的用法</h4><p>使用隐式<strong>Intent</strong>，不仅可以启动自己程序内的<code>Activity</code>，还可以启动其他程序的<code>Activity</code>，这就使多个应用程序之间的功能共享成为了可能。比如你的应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器（事实上也不太可能），只需要调用系统的浏览器来打开这个网页就行了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.button2.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_VIEW)</span><br><span class="line">    intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;http://icu007.work&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先指定了<strong>Intent</strong>的<code>action</code>是<code>Intent.ACTION_VIEW</code>，这是一个<code>Android</code>系统内置的动作，其常量值为<code>android.intent.action.VIEW</code>。然后通过<code>Uri.parse()</code>方法将一个网址字符串解析成一个<code>Uri</code>对象，再调用<strong>Intent</strong>的<code>setData()</code>方法将这个Uri对象传递进去。当然，这里再次使用了前面学习的语法糖，看上去像是给<strong>Intent</strong>的<code>data</code>属性赋值一样。</p><p>我们还可以在<code>&lt;intent-filter&gt;</code>标签中再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前<code>Activity</code>能够响应的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容。</p><ul><li><code>android:scheme</code>：用于指定数据的协议部分，如上例中的https部分；</li><li><code>android:host</code>：用于指定数据的主机名部分，如上例中的<a href="http://www.baidu.com部分;/">www.baidu.com部分；</a></li><li><code>android:port</code>：用于指定数据的端口部分，一般紧随在主机名之后；</li><li><code>android:path</code>：用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容；</li><li><code>android:mimeType</code>：用于指定可以处理的数据类型，允许使用通配符的方式进行指定。</li></ul><p>只有当<code>&lt;data&gt;</code>标签中指定的内容和<strong>Intent</strong>中携带的<code>Data</code>完全一致时，当前<code>Activity</code>才能够响应该<strong>Intent</strong>。不过，在<code>&lt;data&gt;</code>标签中一般不会指定过多的内容。例如在上面的浏览器示例中，其实只需要指定<code>android:scheme</code>为<strong>https</strong>，就可以响应所有<strong>https</strong>协议的<strong>Intent</strong>了。</p><p>除了<strong>https</strong>协议外，我们还可以指定很多其他协议，比如<strong>geo</strong>表示显示地理位置、<strong>tel</strong>表示拨打电话。下面的代码展示了如何在我们的程序中调用系统拨号界面。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.button2.setOnClickListener &#123;</span><br><span class="line">     <span class="keyword">val</span> intent1 = Intent(Intent.ACTION_DIAL)</span><br><span class="line">     intent1.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;tel:10086&quot;</span>)</span><br><span class="line">     startActivity(intent1)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-向下一个Activity传递数据"><a href="#2-3-向下一个Activity传递数据" class="headerlink" title="2.3 向下一个Activity传递数据"></a>2.3 向下一个Activity传递数据</h3><p>到目前为止，我们只是简单地使用<strong>Intent</strong>来启动一个<code>Activity</code>，其实<strong>Intent</strong>在启动<code>Activity</code>的时候还可以传递数据。</p><p>在启动<code>Activity</code>时传递数据的思路很简单，<strong>Intent</strong>中提供了一系列<code>putExtra()</code>方法的重载，可以把我们想要传递的数据暂存在<strong>Intent</strong>中，在启动另一个<code>Activity</code>后，只需要把这些数据从<strong>Intent</strong>中取出就可以了。比如说<code>FirstActivity</code>中有一个字符串，现在想把这个字符串传递到<code>SecondActivity</code>中，你就可以这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">binding.button1.setOnClickListener&#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">&quot;hello SecondActivity&quot;</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;extra_data&quot;</span>,<span class="keyword">data</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还是使用显式<strong>Intent</strong>的方式来启动<code>SecondActivity</code>，并通过<code>putExtra()</code>方法传递了一个字符串。注意，这里<code>putExtra()</code>方法接收两个参数，第一个参数是键，用于之后从<strong>Intent</strong>中取值，第二个参数才是真正要传递的数据。然后在<code>SecondActivity</code>中将传递的数据取出，并打印出来，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> bindings = ActivitySecondBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(bindings.root)</span><br><span class="line">        <span class="keyword">val</span> extraData = intent.getStringExtra(<span class="string">&quot;extra_data&quot;</span>)</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, extraData, Toast.LENGTH_SHORT).show()</span><br><span class="line">        bindings.button2.text = <span class="string">&quot;前往FirstActivity&quot;</span></span><br><span class="line">        bindings.button2.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, FirstActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的<strong>intent</strong>实际上调用的是父类的<code>getIntent()</code>方法，该方法会获取用于启动<code>SecondActivity</code>的<strong>Intent</strong>，然后调用<code>getStringExtra()</code>方法并传入相应的键值，就可以得到传递的数据了。这里由于我们传递的是字符串，所以使用<code>getStringExtra()</code>方法来获取传递的数据。如果传递的是整型数据，则使用<code>getIntExtra()</code>方法；如果传递的是布尔型数据，则使用<code>getBooleanExtra()</code>方法，以此类推。</p><h3 id="2-4-返回数据给上一个Activity"><a href="#2-4-返回数据给上一个Activity" class="headerlink" title="2.4 返回数据给上一个Activity"></a>2.4 返回数据给上一个Activity</h3><p>既然可以传递数据给下一个<code>Activity</code>，那么能不能够返回数据给上一个<code>Activity</code>呢？答案是肯定的。不过不同的是，返回上一个<code>Activity</code>只需要按一下<strong>Back</strong>键就可以了，并没有一个用于启动<code>Activity</code>的<strong>Intent</strong>来传递数据，这该怎么办呢？其实<code>Activity</code>类中还有一个用于启动<code>Activity</code>的<code>startActivityForResult()</code>方法，但它期望在<code>Activity</code>销毁的时候能够返回一个结果给上一个<code>Activity</code>。毫无疑问，这就是我们所需要的。</p><p><code>startActivityForResult()</code>方法接收两个参数：第一个参数还是<strong>Intent</strong>；第二个参数是<strong>请求码</strong>，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改<code>FirstActivity</code>中按钮的点击事件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE = <span class="number">1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    binding.button3.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">when</span> (requestCode)&#123;</span><br><span class="line">        REQUEST_CODE -&gt;&#123;</span><br><span class="line">            <span class="keyword">val</span> code = requestCode</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = <span class="keyword">data</span>?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;code: <span class="variable">$code</span>, data: <span class="variable">$data</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onActivityResult: code: <span class="variable">$code</span>, data: <span class="variable">$data</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了<code>startActivityForResult()</code>方法来启动<code>SecondActivity</code>，请求码只要是一个唯一值即可，这里传入了<code>1024</code>。接下来我们在<code>SecondActivity</code>中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bindings.button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent()</span><br><span class="line">    intent.putExtra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>)</span><br><span class="line">    setResult(<span class="number">1024</span>, intent)</span><br><span class="line">    finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方式在在&#96;&#96;androidx.activity-1.2.0-alpha04<code>时开始就已经被弃用了.Android中这位被调用过无数次的</code>startActivityForResult<code>和</code>onActivityResult<code>，已经被官方标记为弃用了，继而推出了名为</code>Activity Result API&#96;的组件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG: String? = <span class="string">&quot;FirstActivity&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> resultLauncher: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> launcherCallback = ActivityResultCallback&lt;ActivityResult&gt; &#123; result -&gt;</span><br><span class="line">        <span class="keyword">val</span> code = result.resultCode</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = result.<span class="keyword">data</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;code: <span class="variable">$code</span>, data: <span class="subst">$&#123;data?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE = <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        resultLauncher = registerForActivityResult(</span><br><span class="line">            ActivityResultContracts.StartActivityForResult(),</span><br><span class="line">            launcherCallback</span><br><span class="line">        )</span><br><span class="line">        binding.button3.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="comment">//            startActivityForResult(intent, REQUEST_CODE)</span></span><br><span class="line">            resultLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实分为三个部分：对载体、定义协定、回调3个类分别定义写出来。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> resultLauncher: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> launcherCallback = ActivityResultCallback&lt;ActivityResult&gt; &#123; result -&gt;</span><br><span class="line">    <span class="keyword">val</span> code = result.resultCode</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = result.<span class="keyword">data</span></span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;code: <span class="variable">$code</span>, data: <span class="subst">$&#123;data?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)&#125;</span>&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> binding = FirstLayoutBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    resultLauncher = registerForActivityResult(</span><br><span class="line">        ActivityResultContracts.StartActivityForResult(),</span><br><span class="line">        launcherCallback</span><br><span class="line">    )</span><br><span class="line">    resultLauncher.launch(Intent(<span class="keyword">this</span>,SecondActivity::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实大部分情况下，我们可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> launcherActivity = registerForActivityResult(</span><br><span class="line">    ActivityResultContracts.StartActivityForResult()) &#123;</span><br><span class="line">    <span class="keyword">val</span> code = it.resultCode</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = it.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    launcherActivity.launch(Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是瞬间清爽了许多，但是…你还是觉得比使用<code>startActivityForResult</code>更复杂？其实不然，因为上面代码的需求是一个单一的回调，所以看着似乎<code>startActivityForResult</code>更便于维护和使用。但倘若编写一个稍复杂的页面，需要同时请求相册、需要在其它<strong>Activity</strong>选择数据并回调、需要判断权限等等时，继续使用<code>startActivityForResult</code>，会导致<code>onActivityResult</code>里掺杂各种嵌套及判断，导致代码难以维护。而使用<code>registerForActivityResult()</code>可以多次调用以注册多个 <code>ActivityResultLauncher</code> 实例，用来处理不同的<strong>Activity</strong>结果，让代码更便于维护。</p><p>优势了解到了，但既然需要使用新的功能，那么我们就必须要先了解以下，刚说到的<code>ActivityResultLauncher</code>、<code>ActivityResultContract</code>、<code>ActivityResultCallback</code>到底是些什么东西</p><ul><li><strong>ActivityResultLauncher</strong> 从字面意思其实就能很好理解，可以理解它就是一个Activity的启动器，它的作用就是承载启动对象与返回对象，通过<code>registerForActivityResult</code>返回该对象，这时并不会立即启动另一个Activity。</li><li><strong>ActivityResultContract</strong> 是用来协定所需的输入类型以及结果的输出类型，Android默认提供了一些常用的定义，例如上面所使用到到<code>ActivityResultContracts.StartActivityForResult()</code>。当然这里你也可以通过继承<code>ActivityResultContract</code>实现自己的定义。</li><li><strong>ActivityResultCallback</strong> 通过名字就可以了解到这是启动Activity并返回到当前Activity时的结果回调。</li></ul><p>对于这3个类，其实只需重点了解<code>ActivityResultContract</code>，就能很轻松的理解并使用好<code>Activity Result API</code>了。</p><blockquote><p>官方文档的警告</p><p><strong>注意</strong>：虽然在 fragment 或 activity 创建完毕之前可安全地调用 <code>registerForActivityResult()</code>，但在 fragment 或 activity 的 <code>Lifecycle</code> 变为 <code>CREATED</code> 状态之前，您无法启动 <code>ActivityResultLauncher</code>。</p></blockquote><h2 id="三、Activity的生命周期"><a href="#三、Activity的生命周期" class="headerlink" title="三、Activity的生命周期"></a>三、Activity的生命周期</h2><p>掌握<strong>Activity</strong>的生命周期对任何<strong>Android</strong>开发者来说都非常重要，当你深入理解<strong>Activity</strong>的生命周期之后，就可以写出更加连贯流畅的程序，并在如何合理管理应用资源方面发挥得游刃有余。你的应用程序也将会拥有更好的用户体验。</p><h3 id="3-1-返回栈"><a href="#3-1-返回栈" class="headerlink" title="3.1 返回栈"></a>3.1 返回栈</h3><p>经过前面几节的学习，相信你已经发现了<strong>Android</strong>中的<strong>Activity</strong>是可以层叠的。我们每启动一个新的<strong>Activity</strong>，就会覆盖在原<strong>Activity</strong>之上，然后点击<strong>Back</strong>键会销毁最上面的<strong>Activity</strong>，下面的一个<strong>Activity</strong>就会重新显示出来。</p><p>其实<strong>Android</strong>是使用任务（<strong>task</strong>）来管理<strong>Activity</strong>的，一个任务就是一组存放在栈里的<strong>Activity</strong>的集合，这个栈也被称作返回栈（<strong>back stack</strong>）。栈是一种<strong>后进先出</strong>的数据结构，<strong>在默认情况下，每当我们启动了一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置</strong>。而每当我们按下<strong>Back</strong>键或调用<code>finish()</code>方法去销毁一个<strong>Activity</strong>时，处于栈顶的<strong>Activity</strong>就会出栈，前一个入栈的<strong>Activity</strong>就会重新处于栈顶的位置。系统总是会显示处于栈顶的<strong>Activity</strong>给用户。</p><p><img src="https://pic.ziyuan.wang/2023/09/22/guest_8e608b6d30eef_IP210.22.23.7_UPTIME1695350133.png" alt="返回栈管理Activity入栈出栈操作"></p><h3 id="3-2-Activity状态"><a href="#3-2-Activity状态" class="headerlink" title="3.2 Activity状态"></a>3.2 Activity状态</h3><p>每个<strong>Activity</strong>在其生命周期中最多可能会有4种状态。</p><h4 id="3-2-1-运行状态"><a href="#3-2-1-运行状态" class="headerlink" title="3.2.1 运行状态"></a>3.2.1 运行状态</h4><p>当一个<strong>Activity</strong>位于返回栈的栈顶时，<strong>Activity</strong>就处于运行状态。系统最不愿意回收的就是处于运行状态的<strong>Activity</strong>，因为这会带来非常差的用户体验。</p><h4 id="3-2-2-暂停状态"><a href="#3-2-2-暂停状态" class="headerlink" title="3.2.2 暂停状态"></a>3.2.2 暂停状态</h4><p>当一个<strong>Activity不再处于栈顶位置，但仍然可见时</strong>，<strong>Activity</strong>就进入了<strong>暂停</strong>状态。你可能会觉得，既然Activity已经不在栈顶了，怎么会可见呢？这是因为并不是每一个Activity都会占满整个屏幕，比如对话框形式的Activity只会占用屏幕中间的部分区域。处于暂停状态的Activity仍然是完全存活着的，系统也不愿意回收这种Activity（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种Activity。</p><h4 id="3-2-3-停止状态"><a href="#3-2-3-停止状态" class="headerlink" title="3.2.3 停止状态"></a>3.2.3 停止状态</h4><p><strong>当一个Activity不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。</strong>系统仍然会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的Activity有可能会被系统回收。</p><h4 id="3-2-4-销毁状态"><a href="#3-2-4-销毁状态" class="headerlink" title="3.2.4 销毁状态"></a>3.2.4 销毁状态</h4><p><strong>一个Activity从返回栈中移除后就变成了销毁状态</strong>。<strong>系统最倾向于回收处于这种状态的Activity</strong>，以保证手机的内存充足。</p><h3 id="3-3-Activity的生存期"><a href="#3-3-Activity的生存期" class="headerlink" title="3.3 Activity的生存期"></a>3.3 Activity的生存期</h3><p>Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节，下面就来一一介绍这7个方法。</p><ul><li><code>onCreate()</code>:这个方法你已经看到过很多次了，我们在每个Activity中都重写了这个方法，它会在Activity第一次被创建的时候调用。你应该在这个方法中完成Activity的初始化操作，比如加载布局、绑定事件等。</li><li><code>onStart()</code>:这个方法在Activity由不可见变为可见的时候调用。</li><li><code>onResume()</code>:这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一定位于返回栈的栈顶，并且处于运行状态。</li><li><code>onPause()</code>:这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶Activity的使用。</li><li><code>onStop()</code>:这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。</li><li><code>onDestroy()</code>:这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</li><li><code>onRestart()</code>:这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</li></ul><p>以上7个方法中除了<code>onRestart()</code>方法，其他都是两两相对的，从而又可以将<strong>Activity</strong>分为以下3种生存期。</p><ul><li><strong>完整生存期</strong>：Activity在<code>onCreate()</code>方法和<code>onDestroy()</code>方法之间所经历的就是完整生存期。一般情况下，一个Activity会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。</li><li><strong>可见生存期</strong>：Activity在<code>onStart()</code>方法和<code>onStop()</code>方法之间所经历的就是可见生存期。在可见生存期内，Activity对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法合理地管理那些对用户可见的资源。比如在<code>onStart()</code>方法中对资源进行加载，而在<code>onStop()</code>方法中对资源进行释放，从而保证处于停止状态的Activity不会占用过多内存。</li><li><strong>前台生存期</strong>：Activity在<code>onResume()</code>方法和<code>onPause()</code>方法之间所经历的就是前台生存期。在前台生存期内，Activity总是处于运行状态，此时的Activity是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的Activity。</li></ul><p>为了帮助我们理解，Android官方提供了一张Activity生命周期的示意图，如图所示：</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_4aec46f2fe334_IP210.22.23.7_UPTIME1695438124.png" alt="1695438122586.png"></p><h3 id="3-4-体验Activity的生命周期"><a href="#3-4-体验Activity的生命周期" class="headerlink" title="3.4 体验Activity的生命周期"></a>3.4 体验Activity的生命周期</h3><p>如果我们重写Activity中的：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>、<code>onDestroy()</code>和<code>onRestart()</code>方法并打印log，我们就可以发现：Activity在第一次被创建时会依次执行<code>onCreate()</code>、<code>onStart()</code>和onResume()方法。如下所示：</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_7a524a4f102bd_IP210.22.23.7_UPTIME1695459211.png" alt="1695459210334.png"></p><p>Activity启动后 我们按下Home键：由于MainAtivity已经不再可见，因此<code>onPause()</code>和<code>onStop()</code>方法都会得到执行。</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_950a90c3af688_IP210.22.23.7_UPTIME1695459060.png" alt="1695459058606.png"></p><p>接下来我们再次进入应用，由于之前MainActivity已经进入了停止状态，所以<code>onRestart()</code>方法会得到执行，之后会依次执行<code>onStart()</code>和<code>onResume()</code>方法。注意，<strong>此时<code>onCreate()</code>方法不会执行，因为MainActivity并没有重新创建。</strong></p><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20230923165303676.png" alt="image-20230923165303676"></p><p>假如我们在MainActivity当中启动了一个Dialog，此时我们再去观察打印信息就会发现：</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_908b26616516a_IP210.22.23.7_UPTIME1695459420.png" alt="1695459418512.png"></p><p>只有<code>onPause()</code>方法得到了执行，<code>onStop()</code>方法并没有执行，这是因为DialogActivity并没有完全遮挡住MainActivity，<strong>此时MainActivity只是进入了暂停状态，并没有进入停止状态</strong>。相应地，按下Back键返回MainActivity也应该只有<code>onResume()</code>方法会得到执行</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_1752fd92f9fa7_IP210.22.23.7_UPTIME1695459808.png" alt="1695459806957.png"></p><p>当调用了 <code>finish()</code>方法结束Activity时，依次会执行<code>onPause()</code>、<code>onStop()</code>和<code>onDestroy()</code>方法，最终销毁MainActivity。</p><p><img src="https://pic.ziyuan.wang/2023/09/23/guest_46ea5f1413bda_IP210.22.23.7_UPTIME1695459615.png" alt="1695459613638.png"></p><h3 id="3-5-Activity被回收了怎么办"><a href="#3-5-Activity被回收了怎么办" class="headerlink" title="3.5 Activity被回收了怎么办"></a>3.5 Activity被回收了怎么办</h3><p>前面我们说过，当一个Activity进入了停止状态，是有可能被系统回收的。那么想象以下场景：应用中有一个Activity A，用户在Activity A的基础上启动了Activity B，Activity A就进入了停止状态，这个时候由于系统内存不足，将Activity A回收掉了，然后用户按下Back键返回Activity A，会出现什么情况呢？其实还是会正常显示Activity A的，只不过这时并不会执行onRestart()方法，而是会执行Activity A的onCreate()方法，因为Activity A在这种情况下会被重新创建一次。</p><p>这样看上去好像一切正常，可是别忽略了一个重要问题：Activity A中是可能存在临时数据和状态的。打个比方，MainActivity中如果有一个文本输入框，现在你输入了一段文字，然后启动NormalActivity，这时MainActivity由于系统内存不足被回收掉，过了一会你又点击了Back键回到MainActivity，你会发现刚刚输入的文字都没了，因为MainActivity被重新创建了。</p><p>如果我们的应用出现了这种情况，是会比较影响用户体验的，所以得想想办法解决这个问题。其实，Activity中还提供了一个<code>onSaveInstanceState()</code>回调方法，这个方法可以保证在Activity被回收之前一定会被调用，因此我们可以通过这个方法来解决问题。</p><p><code>onSaveInstanceState()</code>方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle中取值，第二个参数是真正要保存的内容。</p><p>在MainActivity当中添加如下代码就可以将临时数据进行保存了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line">       <span class="keyword">val</span> tempData = <span class="string">&quot;Something u just typed&quot;</span></span><br><span class="line">       outState.putString(<span class="string">&quot;data_key&quot;</span>, tempData)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一直使用的onCreate()方法其实也有一个Bundle类型的参数。这个参数在一般情况下都是null，但是如果在Activity被系统回收之前，你通过onSaveInstanceState()方法保存数据，这个参数就会带有之前保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。</p><p>修改MainActivity方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    Log.d(tag, <span class="string">&quot;onCreate: Activity第一次被创建的时候调用&quot;</span>)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    <span class="keyword">if</span>(savedInstanceState != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> tempData = savedInstanceState.getString(<span class="string">&quot;data_key&quot;</span>,<span class="literal">null</span>)</span><br><span class="line">        Log.d(tag, <span class="string">&quot;onCreate: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出值之后再做相应的恢复操作就可以了，比如将文本内容重新赋值到文本输入框上.</p><p>不知道你有没有察觉，使用Bundle保存和取出数据是不是有些似曾相识呢？没错！我们在使用Intent传递数据时也用的类似的方法。这里提醒一点，Intent还可以结合Bundle一起用于传递数据。首先我们可以把需要传递的数据都保存在Bundle对象中，然后再将Bundle对象存放在Intent里。到了目标Activity之后，先从Intent中取出Bundle，再从Bundle中一一取出数据。</p><hr><h2 id="四、Activity的启动模式"><a href="#四、Activity的启动模式" class="headerlink" title="四、Activity的启动模式"></a>四、Activity的启动模式</h2><p>在实际项目中我们应该根据特定的需求为每个<strong>Activity</strong>指定恰当的启动模式。启动模式一共有4种，分别是<code>standard</code>、<code>singleTop</code>、<code>singleTask</code>和<code>singleInstance</code>，可以在<strong>AndroidManifest.xml</strong>中通过给**<code>&lt;activity&gt;</code>**标签指定<code>android:launchMode</code>属性来选择启动模式。</p><h3 id="4-1-standard"><a href="#4-1-standard" class="headerlink" title="4.1 standard"></a>4.1 standard</h3><p>standard是Activity默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用这种启动模式。Android是使用返回栈来管理Activity的，<strong>在standard模式下，每当启动一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置。</strong>对于使用standard模式的Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建一个该Activity的新实例。</p><p>standard模式的原理：</p><p><img src="https://pic.ziyuan.wang/2023/09/25/guest_6d3de3b7b8990_IP210.22.23.7_UPTIME1695630789.png" alt="1695630787163.png"></p><h3 id="4-2-singleTop"><a href="#4-2-singleTop" class="headerlink" title="4.2 singleTop"></a>4.2 singleTop</h3><p>可能在有些情况下，<strong>standard</strong>模式不太合理。Activity明明已经在栈顶了，为什么再次启动的时候还要创建一个新的Activity实例呢？</p><p>别着急，这只是系统默认的一种启动模式而已，你完全可以根据自己的需要进行修改，比如使用<strong>singleTop模式</strong>。当Activity的启动模式指定为singleTop，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。</p><p>在 <strong>AndroidManifest.xml</strong>中可以如下设置：<code>android:launchMode=&quot;singleTop&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.ziyuan.wang/2023/09/26/guest_1dc0c06bc5b27_IP210.22.23.7_UPTIME1695716282.png" alt="1695716279930.png"></p><p>有这么一种情况：从 <strong>FirstActivity</strong>启动 <strong>SecondActivity</strong> 再从 <strong>SecondActivity</strong>启动 <strong>FirstActivity</strong>。</p><p>此时系统就创建了两个不同的FirstActivity实例，这是由于在SecondActivity中再次启动FirstActivity时，栈顶Activity已经变成了SecondActivity，因此会创建一个新的FirstActivity实例。</p><h3 id="4-3-singleTask"><a href="#4-3-singleTask" class="headerlink" title="4.3 singleTask"></a>4.3 singleTask</h3><p><strong>使用singleTop模式可以很好地解决重复创建栈顶Activity的问题</strong>，如果该Activity并没有处于栈顶的位置，还是可能会创建多个Activity实例的。那么有没有什么办法可以让某个Activity在整个应用程序的上下文中只存在一个实例呢？这就要借助singleTask模式来实现了。<strong>当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。</strong></p><p>通过代码更直观的感受一下</p><p>首先从 <strong>FirstActivity</strong>启动 <strong>SecondActivity</strong> 再从 <strong>SecondActivity</strong>启动 <strong>FirstActivity</strong>。在相应的生存周期加上日志打印：</p><p><img src="https://pic.ziyuan.wang/2023/10/07/guest_a37c3b91912f5_IP38.207.142.167_UPTIME1696648431.png" alt="1696648430077.png"></p><p>其实从打印信息中就可以明显看出，在<strong>SecondActivity</strong>中启动<strong>FirstActivity</strong>时，会发现返回栈中已经存在一个<strong>FirstActivity</strong>的实例，并且是在<strong>SecondActivity</strong>的下面，于是<strong>SecondActivity</strong>会从返回栈中出栈，而<strong>FirstActivity重新成为了栈顶Activity，因此FirstActivity的<code>onRestart()</code>方法和SecondActivity的<code>onDestroy()</code>方法会得到执行</strong>。现在返回栈中只剩下一个FirstActivity的实例了，按一下Back键就可以退出程序。</p><p>SingleTask 模式原理</p><p><img src="https://pic.ziyuan.wang/2023/10/07/guest_430ee7fa2a0dc_IP38.207.142.167_UPTIME1696649401.png" alt="1696649398154.png"></p><h3 id="4-3-singleInstance"><a href="#4-3-singleInstance" class="headerlink" title="4.3 singleInstance"></a>4.3 singleInstance</h3><p><strong>singleInstance</strong>模式应该算是4种启动模式中最特殊也最复杂的一个了。不同于以上3种启动模式，<strong>指定为singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</strong>那么这样做有什么意义呢？想象以下场景，假设我们的程序中有一个<strong>Activity</strong>是允许其他程序调用的，如果想实现其他程序和我们的程序可以共享这个<strong>Activity</strong>的实例，应该如何实现呢？使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个<strong>Activity</strong>在不同的返回栈中入栈时必然创建了新的实例。而使用<strong>singleInstance</strong>模式就可以解决这个问题，在这种模式下，会有一个单独的返回栈来管理这个<strong>Activity</strong>，不管是哪个应用程序来访问这个<strong>Activity</strong>，都共用同一个返回栈，也就解决了共享<strong>Activity</strong>实例的问题。</p><p>为了更好理解这种启动模式，接下来实践一下：在<code>AndroidManifest.xml</code>中修改启动模式为 <strong>singleInstance</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后从 <strong>MainActivity</strong>启动 <strong>NormalActivity</strong>,再从<strong>NormalActivity</strong>启动<strong>ThirdActivity</strong>。并在这几个<strong>Activity</strong>中分别打印出<strong>TaskID</strong>。</p><p><strong>通过打印我们可以发现 MainActivity是单独在一个返回栈的，NormalActivity和ThirdActivity在另外一个返回栈。</strong></p><p><img src="https://pic.ziyuan.wang/2023/10/08/guest_5704819fa6887_IP210.22.23.7_UPTIME1696732588.png" alt="1696732586522.png"></p><p><strong>singleInstance</strong>模式的原理如图所示</p><p><img src="https://pic.ziyuan.wang/2023/10/08/guest_aaeb91b4fdf1e_IP210.22.23.7_UPTIME1696734778.png" alt="1696734776879.png"></p><hr><h2 id="五、Activity的最佳实践"><a href="#五、Activity的最佳实践" class="headerlink" title="五、Activity的最佳实践"></a>五、Activity的最佳实践</h2><h3 id="5-1-知晓当前是在哪一个Activity"><a href="#5-1-知晓当前是在哪一个Activity" class="headerlink" title="5.1 知晓当前是在哪一个Activity"></a>5.1 知晓当前是在哪一个Activity</h3><p>我们还是在ActivityTest项目的基础上修改，首先需要新建一个BaseActivity类。右击com.example.activitytest包→New→Kotlin File&#x2F;Class，在弹出的窗口中输入BaseActivity，创建类型选择Class。让BaseActivity继承自AppCompatActivity，并重写onCreate()方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR BaseActivity&quot;</span>, javaClass.simpleName)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在onCreate()方法中加了一行日志，用于打印当前实例的类名。这里我要额外说明一下，Kotlin中的javaClass表示获取当前实例的Class对象，相当于在Java中调用getClass()方法；而Kotlin中的BaseActivity::class.java表示获取BaseActivity类的Class对象，相当于在Java中调用BaseActivity.class。在上述代码中，我们先是获取了当前实例的Class对象，然后再调用simpleName获取当前实例的类名。</p><p>下来我们需要让BaseActivity成为ActivityTest项目中所有Activity的父类，为了使BaseActivity可以被继承，我已经提前在类名的前面加上了open关键字。然后修改FirstActivity、SecondActivity和ThirdActivity的继承结构，让它们不再继承自AppCompatActivity，而是继承自BaseActivity。而由于BaseActivity又是继承自AppCompatActivity的，所以项目中所有Activity的现有功能并不受影响，它们仍然继承了Activity中的所有特性。</p><p>通过日志可以看到，启动的Activity都被打印出来了。现在每当我们进入一个Activity的界面，该Activity的类名就会被打印出来，这样我们就可以时刻知晓当前界面对应的是哪一个Activity了。</p><p><img src="https://pic.ziyuan.wang/2023/10/08/guest_35b81189e5066_IP210.22.23.7_UPTIME1696756272.png" alt="1696756270348.png"></p><h3 id="5-2-随时随地退出程序"><a href="#5-2-随时随地退出程序" class="headerlink" title="5.2 随时随地退出程序"></a>5.2 随时随地退出程序</h3><p>如果手机的界面停留在ThirdActivity，我们会发现当前想退出程序是非常不方便的，需要连按3次Back键才行。按Home键只是把程序挂起，并没有退出程序。如果我们的程序需要注销或者退出的功能该怎么办呢？看来要有一个随时随地都能退出程序的方案才行。</p><p>其实解决思路也很简单，只需要用一个专门的集合对所有的Activity进行管理就可以了。下面我们就来实现一下。</p><p>新建一个单例类ActivityCollector作为Activity的集合，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> work.icu007.activitylifecycletest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Charlie_Liao</span></span><br><span class="line"><span class="comment"> * Time: 2023/10/11-11:09</span></span><br><span class="line"><span class="comment"> * E-mail: rookie_l@icu007.work</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activites = ArrayList&lt;Activity&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR ActivityCollector&quot;</span>, <span class="string">&quot;addActivity: <span class="subst">$&#123;activity.componentName&#125;</span> add&quot;</span>)</span><br><span class="line">        activites.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR ActivityCollector&quot;</span>, <span class="string">&quot;removeActivity: <span class="subst">$&#123;activity.componentName&#125;</span> remove&quot;</span>)</span><br><span class="line">        activites.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activites)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing)&#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activites.clear()</span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid())</span><br><span class="line">        Log.d(<span class="string">&quot;LCR ActivityCollector&quot;</span>, <span class="string">&quot;finishAll: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了单例类，是因为全局只需要一个Activity集合。在集合中，我们通过一个ArrayList来暂存Activity，然后提供了一个addActivity()方法，用于向ArrayList中添加Activity；提供了一个removeActivity()方法，用于从ArrayList中移除Activity；最后提供了一个finishAll()方法，用于将ArrayList中存储的Activity全部销毁。注意在销毁Activity之前，我们需要先调用activity.isFinishing来判断Activity是否正在销毁中，因为Activity还可能通过按下Back键等方式被销毁，如果该Activity没有正在销毁中，我们再去调用它的finish()方法来销毁它。</p><p>接下来修改 BaseActivity中的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LCR BaseActivity&quot;</span>, javaClass.simpleName)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">//        Log.d(&quot;LCR BaseActivity&quot;, &quot;onCreate: $&#123;javaClass.simpleName&#125; added&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">//        Log.d(&quot;LCR BaseActivity&quot;, &quot;onDestroy: $&#123;javaClass.simpleName&#125; removed&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BaseActivity的onCreate()方法中调用了ActivityCollector的addActivity()方法，表明将当前正在创建的Activity添加到集合里。然后在BaseActivity中重写onDestroy()方法，并调用了ActivityCollector的removeActivity()方法，表明从集合里移除一个马上要销毁的Activity。</p><p>从此以后，不管你想在什么地方退出程序，只需要调用ActivityCollector.finishAll()方法就可以了。例如在ThirdActivity界面想通过点击按钮直接退出程序，只需将代码改成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdActivity</span> : <span class="type">BaseActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityThirdBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;LCR&quot;</span>, <span class="string">&quot;onCreate: TaskId is <span class="variable">$taskId</span>&quot;</span>)</span><br><span class="line">        binding = ActivityThirdBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        binding.btnFinish.setOnClickListener &#123;</span><br><span class="line">            ActivityCollector.finishAll()</span><br><span class="line"><span class="comment">//            android.os.Process.killProcess(android.os.Process.myPid())</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-启动Activity的最佳写法"><a href="#5-3-启动Activity的最佳写法" class="headerlink" title="5.3 启动Activity的最佳写法"></a>5.3 启动Activity的最佳写法</h3><p>启动Activity的方法相信我们已经非常熟悉了，首先通过Intent构建出当前的“意图”，然后调用startActivity()或startActivityForResult()方法将Activity启动起来，如果有数据需要在Activity之间传递，也可以借助Intent来完成。</p><p>假设SecondActivity中需要用到两个非常重要的字符串参数，在启动SecondActivity的时候必须传递过来，那么我们很容易会写出如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>虽然这样写是完全正确的，但是在真正的项目开发中经常会出现对接的问题。比如SecondActivity并不是由你开发的，但现在你负责开发的部分需要启动SecondActivity，而你却不清楚启动SecondActivity需要传递哪些数据。这时无非就有两个办法：一个是你自己去阅读SecondActivity中的代码，另一个是询问负责编写SecondActivity的同事。你会不会觉得很麻烦呢？其实只需要换一种写法，就可以轻松解决上面的窘境。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> : BaseActivity() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, data1: <span class="type">String</span>, data2: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(context, ThirdActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param1&quot;</span>, data1)</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param2&quot;</span>, data2)</span><br><span class="line">        context.startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用了一个新的语法结构companion object，并在companion object中定义了一个actionStart()方法。之所以要这样写，是因为Kotlin规定，所有定义在companionobject中的方法都可以使用类似于Java静态方法的形式调用。</p><p>接下来我们重点看actionStart()方法，在这个方法中完成了Intent的构建，另外所有SecondActivity中需要的数据都是通过actionStart()方法的参数传递过来的，然后把它们存储到Intent中，最后调用startActivity()方法启动SecondActivity。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ViewBinding&quot;&gt;&lt;a href=&quot;#一、ViewBinding&quot; class=&quot;headerlink&quot; title=&quot;一、ViewBinding&quot;&gt;&lt;/a&gt;一、ViewBinding&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是ViewBinding&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Kotlin入门</title>
    <link href="https://icu007work.github.io/archives/add4ecd9.html"/>
    <id>https://icu007work.github.io/archives/add4ecd9.html</id>
    <published>2023-09-11T07:56:35.000Z</published>
    <updated>2023-09-12T01:34:50.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin入门"><a href="#Kotlin入门" class="headerlink" title="Kotlin入门"></a>Kotlin入门</h1><h2 id="一、变量和函数"><a href="#一、变量和函数" class="headerlink" title="一、变量和函数"></a>一、变量和函数</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><ul><li>在<strong>Kotlin</strong>中定义变量的方式和<strong>Java</strong>区别很大，在<strong>Java</strong>中如果想要定义一个变量，需要在变量前面声明这个变量的类型，比如说<code>int a</code>表示<code>a</code>是一个整型变量，<code>String b</code>表示<code>b</code>是一个字符串变量。而<strong>Kotlin</strong>中定义一个变量，只允许在变量前声明两种关键字：<code>val</code>和 <code>var</code>。<ul><li><code>val</code>（<strong>value</strong>的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应<strong>Java</strong>中的<code>final</code>变量。</li><li><code>var</code>（<strong>variable</strong>的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应<strong>Java</strong>中的<strong>非</strong><code>final</code>变量。</li></ul></li><li>仅仅使用<code>val</code>或者<code>var</code>来声明一个变量，那么编译器怎么能知道这个变量是什么类型呢？这也是Kotlin比较有特色的一点，它拥有出色的类型推导机制。</li><li>🌰举个栗子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;a = &quot;</span> + a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上述代码中，我们使用<code>val</code>关键字定义了一个变量<code>a</code>，并将它赋值为<strong>10</strong>，这里<code>a</code>就会被自动推导成整型变量。因为既然你要把一个整数赋值给<code>a</code>，那么<code>a</code>就只能是整型变量，而如果你要把一个<strong>字符串</strong>赋值给<code>a</code>的话，那么<code>a</code>就会被自动推导成<strong>字符串变量</strong>，这就是<strong>Kotlin</strong>的<strong>类型推导机制</strong>。</li><li>但是<strong>Kotlin</strong>的类型推导机制并不总是可以正常工作的，比如说如果我们对一个变量延迟赋值的话，<strong>Kotlin</strong>就无法自动推导它的类型了。这时候就需要显式地声明变量类型才行，<strong>Kotlin</strong>提供了对这一功能的支持，语法如下所示:</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>在上述代码中我们显式的声明了变量 <code>a</code> 为 <code>Int</code> 类型，这个时候 <strong>Kotlin</strong>就不会再进行类型推导了。如果此时我们再尝试将一个 <strong>字符串</strong>复制给 <code>a</code>，那么编译器会抛出一个类型不匹配的异常。</li><li><strong>Kotlin</strong>中<code>Int</code>的首字母是大写的，而<strong>Java</strong>中<code>int</code>的首字母是小写的。不要小看这一个字母大小写的差距，这表示<strong>Kotlin</strong>完全抛弃了<strong>Java</strong>中的基本数据类型，全部使用了对象数据类型。在<strong>Java</strong>中<code>int</code>是关键字，而在<strong>Kotlin</strong>中<code>Int</code>变成了一个类，它拥有自己的方法和继承结构。下表列出了<strong>Java</strong>中的每一个基本数据类型在<strong>Kotlin</strong>中对应的对象数据类型。</li></ul><table><thead><tr><th align="center">Java基本数据类型</th><th align="center">Kotlin对象数据类型</th><th align="center">数据类型说明</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Int</td><td align="center">整型</td></tr><tr><td align="center">long</td><td align="center">Long</td><td align="center">长整型</td></tr><tr><td align="center">short</td><td align="center">Short</td><td align="center">短整型</td></tr><tr><td align="center">float</td><td align="center">Float</td><td align="center">单精度浮点型</td></tr><tr><td align="center">double</td><td align="center">Double</td><td align="center">双精度浮点型</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td><td align="center">布尔型</td></tr><tr><td align="center">char</td><td align="center">Char</td><td align="center">字符型</td></tr><tr><td align="center">byte</td><td align="center">Byte</td><td align="center">字节型</td></tr></tbody></table><ul><li>在<strong>Java</strong>中，除非你主动在变量前声明了<code>final</code>关键字，否则这个变量就是可变的。然而这并不是一件好事，当项目变得越来越复杂，参与开发的人越来越多时，你永远不知道一个可变的变量会在什么时候被谁给修改了，即使它原本不应该被修改，这就经常会导致出现一些很难排查的问题。因此，一个好的编程习惯是，除非一个变量明确允许被修改，否则都应该给它加上<code>final</code>关键字。</li><li>但是，不是每个人都能养成这种良好的编程习惯。我相信至少有<strong>90%<strong>的</strong>Java</strong>程序员没有主动在变量前加上<code>final</code>关键字的意识，仅仅因为<strong>Java</strong>对此是不强制的。因此，<strong>Kotlin</strong>在设计的时候就采用了和<strong>Java</strong>完全不同的方式，提供了<code>val</code>和<code>var</code>这两个关键字，必须由开发者主动声明该变量是可变的还是不可变的。</li><li><strong>小诀窍</strong>：就是永远优先使用<code>val</code>来声明一个变量，而当<code>val</code>没有办法满足你的需求时再使用<code>var</code>。这样设计出来的程序会更加健壮，也更加符合高质量的编码规范。</li></ul><h3 id="1-2-函数"><a href="#1-2-函数" class="headerlink" title="1.2 函数"></a>1.2 函数</h3><ul><li><strong>函数是用来运行代码的载体</strong>，我们可以在一个函数里编写很多行代码，当运行这个函数时，函数中的所有代码会全部运行。就像<code>main()</code>函数就是一个函数，只不过它比较特殊，是程序的入口函数，即程序一旦运行，就是从<code>main()</code>函数开始执行的。</li><li>但是只有一个main()函数的程序显然是很初级的，和其他编程语言一样，<code>Kotlin</code>也允许我们自由地定义函数，语法规则如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span> <span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先<code>fun</code>（<strong>function</strong>的简写）是定义函数的关键字，无论你在 <code>Kotlin</code> 中定义什么函数，都一定要使用<code>fun</code>来声明。</li><li>其次这里的<code>methodName</code>是函数名，我们可以给它取任何名字，但是最好能够做到<strong>见文知意</strong>。良好的编程习惯是函数名最好要有一定的意义，能表达这个函数的作用是什么。</li><li>函数名后面紧跟着一对括号，里面可以声明该函数接收什么参数，<strong>参数的数量可以是任意多个</strong>，例如上述示例就表示该函数接收两个<code>Int</code>类型的参数。<strong>参数的声明格式是“参数名: 参数类型”</strong>，其中<strong>参数名也是可以随便定义</strong>的，这一点和函数名类似。如果不想接收任何参数，那么写一对空括号就可以了。</li><li><strong>参数括号后面的那部分是可选的，用于声明该函数会返回什么类型的数据</strong>，上述示例就表示该函数会返回一个<code>Int</code>类型的数据。<strong>如果你的函数不需要返回任何数据，这部分可以直接不写。</strong></li><li>最后<strong>两个大括号之间的内容就是函数体</strong>了，我们可以在这里编写一个函数的具体逻辑。由于上述示例中声明了该函数会返回一个<code>Int</code>类型的数据，因此在函数体中我们简单地返回了一个0。</li></ul><p>最后我们再来学习一个<strong>Kotlin</strong>函数的语法糖：当一个函数中只有一行代码时，<strong>Kotlin</strong>允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。</p><ul><li>🌰举个栗子：我们现在编写一个返回两数之间最大数的函数，我们可以这样写</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个函数中，函数体内只有一行代码，此时我们可以不写函数体，简化如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(a, b)</span><br></pre></td></tr></table></figure><ul><li>使用这种语法，<code>return</code>关键字也可以省略了，等号足以表达返回值的意思。另外，之前还讲过<strong>Kotlin</strong>出色的类型推导机制，在这里它也可以发挥重要的作用。由于<code>max()</code>函数返回的是一个<code>Int</code>值，而我们在<code>largerNumber()</code>函数的尾部又使用等号连接了<code>max()</code>函数，因此<strong>Kotlin</strong>可以推导出<code>largerNumber()</code>函数返回的必然也是一个<code>Int</code>值，这样就不用再显式地声明返回值类型了，代码可以进一步简化成如下形式：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = max(a, b)</span><br></pre></td></tr></table></figure><hr><h2 id="二、程序的逻辑控制"><a href="#二、程序的逻辑控制" class="headerlink" title="二、程序的逻辑控制"></a>二、程序的逻辑控制</h2><p>程序的执行语句主要分为3种：顺序语句、条件语句和循环语句。顺序语句很好理解，就是代码一行一行地往下执行就可以了，但是这种“愣头青”的执行方式在很多情况下并不能满足我们的编程需求，这时就需要引入条件语句和循环语句了</p><p><strong>Kotlin</strong>的条件语句主要有两种实现方式：<code>if</code> 和 <code>when</code></p><h3 id="2-1-条件语句"><a href="#2-1-条件语句" class="headerlink" title="2.1 条件语句"></a>2.1 条件语句</h3><h4 id="2-1-1-if条件语句"><a href="#2-1-1-if条件语句" class="headerlink" title="2.1.1 if条件语句"></a>2.1.1 if条件语句</h4><ul><li>首先学习<code>if</code>，<strong>Kotlin</strong>中的<code>if</code>语句和<strong>Java</strong>中的<code>if</code>语句几乎没有任何区别</li><li>🌰举个栗子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以这样写：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> value: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么可以写成上述代码呢？这是因为<strong>Kotlin</strong>中的<code>if</code>语句相比于<strong>Java</strong>有一个额外的功能，它是可以有返回值的，返回值就是<code>if</code>语句每一个条件中最后一行代码的返回值。</li><li>结合之前讲的语法糖，我们可以再简化一下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是上述代码还不是最精简的，我们甚至可以这样写：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><h4 id="2-1-2-when条件语句"><a href="#2-1-2-when条件语句" class="headerlink" title="2.1.2 when条件语句"></a>2.1.2 when条件语句</h4><ul><li>接下来我们开始学习<code>when</code>。<strong>Kotlin</strong>中的<code>when</code>语句有点类似于<strong>Java</strong>中的<code>switch</code>语句，但它又远比<code>switch</code>语句强大得多；</li><li>首先，在<strong>Java</strong>中<code>switch</code>只能传入整型或短于整型的变量作为条件，JDK 1.7之后增加了对字符串变量的支持，但如果你的判断逻辑使用的并非是上述几种类型的变量,<code>switch</code>就不再适用了；其次，<code>switch</code>中的每个<code>case</code>条件都要在最后主动加上一个<code>break</code>，否则执行完当前<code>case</code>之后会依次执行下面的<code>case</code>，这一特性曾经导致过无数奇怪的bug，就是因为有人忘记添加<code>break</code>；</li><li>而 <strong>Kotlin</strong>中的 <code>when</code>语句不仅解决了上述痛点，还增加了许多更为强大的新特性，有时它比if语句还要简单好用。</li><li>🌰 举个栗子</li><li>现在我们编写一个demo,输入一个单词，返回其数字。我们先用if语句来实现:</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNumber</span><span class="params">(words: <span class="type">String</span>)</span></span> = <span class="keyword">if</span>( words = <span class="string">&quot;one&quot;</span>)&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;two&quot;</span>)&#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;three&quot;</span>)&#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;four&quot;</span>)&#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(words = <span class="string">&quot;five&quot;</span>)&#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虽然上述代码确实可以实现我们想要的功能，但是写了这么多的if和else，我们会发现代码很冗余。没错，当你的判断条件非常多的时候，就是应该考虑使用when语句的时候，现在我们将代码改成如下写法：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNumber</span><span class="params">(words: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (words) &#123;</span><br><span class="line">    <span class="string">&quot;one&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">    <span class="string">&quot;two&quot;</span> -&gt; <span class="number">2</span></span><br><span class="line">    <span class="string">&quot;three&quot;</span> -&gt; <span class="number">3</span></span><br><span class="line">    <span class="string">&quot;four&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    <span class="string">&quot;five&quot;</span> -&gt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 **Kotlin **中 <code>when</code>语句和 <code>if</code> 语句一样都有返回值，所以我们仍然可以使用单行代码函数的语法糖；</li><li>在 <strong>Kotlin</strong>中 <code>when</code>语句允许传入一个任意类型的参数，然后可以在<code>when</code>的结构体中定义一系列的条件，格式是：</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配值 -&gt; &#123;执行逻辑&#125;</span><br></pre></td></tr></table></figure><ul><li>当你的执行逻辑只有一行代码时，{ }可以省略。除了精确匹配之外，<code>when</code>语句还允许进行类型匹配。那么什么是类型匹配呢？</li><li>🌰 举个栗子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(num)&#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;number is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;number is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码中，<code>is</code>关键字就是类型匹配的核心，它相当于<strong>Java</strong>中的<code>instanceof</code>关键字。由于<code>checkNumber()</code>函数接收一个<code>Number</code>类型的参数，这是<strong>Kotlin</strong>内置的一个抽象类，像<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>等与数字相关的类都是它的子类，所以这里就可以使用类型匹配来判断传入的参数到底属于什么类型，如果是<code>Int</code>型或<code>Double</code>型，就将该类型打印出来，否则就打印不支持该参数的类型。</li><li>哦对了，在 <strong>Kotlin</strong> 中 <code>when</code>语句还可以不传参数，🌰 举个栗子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNumber</span><span class="params">(words: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    words == <span class="string">&quot;one&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">    words == <span class="string">&quot;two&quot;</span> -&gt; <span class="number">2</span></span><br><span class="line">    words == <span class="string">&quot;three&quot;</span> -&gt; <span class="number">3</span></span><br><span class="line">    words == <span class="string">&quot;four&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    words == <span class="string">&quot;five&quot;</span> -&gt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-循环语句"><a href="#2-2-循环语句" class="headerlink" title="2.2 循环语句"></a>2.2 循环语句</h3><p>学完条件语句后，接下来我们学习 <strong>Kotlin</strong> 中的循环语句。</p><ul><li>熟悉Java的人应该都知道，<strong>Java</strong>中主要有两种循环语句：<code>while</code>循环和<code>for</code>循环。而<strong>Kotlin</strong>也提供了<code>while</code>循环和<code>for</code>循环，其中<code>while</code>循环不管是在语法还是使用技巧上都和<strong>Java</strong>中的<code>while</code>循环没有任何区别。所以我们直接学习 <code>for</code>循环。</li><li><strong>Kotlin</strong>在<strong>for</strong>循环方面做了很大幅度的修改，<strong>Java</strong>中最常用的<strong>for-i</strong>循环在<strong>Kotlin</strong>中直接被舍弃了，而<strong>Java</strong>中另一种<strong>for-each</strong>循环则被<strong>Kotlin</strong>进行了大幅度的加强，变成了<strong>for-in</strong>循环，所以我们只需要学习<strong>for-in</strong>循环的用法就可以了。</li><li>在开始学习for-in循环之前，先来学习一个区间的概念，因为这也是Java中没有的东西。我们可以使用如下Kotlin代码来表示一个区间：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0.</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>这种语法结构虽然看上去挺奇怪的,但在<strong>Kotlin</strong>中，它是完全合法的。上述代码表示创建了一个0到10的区间，并且<strong>两端都是闭区间</strong>，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是**[0, 10]**。</p><ul><li>其中，<code>..</code>是创建两端闭区间的关键字，在<code>..</code>的两边指定区间的左右端点就可以创建一个区间了。</li><li>有了区间之后，我们就可以通过<code>for-in</code>循环来遍历这个区间.</li><li>🌰 举个栗子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是<code>for-in</code>循环最简单的用法了，我们遍历了区间中的每一个元素，并将它打印出来。</p><p>但是在很多情况下，双端闭区间却不如单端闭区间好用。为什么这么说呢？相信你一定知道数组的下标都是从0开始的，一个长度为10的数组，它的下标区间范围是0到9，因此左闭右开的区间在程序设计当中更加常用。<strong>Kotlin</strong>中可以使用<code>until</code>关键字来创建一个左闭右开的区间，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0</span> until <span class="number">10</span></span><br></pre></td></tr></table></figure><p>上述代码表示创建了一个0到10的<strong>左闭右开区间</strong>，它的数学表达方式是**[0, 10)**。</p><p>当然，我们在 <strong>Kotlin</strong> 中也可以创建一个降序区间，使用 <code>downTo</code>关键字，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">10</span> downTo <span class="number">1</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>for-in</code>循环每次执行循环时会在区间范围内递增1，相当于<strong>Java</strong> <code>for-i</code>循环中<code>i++</code>的效果，而如果你想跳过其中的一些元素，可以使用<code>step</code>关键字：🌰 举个栗子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>)&#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码表示在遍历**[1, 10]**这个区间的时候，每次执行循环都会在区间范围内递增2，相当于<code>for-i</code>循环中<code>i = i + 2</code>的效果。当然 <code>downTo</code>关键字创建的降序区间也是可以使用 <code>step</code>关键字的。</p><p>总的来说，<code>for-in</code>循环并没有传统的<code>for-i</code>循环那样灵活，但是却比<code>for-i</code>循环要简单好用得多，而且足够覆盖大部分的使用场景。如果有一些特殊场景使用<code>for-in</code>循环无法实现的话，我们还可以改用<code>while</code>循环的方式来进行实现。</p><hr><h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><p>和很多现代高级语言一样，<code>Kotlin</code>也是面向对象的，因此理解什么是<strong>面向对象编程</strong>对我们来说就非常重要了。不同于<strong>面向过程</strong>的语言（比如C语言），<strong>面向对象的语言是可以创建类的</strong>。<strong>类就是对事物的一种封装</strong>，比如说人、汽车、房屋、书等任何事物，我们都可以将它封装一个类，<strong>类名通常是名词</strong>。而类中又可以拥有自己的<strong>字段和函数</strong>，字段表示该类所拥有的属性，比如说人可以有姓名和年龄，汽车可以有品牌和价格，这些就属于类中的字段，<strong>字段名通常也是名词</strong>。而函数则表示该类可以有哪些行为，比如<br>说人可以吃饭和睡觉，汽车可以驾驶和保养等，<strong>函数名通常是动词</strong>。</p><p>通过这种类的封装，我们就可以在适当的时候创建该类的对象，然后调用对象中的字段和函数来满足实际编程的需求，这就是面向对象编程最基本的思想。当然，面向对象编程还有很多其他特性，如继承、多态等，但是这些特性都是建立在基本的思想之上的。</p><h3 id="3-1-类与对象"><a href="#3-1-类与对象" class="headerlink" title="3.1 类与对象"></a>3.1 类与对象</h3><p>在 <strong>Kotlin</strong>中 也是使用 <code>class</code>关键字来声明一个类的，这一点和<strong>Java</strong>一致；这里创建一个 <code>Person</code> 类，并且加入 字段（属性）和 函数（方法）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating. He is <span class="variable">$age</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们创建了 <code>name</code>和 <code>age</code> 字段（属性） 然后还定义了一个 <code>eat()</code> 函数（方法）并在其中打印了一句话。</p><p>接下来我们实例化一个 <code>Person</code>对象，<strong>Kotlin</strong>中实例化一个类的方式和<strong>Java</strong>是基本类似的，只是去掉了<code>new</code>关键字而已。之所以这么设计，是因为当你调用了某个类的构造函数时，你的意图只可能是对这个类进行实例化，因此即使没有<code>new</code>关键字，也能清晰表达出你的意图。<strong>Kotlin</strong>本着最简化的设计原则，将诸如<code>new</code>、行尾分号这种不必要的语法结构都取消了。</p><p>实例化对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Person()</span><br></pre></td></tr></table></figure><p>我们可以在 <code>main()</code>函数中对p对象进行一些操作，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    p.name = <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">    p.age = <span class="number">24</span></span><br><span class="line">    p.eat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是面向对象编程最基本的用法了，简单概括一下，就是要<strong>先将事物封装成具体的类</strong>，然后将<strong>事物所拥有的属性和能力</strong>分别<strong>定义成类中的字段和函数</strong>，接下来对类进行实例化，再<strong>根据具体的编程需求调用类中的字段和方法</strong>即可。</p><h3 id="3-2-继承与构造函数"><a href="#3-2-继承与构造函数" class="headerlink" title="3.2 继承与构造函数"></a>3.2 继承与构造函数</h3><h4 id="3-2-1-继承"><a href="#3-2-1-继承" class="headerlink" title="3.2.1 继承"></a>3.2.1 继承</h4><p>继承—面向对象编程中另一个极其重要的特性。继承也是基于现实场景总结出来的一个概念，其实非常好理解。比如现在我们要定义一个<code>Student</code>类，每个学生都有自己的学号和年级，因此我们可以在<code>Student</code>类中加入<code>sno</code>和<code>grade</code>字段。但同时学生也是人呀，学生也会有姓名和年龄，也需要吃饭，如果我们在<code>Student</code>类中重复定义<code>name</code>、<code>age</code>字段和<code>eat()</code>函数的话就显得太过冗余了。这个时候就可以让<code>Student</code>类去继承<code>Person</code>类，这样<code>Student</code>就自动拥有了<code>Person</code>中的字段和函数，另外还可以定义自己独有的字段和函数。这就是面向对象编程中的继承思想。</p><p>接下来实现让 <code>Student</code>类继承 <code>Person</code> 类，我们要先做两件事：</p><p>第一件事：使 <code>Person</code>类可以被继承，对你没看错，就是先让父类可被继承。可能很多人会觉得奇怪，尤其是有<strong>Java</strong>编程经验的人。一个类本身不就是可以被继承的吗？为什么还要使<code>Person</code>类可以被继承呢？这就是<strong>Kotlin</strong>不同的地方，在<strong>Kotlin</strong>中任何一个非抽象类默认都是不可以被继承的，相当于<strong>Java</strong>中给类声明了<code>final</code>关键字。之所以这么设计，其实和<code>val</code>关键字的原因是差不多的，因为类和变量一样，最好都是不可变的，而一个类允许被继承的话，它无法预知子类会如何实现，因此可能就会存在一些未知的风险。<strong>Effective Java</strong>这本书中明确提到，如果一个类不是专门为继承而设计的，那么就应该主动将它加上<code>final</code>声明，禁止它可以被继承。</p><p>很明显，<strong>Kotlin</strong>在设计的时候遵循了这条编程规范，<strong>默认所有非抽象类都是不可以被继承的</strong>。之所以这里一直在说非抽象类，是因为抽象类本身是无法创建实例的，一定要由子类去继承它才能创建实例，因此抽象类必须可以被继承才行，要不然就没有意义了。</p><p>那我们应该如何让 <code>Person</code>类可被继承呢？其实很简单！只需要在类前面加上 <code>open</code>关键字就可以啦！如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上<code>open</code>关键字之后，我们就是在主动告诉<strong>Kotlin</strong>编译器，<code>Person</code>这个类是专门为继承而设计的，这样<code>Person</code>类就允许被继承了。</p><p>第二件事： 让 <code>Student</code>类继承 <code>Person</code>类，在Java中继承的关键字是<code>extends</code>，而在<strong>Kotlin</strong>中变成了一个冒号。写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>()&#123;</span><br><span class="line">    <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的写法如果只是替换一下关键字倒也挺简单的，但是为什么<code>Person</code>类的后面要加上一对括号呢？<strong>Java</strong>中继承的时候好像并不需要括号。这对括号还涉及 <code>Kotlin</code>中 主构造函数、次构造函数等方面的知识.</p><h4 id="3-2-2-构造函数"><a href="#3-2-2-构造函数" class="headerlink" title="3.2.2 构造函数"></a>3.2.2 构造函数</h4><p>任何一个面向对象的编程语言都会有构造函数的概念，<strong>Kotlin</strong>中也有，但是<strong>Kotlin</strong>将构造函数分成了两种：<strong>主构造函数</strong>和<strong>次构造函数</strong>。</p><h5 id="3-2-2-1-主构造函数"><a href="#3-2-2-1-主构造函数" class="headerlink" title="3.2.2.1 主构造函数"></a>3.2.2.1 主构造函数</h5><p><strong>主构造函数将会是我们最常用的构造函数</strong>，每个类默认都会有一个不带参数的主构造函数，当然也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即可。比如下面这种写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将学号和年级这两个字段都放到了主构造函数当中，这就表明在对<code>Student</code>类进行实例化的时候，<strong>必须</strong>传入构造函数中要求的所有参数。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这样我们就创建了一个<code>Student</code>的对象，同时指定该学生的学号是<code>123</code>，年级是<code>5</code>。另外，由于构造函数中的参数是在创建实例的时候传入的，不像之前的写法那样还得重新赋值，因此我们可以将参数全部声明成<code>val</code>。</p><p>当然啦，我们也可以在主构造函数当中写一些逻辑，<strong>Kotlin</strong>给我们提供了一个 <code>init</code>结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;sno is &quot;</span> + sno)</span><br><span class="line">        println(<span class="string">&quot;grade is &quot;</span> + grade)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们打印了学号以及年级。到这里为止都还挺好理解的，但是这和那对括号又有什么关系呢？这就涉及了<strong>Java</strong>继承特性中的一个规定，<strong>子类中的构造函数必须调用父类中的构造函数</strong>，这个规定在<strong>Kotlin</strong>中也要遵守。</p><p>看一下<strong>Student</strong>类，现在我们声明了一个主构造函数，根据继承特性的规定，子类的构造函数必须调用父类的构造函数，可是主构造函数并没有函数体，我们怎样去调用父类的构造函数呢？你可能会说，在<code>init</code>结构体中去调用不就好了。这或许是一种办法，但绝对不是一种好办法，因为在绝大多数的场景下，我们是不需要编写<code>init</code>结构体的。<br><strong>Kotlin</strong>当然没有采用这种设计，而是用了另外一种简单但是可能不太好理解的设计方式：括号。<strong>子类的主构造函数调用父类中的哪个构造函数，在继承的时候通过括号来指定。</strong>因此再来看一遍这段代码，你应该就能理解了吧。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>Person</code>类后面的一对空括号表示<code>Student</code>类的主构造函数在初始化的时候会调用<code>Person</code>类的无参数构造函数，即使在无参数的情况下，这对括号也不能省略。</p><p>此时如果我们更改一下 <code>Person</code>类，将姓名和年龄放到主构造函数中，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> (<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>此时我们在<code>Student</code>再去使用空括号调用<code>Person</code>类的无参构造函数肯定会报错，因为此时<code>Person</code>类的主构造函数需要 <code>name</code>和 <code>age</code>两个参数。</p><p>要解决这个问题也很简单，给<code>Person</code>类的构造函数传入<code>name</code>和<code>age</code>字段就好了。可是问题又来了<code>Student</code>类中也没有这两个字段啊，其实我们可以在 <code>Student</code> 类的主构造函数中 加上 <code>name</code> 和 <code>age</code> 这两个参数，然后再将这两个参数传给<code>Person</code>类的构造函数就行了。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> (<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name, age)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭐<strong>注意</strong>，我们在<code>Student</code>类的主构造函数中增加<code>name</code>和<code>age</code>这两个字段时，不能再将它们声明成<code>val</code>，因为在主构造函数中声明成<code>val</code>或者<code>var</code>的参数将自动成为该类的字段，这就会导致和父类中同名的<code>name</code>和<code>age</code>字段造成冲突。因此，这里的<code>name</code>和<code>age</code>参数前面我们不用加任何关键字，让它的作用域仅限定在主构造函数当中即可。</p><p>现在可以通过如下代码来创建一个<code>Student</code>类的实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure><h5 id="3-2-2-2-次构造函数"><a href="#3-2-2-2-次构造函数" class="headerlink" title="3.2.2.2 次构造函数"></a>3.2.2.2 次构造函数</h5><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。其实我们几乎是用不到次构造函数的，Kotlin提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。<br><strong>Kotlin</strong>规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用）。</p><p>🌰举个栗子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次构造函数是通过<code>constructor</code>关键字来定义的，这里我们定义了两个次构造函数：第一个次构造函数接收<code>name</code>和<code>age</code>参数，然后它又通过<code>this</code>关键字调用了主构造函数，并将<code>sno</code>和<code>grade</code>这两个参数赋值成初始值；第二个次构造函数不接收任何参数，它通过<code>this</code>关键字调用了我们刚才定义的第一个次构造函数，并将<code>name</code>和<code>age</code>参数也赋值成初始值，由于第二个次构造函数间接调用了主构造函数，因此这仍然是合法的。</p><p>那么现在我们就拥有了3种方式来对<code>Student</code>类进行实体化，分别是通过<strong>不带参数</strong>的构造函数、通过带<strong>两个参数</strong>的构造函数和通过带<strong>4个参数</strong>的构造函数，对应代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student1 = Student()</span><br><span class="line"><span class="keyword">val</span> student2 = Student(<span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="keyword">val</span> student3 = Student(<span class="string">&quot;123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。这种情况真的十分少见，但在<strong>Kotlin</strong>中是允许的。当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，首先<code>Student</code>类的后面<strong>没有显式地定义主构造函数</strong>，同时又因为定义了次构造函数，所以现在<code>Student</code>类是没有主构造函数的。那么既然没有主构造函数，继承<code>Person</code>类的时候就<strong>不用继承其主构造函数</strong>，也就不需要再加上括号了。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将<code>this</code>关键字换成了<code>super</code>关键字。</p><h3 id="3-3-接口"><a href="#3-3-接口" class="headerlink" title="3.3 接口"></a>3.3 接口</h3><p>接口是用于实现多态编程的重要组成部分。我们都知道，<strong>Java</strong>是单继承结构的语言，任何一个类最多只能继承一个父类，但是却可以实现任意多个接口，<strong>Kotlin</strong>也是如此。</p><p>我们可以在接口中定义一系列的抽象行为，然后由具体的类去实现。下面还是通过具体的代码来学习一下，首先创建一个<code>Study</code>接口，并在其中定义几个学习行为。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBook</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以让<code>Student</code>类去实现<code>Study</code>接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name, age), Study &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span>&#x27;s sno is <span class="variable">$sno</span> he&#x27;s grade is <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBook</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is reading&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is doing homework&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉<strong>Java</strong>的人一定知道，<strong>Java</strong>中继承使用的关键字是<code>extends</code>，实现接口使用的关键字是<code>implements</code>，而<strong>Kotlin</strong>中统一使用冒号，中间用<code>,</code>进行分隔。上述代码就表示<code>Student</code>类继承了<code>Person</code>类，同时还实现了<code>Study</code>接口。另外接口的后面不用加上括号，因为它没有构造函数可以去调用。Study接口中定义了<code>readBooks()</code>和<code>doHomework()</code>这两个待实现函数，因此<code>Student</code>类必须实现这两个函数。<strong>Kotlin</strong>中使用<code>override</code>关键字来重写父类或者实现接口中的函数，这里我们只是简单地在实现的函数中打印了一行信息。</p><p>接下来在 <code>main()</code>函数中调用如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;1232&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">24</span>)</span><br><span class="line">    student.eat()</span><br><span class="line">    student.info()</span><br><span class="line">    student.readBook()</span><br><span class="line">    student.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person</code>类如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating. He is <span class="variable">$age</span> years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让接口的功能更加灵活，<strong>Kotlin</strong>还增加了一个额外的功能：允许对接口中定义的函数进行默认实现。其实<strong>Java</strong>在<strong>JDK1.8</strong>之后也开始支持这个功能了，因此总体来说，<strong>Kotlin</strong>和<strong>Java</strong>在接口方面的功能仍然是一模一样的。</p><p>对接口中的函数进行默认实现的具体实现如下（修改<code>Study</code>接口）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBook</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;zZZZ sleeping... default implementation&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Study</code>接口中，我们新增了一个 <code>sleep()</code>函数，并且默认实现了。如果接口中的一个函数拥有了函数体，这个函数体中的内容就是它的默认实现。现在当一个类去实现<code>Study</code>接口时，只会强制要求实现<code>readBooks()</code>和<code>doHomework()</code>函数，而<code>sleep</code>函数则可以自由选择实现或者不实现，不实现时就会自动使用默认的实现逻辑。</p><p>现在回到<code>Student</code>类当中，你会发现如果我们删除了<code>doHomework()</code>和<code>readBooks()</code>函数，代码是会提示错误的，而删除<code>sleep()</code>函数则不会。</p><p>以上就是<strong>Kotlin</strong>面向对象编程中最主要的一些内容，接下来我们再学习一个和<strong>Java</strong>相比变化比较大的部分——<code>函数的可见性修饰</code>符。</p><p>熟悉<strong>Java</strong>的人一定知道，<strong>Java</strong>中有<code>public</code>、<code>private</code>、<code>protected</code>和<code>default</code>（什么都不写）这4种函数可见性修饰符。<strong>Kotlin</strong>中也有4种，分别是<code>public</code>、<code>private</code>、<code>protected</code>和<code>internal</code>，需要使用哪种修饰符时，直接定义在<code>fun</code>关键字的前面即可。接下来详细介绍一下<strong>Java</strong>和<strong>Kotlin</strong>中这些函数可见性修饰符的异同。</p><p>首先<code>private</code>修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。<code>public</code>修饰符的作用虽然也是一致的，表示对所有类都可见，但是在<strong>Kotlin</strong>中<code>public</code>修饰符是默认项，而在<code>Java</code>中<code>default</code>才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是<code>public</code>的。<code>protected</code>关键字在<strong>Java</strong>中表示对当前类、子类和同一包路径下的类可见，在<code>Kotlin</code>中则表示只对当前类和子类可见。<code>Kotlin</code>抛弃了<strong>Java</strong>中的<code>default</code>可见性（同一包路径下的类可见），引入了一种新的可见性概念，只对同一模块中的类可见，使用的是<code>internal</code>修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成<code>internal</code>。</p><table><thead><tr><th align="center">修饰符</th><th align="center">Java</th><th align="center">kotlin</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">所有类可见</td><td align="center">所有类可见（默认）</td></tr><tr><td align="center">private</td><td align="center">当前类可见</td><td align="center">当前类可见</td></tr><tr><td align="center">protected</td><td align="center">当前类、子类、同一包路径下的类可见</td><td align="center">当前类、子类可见</td></tr><tr><td align="center">default</td><td align="center">同一包路径下的类可见（默认）</td><td align="center">无</td></tr><tr><td align="center">internal</td><td align="center">无</td><td align="center">同一模块中的类可见</td></tr></tbody></table><h3 id="3-4-数据类与单例类"><a href="#3-4-数据类与单例类" class="headerlink" title="3.4 数据类与单例类"></a>3.4 数据类与单例类</h3><h4 id="3-4-1-数据类"><a href="#3-4-1-数据类" class="headerlink" title="3.4.1 数据类"></a>3.4.1 数据类</h4><p>在一个规范的系统架构中，数据类通常占据着非常重要的角色，它们用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。或许你听说过<strong>MVC</strong>、<strong>MVP</strong>、<strong>MVVM</strong>之类的架构模式，不管是哪一种架构模式，其中的<strong>M</strong>指的就是<strong>数据类</strong>。</p><p>数据类通常需要<strong>重写</strong><code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>这几个方法。其中，<code>equals()</code>方法用于判断两个数据类是否相等。<code>hashCode()</code>方法作为<code>equals()</code>的配套方法，也需要一起重写，否则会导致<code>HashMap</code>、<code>HashSet</code>等hash相关的系统类无法正常工作。<code>toString()</code>方法用于提供更清晰的输入日志，否则一个数据类默认打印出来的就是一行内存地址。</p><p>比如在 <strong>Java</strong>中 我们要实现一个手机数据类，我们要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>&#123;</span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cellphone</span><span class="params">(String brand, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Cellphone)&#123;</span><br><span class="line">            <span class="type">Cellphone</span> <span class="variable">other</span> <span class="operator">=</span> (Cellphone) obj;</span><br><span class="line">            <span class="keyword">return</span> other.brand.equals(brand) &amp;&amp; other.price == price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand.hashCode() + (<span class="type">int</span>) price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cellphone(brand=&quot;</span> + band + <span class="string">&quot;, price=&quot;</span> + price + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去挺复杂的吧？关键是这些代码还是一些没有实际逻辑意义的代码，只是为了让它拥有数据类的功能而已。而同样的功能使用<strong>Kotlin</strong>来实现就会变得极其简单:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对！你没有看错，在 <strong>Kotlin</strong>当中，当我们需要一个数据类的时候只需要在这个类前声明了data关键字。当在一个类前面声明了<code>data</code>关键字时，就表明你希望这个类是一个<strong>数据类</strong>，<strong>Kotlin</strong>会根据主构造函数中的参数帮你将<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>等固定且无实际逻辑意义的方法自动生成，从而大大减少了开发的工作量。</p><h4 id="3-4-2-单例类"><a href="#3-4-2-单例类" class="headerlink" title="3.4.2 单例类"></a>3.4.2 单例类</h4><p>掌握了数据类的使用技巧之后，接下来我们再来看另外一个Kotlin中特有的功能——<strong>单例类</strong>。</p><p>想必你一定听说过<strong>单例模式</strong>吧，这是<strong>最常用、最基础的设计模式之一</strong>，它可以用于<strong>避免创建重复的对象</strong>。比如我们希望某个类在全局最多只能拥有一个实例，这时就可以使用单例模式。当然单例模式也有很多种写法，这里演示一种最常见的Java写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            intance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;singleTon is called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看下这段代码，为了禁止外部创建<code>Singleton</code>的实例，我们使用<code>private</code>关键字将 <code>Singleton</code>的构造函数私有化，然后给外部提供了一个<code>getInstance()</code>静态方法用于获取<code>Singleton</code>的实例。在<code>getInstance()</code>方法中，我们判断如果当前缓存的<code>Singleton</code>实例为<code>null</code>，就创建一个新的实例，否则直接返回缓存的实例即可，这就是单例模式的工作机制。</p><p>如果我们想调用单例类中的方法，也很简单，比如想调用上述的<code>singletonTest()</code>方法，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton singleton = Singleton.getInstance();</span><br><span class="line">singleton.singletonTest();</span><br></pre></td></tr></table></figure><p>虽然<strong>Java</strong>中的单例实现并不复杂，但是<strong>Kotlin</strong>明显做得更好，它同样是将一些固定的、重复的逻辑实现隐藏了起来，只暴露给我们最简单方便的用法。</p><p>在<code>Kotlin</code>中创建一个单例类的方式极其简单，只需要将<code>class</code>关键字改成<code>object</code>关键字即可。初始化代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;singletonTest is called. --kotlin&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<strong>Kotlin</strong>中我们不需要私有化构造函数，也不需要提供<code>getInstance()</code>这样的静态方法，只需要把<code>class</code>关键字改成<code>object</code>关键字，一个单例类就创建完成了。而调用单例类中的函数也很简单，比较类似于<strong>Java</strong>中静态方法的调用方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.singletonTest()</span><br></pre></td></tr></table></figure><p>这种写法虽然看上去像是静态方法的调用，但其实Kotlin在背后自动帮我们创建了一个Singleton类的实例，并且保证全局只会存在一个Singleton实例。</p><hr><h2 id="四、Lambda编程"><a href="#四、Lambda编程" class="headerlink" title="四、Lambda编程"></a>四、Lambda编程</h2><p>可能很多<strong>Java</strong>程序员对于Lambda编程还比较陌生，但其实这并不是什么新鲜的技术。许多现代高级编程语言在很早之前就开始支持<code>Lambda</code>编程了，但是<strong>Java</strong>却直到<strong>JDK 1.8</strong>之后才加入了<code>Lambda</code>编程的语法支持。因此，大量早期开发的<strong>Java</strong>和<strong>Android</strong>程序其实并未使用<code>Lambda</code>编程的特性。</p><p><strong>Kotlin</strong>从第一个版本开始就支持了<code>Lambda</code>编程，并且<strong>Kotlin</strong>中的<code>Lambda</code>功能极为强大，我甚至认为<code>Lambda</code>才是<strong>Kotlin</strong>的灵魂所在。</p><h3 id="4-1-集合的创建和遍历"><a href="#4-1-集合的创建和遍历" class="headerlink" title="4.1 集合的创建和遍历"></a>4.1 集合的创建和遍历</h3><p><strong>集合的函数式API</strong>是用来入门<code>Lambda</code>编程的绝佳示例，不过在此之前，我们得先学习创建集合的方式才行。</p><p>传统意义上的集合主要就是<code>List</code>和<code>Set</code>，再广泛一点的话，像<code>Map</code>这样的键值对数据结构也可以包含进来。<code>List</code>、<code>Set</code>和<code>Map</code>在<strong>Java</strong>中都是接口，<code>List</code>的主要实现类是<code>ArrayList</code>和<code>LinkedList</code>，<code>Set</code>的主要实现类是<code>HashSet</code>，<code>Map</code>的主要实现类是<code>HashMap</code>，熟悉<strong>Java</strong>的人对这些集合的实现类一定不会陌生。</p><p>现在我们提出一个需求，创建一个包含许多水果名称的集合。如果是在<strong>Java</strong>中你会怎么实现？我们首先想到的是创建一个 <code>ArrayList</code>实例，然后再将水果的名称一个个添加到集合中。当然啦，在 <code>kotlin</code>中我们也可以这么做。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;pear&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;grape&quot;</span>)</span><br></pre></td></tr></table></figure><p>但是这种初始化集合的方式比较烦琐，为此<strong>Kotlin</strong>专门提供了一个内置的<code>listOf()</code>函数来简化初始化集合的写法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listof(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这里仅用一行代码就完成了集合的初始化操作。之前在学习循环语句时提到过：<code>for-in</code>循环不仅可以用来遍历区间，还可以用来遍历集合。现在我们就尝试一下使用<code>for-in</code>循环来遍历这个水果集合：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list)&#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过需要注意的是，<code>listOf()</code>函数创建的是一个不可变的集合。你也许不太能理解什么叫作不可变的集合，因为在<strong>Java</strong>中这个概念不太常见。不可变的集合指的就是该集合只能用于读取，我们无法对集合进行添加、修改或删除操作。</p><p>至于这么设计的理由，和<code>val</code>关键字、类默认不可继承的设计初衷是类似的，可见<strong>Kotlin</strong>在不可变性方面控制得极其严格。那如果我们确实需要创建一个可变的集合呢？也很简单，使用<code>mutableListOf()</code>函数就可以了，示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> listVar = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    showlist(list)</span><br><span class="line">    showList(listVar)</span><br><span class="line">    listVar.add(<span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    showList(listVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========List===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (l <span class="keyword">in</span> list)&#123;</span><br><span class="line">        println(l)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========List===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们介绍的都是List集合的用法，实际上<code>Set</code>集合的用法几乎与此一模一样，只是将创建集合的方式换成了<code>setOf()</code>和<code>mutableSetOf()</code>函数而已。大致代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = setOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> setVar = mutableSetOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    showSet(<span class="keyword">set</span>)</span><br><span class="line">    showSet(setVar)</span><br><span class="line">    setVar.add(<span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    showSet(setVar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showSet</span><span class="params">(list: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========Set===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (l <span class="keyword">in</span> list)&#123;</span><br><span class="line">        println(l)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========Set===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭐<strong>需要注意</strong>，<code>Set</code>集合中是<strong>不可以存放重复元素</strong>的，<strong>如果存放了多个相同的元素，只会保留其中一份</strong>，这是和<code>List</code>集合最大的不同之处。</p><p>最后再来看一下<code>Map</code>集合的用法。Map是一种键值对形式的数据结构，因此在用法上和<code>List</code>、<code>Set</code>集合有较大的不同。传统的<code>Map</code>用法是先创建一个<code>HashMap</code>的实例，然后将一个个键值对数据添加到<code>Map</code>中。比如这里我们给每种水果设置一个对应的编号，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Apple&quot;</span>,<span class="number">1</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Banana&quot;</span>,<span class="number">2</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Orange&quot;</span>,<span class="number">3</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Pear&quot;</span>,<span class="number">4</span>)</span><br><span class="line">    map.put(<span class="string">&quot;Grape&quot;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    hashMap[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    hashMap[<span class="string">&quot;Banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    hashMap[<span class="string">&quot;Orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">    hashMap[<span class="string">&quot;Pear&quot;</span>] = <span class="number">4</span></span><br><span class="line">    hashMap[<span class="string">&quot;Grape&quot;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map1 = mapOf&lt;String, <span class="built_in">Int</span>&gt;(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>, <span class="string">&quot;Orange&quot;</span> to <span class="number">3</span>, <span class="string">&quot;Pear&quot;</span> to <span class="number">4</span>, <span class="string">&quot;Grape&quot;</span> to <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    showMap(map)</span><br><span class="line">    showMap(hashMap)</span><br><span class="line">    showMap(map1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMap</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map)&#123;</span><br><span class="line">        println(<span class="string">&quot;fruit is <span class="variable">$fruit</span>, number is <span class="variable">$number</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用第一种写法，是因为这种写法和<strong>Java</strong>语法是最相似的，因此可能最好理解。但其实在<strong>Kotlin</strong>中并不建议使用<code>put()</code>和<code>get()</code>方法来对<code>Map</code>进行添加和读取数据操作，而是更加推荐使用一种类似于数组下标的语法结构，比如向<code>Map</code>中添加一条数据就可以像第二种方法这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hashMap = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    hashMap[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    hashMap[<span class="string">&quot;Banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    hashMap[<span class="string">&quot;Orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">    hashMap[<span class="string">&quot;Pear&quot;</span>] = <span class="number">4</span></span><br><span class="line">    hashMap[<span class="string">&quot;Grape&quot;</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>而从Map中读取一条数据就可以这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = map[<span class="string">&quot;Apple&quot;</span>]</span><br></pre></td></tr></table></figure><p>当然，这仍然不是最简便的写法，因为<strong>Kotlin</strong>毫无疑问地提供了一对<code>mapOf()</code>和<code>mutableMapOf()</code>函数来继续简化<code>Map</code>的用法。在<code>mapOf()</code>函数中，我们可以直接传入初始化的键值对组合来完成对Map集合的创建,如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map1 = mapOf&lt;String, <span class="built_in">Int</span>&gt;(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>, <span class="string">&quot;Orange&quot;</span> to <span class="number">3</span>, <span class="string">&quot;Pear&quot;</span> to <span class="number">4</span>, <span class="string">&quot;Grape&quot;</span> to <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这里的键值对组合看上去好像是使用<code>to</code>这个关键字来进行关联的，但其实<code>to</code>并不是关键字，而是一个<code>infix</code>函数.</p><p>最后，遍历<code>Map</code>集合中的数据也是使用 <code>for-in</code>循环，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMap</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map)&#123;</span><br><span class="line">        println(<span class="string">&quot;fruit is <span class="variable">$fruit</span>, number is <span class="variable">$number</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;===========Map===========&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要的区别在于，在<code>for-in</code>循环中，我们将Map的键值对变量一起声明到了一对括号里面，这样当进行循环遍历时，每次遍历的结果就会赋值给这两个键值对变量，最后将它们的值打印出来。</p><h3 id="4-2-集合的函数式API"><a href="#4-2-集合的函数式API" class="headerlink" title="4.2 集合的函数式API"></a>4.2 集合的函数式API</h3><p>集合的函数式<code>API</code>有很多个，这里重点学习函数式<code>API</code>的语法结构，也就是<code>Lambda</code>表达式的语法结构。</p><p>首先实现一个需求：在一个水果集合里面找到单词最长的那个水果，我们可以这样写:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> maxLengthFruit = <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> (fruit <span class="keyword">in</span> listLength)&#123;</span><br><span class="line">       <span class="keyword">if</span> (fruit.length &gt; maxLengthFruit.length)&#123;</span><br><span class="line">           maxLengthFruit = fruit</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;maxLengthFruit is <span class="variable">$maxLengthFruit</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码使用的是打擂台的方法找出单词最长的那个水果，我们还可以使用集合的函数式<strong>API</strong>，这可以让我们的功能变的更加容易:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123; it.length &#125;</span><br><span class="line">println(<span class="string">&quot;maxLength is <span class="variable">$maxLength</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码只用了一行就找出了单词最长的那个水果，是怎么做到的呢?一起来学习下！</p><p>首先来看一下<code>Lambda</code>的定义，如果用最直白的语言来阐述的话，<code>Lambda</code>就是一小段可以作为参数传递的代码。从定义上看，这个功能就很厉害了，因为正常情况下，我们向某个函数传参时只能传入变量，而借助<code>Lambda</code>却允许传入一小段代码。这里两次使用了“一小段代码”这种描述，那么到底多少代码才算一小段代码呢？<strong>Kotlin</strong>对此并没有进行限制，但是通常不建议在<code>Lambda</code>表达式中编写太长的代码，否则可能会影响代码的可读性。</p><p><code>Lambda</code>表达式的语法结构如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是<code>Lambda</code>表达式最完整的语法结构定义。首先最外层是一对大括号，如果有参数传入到<code>Lambda</code>表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个<code>-&gt;</code>符号，<strong>表示参数列表的结束以及函数体的开始</strong>，函数体中可以编写任意行代码（虽然不建议编写太长的代码），并且最后一行代码会自动作为<code>Lambda</code>表达式的返回值。</p><p>当然，在很多情况下，我们并不需要使用<code>Lambda</code>表达式完整的语法结构，而是有很多种简化的写法。还是回到刚才找出最长单词水果的需求，前面使用的函数式<strong>API</strong>的语法结构看上去好像很特殊，但其实<code>maxBy</code>就是一个普通的函数而已，只不过它接收的是一个<code>Lambda</code>类型的参数，并且会在遍历集合时将每次遍历的值作为参数传递给<code>Lambda</code>表达式。<code>maxBy</code>函数的工作原理是根据我们传入的条件来遍历集合，从而找到该条件下的最大值，比如说想要找到单词最长的水果，那么条件自然就应该是单词的长度了。</p><p>理解了maxBy函数的工作原理之后，我们就可以开始套用刚才学习的Lambda表达式的语法结构，并将它传入到maxBy函数中了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lambda = &#123;fruit: String -&gt; fruit.length&#125;</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy(lambda)</span><br></pre></td></tr></table></figure><p>可以看到，<code>maxBy</code>函数实质上就是接收了一个<code>Lambda</code>参数而已，并且这个<code>Lambda</code>参数是完全按照刚才学习的表达式的语法结构来定义的，因此这段代码应该算是比较好懂的。<br>这种写法虽然可以正常工作，但是比较啰嗦，可简化的点也非常多，下面我们就开始对这段代码一步步进行简化。<br>首先，我们不需要专门定义一个<code>lambda</code>变量，而是可以直接将<code>lambda</code>表达式传入<code>maxBy</code>函数当中，因此第一步简化如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy(&#123;fruit: String -&gt; fruit.length&#125;)</span><br></pre></td></tr></table></figure><p>然后<strong>Kotlin</strong>规定，<strong>当<code>Lambda</code>参数是函数的最后一个参数时，可以将<code>Lambda</code>表达式移到函数括号的外面</strong>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy() &#123;fruit: String -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure><p>接下来，<strong>如果<code>Lambda</code>参数是函数的唯一一个参数的话，还可以将函数的括号省略</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123;fruit: String -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>Kotlin</strong>拥有出色的类型推导机制，<code>Lambda</code>表达式中的参数列表其实在大多数情况下不必声明参数类型，因此代码可以进一步简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123;fruit -&gt; fruit.length&#125;</span><br></pre></td></tr></table></figure><p>最后，当<code>Lambda</code>表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用<code>it</code>关键字来代替，那么代码就变成了:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listLength = listOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> maxLength = listLength.maxBy &#123;it.length&#125;</span><br></pre></td></tr></table></figure><p>怎么样？通过一步步推导的方式，我们就得到了和一开始那段函数式<strong>API</strong>一模一样的写法，是不是现在理解起来就非常轻松了呢？</p><p>接下来我们就再来学习几个集合中比较常用的函数式<strong>API</strong>,集合中的<code>map</code>函数是最常用的一种函数式API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在<code>Lambda</code>表达式中指定，最终生成一个新的集合。比如，这里我们希望让所有的水果名都变成大写模式，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">val</span> list = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> newList = list.map &#123; it.toUpperCase() &#125;</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> newList)&#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>函数的功能非常强大，它可以按照我们的需求对集合中的元素进行任意的映射转换，上面只是一个简单的示例而已。除此之外，你还可以将水果名全部转换成小写，或者是只取单词的首字母，甚至是转换成单词长度这样一个数字集合，只要在<code>Lambda</code>表示式中编写你需要的逻辑即可。</p><p>我们再来学习另外一个比较常用的函数式<strong>API</strong>——<code>filter</code>函数。顾名思义，<code>filter</code>函数是用来过滤集合中的数据的，它可以单独使用，也可以配合刚才的<code>map</code>函数一起使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> newList = list.filter &#123; it.length &lt; <span class="number">5</span> &#125; .map &#123; it.toUpperCase()) &#125;</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> newList)&#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续学习两个比较常用的函数式<strong>API</strong>——<code>any</code>和<code>all</code>函数。其中<code>any</code>函数用于判断集合中是否至少存在一个元素满足指定条件，<code>all</code>函数用于判断集合中是否所有元素都满足指定条件。由于这两个函数都很好理解，我们就直接通过代码示例学习了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;String&gt;(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> anyResult = list.any&#123;it.length &lt;= <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> allResult = list.all&#123;it.length &lt;= <span class="number">5</span>&#125;</span><br><span class="line">    println(<span class="string">&quot;anyResult is <span class="variable">$anyResult</span>, allResult is <span class="variable">$allResult</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是在<code>Lambda</code>表达式中将条件设置为5个字母以内的单词，那么<code>any</code>函数就表示集合中<strong>是否存在5个字母以内的单词</strong>，而<code>all</code>函数就表示集合中<strong>是否所有单词都在5个字母以内</strong>。</p><p>这样我们就将<code>Lambda</code>表达式的语法结构和几个常用的函数式<strong>API</strong>的用法都学习完了，虽然集合中还有许多其他函数式<strong>API</strong>，但是只要掌握了基本的语法规则，其他函数式API的用法只要看一看文档就能掌握了.</p><h3 id="4-3-Java函数式API的使用"><a href="#4-3-Java函数式API的使用" class="headerlink" title="4.3 Java函数式API的使用"></a>4.3 Java函数式API的使用</h3><p>现在我们已经学习了<strong>Kotlin</strong>中函数式<strong>API</strong>的用法，但实际上在<strong>Kotlin</strong>中调用<strong>Java</strong>方法时也可以使用函数式<strong>API</strong>，只不过这是有一定条件限制的。具体来讲，如果我们在<strong>Kotlin</strong>代码中调用了一个<strong>Java</strong>方法，并且该方法接收一个<strong>Java</strong>单抽象方法接口参数，就可以使用函数式<strong>API</strong>。<strong>Java</strong>单抽象方法接口指的是接口中只有一个待实现方法，如果接口中有多个待实现方法，则无法使用函数式<strong>API</strong>。</p><p>🌰 举个栗子：</p><p><strong>Java</strong>原生<strong>API</strong>中有一个最为常见的单抽象方法接口——<code>Runnable</code>接口。这个接口中只有一个待实现的<code>run()</code>方法，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的讲解，对于任何一个<strong>Java</strong>方法，只要它接收<code>Runnable</code>参数，就可以使用函数式<strong>API</strong>。那么什么<strong>Java</strong>方法接收了<code>Runnable</code>参数呢？这就有很多了，不过<code>Runnable</code>接口主要还是结合线程来一起使用的，因此这里我们就通过<strong>Java</strong>的线程类<code>Thread</code>来学习一下。</p><p><code>Thread</code>类的构造方法中接收了一个<code>Runnable</code>参数，我们可以使用如下<strong>Java</strong>代码创建并执行一个子线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>⭐注意：这里使用了匿名类的写法，我们创建了一个<code>Runnable</code>接口的匿名类实例，并将它传给了<code>Thread</code>类的构造方法，最后调用<code>Thread</code>类的<code>start()</code>方法执行这个线程。</p><p>而如果将这段代码翻译成 <code>Kotlin</code> 版本，写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(<span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p><strong>Kotlin</strong>中匿名类的写法和<strong>Java</strong>有一点区别，由于<strong>Kotlin</strong>完全舍弃了<code>new</code>关键字，因此创建匿名类实例的时候就不能再使用<code>new</code>了，而是改用了<code>object</code>关键字。这种写法虽然算不上复杂，但是相比于<strong>Java</strong>的匿名类写法，并没有什么简化之处。<br>但是别忘了，目前<code>Thread</code>类的构造方法是符合<strong>Java</strong>函数式<strong>API</strong>的使用条件的，下面我们就看看如何对代码进行精简，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable &#123;</span><br><span class="line">println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为<code>Runnable</code>类中只有一个待实现方法，即使这里没有显式地重写<code>run()</code>方法，<strong>Kotlin</strong>也能自动明白<code>Runnable</code>后面的<code>Lambda</code>表达式就是要在<code>run()</code>方法中实现的内容。</p><p>另外，如果一个<strong>Java</strong>方法的参数列表中有且仅有一个<strong>Java</strong>单抽象方法接口参数，我们还可以将接口名进行省略，这样代码就变得更加精简了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(&#123;</span><br><span class="line">    println(<span class="string">&quot;thread is running&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p>不过到这里还没有结束，和之前<strong>Kotlin</strong>中函数式<strong>API</strong>的用法类似，当<code>Lambda</code>表达式是方法的最后一个参数时，可以将<code>Lambda</code>表达式移到方法括号的外面。同时，如果<code>Lambda</code>表达式还是方法的唯一一个参数，还可以将方法的括号省略，最终简化结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread&#123;</span><br><span class="line">    println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><hr><h2 id="五、空指针检查"><a href="#五、空指针检查" class="headerlink" title="五、空指针检查"></a>五、空指针检查</h2><p>某国外机构做了一个统计，<strong>Android</strong>系统上崩溃率最高的异常类型就是<strong>空指针异常（NullPointerException）</strong>。相信不只是<strong>Android</strong>，其他系统上也面临着相同的问题。若要分析其根本原因的话，我觉得主要<strong>是因为空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免</strong>，但即使是最出色的程序员，也不可能将所有潜在的空指针异常全部考虑到。</p><p>先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStudy</span><span class="params">(Study study)</span>&#123;</span><br><span class="line">    study.readBook();</span><br><span class="line">    study.doHomework();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码安全吗？不一定，因为这要取决于调用方传入的参数是什么，如果我们向<code>doStudy()</code>方法传入了一个<code>null</code>参数，那么毫无疑问这里就会发生空指针异常。因此，更加稳妥的做法是<strong>在调用参数的方法之前先进行一个判空处理</strong>，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStudy</span><span class="params">(Study study)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBook();</span><br><span class="line">        study.doHomework();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能保证不管传入的参数是什么，这段代码始终都是安全的。</p><p>由此可以看出，即使是如此简单的一小段代码，都有产生空指针异常的潜在风险，那么在一个大型项目中，想要完全规避空指针异常几乎是不可能的事情，这也是它高居各类崩溃排行榜首位的原因。</p><h3 id="5-1-可空类型系统"><a href="#5-1-可空类型系统" class="headerlink" title="5.1 可空类型系统"></a>5.1 可空类型系统</h3><p>然而，<strong>Kotlin</strong>却非常科学地解决了这个问题，它利用编译时判空检查的机制几乎杜绝了空指针异常。虽然编译时判空检查的机制有时候会导致代码变得比较难写，但是不用担心，<strong>Kotlin</strong>提供了一系列的辅助工具，让我们能轻松地处理各种判空情况。</p><p>是回到刚才的<code>doStudy()</code>函数，现在将这个函数再翻译回<strong>Kotlin</strong>版本，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span>&#123;</span><br><span class="line">    study.readBook()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去和刚才的<strong>Java</strong>版本并没有什么区别，但实际上它是没有空指针风险的，因为Kotlin默认所有的参数和变量都不可为空，所以这里传入的<code>Study</code>参数也一定不会为空，我们可以放心地调用它的任何函数。如果你尝试向<code>doStudy()</code>函数传入一个<strong>null</strong>参数,则它会报错： <code>Null can not be a value of a non-null type Study</code></p><p>也就是说，Kotlin将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那如果我们的业务逻辑就是需要某个参数或者变量为空该怎么办呢？不用担心，<strong>Kotlin</strong>提供了另外一套可为空的类型系统，<strong>只不过在使用可为空的类型系统时，我们需要在编译时期就将所有潜在的空指针异常都处理掉</strong>，否则代码将无法编译通过。</p><p>那么<strong>可为空的类型系统是什么样的呢</strong>？很简单，就是在类名的后面加上一个问号。比如，<strong>Int</strong>表示<strong>不可为空的整型</strong>，而<strong>Int?<strong>就表示</strong>可为空的整型</strong>；<strong>String</strong>表示<strong>不可为空的字符串</strong>，而<strong>String?<strong>就表示</strong>可为空的字符串</strong>。</p><p>回到刚才的<code>doStudy()</code>函数，如果我们希望传入的参数可以为空，那么就应该<strong>将参数的类型由<code>Study</code>改成<code>Study?</code></strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study.readBook()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，现在在调用<code>doStudy()</code>函数时传入<code>null</code>参数，就不会再提示错误了。但是，在<code>doStudy()</code>函数中调用参数的<code>readBooks()</code>和<code>doHomework()</code>方法时，却出现了一个红色下滑线的错误提示，这又是为什么呢？</p><p>由于我们将参数改成了可为空的<code>Study?</code>类型，此时调用参数的<code>readBooks()</code>和<code>doHomework()</code>方法都可能造成空指针异常，因此<strong>Kotlin</strong>在这种情况下不允许编译通过。我们只需要把空指针异常都处理掉就可以了，比如做个判断处理，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBook()</span><br><span class="line">        study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码就可以正常编译通过了，并且还能保证完全不会出现空指针异常。</p><p>为了在编译时期就处理掉所有的空指针异常，通常需要编写很多额外的检查代码才行。如果每处检查代码都使用<code>if</code>判断语句，则会让代码变得比较啰嗦，而且<code>if</code>判断语句还处理不了全局变量的判空问题。为此，<strong>Kotlin</strong>专门提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理.接下来一一学习！</p><h3 id="5-2-判空辅助工具"><a href="#5-2-判空辅助工具" class="headerlink" title="5.2 判空辅助工具"></a>5.2 判空辅助工具</h3><ul><li>首先学习最常用的<code>?.</code>操作符。这个操作符的作用非常好理解，就是<strong>当对象不为空时正常调用相应的方法，当对象为空时则什么都不做</strong>。比如以下的判空处理代码：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>)&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用 <code>?.</code>操作符就可以简化为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>了解了 <code>?.</code>操作符后 <code>doStudy()</code>函数就可以优化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> doStudy(study: Study?)&#123;</span><br><span class="line">    study?.readBook()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这样我们就借助<code>?.</code>操作符将<code>if</code>判断语句去掉了。可能你会觉得使用<code>if</code>语句来进行判空处理也没什么复杂的，那是因为目前的代码还非常简单，当以后我们开发的功能越来越复杂，需要判空的对象也越来越多的时候，你就会觉得<code>?.</code>操作符特别好用了。</p><ul><li>接下来再来学习另外一个非常常用的<code>?:</code>操作符。<strong>这个操作符的左右两边都接收一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</strong>这个操作符和<strong>三目运算符</strong> <code>a ? b : c</code> 类似但又有差异.观察如下代码：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span>(a != <span class="literal">null</span>)&#123;</span><br><span class="line">    a</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用了 <code>?:</code>操作符就可以简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><p>接下来通过一个具体的例子来结合使用 <code>?.</code> 和 <code>?:</code>这两个操作符，从而加深理解。</p><p>比如我们现在编写一个函数用来获得一段文本的长度，传统写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(text != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> text.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于文本是可能为空的，因此我们需要先进行一次判空操作，如果文本不为空就返回它的长度，如果文本为空就返回0。<br>这段代码看上去也并不复杂，但是我们却可以借助操作符让它变得更加简单，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span> = text?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里我们将<code>?.</code>和<code>?:</code>操作符结合到了一起使用，首先由于<code>text</code>是可能为空的，因此我们在调用它的<code>length</code>字段时需要使用<code>?.</code>操作符，而当<code>text</code>为空时，<code>text?.length</code>会返回一个<code>null</code>值，这个时候我们再借助<code>?:</code>操作符让它返回<code>0</code>。</p><p>不过<strong>Kotlin</strong>的空指针检查机制也并非总是那么智能，有的时候我们可能从逻辑上已经将空指针异常处理了，但是<strong>Kotlin</strong>的编译器并不知道，这个时候它还是会编译失败.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content: String? = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(content != <span class="literal">null</span>)&#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = content.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个可为空的全局变量<code>content</code>，然后在<code>main()</code>函数里先进行一次判空操作，当<code>content</code>不为空的时候才会调用<code>printUpperCase()</code>函数，在<code>printUpperCase()</code>函数里，我们将<code>content</code>转换为大写模式，最后打印出来。</p><p>看上去好像逻辑没什么问题，但是很遗憾，这段代码一定是无法运行的。因为<code>printUpperCase()</code>函数并不知道外部已经对<code>content</code>变量进行了非空检查，在调用<code>toUpperCase()</code>方法时，还认为这里存在空指针风险，从而无法编译通过。</p><p>在这种情况下，如果我们想要强行通过编译，可以使用非空断言工具，写法是在对象的后面加上<code>!!</code>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = content!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法就是在告知 <strong>Kotlin</strong>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</p><ul><li>最后我们再来学习一个比较与众不同的辅助工具 — <code>let</code>。 <code>let</code>既不是操作符，也不是什么关键字，而是一个<strong>函数</strong>。这个函数提供了函数式的 <strong>API</strong>的编程接口，并将原始调用对象作为参数传递到 <code>Lambda</code>表达式中。示例代码如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.let &#123; obj2 -&gt;</span><br><span class="line">         <span class="comment">// 具体代码实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里调用了<code>obj</code>对象的<code>let</code>函数，然后<code>Lambda</code>表达式中的代码就会立即执行，并且这个<code>obj</code>对象本身还会作为参数传递到<code>Lambda</code>表达式中。不过，为了防止变量重名，这里我将参数名改成了<code>obj2</code>，但<strong>实际上它们是同一个对象</strong>，这就是<code>let</code>函数的作用。</p><p><code>let</code>函数属于<strong>Kotlin</strong>中的标准函数，那这个<code>let</code>函数和空指针检查有什么关系呢？其实<code>let</code>函数的特性配合<code>?.</code>操作符可以在空指针检查的时候起到很大的作用。</p><p>就回到上面的 <code>doStudy()</code>函数当中，目前代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> doStudy(study: Study?)&#123;</span><br><span class="line">    study?.readBook()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这段代码我们通过<code>?.</code>操作符优化之后可以正常编译通过，但其实这种表达方式是有点啰嗦的，如果将这段代码准确翻译成使用<code>if</code>判断语句的写法，对应的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> doStudy(study: Study?)&#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBook()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，本来我们进行一次<code>if</code>判断就能随意调用<code>study</code>对象的任何方法，但受制于<code>?.</code>操作符的限制，现在变成了每次调用<code>study</code>对象的方法时都要进行一次<code>if</code>判断。<br>这个时候就可以结合使用<code>?.</code>操作符和<code>let</code>函数来对代码进行优化了，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.let &#123; stu -&gt;</span><br><span class="line">        stu.readBook()</span><br><span class="line">        stu.doHomeworl()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的意思是，<code>?.</code>操作符表示对象为空时什么都不做，对象不为空时就调用<code>let</code>函数，而<code>let</code>函数会将<code>study</code>对象本身作为参数传递到<code>Lambda</code>表达式中，此时的<code>study</code>对象肯定不为空了，我们就能放心地调用它的任意方法了。</p><p>外还记得<code>Lambda</code>表达式的语法特性吗？<strong>当<code>Lambda</code>表达式的参数列表中只有一个参数时</strong>，可以不用声明参数名，直接使用<code>it</code>关键字来代替即可，那么代码就可以进一步简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span>&#123;</span><br><span class="line">    study?.let &#123;</span><br><span class="line">        it.readBook()</span><br><span class="line">        it.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code>函数是可以处理全局变量的判空问题的，而<code>if</code>判断语句则无法做到这一点。比如我们将<code>doStudy()</code>函数中的参数变成一个全局变量，使用<code>let</code>函数仍然可以正常工作，但使用 <code>if</code>判断句则会提示错误。</p><hr><h2 id="六、Kotlin中的小魔术"><a href="#六、Kotlin中的小魔术" class="headerlink" title="六、Kotlin中的小魔术"></a>六、Kotlin中的小魔术</h2><p>其实就是一些<strong>Kotlin</strong>小技巧啦~</p><h3 id="6-1-字符串内嵌表达式"><a href="#6-1-字符串内嵌表达式" class="headerlink" title="6.1 字符串内嵌表达式"></a>6.1 字符串内嵌表达式</h3><p><code>Kotlin</code>从一开始就支持了字符串内嵌表达式的功能，可以直接将表达式写在字符串里面，即使是构建非常复杂的字符串，也会变得轻而易举。</p><p>首先来看一下<code>Kotlin</code>中字符串内嵌表达式的语法规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello, <span class="subst">$&#123;obj.name&#125;</span>. nice to meet u&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，<strong>Kotlin</strong>允许我们在字符串里嵌入<code>$&#123;&#125;</code>这种语法结构的表达式，并在运行时使用表达式执行的结果替代这一部分内容。另外，当表达式中仅有一个变量的时候，还可以将两边的大括号省略，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello <span class="variable">$name</span> . nice to meet u&quot;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-函数的参数默认值"><a href="#6-2-函数的参数默认值" class="headerlink" title="6.2 函数的参数默认值"></a>6.2 函数的参数默认值</h3><p>其实之前在学习次构造函数用法的时候我就提到过，次构造函数在<strong>Kotlin</strong>中很少用，因为<strong>Kotlin</strong>提供了给函数设定参数默认值的功能，它在很大程度上能够替代次构造函数的作用。<br>具体来讲，我们可以在定义函数的时候给任意参数设定一个默认值，这样当调用此函数时就不会强制要求调用方为此参数传值，在没有传值的情况下会自动使用参数的默认值。<br>给参数设定默认值的方式也很简单，观察如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span>, str: <span class="type">String</span> = <span class="string">&quot;hello&quot;</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;num is <span class="variable">$num</span>, str is <span class="variable">$str</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printParams(<span class="number">123</span>)</span><br><span class="line">    printParams(<span class="number">123</span>,<span class="string">&quot;Charlie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里我们给<code>printParams()</code>函数的第二个参数设定了一个默认值，这样当调用<code>printParams()</code>函数时，可以选择给第二个参数传值，也可以选择不传，在不传的情况下就会自动使用默认值。</p><p>而如果我们想要 <code>printParams()</code>中的 <code>num</code>参数使用默认值应该怎么写呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span> = <span class="number">100</span>, str: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;num is <span class="variable">$num</span>, str is <span class="variable">$str</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数像上面这样写是没有问题的，那么我们该如何调用呢？模仿刚才的写法肯定是行不通的，因为编译器会认为我们想把字符串赋值给第一个<code>num</code>参数，从而报类型不匹配的错误。</p><p>不过不用担心，<strong>Kotlin</strong>提供了另外一种神奇的机制，就是可以通过键值对的方式来传参，从而不必像传统写法那样按照参数定义的顺序来传参。比如调用<code>printParams()</code>函数，我们还可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printParams(str = <span class="string">&quot;world&quot;</span>, num = <span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>此时哪个参数在前哪个参数在后都无所谓，<strong>Kotlin</strong>可以准确地将参数匹配上。而使用这种键值对的传参方式之后，我们就可以省略<code>num</code>参数了.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span> = <span class="number">100</span>, str: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;num is <span class="variable">$num</span>, str is <span class="variable">$str</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printParams(str = <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经掌握了如何给函数设定参数默认值，那么为什么说这个功能可以在很大程度上替代次构造函数的作用呢？</p><p>回忆一下当初我们学习次构造函数时所编写的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中有一个主构造函数和两个次构造函数，次构造函数在这里的作用是提供了使用更少参数来对Student类进行实例化的方式。无参的次构造函数会调用两个参数的次构造函数，并将这两个参数赋值成初始值。两个参数的次构造函数会调用4个参数的主构造函数，并将缺失的两个参数也赋值成初始值。<br>这种写法在Kotlin中其实是不必要的，因为我们完全可以通过只编写一个主构造函数，然后给参数设定默认值的方式来实现，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String = <span class="string">&quot;&quot;</span>, <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span>, name: String = <span class="string">&quot;&quot;</span>, age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kotlin入门&quot;&gt;&lt;a href=&quot;#Kotlin入门&quot; class=&quot;headerlink&quot; title=&quot;Kotlin入门&quot;&gt;&lt;/a&gt;Kotlin入门&lt;/h1&gt;&lt;h2 id=&quot;一、变量和函数&quot;&gt;&lt;a href=&quot;#一、变量和函数&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kotlin" scheme="https://icu007work.github.io/tags/Kotlin/"/>
    
    <category term="编程入门" scheme="https://icu007work.github.io/tags/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>语雀同款链接卡片—butterfly主题标签外挂</title>
    <link href="https://icu007work.github.io/archives/9765c01a.html"/>
    <id>https://icu007work.github.io/archives/9765c01a.html</id>
    <published>2023-08-03T07:02:03.000Z</published>
    <updated>2023-08-23T03:20:38.019Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考自：</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://blog.leonus.cn/favicon.ico">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(进一寸有进一寸的欢喜。);"></div>        <div class="tag-link-right">            <div class="tag-link-title">https://blog.leonus.cn/2022/link-card.html</div>            <div class="tag-link-sitename">Leonus</div>        </div>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>    </div>    </a></div><p>样式如下：</p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://icu007.work/wp-content/uploads/2022/08/icno.png">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(与君共赴，万里征程);"></div>        <div class="tag-link-right">            <div class="tag-link-title">https://icu007.work</div>            <div class="tag-link-sitename">Charlie_l</div>        </div>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>    </div>    </a></div><h3 id="link-js"><a href="#link-js" class="headerlink" title="link.js"></a>link.js</h3><p>在 <code>\themes\butterfly\scripts\tag</code> 文件夹下面新建 <code>link.js</code> 并粘贴如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">JS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * link</span></span><br><span class="line"><span class="comment"> * &#123;% link url,title,favicon,desc %&#125;</span></span><br><span class="line"><span class="comment"> * &#123;% link 链接,标题,图标,介绍 %&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">link</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    args = args.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> url = (args[<span class="number">0</span>] || <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>(),</span><br><span class="line">        title = (args[<span class="number">1</span>] || <span class="string">&#x27;点击直达链接&#x27;</span>).<span class="title function_">trim</span>(),</span><br><span class="line">        favicon = (args[<span class="number">2</span>] ? <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;args[<span class="number">2</span>]&#125;</span>&quot; class=&quot;no-lightbox&quot;&gt;`</span> : defaultIcon).<span class="title function_">trim</span>(),</span><br><span class="line">        desc = (args[<span class="number">3</span>] || <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;url&#125;</span>&quot; <span class="subst">$&#123;url.includes(<span class="string">&#x27;http&#x27;</span>)?<span class="string">&#x27;target=&quot;_blank&quot;&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span> title=&quot;<span class="subst">$&#123;title&#125;</span>&quot; referrerPolicy=&quot;no-referrer&quot; class=&quot;link_card&quot;&gt;&lt;div class=&quot;link_icon&quot;&gt;<span class="subst">$&#123;favicon&#125;</span>&lt;/div&gt;&lt;div class=&quot;link_content&quot;&gt;&lt;div class=&quot;link_title&quot;&gt;<span class="subst">$&#123;title&#125;</span>&lt;/div&gt;<span class="subst">$&#123;desc?<span class="string">`&lt;div class=&quot;link_desc&quot;&gt;<span class="subst">$&#123;desc&#125;</span>&lt;/div&gt;`</span>:<span class="string">&#x27;&#x27;</span>&#125;</span>&lt;/div&gt;&lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(<span class="string">&#x27;link&#x27;</span>, link, &#123; <span class="attr">ends</span>: <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="link-styl"><a href="#link-styl" class="headerlink" title="link.styl"></a>link.styl</h3><p>在 <code>\themes\butterfly\source\css\_tags</code> 文件夹下面新建 <code>link.styl</code> 并粘贴如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.link_card</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  margin: <span class="number">10px</span> <span class="number">0</span></span><br><span class="line">  color: <span class="built_in">var</span>(--font-color) <span class="meta">!important</span></span><br><span class="line">  text-decoration: none <span class="meta">!important</span></span><br><span class="line">  background: <span class="built_in">var</span>(--reward-pop)</span><br><span class="line">  border-radius: <span class="number">10px</span></span><br><span class="line">  padding: <span class="number">12px</span></span><br><span class="line">  &amp;:hover</span><br><span class="line">    background: <span class="number">#4976f5</span></span><br><span class="line">    color: white <span class="meta">!important</span></span><br><span class="line">  .link_icon,.link_content</span><br><span class="line">    height: <span class="number">4rem</span></span><br><span class="line">  .link_icon</span><br><span class="line">    img,svg</span><br><span class="line">      height: <span class="number">4rem</span></span><br><span class="line">      width: <span class="number">4rem</span></span><br><span class="line">  .link_content</span><br><span class="line">    margin-left: <span class="number">1rem</span></span><br><span class="line">    width: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">6rem</span>)</span><br><span class="line">    overflow: hidden</span><br><span class="line">    line-height: <span class="number">1.5</span></span><br><span class="line">    display: flex</span><br><span class="line">    flex-direction: column</span><br><span class="line">    justify-content: center</span><br><span class="line">    .link_title</span><br><span class="line">      font-weight: bold</span><br><span class="line">      font-size: <span class="number">1.2rem</span></span><br><span class="line">    .link_title,.link_desc</span><br><span class="line">      word-break: break-all</span><br><span class="line">      overflow:hidden</span><br><span class="line">      text-overflow: ellipsis</span><br><span class="line">    &amp;:<span class="built_in">not</span>(:<span class="built_in">has</span>(.link_desc)) .link_title</span><br><span class="line">      display:-webkit-box</span><br><span class="line">      -webkit-box-orient:vertical</span><br><span class="line">      -webkit-line-clamp:<span class="number">2</span></span><br><span class="line">    .link_desc</span><br><span class="line">      opacity: .<span class="number">6</span></span><br><span class="line">    .link_desc,&amp;:<span class="built_in">has</span>(.link_desc) .link_title</span><br><span class="line">      white-space: nowrap</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>注意：<code>内容不能有英文逗号</code>，不然会出bug</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用html是为了高亮代码，不必在意 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参数如下： --&gt;</span></span><br><span class="line">&#123;% link 链接,标题,图标,介绍 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 示例如下： --&gt;</span></span><br><span class="line">&#123;% link https://blog.leonus.cn/,Leonus,https://blog.leonus.cn/favicon.ico,进一寸有进一寸的欢喜。 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 你也可以什么都不填，将会全部使用默认值，如下： --&gt;</span></span><br><span class="line">&#123;% card %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 你也可以省略部分内容，如下： --&gt;</span></span><br><span class="line">&#123;% link https://blog.leonus.cn/ %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 位置在后面的参数不填的话可以直接省略，但是如果中间的不想填必须留空，如下： --&gt;</span></span><br><span class="line">&#123;% link https://blog.leonus.cn/,,,进一寸有进一寸的欢喜。 %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>链接</td><td>如果连接中包含http则新标签打开，否则本标签页打开</td><td>无</td></tr><tr><td>标题</td><td>网站的标题</td><td>点击直达链接</td></tr><tr><td>图标</td><td>网站favicon<code>链接</code></td><td></td></tr><tr><td>介绍</td><td>网站的description</td><td>无</td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有什么问题可以留言，也可以根据自身需求进行修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考自：&lt;/p&gt;
&lt;div calss=&#39;anzhiyu-tag-link&#39;&gt;&lt;a class=&quot;tag-Link&quot; target=&quot;_blank&quot; href=&quot;https://blog.leonus.cn/favicon.ico&quot;&gt;
    &lt;div class=&quot;t</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA使用技巧</title>
    <link href="https://icu007work.github.io/archives/419d96b2.html"/>
    <id>https://icu007work.github.io/archives/419d96b2.html</id>
    <published>2023-07-29T07:30:11.000Z</published>
    <updated>2023-08-23T07:57:43.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA使用技巧"><a href="#IDEA使用技巧" class="headerlink" title="IDEA使用技巧"></a>IDEA使用技巧</h1><h2 id="一、入门导览"><a href="#一、入门导览" class="headerlink" title="一、入门导览"></a>一、入门导览</h2><ul><li>按住 <code>Alt + 1</code>即可打开项目视图，双击源码即可打开文件。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/4fa81c51a8b5b.png" alt="1690527585832.png"></p><ul><li>按下<code>Shift + F10</code> 即可运行项目，旁边的小虫子即为调试模式-</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/5b7369330558a.png" alt="1690527632047.png"></p><ul><li>在<code>for循环</code>处，按下 <code>Alt + Enter</code>即可将<code>for循环</code>优化为<code>增强for循环</code>，在打印语句中按下 <code>Alt + Enter</code>即可 <code>+</code> 号替换成 <code>String.format</code></li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/5d8a51a96c98e.png" alt="1690528026893.png"><img src="https://pic.ziyuan.wang/2023/07/28/da96868e287cd.png" alt="1690528134066.png"></p><ul><li>双击 <code>Shift</code>即可触发全局搜索。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/0096bcd4dc133.png" alt="1690528240450.png"></p><hr><h2 id="二、基本"><a href="#二、基本" class="headerlink" title="二、基本"></a>二、基本</h2><h3 id="2-1-上下文操作"><a href="#2-1-上下文操作" class="headerlink" title="2.1 上下文操作"></a>2.1 上下文操作</h3><ul><li>同样的在需要操作的代码处，按下 <code>Alt + Enter</code>即可显示上下文操作。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/9e4ae19c8e262.png" alt="1690528356924.png"></p><p><img src="https://pic.ziyuan.wang/2023/07/28/536470d6d8bdb.png" alt="1690528461547.png"></p><hr><h3 id="2-2-搜索操作"><a href="#2-2-搜索操作" class="headerlink" title="2.2 搜索操作"></a>2.2 搜索操作</h3><ul><li>可以按下 <code>Ctrl + Shift + A</code> 或连按两次 <code>Shift</code>触发搜索。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a34515b5d40dc.png" alt="1690528644744.png"></p><ul><li><code>Ctrl + N</code>搜索类， <code>Ctrl + Q</code> 预览所选类的文档</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a2928125e6403.png" alt="1690528829830.png"></p><ul><li>总结<ul><li><code>Ctrl + N</code>：搜索类</li><li><code>Ctrl + Shift + N</code>：搜索文件</li><li><code>Ctrl + Shift + Alt + N</code>：搜索符号</li><li><code>Ctrl + Shift + A</code>：搜索操作</li><li>双击 <code>Shift</code>：全局搜索</li></ul></li></ul><hr><h3 id="2-3-基本补全"><a href="#2-3-基本补全" class="headerlink" title="2.3 基本补全"></a>2.3 基本补全</h3><ul><li><code>Ctrl + 空格</code>：触发基本补全，<code>Ctrl + Shift + Enter</code>：补全当前语句。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/07a5fa14fea3b.png" alt="1690529434725.png"></p><ul><li><code>Ctrl + 两次空格</code>：查看有关静态变量或方法的建议</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/4f7170be5a781.png" alt="1690529682757.png"></p><hr><h2 id="三、编辑器基础知识"><a href="#三、编辑器基础知识" class="headerlink" title="三、编辑器基础知识"></a>三、编辑器基础知识</h2><h3 id="3-1-扩展和收缩代码选取"><a href="#3-1-扩展和收缩代码选取" class="headerlink" title="3.1 扩展和收缩代码选取"></a>3.1 扩展和收缩代码选取</h3><ul><li><p>按 <code>Ctrl + W</code>可选择文本光标处的单词。</p></li><li><p>再次按<code>Ctrl + W</code>可选择整个字符串。</p></li><li><p>第三次按<code>Ctrl + W</code>以在选择中添加引号。</p></li><li><p>再按<code>Ctrl + W</code>两次可选择整个调用。</p></li><li><p>如果要选择它的实参，而不是选择整个调用。可按 <code>Ctrl + Shift + W</code> 将选区收缩到实参。</p></li><li><p>在if语句的开头。可按两次 <code>Ctrl + W</code> 将其选中。只需按几下，即可很好地将关键字作为选择对应语句的一个起点。</p></li><li><p>总结：<code>Ctrl + W</code>：扩选 ； <code>Ctrl + Shift + W</code>：缩选。</p></li></ul><hr><h3 id="3-2-注释行和代码块"><a href="#3-2-注释行和代码块" class="headerlink" title="3.2 注释行和代码块"></a>3.2 注释行和代码块</h3><ul><li><code>Ctrl + /</code>： 单行注释&#x2F;取消单行注释</li><li><code>Ctrl + Shift + /</code>：多行注释&#x2F;取消多行注释</li></ul><hr><h3 id="3-3-复制和删除行"><a href="#3-3-复制和删除行" class="headerlink" title="3.3 复制和删除行"></a>3.3 复制和删除行</h3><ul><li><code>Ctrl + D</code>： 复制光标所在行</li><li><code>Ctrl + Y</code>： 删除光标所在行</li><li><code>Ctrl + ↑</code>： 向上选择</li></ul><hr><h3 id="3-4-移动代码段"><a href="#3-4-移动代码段" class="headerlink" title="3.4 移动代码段"></a>3.4 移动代码段</h3><ul><li><code>Alt + Shift + ↑</code>： 当前行向上移动</li><li><code>Alt + Shift + ↓</code>： 当前行向下移动</li><li><code>Ctrl + Shift + ↑</code>： 当前整个方法向上移动</li><li><code>Ctrl + Shift + ↓</code>： 当前整个方法向下移动</li></ul><hr><h3 id="3-5-收起代码块"><a href="#3-5-收起代码块" class="headerlink" title="3.5 收起代码块"></a>3.5 收起代码块</h3><ul><li><code>Ctrl + -</code>：收起当前代码块</li><li><code>Ctrl + =</code>：展开当前代码块</li><li><code>Ctrl + Shift + -</code>：收起文件中的所有区域</li><li><code>Ctrl + Shift + =</code>：展开文件中的所有区域</li></ul><hr><h3 id="3-6-包围和解包"><a href="#3-6-包围和解包" class="headerlink" title="3.6 包围和解包"></a>3.6 包围和解包</h3><ul><li><code>Ctrl + Alt + T</code>：使用一些模板代码包围代码段</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/ed25d369395be.png" alt="1690532033070.png"></p><ul><li><code>Ctrl + Alt + Delete</code>：解除模板代码包围</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/b6e236a6d4e9b.png" alt="1690532082762.png"></p><hr><h3 id="3-7-多选"><a href="#3-7-多选" class="headerlink" title="3.7 多选"></a>3.7 多选</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Multiple selections<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Firstname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Lastname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Points<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Eve<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Jackson<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>94<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>按 <code>Alt + J</code>可选择文本光标处的符号</li><li>再次按<code>Alt + J</code>可选择此符号的下一个匹配项</li><li>按 <code>AIt + Shift + J</code>可取消选择上一个匹配项</li><li>按 <code>Ctrl + Alt + Shift + L</code>可选择文件中的所有匹配项。</li><li>键入 <code>td</code>，将 <code>th</code>的所有匹配项替换为<code>td</code></li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/02a63a138c362.png" alt="1690532511051.png"></p><hr><h2 id="四、代码补全"><a href="#四、代码补全" class="headerlink" title="四、代码补全"></a>四、代码补全</h2><h3 id="4-1-基本补全"><a href="#4-1-基本补全" class="headerlink" title="4.1 基本补全"></a>4.1 基本补全</h3><ul><li><code>Ctrl + 空格</code>：触发基本补全，<code>Ctrl + Shift + Enter</code>：补全当前语句。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/07a5fa14fea3b.png" alt="1690529434725.png"></p><ul><li><code>Ctrl + 两次空格</code>：查看有关静态变量或方法的建议</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/4f7170be5a781.png" alt="1690529682757.png"></p><hr><h3 id="4-2-类型匹配补全"><a href="#4-2-类型匹配补全" class="headerlink" title="4.2 类型匹配补全"></a>4.2 类型匹配补全</h3><ul><li><code>Ctrl + Shift + 空格</code>：查看匹配当前类型的建议列表</li><li><code>Ctrl + Shift + 空格</code>还可以为 <code>return</code>提供代码建议</li></ul><hr><h3 id="4-3-后缀补全"><a href="#4-3-后缀补全" class="headerlink" title="4.3 后缀补全"></a>4.3 后缀补全</h3><ul><li>后缀补全有助于在编写代码时减少向后跳转文本光标。使用它可以根据添加的后缀、表达式的类型及其上下文，将已键入的表达式转换另一种表达式。 在圆括号后面键入<code>.</code>，以查看后缀补全建议列表。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/ed61e269d482d.png" alt="1690534971158.png"></p><hr><h3 id="4-4-语句补全"><a href="#4-4-语句补全" class="headerlink" title="4.4 语句补全"></a>4.4 语句补全</h3><ul><li><code>Ctrl + Shift + Enter</code>：可以补全类似 <code>for</code> 、 <code>if</code> 、 <code>switch</code>等语句</li></ul><hr><h3 id="4-5-Tab补全"><a href="#4-5-Tab补全" class="headerlink" title="4.5 Tab补全"></a>4.5 Tab补全</h3><ul><li>所有补全都可以搭配<code>Tab</code>使用</li></ul><hr><h2 id="五、重构"><a href="#五、重构" class="headerlink" title="五、重构"></a>五、重构</h2><h3 id="5-1-重命名"><a href="#5-1-重命名" class="headerlink" title="5.1 重命名"></a>5.1 重命名</h3><ul><li><code>Shift + F6</code>：重命名<strong>所有与选中内容一致</strong>的代码。</li></ul><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20230728173111078.png" alt="image-20230728173111078"></p><ul><li>IDEA还会检测相应的 getter&#x2F;setter，并提出相应的重命名建议。</li></ul><hr><h3 id="5-2-提取变量"><a href="#5-2-提取变量" class="headerlink" title="5.2 提取变量"></a>5.2 提取变量</h3><ul><li><code>Ctrl + Alt + V</code>：可以提取局部变量，并且会自动匹配代码中所有与选中变量一致的变量。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a845344f7a8ef.png" alt="1690536888565.png"></p><hr><h3 id="5-3-提取方法"><a href="#5-3-提取方法" class="headerlink" title="5.3 提取方法"></a>5.3 提取方法</h3><ul><li><code>Ctrl + Alt + M</code>：将所选代码块提取为方法</li></ul><hr><h3 id="5-4-重构菜单"><a href="#5-4-重构菜单" class="headerlink" title="5.4 重构菜单"></a>5.4 重构菜单</h3><ul><li><code>Ctrl + Shift + Alt + T</code>：列出当前上下文中可用的所有重构</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/a0c80aecc4800.png" alt="1690537208428.png"></p><hr><h2 id="六、代码辅助"><a href="#六、代码辅助" class="headerlink" title="六、代码辅助"></a>六、代码辅助</h2><h3 id="6-1-还原移除的代码"><a href="#6-1-还原移除的代码" class="headerlink" title="6.1 还原移除的代码"></a>6.1 还原移除的代码</h3><ul><li>假设开发过程中需要还原先前删除的代码。因为此后发生了多项更改，撤消不起作用，而此时又不希望丢失这些更改。可点击几次 <strong>本地历史记录</strong> 来还原已删除的代码。在编辑器中的任意位置点击鼠标右键即可打开上下文菜单。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/496d7ecb83c99.png" alt="1690537789293.png"></p><hr><h3 id="6-2-格式化代码"><a href="#6-2-格式化代码" class="headerlink" title="6.2 格式化代码"></a>6.2 格式化代码</h3><ul><li><code>Ctrl + Alt + L</code>：更正代码格式，若有选中的代码则更正当前选中的代码；若未选中代码，则重新格式化整个文件。</li><li><code>Ctrl + Alt + Shift + L</code>：显示重新格式化设置</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/c2d55dddcfde6.png" alt="1690538025154.png"></p><hr><h3 id="6-3-形参信息"><a href="#6-3-形参信息" class="headerlink" title="6.3 形参信息"></a>6.3 形参信息</h3><ul><li><code>Ctrl + P</code>：查看方法签名</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/d8f002a921c1f.png" alt="1690538025154.png"></p><hr><h3 id="6-4-快速弹出窗口"><a href="#6-4-快速弹出窗口" class="headerlink" title="6.4 快速弹出窗口"></a>6.4 快速弹出窗口</h3><ul><li>按 <code>Ctrl + Q</code>可查看文本光标处符号的文档。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/8fde9ce454399.png" alt="1690538637711.png"></p><ul><li>按<code>Ctrl + Shift + l</code> 可查看文本光标处符号的定义。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/28/6551090e183d2.png" alt="1690538613744.png"></p><hr><h3 id="6-5-编辑器编码辅助"><a href="#6-5-编辑器编码辅助" class="headerlink" title="6.5 编辑器编码辅助"></a>6.5 编辑器编码辅助</h3><ul><li><code>F2</code>： 转到文件中下一个高亮显示的错误。</li><li><code>Ctrl F1</code>：展开警告说明。</li><li>另一种有用的工具是高亮显示用法。按 <code>Ctrl + Shift + F7</code> 可高亮显示文件中文本光标处符号的所有用法。</li></ul><hr><h2 id="七、导航"><a href="#七、导航" class="headerlink" title="七、导航"></a>七、导航</h2><h3 id="7-1-随处搜索"><a href="#7-1-随处搜索" class="headerlink" title="7.1 随处搜索"></a>7.1 随处搜索</h3><ul><li><code>Ctrl + N</code>：搜索类</li><li><code>Ctrl + Shift + N</code>：搜索文件</li><li><code>Ctrl + Shift + Alt + N</code>：搜索符号</li><li><code>Ctrl + Shift + A</code>：搜索操作</li><li>双击 <code>Shift</code>：全局搜索</li></ul><hr><h3 id="7-2-查找与替换"><a href="#7-2-查找与替换" class="headerlink" title="7.2 查找与替换"></a>7.2 查找与替换</h3><ul><li><code>Ctrl + Shift + F</code>：全局搜索</li><li><code>Ctrl + Shift + R</code>：打开 在文件中替换窗口</li></ul><hr><h3 id="7-3-文件重构"><a href="#7-3-文件重构" class="headerlink" title="7.3 文件重构"></a>7.3 文件重构</h3><ul><li><code>Ctrl + F12</code>：打开文件结构，打开后可键入单词以查找相关方法。</li><li><code>Alt + 7</code>：将文件结构显示为工具窗口</li></ul><hr><h3 id="7-4-声明和用法"><a href="#7-4-声明和用法" class="headerlink" title="7.4 声明和用法"></a>7.4 声明和用法</h3><ul><li><code>Ctrl + B</code>：在方法调用处，按下可跳转到方法声明</li><li><code>Ctrl + B</code>：在方法声明处，按下可查看其所有用法。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/3929cedb1b7c9.png" alt="1690599111074.png"></p><ul><li><code>Alt + F7</code>：查看更详细的用法视图，浏览完后按<code>Shift + Esc</code>：隐藏视图，按 <code>Alt + 3</code>：再次打开查找视图</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/5d41571606bd4.png" alt="1690599187782.png"></p><hr><h3 id="7-5-继承层次结构"><a href="#7-5-继承层次结构" class="headerlink" title="7.5 继承层次结构"></a>7.5 继承层次结构</h3><ul><li><code>Ctrl + Alt + B</code>：查找某个接口的实现</li><li><code>Ctrl + U</code>：从派生导航到 <code>super</code>方法</li><li><code>Ctrl + H</code>：查看某个类的层次结构</li><li><code>Ctrl + Shift + H</code>：查看某个方法的层次结构</li><li>注意：也可以对类执行 <code>Ctrl + Alt + B</code>和<code>Ctrl + U</code>操作</li></ul><hr><h3 id="7-6-最近的文件和位置"><a href="#7-6-最近的文件和位置" class="headerlink" title="7.6 最近的文件和位置"></a>7.6 最近的文件和位置</h3><ul><li><code>Ctrl + E</code>：显示最近打开的文件</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/5ce656e84c878.png" alt="1690600123613.png"></p><ul><li><code>Ctrl + Shift + E</code>：显示最近打开文件内的代码视图</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/4455b3f3dbcd9.png" alt="1690600156977.png"></p><hr><h3 id="7-7-下一个-上一个匹配项"><a href="#7-7-下一个-上一个匹配项" class="headerlink" title="7.7 下一个&#x2F;上一个匹配项"></a>7.7 下一个&#x2F;上一个匹配项</h3><ul><li><code>Ctrl + F</code>：在当前文件中执行全文搜索。</li><li><code>F3 / Enter</code>：查找下一个匹配项</li><li><code>Shift + F3</code>：跳转到上一个匹配项</li><li>注意，在查找面板关闭的情况下仍可使用上述快捷键跳转匹配项</li></ul><hr><h2 id="八、运行并调试"><a href="#八、运行并调试" class="headerlink" title="八、运行并调试"></a>八、运行并调试</h2><h3 id="8-1-运行配置"><a href="#8-1-运行配置" class="headerlink" title="8.1 运行配置"></a>8.1 运行配置</h3><ul><li>点击代码左上角的<img src="https://pic.ziyuan.wang/2023/07/29/eb27041a07a1a.png" alt="1690600625871.png">是创建一个临时运行配置</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/759a51529fa14.png" alt="1690600566371.png"></p><ul><li>我们可以选择保存配置，这样配置就保存为 <code>Sample with parameters</code>了</li></ul><p><img src="C:\Users\Charlie\AppData\Roaming\Typora\typora-user-images\image-20230729111841097.png" alt="image-20230729111841097"></p><p><img src="https://pic.ziyuan.wang/2023/07/29/436ab8e60a59c.png" alt="1690600750761.png"></p><ul><li>要使同事可以访问运行配置，可将其存储为单独的文件并通过版本控制系统共享此文件。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/e48b5ab33a1cd.png" alt="1690600509040.png"></p><h3 id="8-2-调试工作流"><a href="#8-2-调试工作流" class="headerlink" title="8.2 调试工作流"></a>8.2 调试工作流</h3><ul><li><code>Ctrl + F8</code>：在当前行打断点</li><li><code>Shift + F9</code>：使用当前所选运行配置开始调试</li><li>调试时可以在搜索框调用函数表达式来检查某个函数是否抛出异常。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/9687714379594.png" alt="1690604094195.png"></p><ul><li>当表达式导致异常时 可点击<img src="https://pic.ziyuan.wang/2023/07/29/f00e7417cfe29.png" alt="1690611152951.png">或者按下 <code>Ctrl + Shift + A</code>将该表达式添加到监听。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/fc6b03ae7bbbc.png" alt="1690611103971.png"></p><ul><li><code>F7</code>： 步入</li><li><code>F8</code>： 步过</li><li><code>F9</code>： 恢复程序</li><li><code>Shift + F8</code>: 步出</li><li><code>Ctrl + Alt + F8</code>： 为所选实参调用“对表达式快速求值”</li><li>我们可以在修复后重新运行我们的小程序，但是对于大程序，重新运行可能需要很长时间。如果修复只影响纯方法，我们可以重新构建项目并应用热交换，而不是重新运行。按 <code>Ctrl + F9</code> 构建项目。</li><li><code>Alt + F9</code>： 执行程序直到文本光标所在的行。</li></ul><hr><h2 id="九、Git"><a href="#九、Git" class="headerlink" title="九、Git"></a>九、Git</h2><h3 id="9-1-快速入门"><a href="#9-1-快速入门" class="headerlink" title="9.1 快速入门"></a>9.1 快速入门</h3><ul><li>双击 <code>Shift</code>并搜索克隆 打开克隆视图，输入URL即可克隆任意public git仓库的代码</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/6341ad8d942c7.png" alt="1690614101281.png"></p><ul><li><code>Ctrl + Alt + N</code>：新建分支</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/caf261acd55be.png" alt="1690614259677.png"></p><ul><li>提交界面</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/d702ab66db582.png" alt="1690614333074.png"></p><ul><li><code>Ctrl + Shift + K</code>： 推送代码</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/7c3a22be6d469.png" alt="1690614382744.png"></p><hr><h3 id="9-2-项目历史记录"><a href="#9-2-项目历史记录" class="headerlink" title="9.2 项目历史记录"></a>9.2 项目历史记录</h3><ul><li><code>Alt + 9</code>：打开Git工具窗口</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/8d86935cfafae.png" alt="1690614558981.png"></p><hr><h3 id="9-3-提交"><a href="#9-3-提交" class="headerlink" title="9.3 提交"></a>9.3 提交</h3><ul><li><code>Ctrl + K</code>: 打开提交工具窗口</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/5717b7cf44ec8.png" alt="1690614724472.png"></p><ul><li><code>Alt + 9</code> 打开Git工具窗口即可看到提交</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/29/ae562005aa6ff.png" alt="1690614842835.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDEA使用技巧&quot;&gt;&lt;a href=&quot;#IDEA使用技巧&quot; class=&quot;headerlink&quot; title=&quot;IDEA使用技巧&quot;&gt;&lt;/a&gt;IDEA使用技巧&lt;/h1&gt;&lt;h2 id=&quot;一、入门导览&quot;&gt;&lt;a href=&quot;#一、入门导览&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="IDEA" scheme="https://icu007work.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 4(4143)注册方法</title>
    <link href="https://icu007work.github.io/archives/9491d997.html"/>
    <id>https://icu007work.github.io/archives/9491d997.html</id>
    <published>2023-07-26T03:54:24.000Z</published>
    <updated>2023-08-23T07:57:28.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sublime-Text-4-4143-注册方法"><a href="#Sublime-Text-4-4143-注册方法" class="headerlink" title="Sublime Text 4(4143)注册方法"></a>Sublime Text 4(4143)注册方法</h2><p>截止2023年7月26日，最新版本是Sublime Text 4 (Build 4143)。注册方法如下：</p><ul><li>安装软件：去官方站点下载并安装 Sublime Text - <a href="https://www.sublimetext.com/">Text Editing, Done Right</a></li><li>使用浏览器打开网站：<a href="https://hexed.it/">https://hexed.it/</a> ，点击打开文件，打开Sublime Text安装目录选择文件 sublime_text.exe</li><li>在 <strong>搜索</strong> 中输入：807805000f94c1 按回车键Enter</li><li>选中 <strong>启用替换</strong> ，在 <strong>替换为</strong> 输入c64005014885c9 点击Replace即可</li><li>点击 <strong>另存为</strong> ，保存文件到本地，文件名设定为sublime_text<br><img src="https://pic.ziyuan.wang/2023/07/26/385db4c3a936f.png" alt="1690344313607.png"></li><li>备份原sublime_text.exe文件（修改为如sublime_text_bk.exe）</li><li>将修改过的sublime_text.exe复制到原sublime text 4安装目录中即可<br>这样就激活成功了，打开Sublime Text之后，可以看到 “ Registered ” 的提示。</li></ul><p><img src="https://pic.ziyuan.wang/2023/07/26/778d98efbc375.png" alt="1690344350428.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sublime-Text-4-4143-注册方法&quot;&gt;&lt;a href=&quot;#Sublime-Text-4-4143-注册方法&quot; class=&quot;headerlink&quot; title=&quot;Sublime Text 4(4143)注册方法&quot;&gt;&lt;/a&gt;Sublime Text 4</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Win FR:一款数据恢复工具</title>
    <link href="https://icu007work.github.io/archives/2940757f.html"/>
    <id>https://icu007work.github.io/archives/2940757f.html</id>
    <published>2023-05-23T07:31:47.000Z</published>
    <updated>2023-08-23T07:57:14.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、官方工具"><a href="#一、官方工具" class="headerlink" title="一、官方工具"></a>一、官方工具</h2><blockquote><p>商店页面：<a href="https://www.microsoft.com/store/productId/9N26S50LN705">https://www.microsoft.com/store/productId/9N26S50LN705</a></p></blockquote><ul><li>通常文件被删除后，数据还会残留在硬盘中一段时间，用数据恢复工具就有概率能够恢复文件。而微软就出品了一款数据恢复相关的工具 Windows File Recovery，相当不错！</li></ul><p><img src="http://p1.meituan.net/csc/2118a5e67b680fee26cee58963cf7f3a127433.png" alt="微软数据恢复"></p><ul><li><p>微软的这款 Windows File Recovery 已经上架了 Window 商店了，它支持多种文件系统（比如NTFS、exFAT、FAT、ReFS），可对多种文件格式（比如照片、视频、文档等等）进行恢复。无论想要恢复 SSD、HDD还是U盘、SD卡的各种文件，Windows File Recovery 都可以发挥作用。</p></li><li><p>Windows File Recovery 提供三种恢复模式，分别是 Windows File Recovery 普通、分段（segment mode）、签名（signature mode），各模式使用场景如下：</p><ul><li><p>1） 普通模式：用于最近删除过的文件恢复，支持文件格式为NTFS；</p></li><li><p>2） 分段模式（segment mode）：用于恢复已删除一段时间的文件，或者对已经格式化过的磁盘执行恢复操作；</p></li><li><p>3） 签名模式（signature mode）：针对FAT、exFAT、ReFS等文件系统恢复，此外如果其他恢复模式不顺利，也可用这个模式试一试。</p></li></ul></li><li><p>需要注意的是，Windows File Recovery 没有图形界面，需要通过命令行使用，但并不难。它的命令语法是：</p></li></ul><blockquote><p>winfr [被删文件所在盘符] [恢复文件对应盘符] [&#x2F;开关] 文件详细路径</p></blockquote><ul><li><p>例如，我们要将E:\test\下一个名为“XX.txt”的文件找回来，具体命令就是：<code>winfr e: d: /n \test\XX.txt</code>。</p></li><li><p>而通过各种命令，Windows File Recovery 还可以实现其他功能，例如支持通配符、恢复整个文件夹等等。关于各种命令，微软专门提供了一个命令说明网页，以便新手熟悉。网址如下：</p></li></ul><blockquote><p><a href="https://support.microsoft.com/zh-cn/help/4538642/windows-10-restore-lost-files">https://support.microsoft.com/zh-cn/help/4538642/windows-10-restore-lost-files</a></p></blockquote><ul><li>感兴趣的可以看看，非常全面，可以翻译为中文。</li></ul><h2 id="二、图形化工具"><a href="#二、图形化工具" class="headerlink" title="二、图形化工具"></a>二、图形化工具</h2><ul><li>简单来说，Windows File Recovery 的功能和效果都相当不错。如果你实在不想用命令行，那么也可以使用基于 Windows File Recovery 打造的软件，例如傲梅出品的 WinFR 界面版，恢复数据更加简单！</li></ul><p><img src="http://p0.meituan.net/csc/e3d7aef8a3dc47ce6fbd039bf339f281161908.png" alt="WinFR界面版"></p><blockquote><p>官网：<a href="https://www.winfr.com.cn/">WinFR官网 – 免费的数据恢复软件</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、官方工具&quot;&gt;&lt;a href=&quot;#一、官方工具&quot; class=&quot;headerlink&quot; title=&quot;一、官方工具&quot;&gt;&lt;/a&gt;一、官方工具&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;商店页面：&lt;a href=&quot;https://www.microsoft.com/s</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="软件分享" scheme="https://icu007work.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo发布文章指北</title>
    <link href="https://icu007work.github.io/archives/5d597b5d.html"/>
    <id>https://icu007work.github.io/archives/5d597b5d.html</id>
    <published>2023-05-13T08:26:26.000Z</published>
    <updated>2023-08-23T07:56:26.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、快速开始"><a href="#一、快速开始" class="headerlink" title="一、快速开始"></a>一、快速开始</h2><h3 id="1-1-新建一篇文章"><a href="#1-1-新建一篇文章" class="headerlink" title="1.1 新建一篇文章"></a>1.1 新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="1-2-运行服务"><a href="#1-2-运行服务" class="headerlink" title="1.2 运行服务"></a>1.2 运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="1-3-生成静态文件"><a href="#1-3-生成静态文件" class="headerlink" title="1.3 生成静态文件"></a>1.3 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="1-4-部署到远程站点"><a href="#1-4-部署到远程站点" class="headerlink" title="1.4 部署到远程站点"></a>1.4 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>官方文档: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、快速开始&quot;&gt;&lt;a href=&quot;#一、快速开始&quot; class=&quot;headerlink&quot; title=&quot;一、快速开始&quot;&gt;&lt;/a&gt;一、快速开始&lt;/h2&gt;&lt;h3 id=&quot;1-1-新建一篇文章&quot;&gt;&lt;a href=&quot;#1-1-新建一篇文章&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Github Action实现Android自动打包并发布apk</title>
    <link href="https://icu007work.github.io/archives/40fd71e7.html"/>
    <id>https://icu007work.github.io/archives/40fd71e7.html</id>
    <published>2023-05-12T09:35:25.000Z</published>
    <updated>2023-08-23T07:56:26.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Github-Action介绍"><a href="#Github-Action介绍" class="headerlink" title="Github Action介绍"></a>Github Action介绍</h2><h3 id="一、Github-Action-是什么？"><a href="#一、Github-Action-是什么？" class="headerlink" title="一、Github Action 是什么？"></a>一、Github Action 是什么？</h3><p>是 Github 推出的持续集成工具</p><h3 id="二、持续集成是什么？"><a href="#二、持续集成是什么？" class="headerlink" title="二、持续集成是什么？"></a>二、持续集成是什么？</h3><p>简单说就是自动化的打包程序——如果是前端程序员，这样解释比较顺畅：</p><p>每次提交代码到 Github 的仓库后，Github 都会自动创建一个虚拟机（Mac &#x2F; Windows &#x2F; Linux 任我们选），来执行一段或多段指令（由我们定），例如：</p><ol><li>npm install</li><li>npm run build</li></ol><h3 id="三、Yaml-是什么？"><a href="#三、Yaml-是什么？" class="headerlink" title="三、Yaml 是什么？"></a>三、Yaml 是什么？</h3><p>我们集成 Github Action 的做法，就是在我们仓库的根目录下，创建一个 .github 文件夹，里面放一个 *.yaml 文件——这个 Yaml 文件就是我们配置 Github Action 所用的文件。</p><h3 id="四、Github-Action-的使用限制"><a href="#四、Github-Action-的使用限制" class="headerlink" title="四、Github Action 的使用限制"></a>四、Github Action 的使用限制</h3><ul><li>每个 Workflow 中的 job 最多可以执行 6 个小时</li><li>每个 Workflow 最多可以执行 72 小时</li><li>每个 Workflow 中的 job 最多可以排队 24 小时</li><li>在一个存储库的所有 Action 中，一个小时最多可以执行 1000 个 API 请求</li><li>并发工作数：Linux：20，Mac：5（专业版可以最多提高到 180 &#x2F; 50）</li></ul><h3 id="五、什么是-Workflow？"><a href="#五、什么是-Workflow？" class="headerlink" title="五、什么是 Workflow？"></a>五、什么是 Workflow？</h3><p>Workflow 是由一个或多个 job 组成的可配置的自动化过程。我们通过创建 YAML 文件来创建 Workflow 配置。</p><hr><h4 id="5-1-如何定义-Workflow-的名字？"><a href="#5-1-如何定义-Workflow-的名字？" class="headerlink" title="5.1 如何定义 Workflow 的名字？"></a>5.1 如何定义 Workflow 的名字？</h4><blockquote><p>name</p></blockquote><p>Workflow 的名称，Github 在存储库的 Action 页面上显示 Workflow 的名称。</p><p>如果我们省略 name，则 Github 会将其设置为相对于存储库根目录的工作流文件路径。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: Greeting from Mona</span><br><span class="line">on: push</span><br></pre></td></tr></table></figure><hr><h4 id="5-2-如何定义-Workflow-的触发器？"><a href="#5-2-如何定义-Workflow-的触发器？" class="headerlink" title="5.2 如何定义 Workflow 的触发器？"></a>5.2 如何定义 Workflow 的触发器？</h4><blockquote><p>on</p></blockquote><p>触发 Workflow 执行的 event 名称，比如：<strong>每当我提交代码到 Github 上的时候，或者是每当我打 TAG 的时候。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单个事件</span><br><span class="line">on: push</span><br><span class="line"></span><br><span class="line">// 多个事件</span><br><span class="line">on: [push,pull_request]</span><br></pre></td></tr></table></figure><h3 id="六、Workflow-的-job-是什么？"><a href="#六、Workflow-的-job-是什么？" class="headerlink" title="六、Workflow 的 job 是什么？"></a>六、Workflow 的 job 是什么？</h3><p>答：一个 Workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p><h4 id="6-1-如何定义一个-job？"><a href="#6-1-如何定义一个-job？" class="headerlink" title="6.1 如何定义一个 job？"></a>6.1 如何定义一个 job？</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  my_first_job:</span><br><span class="line">    name: My first job</span><br><span class="line">  my_second_job:</span><br><span class="line">    name: My second job</span><br></pre></td></tr></table></figure><p>答：通过 job 的 id 定义。</p><p>每个 job 必须具有一个 id 与之关联。</p><p>上面的 my_first_job 和 my_second_job 就是 job_id。</p><h4 id="6-2-如何定义-job-的名称？"><a href="#6-2-如何定义-job-的名称？" class="headerlink" title="6.2 如何定义 job 的名称？"></a>6.2 如何定义 job 的名称？</h4><blockquote><p>jobs.<job_id>.name</p></blockquote><p>name 会显示在 Github 上</p><h4 id="6-3-如何定义-job-的依赖？job-是否可以依赖于别的-job-的输出结果？"><a href="#6-3-如何定义-job-的依赖？job-是否可以依赖于别的-job-的输出结果？" class="headerlink" title="6.3 如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？"></a>6.3 如何定义 job 的依赖？job 是否可以依赖于别的 job 的输出结果？</h4><blockquote><p>jobs.<job_id>.needs</p></blockquote><p>答：needs 可以标识 job 是否依赖于别的 job——如果 job 失败，则会跳过所有需要该 job 的 job。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">  job2:</span><br><span class="line">    needs: job1</span><br><span class="line">  job3:</span><br><span class="line">    needs: [job1, job2]</span><br></pre></td></tr></table></figure><blockquote><p>jobs.<jobs_id>.outputs：用于和 need 打配合，outputs 输出&#x3D;》need 输入</p></blockquote><p>jobs 的输出，用于和 needs 打配合：可以看到 ouput</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    # Map a step output to a job output</span><br><span class="line">    outputs:</span><br><span class="line">      output1: $&#123;&#123; steps.step1.outputs.test &#125;&#125;</span><br><span class="line">      output2: $&#123;&#123; steps.step2.outputs.test &#125;&#125;</span><br><span class="line">    steps:</span><br><span class="line">    - id: step1</span><br><span class="line">      run: echo &quot;::set-output name=test::hello&quot;</span><br><span class="line">    - id: step2</span><br><span class="line">      run: echo &quot;::set-output name=test::world&quot;</span><br><span class="line">  job2:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    needs: job1</span><br><span class="line">    steps:</span><br><span class="line">    - run: echo $&#123;&#123;needs.job1.outputs.output1&#125;&#125; $&#123;&#123;needs.job1.outputs.output2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-如何定义-job-的运行环境？"><a href="#6-4-如何定义-job-的运行环境？" class="headerlink" title="6.4 如何定义 job 的运行环境？"></a>6.4 如何定义 job 的运行环境？</h4><blockquote><p>jobs.<job_id>.runs-on</p></blockquote><p>指定运行 job 的运行环境，Github 上可用的运行器为：</p><ul><li>windows-2019</li><li>ubuntu-20.04</li><li>ubuntu-18.04</li><li>ubuntu-16.04</li><li>macos-10.15</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    runs-on: macos-10.15</span><br><span class="line">  job2:</span><br><span class="line">    runs-on: windows-2019</span><br></pre></td></tr></table></figure><h4 id="6-5-如何给-job-定义环境变量？"><a href="#6-5-如何给-job-定义环境变量？" class="headerlink" title="6.5 如何给 job 定义环境变量？"></a>6.5 如何给 job 定义环境变量？</h4><blockquote><p>jobs.<jobs_id>.env</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    env:</span><br><span class="line">      FIRST_NAME: Mona</span><br></pre></td></tr></table></figure><h4 id="6-6-如何使用-job-的条件控制语句？"><a href="#6-6-如何使用-job-的条件控制语句？" class="headerlink" title="6.6 如何使用 job 的条件控制语句？"></a>6.6 如何使用 job 的条件控制语句？</h4><blockquote><p>jobs.<job_id>.if</p></blockquote><p>我们可以使用 if 条件语句来组织 job 运行</p><hr><h3 id="七、Step-属性是什么？"><a href="#七、Step-属性是什么？" class="headerlink" title="七、Step 属性是什么？"></a>七、Step 属性是什么？</h3><p>答：每个 job 由多个 step 构成，它会从上至下依次执行。</p><h4 id="7-1-step-运行的是什么？"><a href="#7-1-step-运行的是什么？" class="headerlink" title="7.1 step 运行的是什么？"></a>7.1 step 运行的是什么？</h4><p><strong>step 可以运行：</strong></p><ol><li><strong>command</strong>s：命令行命令</li><li><strong>setup tasks</strong>：环境配置命令（比如安装个 Node 环境、安装个 Python 环境）</li><li><strong>action</strong>（in your repository, in public repository, in Docker registry）：一段 action（Action 是什么我们后面再说）</li></ol><p><strong>每个 step 都在自己的运行器环境中运行，并且可以访问工作空间和文件系统。</strong></p><p>因为每个 step 都在运行器环境中独立运行，所以 <strong>step 之间不会保留对环境变量的更改</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 定义 Workflow 的名字</span><br><span class="line">name: Greeting from Mona</span><br><span class="line"></span><br><span class="line"># 定义 Workflow 的触发器</span><br><span class="line">on: push</span><br><span class="line"></span><br><span class="line"># 定义 Workflow 的 job</span><br><span class="line">jobs:</span><br><span class="line">  # 定义 job 的 id</span><br><span class="line">  my-job:</span><br><span class="line">    # 定义 job 的 name</span><br><span class="line">    name: My Job</span><br><span class="line">    # 定义 job 的运行环境</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    # 定义 job 的运行步骤</span><br><span class="line">    steps:</span><br><span class="line">    # 定义 step 的名称</span><br><span class="line">    - name: Print a greeting</span><br><span class="line">      # 定义 step 的环境变量</span><br><span class="line">      env:</span><br><span class="line">        MY_VAR: Hi there! My name is</span><br><span class="line">        FIRST_NAME: Mona</span><br><span class="line">        MIDDLE_NAME: The</span><br><span class="line">        LAST_NAME: Octocat</span><br><span class="line">      # 运行指令：输出环境变量</span><br><span class="line">      run: |</span><br><span class="line">        echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.</span><br></pre></td></tr></table></figure><hr><h3 id="八、Action-是什么？"><a href="#八、Action-是什么？" class="headerlink" title="八、Action 是什么？"></a>八、Action 是什么？</h3><p>我们可以直接打开下面的 Action 市场来看看：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace?type=actions">https://github.com/marketplace?type=actionsgithub.com/marketplace?type=actions</a></p><p>Action 其实就是命令，比如 Github 官方给了我们一些默认的命令：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace?type=actions&query=actions">GitHub Marketplace: actions to improve your workflowgithub.com&#x2F;marketplace?type&#x3D;actions&amp;query&#x3D;actions<img src="https://pic4.zhimg.com/v2-d06dfc50fef28a5c76fa9034fe797faf_180x120.jpg" alt="img"></a></p><p><img src="https://pic2.zhimg.com/80/v2-5208c22215435edfa36040d6b217c325_720w.webp" alt="img"></p><p>比如最常用的，check-out 代码到 Workflow 工作区：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace/actions/checkout">https://github.com/marketplace/actions/checkoutgithub.com/marketplace/actions/checkout</a></p><h4 id="8-1-我们应该如何使用-Action？"><a href="#8-1-我们应该如何使用-Action？" class="headerlink" title="8.1 我们应该如何使用 Action？"></a>8.1 我们应该如何使用 Action？</h4><blockquote><p>jobs.<job_id>.steps.uses</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-e6855fd2e091401590baf4febf356cce_720w.webp" alt="img"></p><p>Action 库：Checkout</p><p>比如我们可以 check-out 仓库中最新的代码到 Workflow 的工作区：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - uses: actions/checkout@v2</span><br></pre></td></tr></table></figure><p>当然，我们还可以给它添加个名字：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: Check out Git repository</span><br><span class="line">    uses: actions/checkout@v2</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-8ea878b5f2917be32ba9aa18b3a1cef9_720w.webp" alt="img"></p><p>Action 库：Setup Node</p><p>再比如说，我们如果是 node 项目，我们可以安装 Node.js 与 NPM：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">- uses: actions/checkout@v2</span><br><span class="line">- uses: actions/setup-node@v2-beta</span><br><span class="line">  with:</span><br><span class="line">    node-version: &#x27;12&#x27;</span><br></pre></td></tr></table></figure><h4 id="8-2-上面我们为什么要用：-v2-和-v2-beta-呢？"><a href="#8-2-上面我们为什么要用：-v2-和-v2-beta-呢？" class="headerlink" title="8.2 上面我们为什么要用：@v2 和 @v2-beta 呢？"></a>8.2 上面我们为什么要用：@v2 和 @v2-beta 呢？</h4><p>答：首先，正如大家所想，这个 @v2 和 @v2-beta 的意思都是 Action 的版本。</p><p>我们如果不带版本号的话，其实就是默认使用最新版本的了。</p><p>但是 <strong>Github 官方强烈要求我们带上版本号</strong>——这样子的话，我们就不会出现：<strong>写好一个 Workflow，但是由于某个 Action 的作者一更新，我们的 Workflow 就崩了的问题。</strong></p><h4 id="8-3-上面的-with-参数是什么意思？"><a href="#8-3-上面的-with-参数是什么意思？" class="headerlink" title="8.3 上面的 with 参数是什么意思？"></a><strong>8.3 上面的 with 参数是什么意思？</strong></h4><p>答：<strong>有的 Action 可能会需要我们传入一些特定的值</strong>：比如上面的 node 版本啊之类的，这些<strong>需要我们传入的参数由 with 关键字来引入</strong>。</p><p><strong>具体的 Action 需要传入哪些参数，还请去 Github Action Market 中 Action 的页面中查看。</strong></p><p>具体库的使用和参数，我们可以去官方的 Action 市场查看：</p><p><a href="https://link.zhihu.com/?target=https://github.com/marketplace/actions/">Github Action 市场github.com&#x2F;marketplace&#x2F;actions&#x2F;</a></p><hr><h3 id="九、我们如何运行命令行命令？"><a href="#九、我们如何运行命令行命令？" class="headerlink" title="九、我们如何运行命令行命令？"></a>九、我们如何运行命令行命令？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs.&lt;job_id&gt;.steps.run</span><br></pre></td></tr></table></figure><p>上文说到，<strong>steps 可以运行：action 和 command-line programs</strong>。</p><p>我们现在已经知道<strong>可以使用 uses 来运行 action 了</strong>，那么我们该如何运行 command-line programs 呢？</p><p><strong>答案是：run</strong></p><p><strong>run 命令在默认状态下会启动一个没有登录的 shell 来作为命令输入器。</strong></p><h4 id="9-1-如何运行多行命令？"><a href="#9-1-如何运行多行命令？" class="headerlink" title="9.1 如何运行多行命令？"></a><strong>9.1 如何运行多行命令？</strong></h4><p><strong>每个 run 命令都会启动一个新的 shell，所以我们执行多行连续命令的时候需要写在同一个 run 下：</strong></p><ul><li><strong>单行命令</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- name: Install Dependencies</span><br><span class="line">  run: npm install</span><br></pre></td></tr></table></figure><ul><li><strong>多行命令</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: Clean install dependencies and build</span><br><span class="line">  run： |</span><br><span class="line">    npm ci</span><br><span class="line">    npm run build</span><br></pre></td></tr></table></figure><h4 id="9-2-如何指定-command-运行的位置？"><a href="#9-2-如何指定-command-运行的位置？" class="headerlink" title="9.2 如何指定 command 运行的位置？"></a>9.2 如何指定 command 运行的位置？</h4><p>使用 working-directory 关键字，我们可以指定 command 的运行位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- name: Clean temp directory</span><br><span class="line">  run: rm -rf *</span><br><span class="line">  working-directory: ./temp</span><br></pre></td></tr></table></figure><h4 id="9-3-如何指定-shell-的类型？（使用-cmd-or-powershell-or-python？？）"><a href="#9-3-如何指定-shell-的类型？（使用-cmd-or-powershell-or-python？？）" class="headerlink" title="9.3 如何指定 shell 的类型？（使用 cmd or powershell or python？？）"></a>9.3 如何指定 shell 的类型？（使用 cmd or powershell or python？？）</h4><p>使用 shell 关键字，来指定特定的 shell：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: Display the path</span><br><span class="line">    run: echo $PATH</span><br><span class="line">    shell: bash</span><br></pre></td></tr></table></figure><p>下面是各个系统支持的 shell 类型：</p><p><img src="https://pic2.zhimg.com/80/v2-9283bfe170157cf550cbc86c36fa28c5_720w.webp" alt="img"></p><hr><h3 id="十、什么是矩阵？"><a href="#十、什么是矩阵？" class="headerlink" title="十、什么是矩阵？"></a>十、什么是矩阵？</h3><p>答：就是有时候，我们的代码可能编译环境有多个。比如 electron 的程序，我们需要在 macos 上编译 dmg 压缩包，在 windows 上编译 exe 可执行文件。</p><p><strong>这种时候，我们使用矩阵就可以啦~</strong></p><p>比如下面的代码，我们使用了矩阵指定了：<strong>2 个操作系统，3 个 node 版本</strong>。</p><p>这时候<strong>下面这段代码就会执行 6 次</strong>—— 2 x 3 &#x3D; 6！！！</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runs-on: $&#123;&#123; matrix.os &#125;&#125;</span><br><span class="line">strategy:</span><br><span class="line">  matrix:</span><br><span class="line">    os: [ubuntu-16.04, ubuntu-18.04]</span><br><span class="line">    node: [6, 8, 10]</span><br><span class="line">steps:</span><br><span class="line">  - uses: actions/setup-node@v1</span><br><span class="line">    with:</span><br><span class="line">      node-version: $&#123;&#123; matrix.node &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="如何用GitHub-Action自动编译并且发布软件到-Release"><a href="#如何用GitHub-Action自动编译并且发布软件到-Release" class="headerlink" title="如何用GitHub Action自动编译并且发布软件到 Release"></a>如何用GitHub Action自动编译并且发布软件到 Release</h2><h3 id="一、配置连接私有秘钥仓库的token"><a href="#一、配置连接私有秘钥仓库的token" class="headerlink" title="一、配置连接私有秘钥仓库的token"></a>一、配置连接私有秘钥仓库的token</h3><ol><li>首先点击 <code>Settings</code></li></ol><p><img src="http://p1.meituan.net/csc/fe431f6c5e071351005b8f960891b1a539243.png" alt="image.png"></p><ol start="2"><li>然后选择<code>Developer settings</code></li></ol><p><img src="http://p0.meituan.net/csc/43fff60e59380a738053cdd60ed0e1f7279525.png" alt="image.png"></p><ol start="3"><li>依次选择<code>Tokens</code> -&gt; <code>generate new token</code>生成新的token后复制并保存下来。</li></ol><p><img src="http://p1.meituan.net/csc/af9948599cade116963039b4f6897988176494.png" alt="image.png"></p><ol start="4"><li>在仓库的设置中依次选择 <code>Settings</code> -&gt; <code>Secrets and variables</code> -&gt; <code>Action</code> -&gt; <code>new repository secret</code>新建一个名为TOKEN的密钥，并将第三步复制的token粘贴进去。</li></ol><p><img src="http://p0.meituan.net/csc/f381faeac8abed51ad36adee738ef4d7336383.png" alt="image.png"></p><h3 id="二、配置-GitHub-Action"><a href="#二、配置-GitHub-Action" class="headerlink" title="二、配置 GitHub Action"></a>二、配置 GitHub Action</h3><ol><li>依次点击 <code>Action</code> -&gt; <code>Android CI</code> -&gt; <code>Configure</code></li></ol><p><img src="http://p0.meituan.net/csc/f2d6e561835f7aa369fde4574259892f374070.png" alt="image.png"></p><ol start="2"><li>配置 <code>android.yml</code></li></ol><p><img src="http://p0.meituan.net/csc/c210d15c2d5069928b0cd2072e8366d3274932.png" alt="image.png"></p><ul><li><code>android.yml</code>配置如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"> <span class="attr">push:</span></span><br><span class="line">   <span class="attr">branches:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;feature/*&quot;</span></span><br><span class="line">   <span class="attr">tags:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;v*.*.*&quot;</span></span><br><span class="line"> <span class="attr">pull_request:</span></span><br><span class="line">   <span class="attr">branches:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;feature/*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"> <span class="attr">apk:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">APK</span></span><br><span class="line">   <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">   <span class="attr">steps:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/checkout@v2.4.0</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Branch</span> <span class="string">name</span></span><br><span class="line">       <span class="attr">run:</span> <span class="string">echo</span> <span class="string">running</span> <span class="string">on</span> <span class="string">branch</span> <span class="string">$&#123;GITHUB_REF##*/&#125;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">JDK</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/setup-java@v2.5.0</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">distribution:</span> <span class="string">temurin</span></span><br><span class="line">         <span class="attr">java-version:</span> <span class="string">&quot;11&quot;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">execution</span> <span class="string">flag</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line">       <span class="attr">run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">APK</span></span><br><span class="line">       <span class="attr">run:</span> <span class="string">bash</span> <span class="string">./gradlew</span> <span class="string">assembleDebug</span> <span class="string">--stacktrace</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">APK</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v1</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">name:</span> <span class="string">apk</span></span><br><span class="line">         <span class="attr">path:</span> <span class="string">app/build/outputs/apk/debug/app-debug.apk</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">release:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">Release</span> <span class="string">APK</span></span><br><span class="line">   <span class="attr">needs:</span> <span class="string">apk</span></span><br><span class="line">   <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">   <span class="attr">steps:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">branch</span> <span class="string">name</span></span><br><span class="line">       <span class="attr">id:</span> <span class="string">branch-name</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">tj-actions/branch-names@v5.1</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">branch</span>    </span><br><span class="line">       <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">         echo &quot;Running on default: $&#123;&#123; steps.branch-name.outputs.current_branch &#125;&#125;&quot;</span></span><br><span class="line"><span class="string"></span>       </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Download</span> <span class="string">APK</span> <span class="string">from</span> <span class="string">build</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/download-artifact@v1</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">name:</span> <span class="string">apk</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span></span><br><span class="line">       <span class="attr">id:</span> <span class="string">create_release</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/create-release@v1</span></span><br><span class="line">       <span class="attr">env:</span></span><br><span class="line">         <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">tag_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.run_number</span> <span class="string">&#125;&#125;</span></span><br><span class="line">         <span class="attr">release_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.repository.name</span> <span class="string">&#125;&#125;</span>  <span class="string">$&#123;&#123;</span> <span class="string">steps.branch-name.outputs.current_branch</span> <span class="string">&#125;&#125;</span> <span class="string">v$&#123;&#123;</span> <span class="string">github.run_number</span> <span class="string">&#125;&#125;.$&#123;&#123;</span> <span class="string">github.run_attempt</span> <span class="string">&#125;&#125;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Release</span> <span class="string">APK</span></span><br><span class="line">       <span class="attr">id:</span> <span class="string">upload_release_asset</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">actions/upload-release-asset@v1.0.1</span></span><br><span class="line">       <span class="attr">env:</span></span><br><span class="line">         <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">upload_url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">&#125;&#125;</span></span><br><span class="line">         <span class="attr">asset_path:</span> <span class="string">apk/app-debug.apk</span></span><br><span class="line">         <span class="attr">asset_name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.repository.name</span> <span class="string">&#125;&#125;</span>  <span class="string">$&#123;&#123;</span> <span class="string">steps.branch-name.outputs.current_branch</span> <span class="string">&#125;&#125;</span> <span class="string">v$&#123;&#123;</span> <span class="string">github.run_number</span> <span class="string">&#125;&#125;.$&#123;&#123;</span> <span class="string">github.run_attempt</span> <span class="string">&#125;&#125;.apk</span></span><br><span class="line">         <span class="attr">asset_content_type:</span> <span class="string">application/zip</span></span><br></pre></td></tr></table></figure><ol start="3"><li>手动执行一次<code>Action</code> 依次点击 <code>Action</code> -&gt; <code>Build and Release</code> -&gt; <code>Update android.yml</code></li></ol><p><img src="http://p0.meituan.net/csc/e1dbb65ea6a7f7de21d6c9d0730d19d3205339.png" alt="image.png"></p><ol start="4"><li>如下图所示后，表明Action 已经帮我们完成了编译-发布这两个操作。</li></ol><p><img src="http://p1.meituan.net/csc/3fe33a7c8b4f494fbab499b98545674f324900.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Github-Action介绍&quot;&gt;&lt;a href=&quot;#Github-Action介绍&quot; class=&quot;headerlink&quot; title=&quot;Github Action介绍&quot;&gt;&lt;/a&gt;Github Action介绍&lt;/h2&gt;&lt;h3 id=&quot;一、Github-Acti</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora快捷键</title>
    <link href="https://icu007work.github.io/archives/5e339248.html"/>
    <id>https://icu007work.github.io/archives/5e339248.html</id>
    <published>2023-04-19T09:42:30.000Z</published>
    <updated>2023-08-23T07:56:26.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Typora-快捷键"><a href="#Typora-快捷键" class="headerlink" title="Typora 快捷键"></a>Typora 快捷键</h2><h3 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">新窗口（当前路径下）</td><td align="left">Ctrl + N</td><td>Command + N</td></tr><tr><td align="center">新窗口（默认路径下）</td><td align="left">Ctrl + Shift + N</td><td>Command +Shift + N</td></tr><tr><td align="center">新标签页</td><td align="left"><em>(不支持)</em></td><td>Command + T</td></tr><tr><td align="center">打开一个markdown文件</td><td align="left">Ctrl + O</td><td>Command + O</td></tr><tr><td align="center">快速打开markdown文件</td><td align="left">Ctrl + P</td><td>Command + Shift + O</td></tr><tr><td align="center">重新打开已关闭的文件</td><td align="left">Ctrl + Shift + T</td><td>Command + Shift + T</td></tr><tr><td align="center">保存</td><td align="left">Ctrl + S</td><td>Command + S</td></tr><tr><td align="center">另存为 &#x2F; 复制</td><td align="left">Ctrl + Shift + S</td><td>Command + Shift + S</td></tr><tr><td align="center">偏好设置</td><td align="left">Ctrl + ,</td><td>Command + ,</td></tr><tr><td align="center">关闭</td><td align="left">Ctrl + W</td><td>Command + W</td></tr></tbody></table><h3 id="2-编辑"><a href="#2-编辑" class="headerlink" title="2. 编辑"></a>2. 编辑</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">另起一段</td><td align="left">Enter</td><td>Enter</td></tr><tr><td align="center">另起一行</td><td align="left">Shift + Enter</td><td>Shift + Enter</td></tr><tr><td align="center">剪切</td><td align="left">Ctrl + X</td><td>Command + X</td></tr><tr><td align="center">复制</td><td align="left">Ctrl + C</td><td>Command + C</td></tr><tr><td align="center">粘贴</td><td align="left">Ctrl + V</td><td>Command + V</td></tr><tr><td align="center">赋值为Markdown格式</td><td align="left">Ctrl + Shift + C</td><td>Command + Shift + C</td></tr><tr><td align="center">粘贴为纯文本格式</td><td align="left">Ctrl + Shift + V</td><td>Command + Shift + V</td></tr><tr><td align="center">全选</td><td align="left">Ctrl + A</td><td>Command + A</td></tr><tr><td align="center">选择一行</td><td align="left">Ctrl + L</td><td>Command + L</td></tr><tr><td align="center">删除行 (在表格中)</td><td align="left">Ctrl + Shift + Backspace</td><td>Command + Shift + Backspace</td></tr><tr><td align="center">选中当前区域(在表格内)</td><td align="left">Ctrl + E</td><td>Command + E</td></tr><tr><td align="center">选中一个字符</td><td align="left">Ctrl + D</td><td>Command + D</td></tr><tr><td align="center">删除一个字符</td><td align="left">Ctrl + Shift + D</td><td>Command + Shift + D</td></tr><tr><td align="center">跳转到顶部</td><td align="left">Ctrl + Home</td><td>Command + ↑</td></tr><tr><td align="center">跳转到光标处</td><td align="left">Ctrl + J</td><td>Command + J</td></tr><tr><td align="center">跳转到底部</td><td align="left">Ctrl + End</td><td>Command + ↓</td></tr><tr><td align="center">查找</td><td align="left">Ctrl + F</td><td>Command + F</td></tr><tr><td align="center">查找下一个</td><td align="left">F3 &#x2F; Enter</td><td>Command + G &#x2F; Enter</td></tr><tr><td align="center">查找上一个</td><td align="left">Shift + F3 &#x2F; Shift + Enter</td><td>Command + Shift + G &#x2F; Shift + Enter</td></tr><tr><td align="center">替换</td><td align="left">Ctrl + H</td><td>Command + H</td></tr></tbody></table><h3 id="3-程序"><a href="#3-程序" class="headerlink" title="3. 程序"></a>3. 程序</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">1-6级标题</td><td align="left">Ctrl + 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td><td>Command + 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td></tr><tr><td align="center">正文</td><td align="left">Ctrl + 0</td><td>Command + 0</td></tr><tr><td align="center">增加标题等级</td><td align="left">Ctrl + &#x3D;</td><td>Command + &#x3D;</td></tr><tr><td align="center">降低标题等级</td><td align="left">Ctrl + -</td><td>Command + -</td></tr><tr><td align="center">新建表格</td><td align="left">Ctrl + T</td><td>Command + Option + T</td></tr><tr><td align="center">代码块</td><td align="left">Ctrl + Shift + K</td><td>Command + Option + C</td></tr><tr><td align="center">数学公式</td><td align="left">Ctrl + Shift + M</td><td>Command + Option + B</td></tr><tr><td align="center">引用</td><td align="left">Ctrl + Shift + Q</td><td>Command + Option + Q</td></tr><tr><td align="center">有序列表</td><td align="left">Ctrl + Shift + [</td><td>Command + Option + O</td></tr><tr><td align="center">无序列表</td><td align="left">Ctrl + Shift + ]</td><td>Command + Option + U</td></tr><tr><td align="center">向后缩进</td><td align="left">Ctrl + [ &#x2F; Tab</td><td>Command + [ &#x2F; Tab</td></tr><tr><td align="center">向前缩进</td><td align="left">Ctrl + ] &#x2F; Shift + Tab</td><td>Command + ] &#x2F; Shift + Tab</td></tr></tbody></table><h3 id="4-格式"><a href="#4-格式" class="headerlink" title="4. 格式"></a>4. 格式</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center"><strong>加粗</strong></td><td align="left">Ctrl + B</td><td>Command + B</td></tr><tr><td align="center"><em>斜体</em></td><td align="left">Command + I</td><td></td></tr><tr><td align="center"><u>下划线</u></td><td align="left">Ctrl + U</td><td>Command + U</td></tr><tr><td align="center"><code>代码</code></td><td align="left">Ctrl + Shift + &#96;</td><td>Command + Shift + &#96;</td></tr><tr><td align="center"><del>删除线</del></td><td align="left">Alt + Shift + 5</td><td>Control + Shift + &#96;</td></tr><tr><td align="center">超链接</td><td align="left">Ctrl + K</td><td>Command + K</td></tr><tr><td align="center">图像链接</td><td align="left">Ctrl + Shift + I</td><td>Command + Control + I</td></tr><tr><td align="center">清除格式</td><td align="left">Ctrl + \</td><td>Command + \</td></tr></tbody></table><h3 id="5-视图"><a href="#5-视图" class="headerlink" title="5. 视图"></a>5. 视图</h3><table><thead><tr><th align="center">功能</th><th align="left">热键  (Windows&#x2F;Linux)</th><th>热键  (macOS)</th></tr></thead><tbody><tr><td align="center">开关侧边栏</td><td align="left">Ctrl + Shift + L</td><td>Command + Shift + L</td></tr><tr><td align="center">大纲视图</td><td align="left">Ctrl + Shift + 1</td><td>Command + Control + 1</td></tr><tr><td align="center">文章视图</td><td align="left">Ctrl + Shift + 2</td><td>Command + Control + 2</td></tr><tr><td align="center">文件树</td><td align="left">Ctrl + Shift + 3</td><td>Command + Control + 3</td></tr><tr><td align="center">源码模式</td><td align="left">Ctrl + &#x2F;</td><td>Command + &#x2F;</td></tr><tr><td align="center">专注模式</td><td align="left">F8</td><td>F8</td></tr><tr><td align="center">打字机模式</td><td align="left">F9</td><td>F9</td></tr><tr><td align="center">切换全屏</td><td align="left">F11</td><td>Command + Option + F</td></tr><tr><td align="center">实际大小</td><td align="left">Ctrl + Shift + 0</td><td><em>(Not Supported)</em></td></tr><tr><td align="center">放大</td><td align="left">Ctrl + Shift + &#x3D;</td><td><em>(Not Supported)</em></td></tr><tr><td align="center">缩小</td><td align="left">Ctrl + Shift + -</td><td><em>(Not Supported)</em></td></tr><tr><td align="center">在打开的文档间切换</td><td align="left">Ctrl + Tab</td><td>Command + &#96;</td></tr><tr><td align="center">切换开发工具</td><td align="left">Ctrl + Shift + I</td><td>-</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Typora-快捷键&quot;&gt;&lt;a href=&quot;#Typora-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Typora 快捷键&quot;&gt;&lt;/a&gt;Typora 快捷键&lt;/h2&gt;&lt;h3 id=&quot;1-文件&quot;&gt;&lt;a href=&quot;#1-文件&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo博客部署踩坑</title>
    <link href="https://icu007work.github.io/archives/ee2c1e7d.html"/>
    <id>https://icu007work.github.io/archives/ee2c1e7d.html</id>
    <published>2023-04-13T08:26:26.000Z</published>
    <updated>2023-08-23T07:57:52.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Node-js-版本问题"><a href="#一、Node-js-版本问题" class="headerlink" title="一、Node.js 版本问题"></a>一、Node.js 版本问题</h2><ul><li>Node.js 版本这个问题我已经栽了两次，首先来看Hexo官方文档给出的。</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装前提</span><br><span class="line">安装 Hexo 相当简单，只需要先安装下列应用程序即可：</span><br><span class="line"></span><br><span class="line">Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</span><br><span class="line">Git</span><br><span class="line">如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。</span><br><span class="line"></span><br><span class="line">如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/index.html">原文链接</a></p><ul><li>原文写的是建议使用Node.js 12.0以上版本，可是每当我使用16.0+的版本时总会出现奇奇怪怪的问题，所以建议大家使用12.0版本。</li><li>这里推荐一个Node.js 管理工具 <code>nvm</code> 全称 <code>node.js version management</code> 可以自行网上搜索安装。这里给一个：<a href="https://github.com/coreybutler/nvm-windows/releases">GitHub地址</a>。</li><li>安装完之后就可以开始使用了，这里附nvm常用使用命令表<blockquote><p>常用 nvm 命令表：</p><p>  安装指定的 nodejs 版本：nvm install 12.22.8</p><p>查看已经安装的 nodejs 列表：nvm ls</p><p>指定当前使用的 nodejs 版本：nvm use 12.22.8</p><p>查看当前使用的 nodejs 版本：node -v</p></blockquote></li><li>在我使用 16.0+版本的Node.js 就会出现如下问题:<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeError [ERR<span class="built_in">_</span>INVALID<span class="built_in">_</span>URL]: Invalid URL: https://ip访问：重定向到https://tdom.ml(跳转的时候浏览器可能提示不安全是正常的)</span><br><span class="line"></span><br><span class="line">TypeError: isPlainObject is not a function</span><br></pre></td></tr></table></figure></li><li>网上的解决办法都是卸载重装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载 Hexo</span></span><br><span class="line">npm uninstall hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Hexo</span></span><br><span class="line">npm install hexo</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>按照网上解决办法操作了好久还是无法解决，想了好久才想到是Node.js问题。</li><li>使用 <code>nvm</code> 将Node.js 切换到12.22.8 版本，然后在博客根目录执行:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载 Hexo</span></span><br><span class="line">npm uninstall hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Hexo</span></span><br><span class="line">npm install hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新安装依赖</span></span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><ul><li>问题解决！！</li></ul><h2 id="二、permalink-问题"><a href="#二、permalink-问题" class="headerlink" title="二、permalink 问题"></a>二、permalink 问题</h2><ul><li>Hexo 默认的 <code>permalink</code> 为 <code>permalink: :year/:month/:day/:title/</code> 这样就会导致文章标题为中文时生成的永久链接也会有中文，</li></ul><h3 id="2-1-三种解决方案"><a href="#2-1-三种解决方案" class="headerlink" title="2.1 三种解决方案"></a>2.1 三种解决方案</h3><h4 id="2-1-1-安装插件方法一（推荐）"><a href="#2-1-1-安装插件方法一（推荐）" class="headerlink" title="2.1.1 安装插件方法一（推荐）"></a>2.1.1 安装插件方法一（推荐）</h4><ul><li>在 Hexo 根目录下使用 git bash 执行命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><ul><li>在 Hexo 根目录下的 _config.yml 文件，修改为如下配置：</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> permalink: :year/:month/:day/:title/</span><br><span class="line"><span class="params">#</span> permalink: article/:title/</span><br><span class="line">permalink: article/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="params">#</span> 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    <span class="params">#</span> 进制：dec(default) and hex</span><br><span class="line">permalink<span class="built_in">_</span>defaults:</span><br></pre></td></tr></table></figure><ul><li>然后在 git bash 按顺序运行如下命令：</li></ul><figure class="highlight plaintext"><figcaption><span>clean #清除缓存 网页正常情况下可以忽略此条命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo d #开始部署</span><br></pre></td></tr></table></figure><ul><li><p>再打开网站的文件就可以看到效果。</p><ul><li><p>效果（其中60762就是随机生成的）</p><p>https:&#x2F;&#x2F;[你的网站域名]&#x2F;article&#x2F;60762.html</p></li></ul></li></ul><h4 id="2-1-2-安装插件方法二"><a href="#2-1-2-安装插件方法二" class="headerlink" title="2.1.2 安装插件方法二"></a>2.1.2 安装插件方法二</h4><ul><li><p>中文链接转拼音</p></li><li><p>在 Hexo 根目录下使用 git bash 执行命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure><ul><li>在 Hexo 根目录下的 _config.yml 文件中，修改以下的配置项：</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">permalink: article/:title.html</span><br><span class="line">permalink<span class="built_in">_</span>pinyin:</span><br><span class="line">  enable: true</span><br><span class="line">  separator: &#x27;-&#x27; <span class="params">#</span> default: &#x27;-&#x27;</span><br><span class="line">permalink<span class="built_in">_</span>defaults:</span><br></pre></td></tr></table></figure><ul><li>然后在 git bash 按顺序运行如下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><ul><li><p>再打开网站的文件就可以看到效果。</p><ul><li><p>效果（标题为“我的个人博客”）</p><p>https:&#x2F;&#x2F;[你的网站域名]&#x2F;article&#x2F;wo-de-ge-ren-bo-ke.html</p></li></ul></li></ul><h4 id="2-1-3-采用urlname"><a href="#2-1-3-采用urlname" class="headerlink" title="2.1.3 采用urlname"></a>2.1.3 采用urlname</h4><ul><li>在写每篇md文章的时候，在 Front-matter 里加上urlname：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: typora-vue-theme主题介绍</span><br><span class="line">date: 2018-09-07 09:25:00</span><br><span class="line">urlname: 2019102101</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>在 Hexo 根目录下的 _config.yml 文件中，修改以下的配置项：</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permalink: article/:urlname.html  <span class="params">#</span> urlname值文章里必须填写，格式201905260105</span><br><span class="line">permalink<span class="built_in">_</span>defaults:</span><br></pre></td></tr></table></figure><ul><li>然后在 git bash 按顺序运行如下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure><ul><li><p>再打开网站的文件就可以看到效果。</p></li><li><p>效果</p><p>  https:&#x2F;&#x2F;[你的网站域名]&#x2F;article&#x2F;2019102101.html</p></li></ul><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><ul><li>第一种方法是我试过中最好的；第三次之，因为每次都要手动加上urlname；而第二种，当文章的中文标题名字过长时，效果并不好。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Node-js-版本问题&quot;&gt;&lt;a href=&quot;#一、Node-js-版本问题&quot; class=&quot;headerlink&quot; title=&quot;一、Node.js 版本问题&quot;&gt;&lt;/a&gt;一、Node.js 版本问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Node.js 版本这个问题我已</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Nginx反向代理服务器端口至二级域名</title>
    <link href="https://icu007work.github.io/archives/13767a3a.html"/>
    <id>https://icu007work.github.io/archives/13767a3a.html</id>
    <published>2023-04-12T10:59:50.000Z</published>
    <updated>2023-08-23T03:18:39.844Z</updated>
    
    <content type="html"><![CDATA[<p>要将 Nginx 配置为反向代理到另一个端口，需要进行以下步骤：</p><h2 id="一、安装-Nginx"><a href="#一、安装-Nginx" class="headerlink" title="一、安装 Nginx"></a>一、安装 Nginx</h2><p>如果还没有安装 Nginx，可以使用以下命令在 Ubuntu 上进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制代码sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><h2 id="二、配置-Nginx-反向代理"><a href="#二、配置-Nginx-反向代理" class="headerlink" title="二、配置 Nginx 反向代理"></a>二、配置 Nginx 反向代理</h2><h3 id="2-1-不使用-HTTPS"><a href="#2-1-不使用-HTTPS" class="headerlink" title="2.1 不使用 HTTPS"></a>2.1 不使用 HTTPS</h3><ul><li>例如需要反代我们服务器的8080端口且不适用HTTPS，可以进行以下操作。</li><li>在 Nginx 的配置文件(一般为Nginx安装目录下的 <code>nginx.conf</code> )中添加以下内容，将 HTTP 请求代理到服务器的 8080 端口。需要将 <code>example.com</code> 替换为域名或 IP 地址，<code>/</code> 后面的路径应该是需要代理的应用程序的路径。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name example.com; //需要更改为你的域名</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:8080/; //需要更改为要反代的端口</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用-HTTPS"><a href="#2-2-使用-HTTPS" class="headerlink" title="2.2 使用 HTTPS"></a>2.2 使用 HTTPS</h3><ul><li>使用HTTPS的情况下，需要先在服务器上安装SSL证书，可以通过Let’s Encrypt等服务获取免费的SSL证书。然后，可以按照以下步骤进行反向代理：</li><li>编辑Nginx配置文件<code>nginx.conf</code>，添加以下内容：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name your_domain_name.com;               #需要更改</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/your/cert.pem;         #需要更改</span><br><span class="line">    ssl_certificate_key /path/to/your/key.key;      #需要更改</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://my_app;                     #需要更改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 或者以下命令</span><br><span class="line">server </span><br><span class="line">    &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       443;</span><br><span class="line">        server_name  your_domain_name.com;          #需要更改</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /path/to/your/cert.pem;</span><br><span class="line">        ssl_certificate_key /path/to/your/key.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  </span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  </span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        if ($host ~* ^\d+\.\d+\.\d+\.\d+$) &#123; </span><br><span class="line">           return 444; # 如果请求的是 IP 地址 返回空响应包，禁止访问</span><br><span class="line">           &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">                client_max_body_size 500M;</span><br><span class="line"></span><br><span class="line">                #proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $proxy_host;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                proxy_pass http://localhost:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其中，<code>your_server_port</code>是你的服务器应用端口号，<code>your_domain_name.com</code>是你的域名，<code>/path/to/your/cert.pem</code>和<code>/path/to/your/key.key</code>分别是你的SSL证书和私钥文件的路径。该配置将来自NGINX监听的80端口的请求，重定向到443端口，并使用SSL证书对HTTPS请求进行加密。</li></ul><h2 id="三、重新加载-Nginx-配置"><a href="#三、重新加载-Nginx-配置" class="headerlink" title="三、重新加载 Nginx 配置"></a>三、重新加载 Nginx 配置</h2><ul><li>执行以下命令以重新加载 Nginx 配置：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t &amp;&amp; sudo service nginx reload</span><br><span class="line">// 或者执行以下命令重启 nginx</span><br><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><ul><li>现在，Nginx 将代理到服务器的 8080 端口。在浏览器中反代过的域名或 IP 地址，应该就能够访问应用程序了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要将 Nginx 配置为反向代理到另一个端口，需要进行以下步骤：&lt;/p&gt;
&lt;h2 id=&quot;一、安装-Nginx&quot;&gt;&lt;a href=&quot;#一、安装-Nginx&quot; class=&quot;headerlink&quot; title=&quot;一、安装 Nginx&quot;&gt;&lt;/a&gt;一、安装 Nginx&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Win11鼠标右键菜单改回旧版教程</title>
    <link href="https://icu007work.github.io/archives/71255bbb.html"/>
    <id>https://icu007work.github.io/archives/71255bbb.html</id>
    <published>2022-09-15T04:58:12.000Z</published>
    <updated>2023-08-23T07:57:00.280Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Win-R-regedit-回车打开注册表编辑器"><a href="#1-Win-R-regedit-回车打开注册表编辑器" class="headerlink" title="1. Win + R : regedit,回车打开注册表编辑器"></a>1. Win + R : regedit,回车打开注册表编辑器</h3><p><img src="https://kjimg10.360buyimg.com/ott/jfs/t1/139822/19/29185/15405/631ab505E09e2eade/c389051154367b2b.png" alt="注册表"></p><h3 id="2-修改注册表文件"><a href="#2-修改注册表文件" class="headerlink" title="2. 修改注册表文件"></a>2. 修改注册表文件</h3><ol><li>找到以下路径：<code>计算机\HKEY_CURRENT_USER\Software\Classes\CLSID\</code></li><li>新建一个名为：<code>86ca1aa0-34aa-4e8b-a509-50c905bae2a2</code> 的项</li></ol><p><img src="https://kjimg10.360buyimg.com/ott/jfs/t1/196759/29/27835/87013/631ab582E4eff139d/9c1b2a2c653877b2.png" alt="新建项"></p><ol start="3"><li><code>&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;</code>上点击右键，在打开的菜单项中，选择新建名为<code>InprocServer32</code>的项</li></ol><p><img src="https://kjimg10.360buyimg.com/ott/jfs/t1/147905/38/29644/97959/631ab5e3Ec88a96af/b9bad59fbb8816e9.png" alt="xinjianxiang"></p><ol start="4"><li>点击<code>InproServer32</code>–&gt;在默认名称上双击–&gt;编辑字符串–&gt;数值数据留空不填写–&gt;直接点击确定保存.</li></ol><p><img src="https://kjimg10.360buyimg.com/ott/jfs/t1/67854/13/22408/9371/631ab68fE7db4291f/3a46b18af4b5c391.png" alt="编辑"></p><ol start="5"><li>重启电脑即可生效。</li></ol><p><img src="https://kjimg10.360buyimg.com/ott/jfs/t1/163187/26/27770/15784/631ab6bbE969e4be0/4a471c22785fb78d.png" alt="生效"></p><h3 id="3-还原"><a href="#3-还原" class="headerlink" title="3. 还原"></a>3. 还原</h3><p>如果想还原为Win11鼠标右键，只需要把 <code>InproServer32</code>这一项删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Win-R-regedit-回车打开注册表编辑器&quot;&gt;&lt;a href=&quot;#1-Win-R-regedit-回车打开注册表编辑器&quot; class=&quot;headerlink&quot; title=&quot;1. Win + R : regedit,回车打开注册表编辑器&quot;&gt;&lt;/a&gt;1. </summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Font-Awesome-Animation各个图标效果</title>
    <link href="https://icu007work.github.io/archives/82958ed6.html"/>
    <id>https://icu007work.github.io/archives/82958ed6.html</id>
    <published>2022-08-27T03:35:26.000Z</published>
    <updated>2023-08-23T03:22:41.657Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="ca49ea4e6b2e163c41943e6d4088503e0bad743f947534be1b4b08aaf573d806">4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186d60d6b44f35333dfcdb5d68b77a4115e27f69914aa13f0d526237093837906edd4db4af16e401f54d17ab765a4640fbbff7024eacaa05660e465fe10965fdcc6e2dfe13d6e044eed5e5d7ae457afd454757b567b8fc9f6d43e8a6d869d17610ab9565f2908a7157ed9225989f5724bf0a180869151f0781f62268ab4db1191d99c1e144d566b8e009b14cca676d7d3435996eead3858cb060eb42cdd567d60db17f0d2cc82333895f69cd1501d73c94e146397bb4d0438d714af76ab77ef346b6b390a9c170c9cbd909040abaf98fbfc958eec1dfea9f0479d398fd278f34dff736d279d94874d7bc6f8dd757698fcaa2840809037e89c4e1855e324eda163acd48473cab5e75f9a03ecde1893581e30756cc3b1c77ef5632fd2599eb6f7860ec5743bb0d6c0b5e140e3c8f6ff301613877f3d44de935b47284eccf5522ed8751990a7a576a95bb812a1d1c51fc0953cfde2cb7ed2eaa5882b9f4eb36bf644b49b39d3e48bc2a5daf4b4104ca7cf6daa1118a8d763163bc2a81192abe9b3bce80b9dde24a60feb7b748ac73491343e98be0afdcb62203f3132d725577a27751dc3f3d110a299f0c320cc598014a5537d7da5484cad762de37c474fe048a418412ee995532a29cb26d898563474190432bfc05e2f1309eabc6c902a105cb377b0b5164bf4247fdc6d34c8457f5b03d19035069d37bb6fc04c2d9301e9b6a019900f59d93bcf23dc3ac5217974e6602a7337126aaa54ca89cac49d05e5e61c49c096d5565f78950c944d28ca7a0ccd6a4de4e0052b8124450805221f921c87b12e4ce22223d03a6b5d0444f42a9ce24c636a498cdad75eac3a3b9ed7e3ac20c3b404b149845c8607d7f3a5298ae2edaf979aaf00e6089cf733421af8dcc152eb3c11e6338d49e7b3ece5f74b3e88a932970d465ec2662288d1a08dec5954e94d08ef40df8395411417bad5612526f963898f9f26bd90fd00d641a983142c708d97d8702063b82799e60d95f606fbf217b0453d6e927509a10366b0ab2e8bc5ba35404f22eb6c65b110bd345ba22e721dec3d29675ab2ad8c434f4a8f208ce9d9909e752c7b3e92b37939366a234c5b7770c09c083d7b043fe7e8ae66a0a16e0107bcb029177fd9f45df2ed15cf78a7eea181c13e43dabfb1051f605acf2336dbffe68303da22cb50dadac3256d7aa861068c338a6f86d21653f0367e9b9f8cd926181eadfd5a8ffa5b79ee48311a8a62a03426728498ea04ef73e3e5bd22ad0197b408397e11fd0438f1145d067e1b184450d2421c56f78d84a058c40d5d6c6fbc505e55d6b0270972affa919310bf3687e483f7ceb884400add1a74e331399c7a1e0755ec7dd442a796582a68224fab8a1924e7d8796fa0753b7e8671f345621c972c9481866b50da3f787d85bafe8df7ec297db3d17a2fd5373ee0655ebfb46e8719fc05416a621f4130efedf3c3b180842a5e7625dc7d264c31dce176751a99ff6edacece691cd7230bcf2b82c213f2455ba26d0690a7fed79102c22abf580f2aaa1a70df53b18d89a466ef8d9b0472677470316e834e97f8d488757026d2888a72f12601055f462cb26091d7edb4866eafc20b205b8564329fc0490114231033367e2779fdec370bd906192b5b37fe72af0ab7491f7cf631dae4c44880b46f8e4156477ddd7e376f454e3e6468451416c49bb3cb535fb7221c2721e946c76378c9ec3545d067d685f1f4ad4138f54c0d6c7db58bae32d2500013cb5fe3dfc34e3c3d59216564ef3b3d2c080425e416c9b0d7628ee75f3d98f5e5fbb0de097758e8b19d1bf8daa159711d9521b223f140c36709334980de195645b336be9851b36067f25532a8637e004849e895bdd8ceb8c1eba3a3a93b4176b8b46c20e47b69844b39111dbfb2b018cff733d6986e61c3c67057d85c73a71eb4ddddd97d7e6f87e2c25cf93858442857468d067fc03e3fdb939372b3d88bacbefd3a4fd9877caa2d301e7aa64a9032efc5062b3a61ae1e9a4b56c2b06c370a12db877793fac8f94388c9b6268baeb35f88e30aaea674c3b64baaec28083f57911d88eb7c5ec9fd9c0ee725cb3fe465c6ac3edadfe6ccf7c0e4e926e6019fa5400786c59c71d4409d1cc0122bd27523adca0a11de9317b24f97ec484fc04bdfb48bcb565495de5617ae5440efa5f7845a739505d9d0697c19f1115369b9d49758633cc98869</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你非常好奇，请与我联系。</summary>
    
    
    
    <category term="资源" scheme="https://icu007work.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>分析Android项目运行</title>
    <link href="https://icu007work.github.io/archives/7d2e59d3.html"/>
    <id>https://icu007work.github.io/archives/7d2e59d3.html</id>
    <published>2022-08-26T03:41:59.000Z</published>
    <updated>2023-08-23T02:49:20.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析安卓项目如何运行"><a href="#分析安卓项目如何运行" class="headerlink" title="分析安卓项目如何运行"></a>分析安卓项目如何运行</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段话表示对HelloWorldActivity这个活动进行注册，<font color = "red"><strong> 没有 </strong></font> 在AndroidManifest.xml中<font color = "red"><strong> 注册的活动是不能使用的 </strong></font> 。其中<font color = "red"><strong> intent-filter里的两行代码尤为重要 </strong></font> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这两行代码表示HelloWorldActivity是这个项目的主活动。</p><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><p>活动是应用程序的门面，凡是在应用中看到的东西，都是放在活动中的。，所以我们看到的界面，就是MainActivity这个活动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity 继承自 AppCompatActivity，Activity是一个Android系统提供的活动基类，我们项目中所有活动都必须继承它或者它的子类才能拥有活动的特性（AppCompatActivity是Activity的子类）。</p><p>MainActivity有一个onCreate()方法,这个方法是每一个活动被创建时必定要执行的方法，但是也只有两行代码。并且我们并没有看到HelloWorld字样。</p><p>我们看不到HelloWorld的原因是因为Android程序设计是<font style="background:green" font color = white><strong> 逻辑与视图分离 </strong></font> ，不推荐直接在活动中直接编写界面。更多的做法是<font style="background:green" font color = white><strong> 在布局文件中编写界面，然后再在活动中引入进来 </strong></font> 。在onCreate()方法的第二行调用了<font style="background:green" font color = white><strong> setContentView(R.layout.activity_main)方法 </strong></font> ，这个方法给当前活动引入了一个布局，所以HelloWorld是在这里定义的。</p><p>其中布局文件都是定义在res&#x2F;layout 目录下的，展开layout目录，可以看到：activity_main.xml文件，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用于在布局中显示文字的是一个TextView控件，而我们可以通过android:text&#x3D;”Hello World!”这句代码定义需要显示什么文字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析安卓项目如何运行&quot;&gt;&lt;a href=&quot;#分析安卓项目如何运行&quot; class=&quot;headerlink&quot; title=&quot;分析安卓项目如何运行&quot;&gt;&lt;/a&gt;分析安卓项目如何运行&lt;/h2&gt;&lt;h3 id=&quot;AndroidManifest-xml&quot;&gt;&lt;a href=&quot;#An</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第一个Android程序</title>
    <link href="https://icu007work.github.io/archives/c521edc1.html"/>
    <id>https://icu007work.github.io/archives/c521edc1.html</id>
    <published>2022-08-26T03:40:36.000Z</published>
    <updated>2023-08-23T02:47:30.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建第一个Android项目"><a href="#创建第一个Android项目" class="headerlink" title="创建第一个Android项目"></a>创建第一个Android项目</h2><h3 id="创建HelloWorld项目"><a href="#创建HelloWorld项目" class="headerlink" title="创建HelloWorld项目"></a>创建HelloWorld项目</h3><p>先在Android上面new一个Project，输入应用名称、公司域名然后选择项目代码存放位置。然后再选择活动界面，给创建的活动和布局命名。然后等待项目创建成功。</p><h3 id="启动设备（模拟器或者实体设备）"><a href="#启动设备（模拟器或者实体设备）" class="headerlink" title="启动设备（模拟器或者实体设备）"></a>启动设备（模拟器或者实体设备）</h3><p>模拟器安装步骤：</p><ol><li><p>下载SDK：目前官网上已经没有单独的SDK下载安装包了。谷歌官网推荐的是下载包含有Android SDK的Android Studio。<a href="https://developer.android.com/studio/">官网下载</a>地址</p></li><li><p><font color = "red"><strong> 安装路径需记住 </strong></font> ：本人安装路径为：E:\Program Files\Android\SDK_Tools</p></li></ol><p><img src="https://m.360buyimg.com/babel/jfs/t1/87812/3/29255/39841/62b9474fE6fd09a54/b52fbb814d641d1f.png" alt="目录"></p><ol start="3"><li>双击打开AVD Manager.exe（选择下列文件安装）选择完成之后点install</li></ol><p><img src="https://m.360buyimg.com/babel/jfs/t1/36673/34/16367/135571/62b947d0E35bf8fde/e82391d638b98122.png" alt="下载"></p><ol start="4"><li>勾选左下角  Accept License，开始安装</li></ol><p><img src="https://m.360buyimg.com/babel/jfs/t1/216102/34/19510/57309/62b94867E901dfbef/32f93d3c8c72f9c3.png" alt="Accept"></p><ol start="5"><li>耐心等待其下载完成</li></ol><p><img src="https://m.360buyimg.com/babel/jfs/t1/213735/7/20495/57747/62b948a8Ef5d95be8/458f6cb626d76972.png" alt="下载"></p><ol start="6"><li>配置SDK环境</li></ol><p>“右键 我的电脑”—“属性”—“高级系统设置”—“环境变量”—“系统变量”—“新建”</p><p>ANDROID_SDK_HOME其值为E:\Program Files\Android\SDK_Tools</p><p><img src="https://m.360buyimg.com/babel/jfs/t1/14597/4/16956/49620/62b97c9eE81609139/5ae3ef33e9c23834.png" alt="环境变量"></p><p>编辑Path变量，新增如下两项，<font style="background:green" font color = white><strong> %ANDROID_SDK_HOME%\platform-tools </strong></font> 、<font style="background:green" font color = white><strong> %ANDROID_SDK_HOME%\tools </strong></font> </p><p><img src="https://m.360buyimg.com/babel/jfs/t1/119511/30/23462/35517/62b97cf2E1900381f/d8be8bb741150705.png" alt="Path"></p><h3 id="运行第一个项目"><a href="#运行第一个项目" class="headerlink" title="运行第一个项目"></a>运行第一个项目</h3><p><img src="https://m.360buyimg.com/babel/jfs/t1/8552/30/18256/147697/62b954f9Eb9ea1f86/c853c46249cc52c1.png" alt="运行"></p><p><img src="https://m.360buyimg.com/babel/jfs/t1/177838/11/25850/13873/62b91a90Ead9d07eb/fe87b0ca60bff876.png" alt="第一个Android项目"></p><h3 id="分析第一个Android程序"><a href="#分析第一个Android程序" class="headerlink" title="分析第一个Android程序"></a>分析第一个Android程序</h3><h4 id="Project目录"><a href="#Project目录" class="headerlink" title="Project目录"></a>Project目录</h4><p><img src="https://m.360buyimg.com/babel/jfs/t1/198246/23/25013/22163/62b95440Ea92a2960/08d623ec793aa4a3.png" alt="Project目录"></p><ol><li><p><font color = "red"><strong> .gradle和.idea </strong></font> ：Android Studio自动生成的目录，无须关心。</p></li><li><p><font color = "red"><strong> app </strong></font> ：项目中的代码、资源等内容 几乎都是放置在这个目录当中的，后续开发工作也是在这个目录当中进行的。</p></li><li><p><font color = "red"><strong> build </strong></font> ：包含了一些在编译时自动生成的文件。</p></li><li><p><font color = "red"><strong> gradle </strong></font> ：这个目录下包含gradle wrapper的配置文件，使用gradle wrapper的方式无须提前下载gradle，Android Studio会根据本地缓存情况来决定是否需要下载gradle。Android Studio默认没有开启gradle wrapper，如需打开，可点击导航栏 —&gt; File —&gt; Settings —&gt; Build， Execution, Deployment —&gt; Gradle,进行配置更改.</p></li><li><p><font color = "red"><strong> .gitgnore </strong></font> ：用来指定目录或文件排除在版本控制之外。</p></li><li><p><font color = "red"><strong> build.gradle </strong></font> ：这是项目的全局gradle构建脚本，通常情况下这个文件内容无须更改。</p></li><li><p><font color = "red"><strong> gradle.properties </strong></font> ：这是项目的全局gradle配置文件，在这里配置的属性会影响到项目中所有的gradle编译脚本。</p></li><li><p><font color = "red"><strong> gradlew和gradlew.bat </strong></font> ：这两个文件是用来在命令行界面执行gradle命令的，其中gradlew是在Linux和Mac系统中使用的，gradlew.bat是在Windows系统中使用的。</p></li><li><p><font color = "red"><strong> ProjectName.iml </strong></font> ：iml文件是所有Intellij IDEA项目都会自动生成的一个文件（Android Studio基于Intellij IDEA），用于标识这是一个Intellij IDEA项目，我们无需修改。</p></li><li><p><font color = "red"><strong> local.properties </strong></font> ：用于指定本机中的Android SDK路径，一般情况下无需修改，除非本机的SDK位置发生变化。</p></li><li><p><font color = "red"><strong> settings.gradle </strong></font> ：这个文件用于指定项目中所有引入的模块。通常情况下模块的引入是自动完成的，需要手动修改的情况较少。</p></li></ol><p><font style="background:blue" font color = white> 我们不难发现，除app目录外其他目录均为自动生成的目录，所以app目录才是我们以后工作的重点 </font> </p><hr><h4 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h4><p><img src="https://m.360buyimg.com/babel/jfs/t1/126318/30/23870/10698/62b9574eE8636e973/ca6126a62c59951b.png" alt="app目录"></p><ol><li><font color = "red"><strong> build </strong></font> ：与外层build目录相似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容更为繁杂</li><li><font color = "red"><strong> libs </strong></font> ：如果项目中使用了第三方jar包，就需要把这些jar包都放在libs目录下。放在这个目录的jar包将会被自动添加到构建路径当中。</li><li><font color = "red"><strong> androidTest </strong></font> ：此处用来编写AndroidTest测试用例，可以对项目进行一个自动化测试。</li><li><font color = "red"><strong> java </strong></font> ：java目录是放置所有java代码的地方，展开该目录就可以看到已经创建的目录。</li><li><font color = "red"><strong> res  </strong></font> ：项目中所使用到的图片、布局、字符串等资源都要存放在这个目录中。此目录还存在很多子目录：图片存放在drawable目录下，布局放在layout下，字符串放在values目录下。</li><li><font color = "red"><strong> AndroidManifest.xml </strong></font> ：这是整个Android项目的配置文件，在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限说明。</li><li><font color = "red"><strong> test </strong></font> ：此处用来编写Unit Test测试用例，是对项目项目进行自动化测试的另一种方式。</li><li><strong>.gitgnore</strong> ：这个文件用于将app模块内的指定目录或文件排除在版本控制之外，作用和外层的.gitgnore文件类似。</li><li><strong>app.iml</strong> ：Intellij IDEA项目自动生成的文件，无需关心。</li><li><strong>build.gradle</strong> ：是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。</li><li><strong>proguard-rules.pro</strong> ：这个文件用于指定代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建第一个Android项目&quot;&gt;&lt;a href=&quot;#创建第一个Android项目&quot; class=&quot;headerlink&quot; title=&quot;创建第一个Android项目&quot;&gt;&lt;/a&gt;创建第一个Android项目&lt;/h2&gt;&lt;h3 id=&quot;创建HelloWorld项目&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="Android" scheme="https://icu007work.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>xray面板安装</title>
    <link href="https://icu007work.github.io/archives/25e76629.html"/>
    <id>https://icu007work.github.io/archives/25e76629.html</id>
    <published>2022-08-26T03:37:14.000Z</published>
    <updated>2023-08-23T03:56:50.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、升级yum，安装curl依赖包"><a href="#一、升级yum，安装curl依赖包" class="headerlink" title="一、升级yum，安装curl依赖包"></a>一、升级yum，安装curl依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum install curl -y</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>yum update -y</code>为更新yum</p><p><code>yum install curl -y</code>为安装curl依赖包。</p><h2 id="二、重启系统"><a href="#二、重启系统" class="headerlink" title="二、重启系统"></a>二、重启系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="三、安装Xray面板"><a href="#三、安装Xray面板" class="headerlink" title="三、安装Xray面板"></a>三、安装Xray面板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)</span><br></pre></td></tr></table></figure><h2 id="四、centos安装宝塔面板"><a href="#四、centos安装宝塔面板" class="headerlink" title="四、centos安装宝塔面板"></a>四、centos安装宝塔面板</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、升级yum，安装curl依赖包&quot;&gt;&lt;a href=&quot;#一、升级yum，安装curl依赖包&quot; class=&quot;headerlink&quot; title=&quot;一、升级yum，安装curl依赖包&quot;&gt;&lt;/a&gt;一、升级yum，安装curl依赖包&lt;/h2&gt;&lt;figure class</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>预装APP安装过程</title>
    <link href="https://icu007work.github.io/archives/3e55a450.html"/>
    <id>https://icu007work.github.io/archives/3e55a450.html</id>
    <published>2022-08-26T03:35:26.000Z</published>
    <updated>2023-08-23T03:21:28.554Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="976688e49b2b85e45cd5c800a0bb7cbfd07a7b2a74f408e504525d11ae026434">1ffc7d1a99edb7ab7287058947423f9ffbf9543cdfb22829d375b488d1ad9403d4d4404fd170a821ecbf52239434e322683edc8c1a74f2e180d21ebf9c065e1f473be3b4124c8b09a0433535fc5051a5e27183cbfff1f43b5330e156428df4fc7f77d6e965aa6da3467f8b4913a9c149345fbec3b0a302f61011b75fe6b94a62d2b025bf2821e4135b8a0b0c27cdefb91f173f298d7743e25ab69192d61b989daad571db83746b814f0b9cfe79440045cc24353a8b07be1f839cd9f4ea29c785ed2238b587a7ff7b208625f1be1aab7083a85e90c71de0c5257b5900dc6b2c24dc144179348c3ccd3bb792c78f0d2b8c45c1e201b27bb53627bbb2d1785ce9aeda60a23a1c69d7b1199e25e81ff4703c049e1284916d08829db13d10d36bc06f68a6f4cd205d6b413c64def829d5af46a93b8a6e12bfe476cc1486950fff687a756c678c405247cfae3f3514cad5b46644aa8bd54b664abaa83d3b2a4904bae032c19ee11d06dfa4288f5f2f47d04db0216324b49be27f96792461f6e3a5c71d7147959e23fc23f75061efb0a9b407b45d959b619a42650790266066a378dac8dff577a0b58ad8ec740db6fb43c251ace6566b830d78e002e928240d27c8024dcf47c218cca295d0f45df138f08e4e80d26194d40a7e1de6f63255bacc1950be0449c585c1a165d6afe122ce631d574d3d0e38692a689d48aaf4486fe1eecfbde424937be4c6827181cb3ee25d1f7e481e98c08fd42626d46bf0ee893fe79dba731990723c8078afc79d7c74ced28e6d3df1267239b8ac8dfa1627c0a869e97bbf53bcd609df7045d1ba08e17071aae3945238674087497ea3f7d7512ea86985589f36ea9ebe8af9ce604acf1b6152d3d1928c8be21e79ee01910261904858ba904dfb17311bfc8027118888ed4dc8de9fb8ac1bd55bdb6f0af313264f6969ea71c414bf8df13490b7d7febb4162886f46fcdfc6c16a1fe46deb38c43d51ae19980c3a7d4dfabf5a079f28f0657881ee3010f28d2b2be89ef5294745153609bcfa1550453f43907e375e112bdd74ea12a14c637a806f27522bb75d60e019a3a8915977e99bdd44b09cf023d2daaddd500f9dde91f786ead50dcf1b408176ccee22370378a65957c17bba6f7d194e3c50914de5d1d9f5c5220f5480ec5f8b5b8daa44365ad31e3dae8e7e985c71490ca08f993fc43f82c60286394baf32df27a0b58acf9fbd3febeb03fb6b7c10c0554602007c466afc757811206d57c1149d4e09b69fa859c2842945a585c611bf37cd8cbd746950f7069cf33d7037a8976a48c337652ccd9071cd977c2219f79f5c4dd768523325682e36d88f4cf48f2d2d7c2219995f141d80037052178188c3e59ee8dd6a18340b513e161fed091b869cc39e5acadeefcdabce77760ac0e256440589fc8e64c34e26744a3a2ad254f3f4bf371797ea093fd7147ee45e6b636f91eb35272c7cd0cc5842dbf678bb0e826ec8fe4e789df1b6f987950faf459b78cfb5850b653d85618c1a25a2b41dbe8974e240210ed4e3a206e4f7d733ee512e47bac2a7e843cbda9f0869dddc3cfec6632675cd42e7fee3aca4f5e95457759f5459ad557ff2c61f564f6041926d05c5c860cd68933c9060a269c6ee8053f88809ef30f83b53fcfedde99b725a48c39cbbea0a70e5c6c72c9c799615ee8d17bf0f8bbdcc6b414250254df0a30f38eb0780b41ddd9b8d0b6ef23c8edd768fab0aab575f318a0885756b00edda3a51a99a2e0a94ad91f81cc52246f42f283407d154bee21ee76bd2e2e2c8bb4827a2a6d12f23c98881ebf52893c777865a8fd8d123083444e84c0599bcbf8568a250d2a93d32070f57b27833a48d5efe6046b38f214a32c6f86b6ca582c1b56cf78966b39865c218738cac4cb2e303601bd9372e5f6f9701251e3d2eff59486a4ad1f994a825be5c15ffedd8f009b42c1388b8e0a47fefe7820dbf135478b74df5b0ab8c09d7c3746506d29074a026ab3d176d949f32b4a59cb653a736bae98e2d974e18c1814dbcf34139eb9c3f0c028a6bae00f340341cba35a6269ab314a09f43476d2c5d77d04875ddcc19a731a12c07f104d66ff46a9ea08a2f9b0fe9e3a68d3e33f9d25e944da16128dcf67064cbc9425321a498a648f33e873691535d66aa6f8c758995290dd36b454a1918be2ec85af4842bfce2a0125c51ebbc054e5ba300a94b43d8c015213fb93e440825febd4f587453f306a1a166bd2923e1ad91dfe56dd1a58f0ecd6eeb03fd4824f22cae088ac3d847ebd48aa99cc875eee8b7c77aa86683</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是机密文件！</summary>
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>记第公司开发环境搭建</title>
    <link href="https://icu007work.github.io/archives/12ce6b69.html"/>
    <id>https://icu007work.github.io/archives/12ce6b69.html</id>
    <published>2022-08-26T03:34:19.000Z</published>
    <updated>2023-08-23T02:53:54.190Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="2226750b39d9aecf73ae1b4318eb1bf67190d7e55cc810d7e81295387a717869">1ffc7d1a99edb7ab7287058947423f9ffbf9543cdfb22829d375b488d1ad9403a8e003ba98bba46612a4bafe4e7a2a9d387fe262b3c710c67a8a79a2d19d59f241e2d3b49afb6e8724072762af3755e3689dc58c751c9d10c261f1541c39a07bf246412c3971fb4756c405bf9042d36e1112d685ccf9b063e6eedfd6800e7e8e7f48fad43118bbf48786a4139cdfc17b2f1c145068edcd798f26f2b64dfb0ae7eb27ed6146ef90972e370c880b68440e90c262816d6ae8e3ff90f64d775dc80f9d165de319613d16d374661778bd93b8fd21dcae9e40b8bd8134f798bc09c858ff9e46675fc8637ff9e35324117faf9aa46b0ba259fdd47c8e402f881eb969cb94bec83c5c4d3fa32f46b5b16bb4de6a73c288cfac1f6be9afac6f08124689f4dc7111b71c344301645741cf8b84dfd0b7cd87b44d8eac4f2274d159d9deefe97c6514cb7b97dcde1620459854efe66aa2f1cfde3eb836603d4c403241ca3766fe499cf1f5556b14ac8d1f7d7ec3f9c87b01cdf802f8f7886e2a1f1472f7f0a9fd1574a175298e8db6762974b808de0558c9ddfa52e9327fe3cbb1766867f0a4a19fcdd73e9682f720d04c838f65ab0ec93607957d03271ebcb89cd8179d35d69ba2c5703eb016f75fcbb48410c44d9df5d4584b2d1a96aaedc893eb021b80d9689f0c3f12fbeb7bd5f9c1c51ccf45f998ab11b39fc6e18f8f39dccdeeea0443a496c496d41f27a392e70c00148ab418c496b8bbbceb2100100a173ac0748a1162776ffa562f5aab45200bb6aef01d93d10c3e731e976b89bf8414fc3754a615603436d8878e4b23ec9d4584e4f72fe7bb7651d315feb2eeae38645c208eba315a435fef02a1cfd3ecb0d92c75c6d366785c4db85e4173af3e9d904340eb7d7d8856ea5001be5d3f119637a673e4af08c768d9ff473ab3a0baaeeb0917f27d457bb09c51d1df886fb029880b2c4ace13cc96f74aab8b0cbf2e0dc59551e0a5980f119948ea5b2b8af5b73fbc55c6daac041aa98b81eb5e0e3ba2fc354688817e12f6f3c2a197994ca6a83c7ff4bfb1d89a86e100f7bb8a31f2f0a21460a916ce02b0571430c489da8b721838ed628c4f7a936d61d73d56d5998f95ebef4d1c24b24d390aa20f7f5c72f4ba1f4e33d073033b9acf424338e04a5d5f54b8e71412c4b195264d1524ea7461a05cef22545d1bd41d134c96f7f0c6b806985d759d453b5301c11e79dc521ed017753060caa5db9234f3bcfdd5a25e7b3640e831e1a8d19afe2b126bdb9c9c9e601f29c83a87be0fa299c0fc9bc260fed8927285aafbe2fcfaa3eb9bf6cc2f509752e7cea9258a47ea762bab644919e023533f27e4eca2f2738b87b3076c88b89e5ad166849d4ba2ed1ff36f079018a9fcbee57301bae0ec4647b7637d284605904354e5c015768288a55bbf3994ba564e78ada8aee9944b60d760822ebca655048fa8743ddcb1c7a4207faa710f09f0d4dbae4412d64da81bdd2f985eaf113536ba6911de16c66fc550be5703a1814e0f3bfdbfbe32b3fba9cf37e11b8782208c6ef061b59914218385cd8512d9d41b52f13f53c9306cdab844cf0e009a30efa06fae9cf957cf1a5a354b5612c5d6d54a2a37181efbd8321ec331f4195be9345039ddb3b275b6e4ef489e7e420d7ded6d08cffc467950b36a4c5a62704b592a5bf36becab13ecae05f64a1d8fe45bd975bf77e5d6bc793fbab3eb1fe2f9185d017afda691d927ba6e0ed2b69a4677ee614d7668d212d71ae3777f5fd07de0bacfe2b74ac74a079aefee6890ed6aae37b01b8e4c25d417a3297647e511241ae4c9a48f9dc99cd0df770e2e21767a8f1c64863055cba63d49a731834d370ddcef0dede32e05df55aa37fd898d2335a66572969f74beb5c8e4f02513fab970cad155b1b438eccf51b98a7b7d175c210ae897b4a112a751186c8193571355c0b2502de5314b23f2a9d0da54354b21f566ed7d5b284719d5ec94df533cc295d096f5adc7fb43771f04daba647207c17b4d92ae6022b17775c1931009aace9ca49a5ec2c89891023a5883d7e569284c7a788391b26178c0267c6d764c6e7de05dba5ab744405b85b89f1312a1dd58c40f1280c884d1020174d38600dca07a0426894b0c765a9283b96ec4685225f780169440826bb7132302215a522a68e201dba65c4b79fe9f9a6fbead959cfe170c39cd09e3d8c4b5ec707d27aef00c34ad362a311ebf8b4b666922c82da6807ebe0beb0f300bc745c00e007949146e6676a951044a1c74f2eaafcff3d8a1c3a3750f169f8b31cf9fac7ba55708ba28c4d93a0fd93d596cd4e19f458256c61c9f3f2ecdceeb53e358355e82702912bb2ff25e2d0d903a9fbfa465525531b97c56dd61f34cd9232e69ac1defed1093d50008f97ed36a670b359f000d3500902531743abc52b311ea5d18d61585c3b7c37b46e84acec97952e5b98e716a5eeeac205050dd2f4d9ce14aff6ed9a3a8168e8ddeaf4169e0c49bee7f4902b5b3b34850ac620361acb2162f60e10339bc011117a5f520e275a0589ed5edec20f545d7fc9d98e93155814dd4e8f9915b5717517e4d1cb75af38ccda8fe00ae6461dffc2255e5da7b99a72f26972197e2b4dc686bc29732de7839582b8d9c2c6ae66d931c58d06b220b4349e3a332e76a4e69c19e7d30361c53009942a39e0c865479aa32b4da19fbc1d622f7a433e4e278e4fe86ace88d8a48c7db79d3a9c3716ac08c4947ac728ed5712247f8e6f29cb2a676d972d8f912dc6a402a4c11e801537a3373726c366e9f8ee48725e68a4ee7fc7da07cf48c64cdb4049ea40763d738a2722af21a58a33db5a0985c1b634f59e0d9ff4d2f2c2fbb848092edb9af90f8db4e1fdc72888c90b3ad70fb8186c1f13ca9ee2b95463899ff05aab83fbd51a9d76a02338379fe5a33f405b6c90b28d8d5c3a44e3fe6596b0192812344b27531882d39820295e22d2c13b946bc0eab46cd81643b4e2555a87b2e48a983f6949bd01e9b66c0c54db06ed9061478ad868698428b41281d7bafdfbd7992d228de80ae40302d592561083f80a6dfc9eef54aac54652f1de99c1bea561a5aaf3d6e10ec34d34875d1e4a832c10f108c2b72c20996e946d59e11b005596e68fe99808ec127a52c5d9c055fd4ee289bbe962738c8b701c52e2d750d232131caaca5e3164a4b6d9374a1122a7dcd3ed470bd49746a6ae27140217915babe40dc9daecf059f6e62fc6fd592a4e3acd867fada62d2d0e22d5057cfb6414d805141c694c9cda267cbb7fbd0999510494cb6413e77bdcd8679449634d9db6ab3c4b9c3e4ea7604c84eedd6d1c5803eba96d0a8baac033ee853469c8335ee7080bc9275f6c75a711dfb5676a74abf34de2fe6a7b4109d7374f680f7b75fc1e309de1656e956121fcf02fa40bc22e29c9d4bbbd6db8682e89f3049b33c3394f208ae7d771c9b4752692ee88a7b5845f5bf74218454880ec668a848bcec5708bcadec48f95900cbd676ef2b3dc4bc5035ccec3c3c07f94d82af8b10f701e3d8312380acb24399647a8180e6b4ce75f879be442551d2f5cefa9eefb1b287484b68572e3534a4bbbc051e9110291c48ae8d9551ce09a11e45a29dec44b5e5592808da8c8d30d99b98d7881d24bc628ff3532f643a4fb270e2117c245e08d6f442ccb23d8381b3c4a443ed0a564b295083b836c929ca659a921c9c126af5c1fb6c9ffd6cb921529e101d0b48b03bd7ae2f146ce12029ef0c6106f5d7f7ee02287cea916b25d4ef716369d949acda7279aee142245a92381f991040b328fbfed547414b7140ccc7a828455e0ecc2a8e75dee7de0f2a92b51e2148ac88f54c1b52638f379778f4e5e04d1479fe64c14fae40e5ca4c8cf3568355150c2e315a2bcf87f395455d598063e8b2ba49b2293ede583b25ef3b6bfbdc4bacaf7338d92472db83946d1012ad95b284b36c6c2082f4a59b857a60ccb4a9fa0acd14ce407ecffcb699a8ef418827bcf8572d536a32624a4090712e215b6f4541ae556ab6aec57ff8bb59b870a0d45367487b36db656de75d0a6aa56bdc65a66566ecb431ffcbcb2eb6bab405e055eba67bad00dcea0e834fd115910aa5dc48e50816f686b7c3b5bd50e16a8dcf0e3e4ffa8b247451c081ce35363c5a0790d579b7a734f5865fb943ce6e8586a29f99938e4adba5efbf68babbaee14c61c9e591936c4fb191301cb71eb6283103f878522cfc8125172c046d3d4c99b64cc0d73eb17ffee48e0a46e462f8e6d896e1c3d73d495a4470c855f5758354b30bb0114f0dc27c98e8a2e78840107db9dd5f7afc2e009d8b5c0ae47bff6f7fe776c2e6b3dd865abce6eb018893afc18e0ef51907e07d4541a45f1fa623d174d8561638bd2c072834e5ed637c04df8993fef68e6743049983f35d4c6621b83a5fae5ec44b9dadea773256d8e1e34d0b301b3c54dbdd21a043d4c677c948acd42ad763f1a35ee244480437a4d943d9a8959b7cf96f04cf470d885f5e4aa6b3027554df92c7389afc4bd13f83f8feb08d719e7225eef3531f22a6ec0dcdb3f2facb4e8125c0896d0680f6c7cc4b5a8fd4a253e70a4e00768337eab877b5f24afcc254d23897f2f3ce4f7153f6a57266d52b2905dc42e0b5f688412354148cf21a603174cdfbb3fed5f3ce41166b6e3ebafc4ec372c2de5927c8764bd9321f25bc3d1ac5a33cd9d6a76dc16e1bf51805d2aa64955acfc11e5015951d806bfe2a99e7c6b7d220b5ac74446f9131bbd451d4d8438b3bed542c1c9077de6383ee73a1e0c73829c3a5f242e4e7f3f5fda32a7bb8d635697bfaa075ab46f74aadd2d96ab963ca992255b52626909bbf582ceec7d7bc9ded1d6171912a111dd8afb4b06d56c8c990bf1e42e2e2c4679d1d04b34f185d610a20b23cb68ad18d0156f8e3655057dedf4f18ad43fd790117b1406c4c0a957ce71e677a54e42c84d415cc1247d44182e9687074f6a784d143225c60a4982ca6a5853d051354cb89845e472db13eca0a25cab937e68cf134fc5dddf26d194139ad18ab220c75bd129fb3697475dc70dd2fd0083d1a2cb0e2d0890b991a83bffe3e530a686fe85fcb3f1fe041fdc4a0a32a388dd99a0a743f437981a4e90f281c3a3c1f2e1684f1981e6e78ce92410300026114374b9e8fe23501ba3b386a6f1ef31e321a9f04d230643c94ae6aea953845bde1ee07b8736deae7a1719bab56aa6d0cb3ce246cb938c293bc06c9fb9afe82b07968a55f6febb703d0295945f1a0c890cc0efeeeab4de5e0b1a3247afe9e7e971dd9cb80b2e17336dc83c0216f389342681627f04e638c17a6eb1bed67fad660916002326b5a801b1f394af28ec9d732079b5de58e419630f3cd024a04269422274be6d928aef9fcf7cc7fb1a2c2dcc6ef3484519e3fae1eb009916a47b3297bba169b5d65f6ee181c5b7820d144e88d5359a1687ae5845e4f9e4bb16318e494954748531f2858447f60b9c9cddea059e6c988edb02cdb48b185e640aff36f069efdab3fcb88e7674b8f651f32b9f0f40ac72822aff5801f0decf4434a339da7dc335cf37163b399149e89c78a5441ca974f8a27d6edd24bf17098490f6c7e8c83a80a6bf32c0021a1b5fa22db7ade2a3502e19b1e4b7f32cb59b894b618f087508a25eb7f125adc61b978ff85b1fca89b24203ecd34e5a24f3102535ae395f21db1860a3efb0ddda835244473261844db57eea1c3f0f2d902b5d4b7996b0a60dea21b103d848035550c024625eb9368d44cb0a9b0daf962d784dd6fbf75104461377d115cb6eeb4e4ec421ee19787fa5e93f32b600f758a3e17487d9fdf1cac0a43fd80e4fa2a81681e8e3718ce445c54a50d45ce476568d09b945b5df31db5a31b5d842b0c0d28092a67afee49ff653ac8a1dc6ac4f46f1af1db9bff523114cd505c84be5124224c36f5c3595bf46c9a2a90d203571ccf98aa1cdf6fc13a7510218aee6643af145945ed4c17c53314d302f766cb34754715153090089b5ba95ddf46cf5ddda83ca3f6d57ac23ab22554fda1bb33d38f6524ca625c20a58b2ca42d806d0b0b14d2e62fa44b2ec35c1ac25edd214519635324bc62b620b064f367fd5f30db748e1789449817bced77eafc8b5189da725ee2555eefcf0a93560f2f769c67b9bcd5a3def087dc52f7efc0171aa884f3f120c21a83d63f093411245f577d9b1327a0ac6db3c36dbdc41c5a3cb5f37cdad0bcf81d8eecf6d54d9791b91782512018a63606a61d5fb7c9880d92084ae8a91e63406a45e77975782290cb4da080037f4ebb5cf04b039131c82006513395928f7591378f889043c1cf0c5d6d3398c2cda3be1800cab7bc3e7282b82b2c0264a42a91d7ed17985cfbcebcfec908b399eeb53a1fd1b8e702ffb3aca6007b4ceb5a66b7494cb08efdd1186226ea3bb6274222784c1769a1de4213a79dcd35169d2b58c9aa2ba8ab1545c2697035e7d56a7cb19e77bfb523a49893f280e79f68df38828c61ff0fdf9e8cb717486078e43143a1e24d7c11588bff89217cf124e8eb1307198485d26edfcabbbebb2eee809d5ef4e5cc51e5e5d6f84bd0620d2ede182050fd00fdb443e0774eb3bcae4024daf1334f0e907abf30648f04d8a53d182bbeb1aed10e7ecf63081a45f75bf2061df6dcdbfdc611ad08b13c29088ddc3cae4f69fc101e35182111576a4f129c230bd4384b1962761cdbe4f46d6b765244434e79f51775aec54e47e9915714bfba746b4bc94a23f2d32aa765802e8673d5071b95d28fa9e6d8cdc9c56de02dfedb8cbcf162b3f53ee076a12d443622b4a7602513375131da3d1fc830245fb3d64c566e79fad91ac163e8782b04dfcfe84e0f0c863a971804a12b10bfa7d52af20a257f995ce9b26134f4dc533300174faac3a364e4c46408f7fa36f48c86e4b6c1ebf8daf02e14807b576aed7cc0ddb3814a21ae5aceb9180c8101765c16e1e07dda5bbf213bd79efc40c41d82eea04944208ce502d5cbea43f72efacab0733f7e3db571508fe6ad6c4f80d6d882d45c41fe4ec14fe79ac3912f12eef11e5f06d971eb83eb797741c71e6f6a2e2cbb7caff4d17cbde9251431d4938a31082ebc21f712b731d050e8c82c6a23c8eafadbdd1b09896a46cc0f70152fbff3762678be00401f5df54ad01b48ad2c7c7611070f8c6458f9a991a2e1a0b7d96dd047a2e5dc0ec9710de5cc5143bcaf2d5d5fc77cba67072d212415b836ee8378ce40e4a92804f88d9fc003902349d0ef13eb40cd37e631e16e16abbff05d1d3e4edb9d75640801c3f3663ee9a664701228e6af743b3c1172a280ea31ee780f43e404a785018f462b15209841a212746cfc090d9e0b1d0aad3419b62da5a976b28c58145948d64a9784cde03c1d7fcc07197b8f4f1aa2e9d13c7051440148597c249eca67f5f658204faa85e1fee0c1d1f07afd41fc70c7ad19feda8a2eecd8bcc8d40db3461588b3e2feb6ea009aa4b387c134c59e0d02b631054d1d3e21519e73eee45e17d30b8aa228908b1472962d85b11a6de24213be4878726dffbd2fde3247383bbb91ae21dd399b1ce0da3e1cbbdf36771261dd4bd7762357a06a8d1773b528c237769cac87a78e44498334d52d7829efa3b2324ebedea920fa34447bc4b2d24ed0b45b963996fa4877dd3f437ef4f9d8d051dc32814b3c0034adf63ee62c6a9b37efc23edd5e6e11ad32d4d0f52f6a63ed8f09153e5e66e7fb3be36fdf9a666c6365f13de9b5d098bdfff65b4680ef9ae001146fc77fb9fa133d3c498de8fe3ca8502d011d309702a03271edbe6951792a39e66648613005c3df409474938b4ebf15e5e4705b1a8d7bd3f44516b86005796d28c7982e13d232f1d02d4c4570de79317a5e6ed45e5608243bd9f28033838873dc8d7cc5e9d81a7a506945c2c2d7179821f28e3f3dcdc1952004201799e654cc80d313c7be2aaf2f920182a8e1b9627024bce679d313bf55005389e5a32c03f575b4140f1bea50e3cc4c127557af50c9722a0909e5d6a82b73dab053b69fdb60e16d8afcf63b8efe51970b551a3e3415f5fd9d3212dcb45bf5e8f1474ee5b78a0a4b0efe2024f40210aa8aa580a6826851a8929612721e49ac2c319d30f9d11fe1791e96bd5acdb34d3459a46f02c6e77aaa067cbecf3543c82f10aa8f3c6cd8b1d2071c4578e3e5e0f8f8ac7cf70e27099fbdd7a09deb0aa4f6393540b14fe5ddff0bba8bbe4175de1dc26f932ce6b3bffbcba0b840c1632ab5b756caf8ffbcf39f5923d5db11615d1d8c534f5c29d6448db8fb950fa834e180945a9731f099b9c4b468fff3137c2ace412cee7c7c6376cf7790e4a9630f972907bd449b9721da2c687966b9d1771f5fcaee098241892eb4dc50eabb87dc8e2b70d8a20573e166db3e41c382148b7c9f4e7e184e220daf694d11e5d48aeb5480255961d8c3c4d2a7f563e64a3d3ad1469fda4ec2f2cf2fcd6572280cbd2fe8e62a0d8778ade00fb09a0b6febadf6147e4f9ecc95111c1cc3c1e7eb59c2b73019e2860e60e6cd32a7d71825d5086a00e6b9d10ed0560d62ec30166b5ca2ed4229ba2006c06980c77a8bdddff55fcc1ccfa2b5aeaa936e1c8041fc20d3b8a4b61a1975eaba1e9ae7b1ae9ac55bc3a9a1f55c314eeb456537aeccd321e70315962a2a467294e93a3d0726581e49b8987fad398741a15b46975695b65c435b0e3f7aa7bb2eb595b2f61e8b924ed6b79cf4b45519b14760be770eda3de82e5247af9b4798ca6bf82c22842230490ef91020a985d5cc50018c5061007fc1fc829a66c45dcf7510b4d2f210f4f4a52fad0b1aac8cef0f0cffbc3b7afb917f9dea440f05822ff515780024cc6fb92b424fc8ad1bcd127f3077cfaacdf5a4f1ecdc8a0c3421efc582967b770d5169c1d17c919a8bc7bb3e354e142f8c72495a2d1f31db538f980543b0a44c23fc70c246293fd570590a92b1a7323b9227da6d972c63e74f1d6a55678205ceaaa23c73584899053ebf4a6a5d64e4232e527c5f69</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是机密文件！</summary>
    
    
    
    <category term="资源" scheme="https://icu007work.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>记第一次完成业务需求</title>
    <link href="https://icu007work.github.io/archives/55cbdc7c.html"/>
    <id>https://icu007work.github.io/archives/55cbdc7c.html</id>
    <published>2022-08-26T03:31:28.000Z</published>
    <updated>2023-08-23T02:56:21.825Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="5ff81624128f4da33b3fa55eca10d9676ad4312bfc251a045c7357e61272a3cd">1ffc7d1a99edb7ab7287058947423f9ffbf9543cdfb22829d375b488d1ad94032e7c6555edb40a8496bb774ce545d75f9d4a307f074f85f9840b4980d47144e893856359d4231c0637e32df4edb716ecb414f026dc2f8426793cf2b7f81832645d4d894c577b13e636ddbba74cb3a2b377cd18ceb3ce2b2fc67e75466315ea8cc4dd047a0104f8543894dd59faaf3a5dc3d83ccd8b2dde3dd49f17204d48befef5142d1bdf6f8c321fbde55a68a1cc31aa09130bb65207be7715cfcd9a975cfa2f8f8faaff55ee782cf7b8cfc656ddb82dd65512b85e78f5924005a812802294333913abc1960fc38ffe93c1584850d88fdfd528dd711b137bad6fec89f0259ede41f84b7996a41d8f6f7d22eae0ff939600fbff77a33642a03c2373e587c8279482f9de6480179f3e0fc339349b801f180d20d93292426fe52c8e7762bffa54b91a2d858cf71feeb11e53e00129d7c0a9eb142deaa09e725c42fa836c4c201e825f3e889720983b1f83f496110f61489b2f53122d9f8949daba265e2c760593925a16608ae357556d2cd338b86842ee11c5cddec03d85b2515721eca78c4bb9bc57603879109383078e74389f386f48d904429265626b920ecb5b4767c610e65b13414ba969f233ddbe12586e028a931fb1627cfa9c01ef489c223b08480e3df1d68554f810f5151fa9bb7e793cad72bf6ab1b7d0fba239ca89a22e8992fbc0d572d4f447575821a036aa308557cedac73549fccde42deb9025050b599b2762dc5a9f2654def91a636118673437464ec05833f00274fa4701757df1d64fb41c58d2dde12d59e83aab2424eef2a0f100344777b930eba084835fb8d14d1f2d1cc99c5373ba213449f9df41646ed6d4dea09f21472a0fe4b764beb208c04b36a44a73cce37d858b1e1c5f3be3c9cce9bb02628c40edce203c8514142d90dc5d0051a91e29ad228b59743f35c69c8cd3eeac06341fc0f40f46acb7a4fca1d14222797797f91d8271a5a65a6d6a6363d9c7e7884f724f4ab2be8a8d401e481b27c199ded28b4c36ca787ba563726d7129682ad8b499a4a5fa1274fb62482797854b95f6722c253600712e52b989e9ddf21c6f2c5fc8a58e7f398fdb2156bd9ed33363e664dfcdceb14df8101f6b0732579c46edcc99d011204469fdfea631360fd712f00a69603ec6627816da63544291c37073f6b7d272653fc133dc57ea234e7e7db01d49eae4272a3aa3537ee85a92b236663c89ac9478c56a4a7b2f94d2ed9757fa6581665b0d407c9022eb7e5477f71c09e62015f166cd408b433ac00a647e1547b15700423382869d24fa306300595f47d3e288be53ad08e1af17eb21e029c978c540a75c7ef7bcf151b1e0bcd7a60909afcc5f13ff9b5a51519bd8c790deec91f5b52affbd0e35cb6f5da192d2a40b10ef5b0fc1d3175694f31a09c7db574779d4b390ce2d85d81c3789b30cff8eef2263d7a5b0c9a31f86688fa7b7da58713e3cec85baf5b853e47ca2025db1258a776d72e02006104e6c6046dc90cd25c83e997083fb69a4edaf5c305aa623f1265e5cbd424a1a41b2b4f942907db923581d11e746b7e64a95538b7a8d5715fc345955a761656f2cbe081b342fc9b917eedc7f82324e60943143bdaa955df8f619adfa7ee8902c3f2d6f2e514366af2439f7cd9fdda1402db89ac009657616dd2c20128cbb670e7cf95578f40699d329a6788ce3dfe5f8bff554378bfb83099ad7e4bd170c05c0fb3b3e267ca94b37968f82d198586644cb6d64c44d17c3872b1473adbc9569a7936ddc7e79b163f252b6a6c928cf3231c42f8befaa81c67b57e8abdfacf23a824874cd19d65731ea2672d8b75a9185058aa749df3c33fc57c53a664b10b598c51f66cb67130fb1ce3957a0e79b35cbdda3bbe6de579321a53c328197ad564737796dc588c71dc2d214bf50683db1ef8a8e73ff68c67cfd7eb5259a882b077007bf697fa286e30c8eae46dc9662585a6f7df27bcebefaedbf7ba1cea55e68c4aff8c106926184ce5d97099c2d99ba356f248d2f469b5bca10871e14c0e380f298b3869a4bc60e30d2a03dbc6b1dd468e26b6b2ef1b6bbb7860e774b611ea7dd1e4e53d93871b5aa8b5d6c756658cdaebcfcbc30117f3a0410aee408725eeaf4e5184dc92d1c7f5075b95b48cf186ab1a3efe512963a169bc14a87318d0898ebbe0a17eeccf755cb850063af44d1a0fa36103cd23dffbd978b0de5cfc90c0842818fdce33937303fdd2efe6d986be3588c705ddd8fdd0a2549204b9e33725501b672e1f914665733cf84539c46e8424d19c4348d813514f35e2b849a66541e4ed5f2b3ccb6ef6b16bbb2c493acf521e06668c73c9f3dda8ebed62a2dac32eb4aa3c45d1e32d4027ec6f342cc91ba7766c6976e3a7e60b55e6135f400bbfac9e3870c397a05e5ac8cd2f723eeb61273d792c1bfcc4e27e6e66d9fd5687b7ba610f917281edd4d78ffe56f04aad08ca1d20322fcc2515918eb3646b9068c0d890579e31b501b71dedfe7ab41b68b65b85ee19101143deeb38ba5772d3b8fc6bbe5efa6278a8b89b53f5c889d507d2e3803101215aa0b7f31887704931b14381c15cbc712bc3c0278c0a6c498612f710e100631765087e4e5e3366014cec95d7b3fae54e331ad27c39b817d92b580f99daa53040220990638723117406f8c232cdbab2aae408b8640779a570fe651b0bb4c694fff8615a7304b08c1248d5ea028d50796b605d9ed4d2d4e5f17cf4493144206cc54fda1b7faedc87cb6b8fefec1c2bd226d5e1021ff1806867d3ff6dd114165b5e91ef8c3ac14f5c21d48f5dde2032f41ed2591c6f6cd2f81f9346f31d32ad01a0178a1668ab280e03b504d3d4fcf6747de005b2ef05b949bac7ed44294c96e0f0d3fce58396b5ca95220a83ce593c3fb9a53c65083dd49dcd8d0f16ee1eaf2d9fe9950896dfdd46216ebc69677e3b76bd15736aa00cef383b0d756779bc593fc1e73a3c9e079c6e04329ae1164df7dba288c2e7428da7c126cef71a7909977b830b7d3ccbf2120cdcdd359098c434bd59cec54f39b5a83f5f0111fa4872af0701248cf75da57706c4f05424adb4cf19b15cc7da903b3c8b63e48b440a46ac5da746f3785fdbfc8494e5ba4bbcf1f425ec853abf67abf8f6d4f2042052bad2184b671ab44cdcd8327bb95bebbf00c3882a164663a0317544bd45172a4bbc8a8873e19024ac9ab86c607761cbe1d4c6f465700299ae2cc7ae3d04207e6801704c0ad335b1bc197ba62458a9533f3659bd5a596abc845e55f5ff08dc1ef7f987cbfb85a809f07d603dbc7fe6163402ac60c9bfac63555948ba1c3233e69d2f0c0c0dfe4e7eed5f29acbb3f42f0d9a92d9c92e320ae93970fad87a15878ebd4b286b9904f2cd9a611c69c53daad06c44a7bbc1db19841a0c8ee675cca2c2ee00116c72466a661f4728264e4de99798717b4e7021773efd0cfe5aad9eaa100afe7da4738b8d7169ece3590b316cf9bb2dd3d7d08d7e64a71a6aa6e695edc2f5c5ef0670e1e403b0864eaca5078891c7edeb5196c3b9865132ff1c2937d168db3cadfcdd31c9839fa5097d73da6fa78591d11514cba258fdaeec092f5ae22dffd96e74359748601bcbfb2ddc0ca0a7b23a60bae98a759a52d0839b55c89f843eefe15b9da8ba1769f35e774c2cccab879b84ead50c4cf666aac905870b72a185f162d01871dedb219e4e81650024f9b5734a14935104bbcb60779acf00a028d9b0b581d7841fa5826285ff9b3571c43e5e410eb9d24c09b94f49f164a98a11389daae8d28c23da9c40e5685162d217935ed0f958087e4f0ed621c05bc6aaf2ef98925b2a17587d6e6f1b41039c04c15c647b299b6a10d8a349401212037a81a2e10099cbb4ff694f72049a91c8001cb4dafd93ad502df701385e6354422aeba9ae8618d82eb4ad328ded433b0f2a5eeb3e73ba8ea6d1130ce8e36d2a8b2e44f567f457b499aabf31d6e54b78238e273965e10c6308286d140fb9ec08a6d23fc6bc309b0022ceeaf36d76341e29b3f2eb680848e2a54982f4ddd65c22792443933549bddb73ff9cfb6d5f5f85cca9ca0dee0a8a4487e83969e50cbb17fa40aaf270a1f572f26878325a28ece8b3ac5635750f4ea5d52e4224ad6c53b71c3f14480e3ee2fda43ff8e10814ef9afcfc14bf7d5f17bfe41423bcd9ee8c75ff1335a6d616b8b8ce6c117453a133cd8ae9e5df65ec1b0b5d75ca94fbb8cb2854134c0c5b9aa643912bead31071961cb9d8ce15576006d539c3603ff981498ffeb2fff903506b12fe33e21d1ac31b0108a0f85274bda651fcc8e74679cbb55c6039eaac62cee7c1160722c6754ebe05b1d16786c1cd0d1da778ea71701be025aec3875bfa42d3c4dd270b95662617037b957496ee7ca60578a2f3ac125d0fc7c072be56bb8e92a02018749231031984d5db2e3f1122a76e098896bc2443797662c6440f45f1fb829d1975e5e5c44ec814f54cefa1a20b20ed5a1e1f3d9593b4ddb13562878a6d3a7d1315be8aac88f21d123ea60fa01e244141f1fc919423e37e0c5fab14c56e64e279dfffa1d78e30262376b5d26004487d09d2f620db0fe52bf937e572b311b73f49f96bf63399aab84f547ab92a58593d49580af3fd57cbf27949048972506e9c9d207ae4148ba876716cd8c2db4d4209786f39b38e1a23f9b7268350117b27d90fa59209e135cf7f79bb2301884331c1ee89670da88c63380982e7edc3847238ed006e63aa4bfc96323e81f108359d25f082bc3734d5c2877285805b1c1f9c21209a5414de5d57956bb3780a8876674950cff6e1b270d1ede73dca2a7ea3e528f30291b6e5920d88872a712b6468538e16a68568afdc2939e72d969d7409644641fc050e749b1664231bf8d3165f79cd24a56c33467542828182146ff7d80e35bc4116dc37c1e8e34fb9dadd411b365f4555a57f27770bd61dd7507767210469dbe49a98e4e0b8f4bdb5e623741c3ff940265a29ffeab4af1031934462b6534a4062a15b90d26cb81d94c3b48d60fa3b19881c688a892d2c5d9ce72e9979e765755e74947d237a2ed01c3ae99a575d2743bb7c4e2bdd568ca10840c45fa274cce91dd269d95f3390a156f30f14001796999c4311af1ab1f8fbb8a2df4f4bd3bddecdacb5edb5a29217f9ac4d5a479beab0423b36e00c26087a2ffdfefc9220b99b2315e40e3958ef7f04944eca3b275b571db71ca5545afa5cb73ed9b3a88943f1c29df5b7087130757b6a2d25b5762552439e49a92ef18f19ed8eda8cd3cda7aa5e7b2e3e536941d2163458ff14244645332307eacbf5c8f40882b596bd2c447e3394ffbd26f46ff204c1b8b00c82d39117adbd09caad75dfc9c354a19aa6a6a12077f250de544a97e5de8f5be56be63a74706b8be14a117540fadfb366d098543fb5febf4edcbcf67df70cd670c8b652d884e3fc684c0b66f1a66734c4d3b282e66086a06eaff660b04a1801949fa9a5afc81f1e5da59840ce9d388396654de867c75f4e0254f6e768f4bea23416156b5b728c67359ce1f0f855945a8215f105452b8131ea48066ba42e696512692ce9fcf25d8516d86866b4572b60651450d1f64701339d45188277756563c91527dbbad937f9c574a2e2e103a8cb0685f14da3775933175270ba9be35a2a64bc9e62ac025eaaeac9584420a0219fb980400817b5a327ce1d04c60bd4d3129fe2a84a3785c9a1b335b1cf0c714fd69c9a6b8d345b5de83e78003b0e626e9f4fd93f26f1f175889d9cc579cf992eeacc129507a10595fd5dffd01ecb6185ea03b2dea03015284af8fb0555357e47290f8afd595eb9591ea8dda9ae64a73939cc7836eef0e59bd85e3d1bf7975274367fdff7969caca35b9caec547dda03c25d5132a7f16ac785f5518e4aa0bdc47c6199e9e0d14c069877ecd19ff06ab88fa77b14b08873885f1d1cd20cc43647fd30216bcf83ede47b74637fa1a17a0ba47780ef571399df33bc8f95a04ffaaedf6ba3040d648ccfd4a1fa5cba928d56ed5524d56bcf9793db625009771b14e674f0960e88c786ba83481dbc7cfb8667a8866e08e6b8886f904ebc29cc5a818828d6ea20bd0b6aa2ae70993289aaa3cf7f499b502315ed60edc7e96b911d927edf051aab983ee6d6beef6f09a5f1a8a41e37af973518866438ab6b75c31eaf014d65179e106f3257dbc5ba6169cde8410b24ea355ec54ae3aaae1bd39811895b1b3d9de5046210b0529fa11fe7afa7d5c3071910a12038057d149f02379b77fa518bfe853c1ec0a06eab2fc9e4ca5d01cfd2660290f2ac81162e8fc0673c60b9c5e1f08b32d010691f355fbcbf97e194f9e16b66708219ecb8bd9c15ec80e1845d4839d62f9cb9735ab360323be894c4f272a51604356da39c1386922709aa8c0bc0b916fe7c36499b3c8c7797586210743cdaa14a27ea108b8548ec28619972765b4156ba2c95c54b07b15f3761b2fd6c6cc6c6b578ee60c54bb054e67423dc7b06c7a95f501e8449af7480b0bdabfe0049442bf81dc3439fb6deaf1d0a334d46704d93afeb6b312a869cc86d6595d1be39b42b9b67b8af9d1373c61c5df703bf993af4e98a7095de11ec1a758b61a83c044ebb6319666bb52e06c7d78d2204891d53ca0ef614f85c92956e794e7bb4de971734a264c281dfdd91667c53f81080adf01cf89e90441c03df473324da2301b312d37763160b85de82a04683fe7edbaee555627b419a1eb0b607f3b38a4635cf186b91d10e8bf9892afee30123dbf5e22e17ecc168d6c789bfed6804b699ff9327e74aba5b8466a01d891102c6e757703311cfb8f469cb5c25be6558e8176332647ed1d07a6c52fa260a7d98ccdbfeba180f6e3047016e3fb728d2aded383eee67372cdd6f18c80bbc697d45484eb2adbf2687a500021d0932e6d7b475b66e8b883bc61f2ee9aa4587a9896d38af5f7d169cea43a96b9971e09eea590626d7d4dac139b0303ebd907a3153e0366e04c5274eb769d778ae687b0d9a47727950779d3171501de0683d5ddb72e3204ae9498b0ccfabb74b629786bce3b08448ce389941d038fa1d1cba814b1c86f68818c47c59fd0af96f57f360101f02cb63544f46b68b51b840ec3f38e160f44fa07de7692a61fdcc17d6ab2c60e5c25c0a3f2bab96b919d543ccfe6ce009a4d63f18c088a36bbd73eb22d238a45a8d1d4be2b9cc9d96580a4d4e4ad1844efa0d138d8cad80c4fdbf6bacd86b1d5a4d51ea267d82c2ec144a9d8a4d5b4b18118cea4735c817a062e8e5409ebcdaddadfa1aa5fd8bd6094ec30116c09d206d94ae3af36263ea5bcd0fa67487de9479c37a971331bd3bd528f0f66aa262bfe6d9759b8641cfe0c9aae8264702563a0f3bcca3451393d597651a57ba234d80e2d54120ebdc8b1bea4724848092a287bc11132f600d67095ba7e013fce89a97046c12a84027eae4757fd80a44c78258e99f6ca587ebd9a64a1bd3c9ecfdd89a9a890d4ec234958ece7d87ff5bfdba098f5ee1f0ea19e83aacc652560699455186941160559fd96be5aa25b3aa2c7a5d8a518dc79dda5fa27cf60069ac10af5044180132d46528b7a8a5b61f1960770ca5b158b86e24e5c34b22c60a20c9dbf7920e0824e52fc10638619f5eabd05a375bfdbc6c3ab7d32c3177403056d32da5e46b7acf49b8d904a9230fc874869bff2d0743aaef11152c49d86c3979f83a01c5be496ef207494adb1520a7c9603ed4166e24f5603faa81445406e2a0d026073bea4fd3a1cc601155ceff9840dc921c75eea51030cba7abdfd91e4bc8f7398253851e4e585f1b3614fa98e2a3cde4c1a1b90f5a66637a441019fccadd4ec189acab2d65852b1afcd3886cab60005b0bcfabcad7ff8fe222ac778c311c53ba4f1ec5930b7ff0db822ebedf5e671a95f989325628b667f64e810a8a7426e85a068f7f8737ccdad3cde5fbae86dccaeb1140b62c4f604de84368cb2970e5b59c6adeca65ad47383b3f3724ced757dc033169cd75821534d8cfc22d975e00042237a5c6a94b6b3d1ca8a037ecf68c302bce4dcb1d319566f65e3e30177ec2acdc101fa77c02efef61eb09036d522b32a8039eeb5a9dd5cf1922c3b64284bf0bbbaf6a926fbf0651d4166d24c38b117f3be97c9d4a5d20d4f1acc4bf1f0491fb091da084df57de751a11e599272c158d4db69d0ac31da6c85d7ee0268cd2a689890c4c851c40aef9a6d4bd4292440c5f490d7fd3e6fe931be49e31982ac952b198362893872824c3a8dde27ddb481ec29046f3de1e323ac4a0305eba04783325a5b039d133099b2b65d798a6e104b6ad1779534cb2a5d77bd20a30a8ae895a16115825f0912d75986b0da6a951f54fae51f8ce16a0f9644c937985e19c5ad2084a2f436381132624dd7c157fec53b693003717ad700aab1c555c2bbfa03e8206a6a0ed41e262a9f58eff4a423897d05a11f06c14e32e186eee4f58ded7937e3f77abaedd40db365931cede4ede3c5a62e28abea1c841b7d24c88cbd0bacfb1081628b285257dc8acddb988449c3e62319d61c2ac7fba4e69e75ffe3a26a742b6a49a25c1afb2b7c83c33141dea560e981c0c8aa8cbeb5bb10c1ad9122fc37c07b2b1bab894804a599e1850bc4ebd2c3c1e168f8c0414088580103dd20dd841d16425f4d572767f731532d1d81840c873b3fa524edc6587de2e70ac687b16323e812cf55875fb3d5122074c4ed851ec993944d8d3d36189eb6587536b477db689035efd3a9f343349d8d888d9665aa98e0403a00d71ad9766b0e733d1698b23c0aecb539a4992cffd716f952b2726d8f757933b0649d07200ca0fa53cfae83b24d5f88aceca96f79a3ec202a7e1669ae2dcc9c39cbc9099562b275b9b3220cc841a0cc1f56db38af02b7b1db8d3c265287177a6235cab0677cefc30b73cb4f868ad8b2a21822fa1bc94862b9a8f5769e05816ba883cf0e6b3bc2d6cfa5e1cccbe1366ed18b3830a50a321db4e85f48dc597cb65ac8f5fecd48e8172324d075e413691da2f957c476773e35c3042e5d621b89fef039275993ede3179ddcabf2963694787cb0376d3827378ee36f7a6cee51c41dae473b06acb1b3855cf221e4fc3f334f5a1843c0dabd3432e57521d8efc0389a447b7aacc1b58a18dfe7ae448c5efeca5cadc403f32e4279b10b96728ae83d1db594a516eb510b7c999abb98f126c721c8ae3e335e89154885c0f569671a108f5372c5a5cc7b4cb97f2386bf224c176b8e9a7ed0b4b0afa28dd233c91d16b73574e47f4d41162aa6f22469d2f76726723352886a10f43a201806fd62afdcc2bd3a59052881f81601e1e27664fb25b2b8864082990344821949296f3cee529cb11e9a0bf12f0969a4956c8ec73b2a3215fb47183cb4931914540cad919a11cbd942b7461d534531b786294fcbfc853bdd0e6278f07da203fe047fd5c27e388f6b7f58db36364b23c11d4c93762eb9a4c4c0aa403fff34eaa960ba4563052472519a36298e44b98dc78de80ef95c7dbcd35dd2deb0cd0882c0c079a82276cbfe6b8ff188c7f29476bb7e03e89860b6c4d9f0bb288d8e3ee17e3ad1179ce6a39644b9ac5cb7e2dd0208d5830eeca92a3a6a4f856d1aae901088723da4567ee7ccbe1bc5a0cdfff77059d91110b7a105797c1cfe700e3423d884b52082825374bdd599f5d8e9b5e9093b88f3ef8e78ac123038b9219acb5631febb13566b4c590a70181b65c15f99a99744408bf0a2c26dfa64b729eff44a70eae3a4b291723ab1532af464a85c9e38ce0bf5c99b66ed87aca276500173564afe053718d04f0a4532a9dbdeebcea4131cc7771d28eca7da2bbb9f52c89f55919267a79b58313d9199cfed37d0e54008b1df5c1537efbeb2bf116243c012203cc2d181f858854b789d34fc65915c2f3e11efe224516d2008136c91ade4ba8a2f3e8b349ad7c3eb28575ceb9845f53ea6caedb6b5acc20f709a827ed2af2a7a5b9495877d7bef4aa2de60dbff11b7317d4f7991beeaeff208309cf1388566dab2545d3fc1598d44cd339353daa9feaf8b287b5df23682998d9641ba942f79d2cdd6d5f89cf0e4b0434096d9803324aa128bdd12431fee2f973fd9ff6f74c378657a4cf7ab6c92ec4d30f126c4c0be8fafafcceb38b0085a49604378aeeffd66db5d81f252eea7d59c33f9feb96bded5086c5d1816f186f14340530e02be92245776cb95492ed6668590c98106ecb0080cedf0c8949460839c912ab7e3a7157efee367cc3288789caa0e1d9fdaae51ee2ce30edc84bba5b39c83b58487c0b5cdc06660ec6d20ccc80639ab4c74901a76763ea69ac2ce082557d1d6496d479b26ac84e4416086cf59e754ea4b83153f9ff2e31673c27e84ec45370d5a9edc8e91ecba53a57e7f9792d3fb59e0fe3b8a68985c3879d2378921a24c439f79e9ee20dd016bf4c5c6fffc9c8436e6c3767802c9088f38e7e4af07a3d60bb88f7b96c30055a92290299e8af37fb2629fa610a8848dfb3f289b56f32a0f1562b3aac97e591a570fcaa049a1856be191d428c6e8bfee5f72f004ea8d0ad356d27ebc6b193bfbb196cade11fac93d5e07a6a2339eb3a7ae15d25f12a4561b2f64eabeda160982f168e828dc18561fda7938b7b9377962c921b3cd380da2f2994b9203d9616778054140bd81b5d5ccb94778d83207084d686a2e3eb442c6bca8630c891372af0e08e583b85164d242b1836e8b58cbf30c9799d3ba882f7d5d571218d4e36bcdb92d843054ae35642a0d0a6ec6d8539434287a9ba6537deb2775446d4ec93218bd18d98690ccc1f6560b81691509a687e0a072c28651841ab0e34efc4d092d4128d2eb375a3bd8b65305fabe01fef57e8dc752ac152e836539704886cff0d0cc759126e3fa737a3eca7d47e7ddda8836c15de9365111470f3690130eb3b30693ec0ccbdf0b876900b7f6f5a5932a0eed1455229fd455ee82b55439b521cf460e9a797ebebe332defc6ef7fd3b8c16b56ef6b2731de2c4f8c0538194152c77bc5b7e4e3eba27a6031b0fc3670f0a62ae7ce0d64bc147bb7d92f569c78b297678dbe291ceb856dce7cc4da039072843c71b0e4a502621eeb14103a3d75fcda026911665389337fbd33c2419371191f567a2c4ef4bcf7c44aef3400123ed744c94ad1b37a12b5937dabe9d435bcbe22c2164ce4d8357fba7c0a8a3ed65cfc87352e08a40a0cfa49acc1f9470e638ec54d48f65b10247d9bcf2f1225edb4079f23fc6bacf9c02f232a4ba90e40a7537dbdab020f81a9bcd5b4ccd88fbd510adc85c4067d846a2fd21c11a8359f21f9cdd035b660824bea7e0006217382377e45f53f2369c74c85101560ef6c276548b39b0ad60f4a092371d0d739e493f927ca11658bb201f3bb07fef983a7395e0cd24b254b6a8b0d0786f74ef758972eb9253073d8e6242aaf497da0578b83ad3870593b7eb0ff317f0c3ea7cf2b9bb9e749001d1851d64fee2468f657d708b7c7861de98c2939847a542bc9cb2406cfd5c30e4a7d1feee969fa258b730bf39ef48a36b01c437e0c96da29f5cb1960e64b4932b1c1cf01629175bf6482de2ebb594c01b5b9091add476377f3376d3063d3e972060e23d35822748aee742afbc65575867fbaeaafeb65d6a4b5217c7fde606f7c404894bdd4d261dbe7530e823b586be8b67964c09dd5a2a7777d77ea6b4e1c305bd5a9594cbd88cac558cc349595d42b5118a49fdff39924dbbcfdfd53483bf3f62a940b016b9a09afa67a3d2f748ea6dbbf3dbeeb5c47f289067aa7afd8676983dbc406beed7b10d1da1daec7353fbe7c0d86d4e5d1aea840d66fb6a143da207b67ff2b8af2f2f650a03d7e6e933bd4cf0f86e03e8901c0ab7f39ffc5e37e3ee4b325810460a0c633cc2ebd9beec7e25fd79d2cbc3c76376fa305a1bac1d1d7619dd27d71e11a3d328656da3c1e9ffafefa895f9ff5126df7d3a90d7cf67d8db95c072387c3b4fcaab0b1644742334c3b1e76a585bd1589a4bb86326014f345349517896c780c9cf53afb9d1b5b94896288a4f9fe4dac8050daaf74ce93914814edad0dbaf797b015731d39d14fa6cd77754626aef9e55b493732d12fbdca2543ddf81b22e90281bbea7e36b94497ff9f12938436acbdaf13171baf450f366abbc625108d4fee7861f268994d81c97bf416cd9fc63f351e8170d35f80af099d2107413dfb208008d6f27f82480ba0106d3cc44a3573caa3f3e28fa7866853e76775b72e7c1518499dd6eabc8e989b72b9d93d5045dff22a1c75cf55594580546bcc9146a555bfdcbdac5f22fe820bb64ed36f444fc5d8f323a8b4a9aa3ab5a6fa52ab397b604f594bba842bd4cbbab7d6bc3a4f0e31988b3aebfdc883fbef751627007c94c85a01a7caa5ea857f419878c8bdfa468e3928810c9e4fb905b329f0c59c716b3aac241d2f55b8627762ec86064e9fd99ebc3795b63acf0e255cbb18c70059eec7e6ed07c5a4c95e1183ad78dbdb4632f6d6dc609b843f753a915251b0f4767028b33036879a8a0508260044624c1cf0359d2461ff9aa2eb82e251fc7973508088f6677375ef4cd7f09fd89ef48f65b9fbc664bb35361eea8c9720bca0e8dcbf7ad3627b2afc8254eded4ea75a34bb47a04adba005b08931f1722302d8135b5d9bc80ecdd1b16d66c5faf23c020add5d011d8d444ad67faf405a655f3745fbd7c50d99c64c8dc94795344fb2f39446166df54208cb6a908e019defd69b712c9f988fed6d3af11a15d7abb7c53891238504cb5f6f552e8b607770d230a2dd8884ee53deea3be670c939ab47c1c6ddae734e0de995900e6fca3cdb6d8613c3231adc96dca6713e5e2d2d238d4ff2213990825b86a3bc8f6b482e658884883cd81e297adb009d516082a3146899604ed8141406823bb96242257a91e0aa6203ba1bce561f1fc22a349d41d82b61ad8dba60118eacbf9572c423b4202be5acb7dc84b67cfabc2ae6142c11832fe7970cf362d5bef892e0bc5b0b411c43d36666c690aff974d83fd700af8fdee3c54c8e3a504b27d99c8493a60c0e5a0d07350ff8176596781fe8a76cfc45eb765c23e570ebbd5b9dca8dc3f4ff0cc3b7a7d56f0e96bebeaaf1920b43e2a97ced4027dee8276ceba8919191037a9a20b268cb35cb1c13f02ad4de6a89c8b335cd808663960af1fb7bd41067026208416954a67f17fb1e2523cad1b8130edbd911980afa9cab137da90c809fb23a12746480a85c44ff75542fe37ce3cc7435b43f0db9eba0999b2cc9fe21ab96067dab3a257f6daef96938bc891b86e8defe38b0c6aa471c9784dd64932fad1e665942dd0bdea3933f4cd9df036dee721c155746c6b19d84f63362dc7a6b0767359b7b2cbfc8e23882068e7a8bbb27a2fc99fdfc6f6cf993555025de83c6b7b4dcfe31da213e2fa689e2d92c9f2eafa86b9989207f64b056cb2eab3e4e2f2b6295c99b66531bd966967f7e3ae8450a091abb500d9d96d17f6a10cb776550fd2e875494ede2f734f6108fdf88ba30b510e84d946684567450d5c83da6f66a709b4d65b9b345d943e39d19727f1656ad19097698bf9de96a64440adcd8dd5f8008ac981dc5f8573c2e4c77f9577266158ced0c2ca950f22aec709c725e85b15f8db540560595d8abd8aaba9491419f711f988c169cbfc7e24f6e5248eef7832e97ce237cef8f3e8c46554e4e72323683d2dd8e7c5978e75b36e83173d41d73fa681bb0af814e2a2c9cd4db0b6d732b796914bcdb2106d284d37a2d86277cbd74475179b251fabf906a1456c3031744ff84f12bdccfbd77f160bf928cb454ad638f83e33a8943136a5b0159acdd3483698666af855415f66cf3dcece9f717a2f479d741351c683458d1ad0792878e68abfebb5c58c836ae8dad6c95689f9ba3de3f256696d47901382e9c9e4ad9427254bbec23f78b5ad2b817194b2e2ea056b11b8ee27035a511e83b3305ad70eef77b3d6bcce496a42b7f3cf02a0909918d59b64592360466c4b9f7172258d6b28b4a8b905407b9f3a2f55e832466295d4da29e75f1e290751d825866bf745e237284f2a4d48ddf52b8d456d962aa7404f3380d0312b88e090e02fb2bd07fb475ea02d3ac327ffb31b9a77093c6a50aa05bd1a0c08db3d15d63d4d71c806fb3ac40b4f74ceb77569edba7ade072f760acc456efc49afb7e07a39b7415d191fe25fc2f689af5bf4e7472be6f80f091eb993c0c73b87442e3bd2c18ef3908ab2dcda496812bd1c6bdbfaca1b63f46dcf42d2097b71fa3d6bcf7e462e3b4a148f548a7174924753d3c7f94455feba75e0c8d21a43f0cac7f91150dd42b6fc0c6193b473631ef86ad5a36e301187c998ea57e4e970db52713486eadb1075a478fb93ad7a52c46b25bff9d013a0ced16ec5a4b68f670c0320c94fef9ffb83c29995e82c6edbaf98a6ab8ce129e70dc89978f358f3988c53c2cbd0e7fda48eee7aee983d6e6d79ce45c225deef31025efb8f74a1ccafb900c56512e9e2e4954d9ec14cf92ce680af0aedddc32fd7a111ed8471b9e4a6cd9773e8d6fb43639257a181a49647e19e1f7b8f32a2d9117a4a623914c9a287673737bfc2526cf61d126999a8f9a5a233aa27abb6e99d6ad48727211322f4eeda5c80db1af707f4d87d2276e4e12fd48b592c06e0040bc869ae16b50fa8d961833f89d4f1c1bacf5dd81af80bf8b663b5b32686c9e41945f921bb83b5680b4810e4152b24c43548be2a0e3ce2988cc89571089d6c107d68619e8a9187c3df4afcd56cf158d1b648b18654482771972841d6a2535b845896ac73b7fe6aaa47b3c5d8d8aea477159538672b2f2c74b7a5922f0b5a0371ebe093ab4ba29cfd3c11eef887b0b0f740ff87214c25dd38a619443b483823e22cef0d835df47514b5626fdfe2a8e6e8acd75b23467dc4c4f6cc736e51e9c7ebb0dd048a59fbfd1cc6f58dbb0d0d32eb6f88e03004446521f2c0cb41408301abbe9d092f164358641e5a6217b5fd34670a14ff942f18fbf9f85be2627e389ef1c016da9bd7b6d415198c7c1f3daa3bb15c7e3b820b338ac7b512ab5f54ce4cfb75b5eabf19781af1249a830cc8a9b348c06c8443427b2c4d9ef999d134c1a4874b8e44cb164d862d4b9462140acef09018da52675ad02cce1d3000937b5596c0cb024944dda0430c7625e8c63a3b290180a995f47101d485186df130e1770c4793197d9ece267105396cbd2ea3cdbcc482ba32deda12b8b547571a1ced850a58e03c4e4d029faa675dff6750c21af750284bc2204959643f6af9283c86af023b94fdb3ffdd3fab263c00fd3b326b769d3a568380d1249bbd3611933bfe741fc1d5ea92288f0ae32e17111188578235a1e8917d93d76046547bd72d04f12493f12f69218488c44aa5df0e0cfe20a7a1d5c1bcd13a043c1b66473303a4f48b56dbc0dcd6839ab27a686077a9dc2de593861f749c54e0b7282073d352cce6c5299024fe6e85ff41d6cbcdb3f21beaf257f86d58dfe2ca43cd7816826f3870214ed06c4ef0ba277db44bf2f1af5fe8ee23dcb23114e0bfa0cb36ee1fc052987a8f84042c0d8e8279a9060864fbf7bd058d9a2ebea4d03b926da5698b958820892170f07237627695e915aff25fbf3a2ea5f46b4b4c437e15a19b92bf6c828b5fb14e4dd84fa85647e00c2afc882fb2c4a148ff24e13d722aa421c7d2fbc6d1fb1b8c53f6b19762247b767bd74b27829f13b5da0ee82e3ac808cca1cbf9ce73ed351a6e25dfa4aeee73d14a98036c70e69d72db5387054bd1d50ef8dd19be573cb1679512b0eb5b7a33a14b11b6fc7ae8cc13bd37437e2d0467b4b5fff74e5e4b26970c56f99f2df40b7dfea150165ff3d1dad5dafa07bad5f2f21e8a31f53357904d48f841f46f1177b9be5d2f1123c1af70513423fc7217801e10b65598ebcf40754e9c5086efd7e9b46ed9de7ad856c7609e2404b01d82d5cec59af0359dc86c3ddc0922b64909be8986438407ab0c939b087203dbfcad0f438a4873866eabfe30ed568ec54aa46c0781d3eefeaef83a6ea75e0382d96f9b9224555287e09df7da69269244256140649811bbf17ec7fd034191763431c922fe2f18e2f9f113e3e7ceb03531edb5b3ce4495dc8c333489d2d3423d133efd089d70148d0b31de3d8a29779bfd19569a5c190000d25400bfa4967397bcb30f6450e1696976c9306efcbdf47a8e17a6ee99ded1df051cde54f935caff68a1d744cab84d3a5ec1a3a0f6d25a13e7eed2463c6689db95129f136d7a2749efbf6b5f7d04ea38918dd9ee191d6c84f40b2527543efdcfd280aa5120abe1619a75402648255d4f756c00fd3cc498c0b4655c56bee8354f31e3ee8b11817597200987f81ceeab8600fd911dcdfbece23f03bf480145f46d714c5803e1aaba2613d17b1a54a8ef193a425939487dae71d7ccfa22a2e8cd9cb18a26fc25102046c44890c7f2273ed0bce361b44299721262ee2e132e65f9dae9b65ee8e4156929939e13dd4c9e5a14837601fc7de2aeae936a78fb73c6bab2d3e1135dd3e2d55cc492ccb4636f8c66d46caf6b3796d9d9742be793bfa9400772dd2ad5f1d7c60e0be94d704b144ba82113dc3351b201a9aa307eebde8b5e6f318eb49a4706e55c75ebd04b56da06133b9fcc1fdf339a98b4ac60e0096c7a9f51d421098f6c4fd7d377f95c44befc9dc8338e38c5ed49adc6b98f40314734336e34bc6de9610cec3a336646fd466ab6db1d7fd1cc1bbd143fb280a3a7585cba76712803e7779da6316638c449e0bf9372dfba998f03e81651fbf6d937bdefd0b427376544e6d81107140147bccdf7d09412562dd1900d73ee2aef48bb5e693b717b95dc7b846856eca46b0ff927c56dc07352ae74ac521e46a89558756d1a3ecbafc1730381a886e28113c6fde6a42d2bd4d4c456906c9ec976f3eff52574409eb3a0249a0322f584ccc65efb3e75e2a4a374aecc9323debf089ba4e668f21493cac91ede2a379ce2ebaa72e94145f1ed4366f5bbdfc380b25d3a3dce507314dac230abe3cbd2864417d8e3c7435886d75c148b8268ded4946196a009fcd7ae9573e6bb53ed5cabf06c9a457133d8188d83aaee8934891a1d7370cb9b35ec9e9109aa73c0f04acb175c94ab14dc56ce20c2adc14c77b392c59ff4e46ed10e5a42429486f8728f57e548d47421743760da08a305cf9b662041da129227dfbc1d9fb1e0bfb70571897a4b43c103a8cc4f9343a0db35c9c24874b122e90e16a485545dc2c825e3865635bd36c46647712d5b7cbaea3f9bef729211dd36ee32745b14b843539b65566df2d01995e61c2adfd86ed0a241881cb9fee25bfdeebb38f144d6aa67ba21e82e0d6328d6b45694e599d697689480b4ddc1ea6ec092ee48dbf9c733b801c13dba9a3c558aa128b5978a1057c92bed91b0414b5fe7d9c37466eae25dd9233c07d0b0ded5b5d9f0e3ed3e02c7e9fe8a7df617893e12ae09f2c94cbc2c27be4f91987c1ff9a519b9f4118e61e7ac33b3abb6877c44229105f84dd924c765bbb0fd0645c70be380f664c8a73ddc2bd088ba3b0e4e664459bb50dca70ddaa9adb337841bf934b233e0c5d842e5e6f92416e92e1aed424f78c0bede2c1390314077f2f02b6ff34c9a755646a80b989f7c11c6b4762bd4e656a97b3cfb36dc6b14c9492428c568857695dca0d4ae1cae3b772e16114913682a86163b76b577adddc0df8f2f9951d7a89abe506fbae7284c763dc6dae5300d584b34bdaf656670734bc7f1a8a9c2b34bcecd225366574b54cf148cc37f7e0733bb695f051d525732952d61e471b68f0a60d8c0f94237802ac2238e9c3e83aa40f286fcf7fb54b6dfd39d0c24e4de6410b8da663f6253f62c208ff5beea26e707772d20afd5ab07dfacdce20e8b138b75fc06dc3c13ddbcc54cd8653e3253bed90da221d54d6a2177c5d251a451731cda957e3f3ed5006cc3850515df25b00f7d6553942bce5a33f8373dcecb8fe1ac09459920f181ac0a86be1a22133a7d7f99d0c5d87e820f6218326efacb2a23ea24579737f5061fd675a5e2c23246b45be558b52417072c483cf8f18b626cf90e163327230dbd66cdb3fbfcff9c89b38efc3ecad29a94d3aa682d635f7e18121a7cf16751ff349848a2a315a50ebfca1047455a241522744e03ae22f87822159523588c2dd0d41f13e274b1bb479fabe728fddc5307cf7b964ecf43b4ca5df14fa3796323059f658f2c9a6680b10566e25aba0c040efa7736f2887bfa1ded318b055dc6b3f0341286b711db4f0ddd9e6080ec8f92158a0603a7b618fcf12bd1e96fc947e0cc78dbbc665766b36b8650be81c94bde437008129d2e7e7468438eed53861ebcaef117ff007cc67a59d74d96427eb54a8d0ace57043ed09064e6ea64dd1d9ccdc8b52dd8792f086dd983dbd63e294bffc9650358c631dfdd2487f548c2da8836b0b82d579bdad306216bee9c40c79fe1b1de42b65973896c7350a018cc5dec84527ca864fafb3163addf004e9c47c567f4229fbd3edbcf0bfc182581d3910b5ef341706c809b5ce7a900081a20a6a4b4ee6dfb3ead5f220a69dd98746f593551e6075225d989e7a4df03d8703f111586e5dd46d4541cd2a2110515ac3f04b516244f097048df66c806f796fd1caf6b3c07520fc4c12e68e6f614ca35991f6db2c3af419747c16abfa0afa471001f8cfe51630f493768c08f308a994af8d375974fe6c5c81f65ffe7309eb5fb730214563c84e3e1c97b36bf9d78c9e678d1323ebaea2593a705d1b78790e52cf0cc1eefd2d18a9ea1668d938c70bd9e16952132e3abfb19fbbcd22ad81cc26d80abbf57e2bac1dab000e195471f49efc1d9d71f62b0b87f9fa9e93501fd6758616236f7d33ba1a895b912b7fd983df8a16f35ef2d4596e76d4ccfcffb9af683311ec4bf2c8b1d755cb26f87f55063a5e899c4f74d0e4e7dbb2468df6981ab055704ced2c3cebfb04e0bec94f0e6ac30f16c1f379a472da4fa5a9d67efbfe804aab83c6564576a5547868c9e85aae62353da3a7077e59b23409a25d0000fe711086e8db0eb73fd3c0e647fc627212f3032c0bf311f951fcb294b25abd17145057f81ef77ee13359bf6df97b1a828b6fbb161469ba2c52bd6089739efb7d98bde9613325fcccbd53e408844ae395ca73b9c5bffbd598b8184a473111fcd8b2ec6c1bcab1373f93dd3ffb33d1c63fc4b57d2343354671f8823ba678dd2bffde2b6df67bed3da7abb128fd72585288bb4a2673f22de4b7e49025bdb54e7abdfe13b65bfb74114f29c8cb96f80753d9c04660ad36e770eff54e358a69c8ece7fbf367ce60e6c6cd3b29d82f338250313a790fc792178b9c81b0f451256481748ece63cf9e6be51ebcbf99d465395b8bd20366d77c26aefd0049a6fa733c75770c477dc32665e1eeff5872a94d2c2a00256c3197912fdfae937a398926db4e73e631f084a43fb64b40f3a7266ef8886caa6cb54d3193202c50888c36f0965ba7eba40966b163614a331d7968e768627bc093fc76f5baa6260840334dfa957b38a6a1acc51ef436883b8b16b1eeef8d30d477d5de92e13c22b9d04c364da955cbe9a2c7b82502c0cf2a5a9aa6dbbfde459bf923c5ee46c7ae9cb1ccf27d2a590a41a342fc22427ddcb9fd010f1c9669b2a21e5c4e9887acc27ea157bcbaea1feb7f4460403b251668786f9512346b5896645f15805c591b8172727371497cb309749e9a2c4899eb4cb66ab9d6daa50214f9d959bff4dd13945b920670829a01e49757cb5080ed03a9823e130a97cdc50b49fe6d7f4a6ec024513d42422a3167714563c7afa5412e930d08932ce93d499d7bd564f1f24c180d93f1493d2d214e80dc23861a3dee6c1b845472658385b8775809e1fe23e8e5be45fc783e244869febbd18f8cb92d294e118a796f515dd8acf82578eebe14551569335f24c665c666719f3806a3aa21c05c7e4357752a22c0534ca098ad01008e478bd2b83c9c289a1107e96b5b1213787876b44631b716f4aac149b313efc8d7e5069ef0a6343ed984b88de47ff192d27993020ebe2ca7c19a01749467a7b2cf39f1ef3216ce0b8a83c6bacaf025573bd1e153cdcd6f8afda5def2ea31c1220fb1831a864a76ef004fe7e875999fac5d78eb9a74eb81f4551ca0a632420e28a8ac3fb8e563f3c92abd8d0a9170d2d935e66b6abfe44a299ad71d5b85a503c8afec2442c503c7b4645c306cad3cf826cc41eeae142f4467750ec650ae28eaab7ce86fae98e7e3ca3c6a5f0cdfab37a40ad8578cb298853335da300fefab7810f2b62c31bb8cc0a918fb17119216cbc28643e8cfd41543cfab449cddbbb7947dc8a54aef3021b4fb2cd73e1e8dd9d36b8c97ca92c8f62384ff1ff21039b19ffb7a5aaa440d317b6a001b789875d541dce6ffdded62aa4f64d83f1267a10836d375b2660ae1812efd6b95769135851080b7fbd65c9afa1ffced8946418f0bff054cf0e5183e2636fce56e642e80995f2f41ed04e1793709edfccb8bb8754c3af7c4e49244574e0bbf0f38f0ed97a1ae8dc856ad2a4d91e7fcc8695b96479b301ca3e26aa8ce65d057c36308578afc09b30e32eac58775704c68dc50df7ced14d279da4a706c1fcfae820512eb8012e9ae999e6a8d677e7c7b9433e44f8766c53ed19d2b5e9ef551b789b343db3c9fa452b113a2bf6f8eff97e1ba2bfb44c029b27fded6c6f18426f9ed20d123679dc5eb4cc832406025e90684cb04ebb09e02da8d45e05c6bd12614b38a9807cdebc2cac68216642f7022aa9c86b57bf9ddb639ec97ecc275497c1bf893d6e66d663614f05fb0652846d234fd15919dfdd4ee85ac312c66ec373a8b6e3844072e28c57ebc5d4c5df16f2d7df3e54e56a9cf7a01d3dd85cb15c332a6decd4ce74519946c417b409fc34ea1e99115fd7f86362535c82d82993b0f540bf1e4b50a1ddbb2b32fb41a384204acc8fc3e8c1364d8193180e519806e364b9fc74e310b4f7f4ca60ba193928abc7d705ee1e397fcfde82f76efed844a85891220bb7d70db38d513f33475a39f52ba4462a7bc4e5e76ed9e1ba461f107181f047775384e663f5d4704c95aa53232fc5a318331861f53539f053b6c7062bf7999ad30b929ca961824ceba6b071e1508ddfb02d383fab93b07267d8a8e06c77e06d6d61aeb5e2fe6213bbc9b596a5ccfbbd31e11b42c77a71bcfff6bb843aa56ba05573999daaf3125f851b5a6133ead1e23a7859a063e05a5944dbe3205ef576c9ecbf389fd97b0b2028c97f92da72a124cb8ee1e54ddb6075f17b538282c6f3c6de0a5b2faca33e439fd8d774ada14d0f571fd15201c0d4f6747e20fc723a9a5f703a8d9091fd3f600c71eb69764b3e704cd4fbe6a07bd09f589ba5bd5c19c886ce4a48de3a65e60b8ae60d649c1c1e1578b5f1042e6128f60603ee9afdd3de1e787766a89b3a0f2e122c6a90bea7ab7cf6936370f3adc09495e54ac64de73e672cedfe4fce0f534c306c1008a37d312fd98a6329cab6a5f13972b55c3209d4e01200d0d28e625dc1b45e10849c635e2aba5c66db2f520b7daa0d9b44b02d1bb990b5607c413259651765fc8851a37d2396ed0745fdd5188d1c4a7ef9c9a529df3c2bbf9d5bce38dda86d0e133470b23099e60da1e05505d86eeba9a93f17d8d28cda2ef9d8cd30f71dd7f26569ed1e14b8b10ef14fb2bf27cc6992680f9b2f96488d450bccbcaa017df7845093cf98786309ab464b89139dd1a057766fb93c0d389f9462a08d8855badc550df4a10d45a70063fb90fda96ba5e45a30764aa256f5fc816b74e95ad64563e7a748f57ff1716d68e3f7dfd9e8a5ad8d2713436c546b82a29dd9c53e314e0045495e8927b87ae7707ffc20d447bdf4add393ea8ac68cb8d3b2957e1ae36749484b51ffa45a460a3d8ac7eec3fbb4ca33d88f9cd03220b832b99d4b76ceca9324c9bf9a9d71c48869dd9295f13c2bf65e59e440d6b545d6d385cedce2b606b6ea11811ecfa0369a01866946082abf8debd3200264840b505e3b7599e6366a8b5095887ec1b8134f54e86ac24230a65c14564bc66a094ecfae3d815d897bf4279dfd47167b6bc641cdfae40c39d8bf962ada65eb81dbdb3a6cc18b03a3627d984d669c22435648c75d27cb97d8f49d1b2941fc024db46e8a2628b7df9d7efd97a14fcd532376fb92437890fc9db419fc6b0658aa0f3e52236de86f9851beb17c150206b8219effb27abf52327662cbdc1ff1d9af6305991b6060617c63f1c32382f0e318fa5578409bd9948cc532db267a4c7e3fd2e6b4d2f56649fd51d08c5ba04a46fe78ec8916f74a3814093443e9135802f9780efccd5412197a667bd126429ce5c001a7fcb8a8446b2d53c4ac36640a7e1e64b743614fdfa71ecabc4c43ec2240f7a3e658e9a20dabca329c532af62aed82feae97111028a87b5e3e0dbf836d40ef3430e7a24f2c4ea99faadc2c1e02b2266d8a7afe25d6af02f6f6034542ed79f5ab9a751afa854c278b078d957b052912342f3953636df77327ed551dcacf4a17b5523564710342d3fada7dd28f7f965e0d3c313988de8d3133922586d28c0fcec29fab2f0805cdab254afe2e68d5f8898ce3140c459e253fa63241bdd4c34177157af65253f6a0a7b01c5c6815ff5c0a50118ced4a6d54aaab25b469aa50f8a050061b0f6cdd9183fe7218f8e13b9f1cc49dab84cd2c549c334764ba971845d347fcbed24684a825c0b26812a4620a073784aa9a42de6abf03ca392ef08072f21161e58774057d81bf5c3739a20bd1f7f23900d66aa89ee3ea9fae17ca512619d2feb938dc35900ae7d73b4111c8a06035cc28d69aa05ad96ba0c13983065b3355a1da077353d410ad170ca7c2456801d21dece259c20d98451d69faaa4b80a187c858458d785a6168f7965a88b645a9d800cb5962262fcb2f6b615a3480fe31e964f4dae3a718c08a0ed705acc06cf75c0825ae48550ec901a209abbd3b28c24efdc7e22b587dcbbfde36e95615892ac35a7d4d4bf46fe48bd69008e0146bb9785bc7b55a8035f19466bad4b7b1e38a3a5811ff5d0c9f31d71f9b87c6b7db8bb525c703a2534d87ba9ac111fe3dbc8b0c8c3fd88e14b4ccec15573d15cc0f81f556ce4771c3aa0bbb81343d1a2be914f9d1a6a6621f7ab59d1bfc1aef722011621f8f3f85b42eda1924d434752352a6ecf9811c99cc0e066451fd15f8ca7caaea3c3649d8fba839964722681f66fd4f1819cb0a3eb3ebb5798630dc252d26000546bc6dd589e917540a493d089d08528a26fb9b758b22e25d49b80a205ce158a8d5848f5d87f60f1822c4fc457b234947a5636866bf5efe4ca498c8c7b8ccd3b8354e53606935f9d83997dee8ec2fe6614db44f33707b99e5bc5de58470293aa0b3a7534d0719b9aaabe4ddc6460194ce71b7033541ce686884e462b9455f2e212a980265c17f5a5ce3c19a0c41bbe887cb464c8f08b143c8da321f5f6925d102ba499355f2089d6cd26deaf144b3dd7cf4b439f4ae72422b62c83a6135084d8af25bea129d76b21456ecf7b9a0db582a20b0d840298c364957e4be003418092f0a42d81a913776daa7ca56b7548e94cab33fff955164f8fe971b625179eab8c25f9e61ee90231562d1c6db18f2339d3cf621487206d0872fcabb4186d9a7aca9df9f2f20fbebe41840fdd4fed3ad6f5c8d9a68dbe188919b885f7ac25bb2e3cf25e7cfa16b35b058329c35a5ab6150e2988e10a8c37d6fc6db38028c0735c9e8874c0248b2d5eb86ee9afc979a0b4c5f807aa3aa623e4ca5d7891c47a3422b8082c7b9e764b2009c703647b91a31d28fe0d58eb5e99b19af313c613f020a7e2f23b6f573c1b04f8205ee16ec9663eed7bf43abe983c85134c2f458891be9af919c20910a98ea532432b5d8e2ffbd45d253fbf7aaeecb3f2f354b0199fc740475659867230398d9c623189b70feee836991899143bdfa8a3c09bb572a9b618f33d00fa504a86d6d43359adeabc372f6206f9a463af0486ae8bdcb1b13adfef51e3b3e466913c0f036b98b9b19e4fe53dd62ff94d0cdc7578af38aff43d4318be8f060a87a0377ee133e78b9f4ed12b3cb1077fc6a81c1ac0d605138ab2ed8bb8a6b278abc4caceeddf8a1c313de98745b7bd7a4365ba3358b8a42e79ddaaebbebf0780b4391ce3d921222ab31bd49e9d0395838320efc065754b79afed87337cb04c3d08143156f6279e3dd34a77f8628788e1837eebbb9beef16202b6f893515a7fc9561003782520c3f87b2ba04c394434f63249a53cfdafcae60bc20ecbaa1a4ef8e7562f967ca29553aa87dcf078aa70422a564acb4afd38d1ec6bbdd787c036eaa989bf558952bec798b7baef1c36ccece8f805870d8be3c9e03ebe825477d007cc3d1bc8ac4de6d8aff3bded4d67afe4659dc47c63ac9d0314f57966ff2c3dda938738b89bb9a24f59d19e1f65ee31b2b2532530e0d8a9393f6e621603d67bc10a78fee800ead3284dd091d2d4761d32cb5f5f6c3a48c4fd7e6c9d508b0e2fecc5804e61f8ccbd4e6b0cdaaf8536743cc2ae22fcb2b1f918235721edb611397a3bcf99004a595d32bd221a0f2dbd4b76e3ab1654d6e23cc0078eb96f9f94f4ff2071e1d9c63a4d65adc29aec578c593e3892f4ab92c4e46dfd3b5d1d6fdd01d721445ab5fd23bcf3fd72707b6523c49536282820adef9fc4d8f97532ee821715afd9ec56e4af28675ae8f44fc1418ee02e3306b258d71a93edc53e77b2e531b1a963b5fb863367c506885aac514b99b4801db928e6b429ff82eef41a9204dad3f8d0525db9ae653f8f492b7446834e0be542b271a730b5e721b52ade0710df71dfe344eae001f3dd33f3d9d78a0a3a0cdc4d3cdbd8083e9ede96ace44100e04361d2968178e41ac66da1257a57d602e108a74fd2463206c3a38df158bebec6923b6032bbb6ddcc30cd8fe4d58db5041cdaa80759319f3a9aa86ab355648b0e502cb7b9a744c1457cb8379fe420e0999ecbf8e51ef1ed5ac6fa3ab74caade6e6dfa83326dcb3d33b94b3dfd95e1b290e8163aaf300ace20877d6780e211240991a5b29294dd290de65ad1dee7af71619602b568bb2adc1c2d7789a88c64e11267bfbc27d499988949591afc1b89a5bbc1c80003d9a668daf595a167c48c5ba8d409b899ae7c917b4656bfc240d0dd238f6975e3d402871e53212dc655b455885c4cc0a5278bdac5d2e617ca372a4c827d7e4a0c23ff91d8f01aa57e8b9126c2f6b830e0481d0373074eda61b2d1294d891bff820e9ad23d836a58f29d34405dbb603d7906ec060aa5ac98dca6a1b22538c99fe05a95cee0a44034b81718026b6ea38b4a3b9924427e5f02d1a9702867c8dcfba72f063173e10191f443a76f9d4738890d5bbfa64e4a511a86d15345c40035eafeb69ad812da9ab488167b12880ded5a85ec29fece1409aaa1d6df6fcd96362cc14c39502e91f7b7db3e6cc8412c18039e98ef17256984d2d4f00379c4850598ac369ddf480e54952bd820d88cfa488233ccf65a7c8b601b90a10157cf660c12f2d0bcace4f172e45a2bb359f68c1edfc5e3c0fc49897f22c73653e0a34949bb85165a6eec31ce3d93b253d30a403f1471d98bef233e9b6c9f6c8ee6ecc550c5a493c86da0f2575d85b107e531bb48a265c7420bf860b774098b58be2cc3540221442adfd44b745a3675986514d0a351558b763827f70af33af5fa92ff1184b96792faa8dd5fb136a4d8329f5bb3dc7359b5d33d09e6d1fb4b1b9f36340450168e59653ea7bfa8abd9cbd208cc66e9c95c199c5d6ba1fd41633f4823a411a9734c0fa62b32afcf08139a632407553632a61230f65a6a65c08a0d95772f592f3c94bf3fd09d4affadb446e0b7e3a731946c6a57e38a0150dfb754e4d7113306d76952f1db420f86f1d0e2c3e41d6066a97fd8121851c959931e91d97419d19cb30b1e47c8affd8566299527343e7bfb19e4de71018f0086a304c73e2e08a41ae8b61b0cc4d09843e951dc814991e79a6486a63fcb288f63f64cb19fcf49f849de5ef7cc3309026fb44a1c18474feb02eb178fba7395d5264b1f806093062515e9212148c84317698d48a0fc74826ca03b110c0a9055a8709bede604de498b21295f504157edc51a8b41dedf25211e8db10844ccc424aca304ee0904df6412961b5c1e949aae0811e3cfc2af19d88845a10d608ff8c91023a03ca9401025529b5550bfda06993d30d3af059398cdaeb88a4c801aef6b4f5a559c6733acd9183323aeccd1fb108f2e6e9f7683cf95375670965a0072d753152ded318b099a57713b137ee36dc564ce728a7f5bfb3b8462927d0d5099ef95801bb41247d33fb627ff663df0565d8218fbcd4945b24a348e9f34096902019734c790e7fb0be67c456f9e94e27622aa07a82cd0298d340847bb93d8d0f6099046f67a5843522d889f42b2bfbec431f835d829cdfa50c9d460430e36e03216aca87164b21e729fb15e409e9e743b056a98861563351396037d1d8890caa1a2dff06b767af597a4c49292b7d01f3da7064d0de8ee2a4f4a5714093393f1185704ca39c0977f0dc780f5c6def85aa87d6034bc4c3fabeda28d44a7aea5ffd3141b472b48589c854e962ad6118c82d7d7099e18463bb09603447ccb89198de8d85f37e80a6c3cda3b07814d30eb8de73f3a0624bb704fa16df73b483aaac004b71bf806b67ca48ebb8951d85c3001eba1881a713bba2842008cd0cfff7afa75eb880d2d9f5b249344531a2d651fb26af70eef8abb258e34f0f463105a1a9393c821595cfda2223afedb32e3b8ce16e088eae38f5ac8d482f3c7bbf793d0bcc4546a791c82553cf8dd498bcbc21208df3cac99ae6706241ff9e7513fb0c753dd520d0312287c30edf1c06b6ef35cceb3f60fecf83cf9c7aec1e64ce2b080a228113beb6c5809ad8c92e97b3fb90fa2495346d4d7f14e96e9e9124fa370f6cce9af1ea41ca8dd7bf0174af114a086584b9fb03a7906e1e5050a5aa03dd0a190948aec7ad7b47a5084136064ecdeac2411fd6f425eb86acba6b6d871883fe5526c38945bf6babdea1e57d85d81df1e51f85c5cad2b1967659f3d4932934653789e6ef329eb2439f634d24b52a51a0c26da52e594eb39d0fffcf504e502a7ec99a3de5b29916c38fae1671c1b6dd41b99215e2edd4576f828de1f90dc857b1982906fb273f5e88a00e90991a9d826b18a1e63eac5c97536d257391dafef075e5d8b5477bd4912b44d374b4b6f0434dcc9ee86a217517ef4969f6c40fb8054db3e399ab08d8e349cd60c4430ad56ea377c697f26df6b9fb32b7fc05f7036d10fe3bab708ee1bdee18cfa73686e691f421c548f6ab840a3b06de64717fe85ee4f42ac931fd87e966b75b4a8ff7e8a1dadb645f3198419a8d3e1518d98bb0762619c89b946651f3daafc6017f541fba74a5ca4d93de28ec7d1dd68fb7ee71ba2465fb2f3767c844ba7186bb5512245c9c451ce229ee06080448a0596a8f26f359b91833c8985f61ea7c69c6dc69921382c5067681f8a6f203f15e2a7191a2b09029331f30503dab1552bea622095b685e9ddee8afc5a8be4b17ce3d1c6d4bd8eda39182d28973e4a3822f7309cc172d4ca4166c7228131cbf5e9fb02374ff14f4a122dcb736714a6d8d544ac61358985de28bf248a374428ad300ceca513f91273fdfa7376ce1475138beddc130cd30dfc74c2045de81ba310854833903918842b679268e7dfa61901f7fa00d852e2e84f7b61c60533ca601879c084cad3d102825472f3b58d37242afd10c596c0e55829226257d3e3f86ec4d382e447c8e95585ebd753fd5020f1965dfe3fc14d491dd25b750cb109951bc31516639e3446686c9c9dbc51909115042edaf4f173b3398f0b075b7579f631ba1184fd5ba5d1f7ed3932589682390cfe64714185c43dd334a1c6fcbe02fd458e7bcd0c39b4daaf2dbfe4d8e8b441a536532f10edf050ed7dae1f3b7b63c82a596ef6be88799464ee35cf40a4a96d4b3112f3d9c88de2e32fe18d1ae989c033ddde4f00e2b3264abfb7f61f1fc6a34ae92a99df2281e1558700cc53c3a01b6b8372fdbdd651d092c580e166d696404f9d82ab8952ab94ccf4673a21f260d3c4bfbd5a7a7300f0461848ed37002d742341510f5effdaa0e6a564ce2bd942db0ff90fc190b25ed5f2b7f0510b78957d036ecf51381ff127fc4b85e214f9c4d313887f27327dd545e1cab02e15540b319e668c5634c89ca5309c28436d72282f8d65fb0d97b4ccc8ebc052a7ab94441db0bbea067d25cc1018316cb2e607b7f5e152777957d3fc31ad1b60ac6ddcce7212854437bcb6c082fb4f4b5a4b5448199c095613699bc75d47bb31fb73f8ae800fdfafa64175e3ec4aad200903a3040c89bcd4fb7db25e244397bdc47f5cc3db435f4359eb658ec296aae0a5a5f82783f3ca9d9e0219fac0d119a448bfaf9d0c02bd61e813cfee28e5d603be23f160c2357ba4eac0901ff7429b2740b3be953910baa9e8235e84f8414f7f6c71ca41629f34dc9c9d29d2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是机密文件！</summary>
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="git" scheme="https://icu007work.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git-push时冲突解决方法</title>
    <link href="https://icu007work.github.io/archives/80c83deb.html"/>
    <id>https://icu007work.github.io/archives/80c83deb.html</id>
    <published>2022-08-26T01:10:27.000Z</published>
    <updated>2023-08-23T03:25:01.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、冲突原因"><a href="#一、冲突原因" class="headerlink" title="一、冲突原因"></a>一、冲突原因</h2><h3 id="1-1-多人同时修改同一文件"><a href="#1-1-多人同时修改同一文件" class="headerlink" title="1.1 多人同时修改同一文件"></a>1.1 多人同时修改同一文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">liaochongrong@urovo002-07:/home/ssd7/lcr_work/SQ45S$ git cherry-pick -n 4a7c5af22778e57440fdf09921b25e1a40a6d5e0</span><br><span class="line"></span><br><span class="line">error: 不能应用 4a7c5af... Product:SQ45S</span><br><span class="line">提示：冲突解决完毕后，用 &#x27;git add &lt;路径&gt;&#x27; 或 &#x27;git rm &lt;路径&gt;&#x27;</span><br><span class="line">提示：命令标记修正后的文件</span><br><span class="line"></span><br><span class="line">liaochongrong@urovo002-07:/home/ssd7/lcr_work/SQ45S$ git status</span><br><span class="line">位于分支 Pie_SQ45S_Release</span><br><span class="line">您的分支与上游分支 &#x27;origin/Pie_SQ45S_Release&#x27; 一致。</span><br><span class="line">未合并的路径：</span><br><span class="line">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 标记解决方案）</span><br><span class="line"></span><br><span class="line">    双方修改：   build/buildprop.mk</span><br><span class="line"></span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-缺少change-id"><a href="#1-2-缺少change-id" class="headerlink" title="1.2 缺少change-id"></a>1.2 缺少change-id</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">liaochongrong@urovo002-07:/home/ssd7/lcr_work/SQ45S$ git push origin HEAD:refs/for/Pie_SQ45S_Release</span><br><span class="line">对象计数中: 4, 完成.</span><br><span class="line">Delta compression using up to 64 threads.</span><br><span class="line">压缩对象中: 100% (4/4), 完成.</span><br><span class="line">写入对象中: 100% (4/4), 656 bytes | 0 bytes/s, 完成.</span><br><span class="line">Total 4 (delta 3), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (3/3)</span><br><span class="line">remote: Counting objects: 4, done</span><br><span class="line">remote: Processing changes: refs: 1, done    </span><br><span class="line">remote: ERROR: [19bc4b1] missing Change-Id in commit message footer</span><br><span class="line">remote: </span><br><span class="line">remote: Hint: To automatically insert Change-Id, install the hook:</span><br><span class="line">remote:   gitdir=$(git rev-parse --git-dir); scp -p -P 29418 liaochongrong@192.168.8.215:hooks/commit-msg $&#123;gitdir&#125;/hooks/</span><br><span class="line">remote: And then amend the commit:</span><br><span class="line">remote:   git commit --amend</span><br><span class="line">remote: </span><br><span class="line">To ssh://192.168.8.215:29418/NoUcode/SQ45S</span><br><span class="line"> ! [remote rejected] HEAD -&gt; refs/for/Pie_SQ45S_Release ([19bc4b1] missing Change-Id in commit message footer)</span><br><span class="line">error: 无法推送一些引用到 &#x27;ssh://192.168.8.215:29418/NoUcode/SQ45S&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://m.360buyimg.com/babel/jfs/t1/61562/20/19916/87101/630746a4E781cd8f2/30ce7c00b6bce0a7.png" alt="差异"></p><h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><h3 id="2-1-多人修改"><a href="#2-1-多人修改" class="headerlink" title="2.1 多人修改"></a>2.1 多人修改</h3><ul><li>通过 <code>git status</code>命令找到双方共同修改的文件，然后编辑文件，把多余的代码去掉即可。</li><li>可通过 <code>git diff 文件目录</code>来查看显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别</li></ul><p><img src="https://m.360buyimg.com/babel/jfs/t1/132834/9/26175/55311/63074527Ebe1d9bb2/5731e9aaa5eb446d.png" alt="差异"></p><ul><li>如图，删除标识代码，此冲突即可解决。</li></ul><h3 id="2-2-缺少change-id"><a href="#2-2-缺少change-id" class="headerlink" title="2.2 缺少change-id"></a>2.2 缺少change-id</h3><ul><li>其实这个冲突的解决方法，git已经提示过我们了。就是这一段</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">remote: Hint: To automatically insert Change-Id, install the hook:</span><br><span class="line">remote:   gitdir=$(git rev-parse --git-dir); scp -p -P 29418 liaochongrong@192.168.8.215:hooks/commit-msg $&#123;gitdir&#125;/hooks/</span><br><span class="line">remote: And then amend the commit:</span><br><span class="line">remote:   git commit --amend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>所以我们只需要执行 <code>gitdir=$(git rev-parse --git-dir); scp -p -P 29418 liaochongrong@192.168.8.215:hooks/commit-msg $&#123;gitdir&#125;/hooks/</code>以及 <code>git commit --amend</code>这两行命令即可。</li><li>当然如果不放心还可以reset 已有的提交：<code>git reset --soft 3bf39e60e2cad62f3ada0414f3cef64f386ccce3</code>，最后那一串为 commit id，reset完了之后，再重新进行提交操作。操作完成后即可看到change-id已经生成了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、冲突原因&quot;&gt;&lt;a href=&quot;#一、冲突原因&quot; class=&quot;headerlink&quot; title=&quot;一、冲突原因&quot;&gt;&lt;/a&gt;一、冲突原因&lt;/h2&gt;&lt;h3 id=&quot;1-1-多人同时修改同一文件&quot;&gt;&lt;a href=&quot;#1-1-多人同时修改同一文件&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://icu007work.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="随笔" scheme="https://icu007work.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="git" scheme="https://icu007work.github.io/tags/git/"/>
    
  </entry>
  
</feed>
